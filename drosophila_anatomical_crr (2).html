<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Drosophila - Anatomical Brain with Neural Activity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid #0f3460;
        }
        
        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            color: #e94560;
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.8;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 2000px;
            margin: 0 auto;
        }
        
        .fly-container {
            grid-column: 1 / -1;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #90EE90 100%);
            border: 2px solid #0f3460;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            height: 400px;
            overflow: hidden;
        }
        
        .viz-panel {
            background: rgba(15, 52, 96, 0.3);
            border: 2px solid #0f3460;
            border-radius: 10px;
            padding: 15px;
            position: relative;
        }
        
        .panel-title {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: #e94560;
            text-align: center;
        }
        
        canvas {
            width: 100%;
            height: 600px;
            background: #000;
            border-radius: 5px;
            display: block;
        }
        
        .controls {
            background: rgba(15, 52, 96, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 0 20px 20px 20px;
            border: 2px solid #0f3460;
        }
        
        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }
        
        button {
            padding: 10px 20px;
            font-size: 0.95em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #e94560;
            color: white;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #ff6b7f;
            transform: translateY(-2px);
        }
        
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 15px 20px;
            background: rgba(15, 52, 96, 0.5);
            margin: 0 20px 20px 20px;
            border-radius: 10px;
            border: 2px solid #0f3460;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.85em;
            opacity: 0.7;
            margin-bottom: 3px;
        }
        
        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #e94560;
        }
        
        .rupture-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(233, 69, 96, 0);
            pointer-events: none;
            transition: background 0.3s;
            z-index: 1000;
        }
        
        .rupture-flash.active {
            background: rgba(233, 69, 96, 0.3);
        }
        
        .legend {
            position: absolute;
            top: 50px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85em;
            max-width: 200px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* FLY VISUALIZATION STYLES */
        .fly-world {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .fly {
            position: absolute;
            width: 120px;
            height: 80px;
            transition: transform 0.1s ease-out;
            filter: drop-shadow(0 8px 12px rgba(0,0,0,0.4));
        }
        
        .fly-body {
            position: absolute;
            width: 80px;
            height: 50px;
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 50%, #0d0d0d 100%);
            border-radius: 50% 50% 45% 45%;
            left: 20px;
            top: 15px;
            box-shadow: inset 0 -3px 8px rgba(255,255,255,0.1);
        }
        
        .fly-head {
            position: absolute;
            width: 40px;
            height: 35px;
            background: linear-gradient(135deg, #3a3a3a 0%, #2c2c2c 50%, #1a1a1a 100%);
            border-radius: 50%;
            left: 5px;
            top: 18px;
            box-shadow: inset 0 2px 6px rgba(255,255,255,0.15);
            transform-origin: center right;
        }
        
        .fly-eye {
            position: absolute;
            width: 18px;
            height: 18px;
            background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
            border-radius: 50%;
            box-shadow: inset 0 1px 3px rgba(255,255,255,0.3), 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .fly-eye.left { top: 6px; left: 2px; }
        .fly-eye.right { top: 6px; right: 2px; }
        
        .fly-antenna {
            position: absolute;
            width: 2px;
            height: 12px;
            background: linear-gradient(180deg, #4a4a4a, #2c2c2c);
            border-radius: 2px;
            transform-origin: bottom center;
        }
        
        .fly-antenna.left { top: 2px; left: 12px; }
        .fly-antenna.right { top: 2px; right: 12px; }
        
        .fly-wing {
            position: absolute;
            width: 60px;
            height: 35px;
            background: radial-gradient(ellipse at center, rgba(255,255,255,0.4), rgba(255,255,255,0.1));
            border-radius: 45% 55% 45% 55%;
            border: 1px solid rgba(255,255,255,0.3);
            transform-origin: 10% 50%;
            backdrop-filter: blur(1px);
        }
        
        .fly-wing.left {
            top: 10px;
            left: 10px;
        }
        
        .fly-wing.right {
            top: 10px;
            right: 10px;
            transform: scaleX(-1);
        }
        
        .fly-leg {
            position: absolute;
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, #2c2c2c, #1a1a1a);
            transform-origin: left center;
            border-radius: 2px;
        }
        
        .fly-leg::after {
            content: '';
            position: absolute;
            right: 0;
            width: 20px;
            height: 2px;
            background: linear-gradient(90deg, #1a1a1a, #0d0d0d);
            transform: rotate(-45deg);
            transform-origin: left center;
            border-radius: 2px;
        }
        
        .odor-source {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, rgba(144, 238, 144, 0.6), transparent);
            border-radius: 50%;
            animation: pulse 2s infinite;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }
        
        .light-source {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255, 255, 100, 0.8), transparent);
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(255, 255, 100, 0.6);
            pointer-events: none;
        }
        
        .behavior-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            color: #ffd700;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ§  Anatomical Drosophila Brain - CRR Neural Dynamics</h1>
        <div class="subtitle">Real-Time Visualization of 140,000 Neurons | Photo-Realistic Fly Controlled by Brain Activity</div>
    </div>

    <div class="controls">
        <div class="control-row">
            <div class="control-group">
                <label>Odor Stimulus: <span id="odorVal">0.5</span></label>
                <input type="range" id="odorSlider" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="control-group">
                <label>Visual Stimulus: <span id="visualVal">0.5</span></label>
                <input type="range" id="visualSlider" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="control-group">
                <label>Light Direction: <span id="lightVal">0Â°</span></label>
                <input type="range" id="lightSlider" min="0" max="360" step="1" value="0">
            </div>
        </div>
        <div class="control-row">
            <button onclick="sim.triggerRupture()">âš¡ Rupture</button>
            <button onclick="sim.reset()">ðŸ”„ Reset</button>
            <button onclick="sim.startLearning()">ðŸ“š Learning</button>
            <button onclick="sim.randomStimuli()">ðŸŽ² Random</button>
            <button onclick="sim.toggleRotation()">ðŸ”„ Rotate Brain</button>
        </div>
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            <div class="stat-label">Global Coherence</div>
            <div class="stat-value" id="coherenceStat">0.0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Rupture Events</div>
            <div class="stat-value" id="ruptureStat">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Active Neurons</div>
            <div class="stat-value" id="activeNeurons">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Memory Weight</div>
            <div class="stat-value" id="memoryWeight">1.0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">FPS</div>
            <div class="stat-value" id="fpsStat">60</div>
        </div>
    </div>

    <div class="main-container">
        <div class="viz-panel">
            <div class="panel-title">ðŸ¦Ÿ Anatomical Fly Brain with Activity Flow</div>
            <canvas id="brainCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF6B6B;"></div>
                    <span>Visual System</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ECDC4;"></div>
                    <span>Olfactory System</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #95E1D3;"></div>
                    <span>Learning (MB)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #C77DFF;"></div>
                    <span>Navigation (CX)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4A90E2;"></div>
                    <span>Motor Output</span>
                </div>
            </div>
        </div>

        <div class="viz-panel">
            <div class="panel-title">ðŸŒŠ Population Activity Manifold (3D)</div>
            <canvas id="manifoldCanvas"></canvas>
        </div>

        <div class="viz-panel">
            <div class="panel-title">ðŸ“ˆ Coherence Evolution & Rupture Dynamics</div>
            <canvas id="coherenceCanvas"></canvas>
        </div>

        <div class="viz-panel">
            <div class="panel-title">âš¡ Neural Connectivity & Signal Flow</div>
            <canvas id="connectivityCanvas"></canvas>
        </div>
    </div>

    <div class="fly-container" style="margin: 0 20px 20px 20px;">
        <div class="panel-title" style="margin-bottom: 10px;">ðŸ¦Ÿ Photo-Realistic Fly (Brain-Controlled Behavior)</div>
        <div class="fly-world" id="flyWorld">
            <div class="behavior-label" id="behaviorLabel">Idle</div>
            <div class="light-source" id="lightSource" style="top: 50px; right: 100px;"></div>
            <div class="odor-source" id="odorSource" style="bottom: 100px; left: 150px;"></div>
            
            <div class="fly" id="theFly" style="left: 50%; top: 50%; transform: translate(-50%, -50%);">
                <!-- Wings (behind body) -->
                <div class="fly-wing left" id="wingLeft"></div>
                <div class="fly-wing right" id="wingRight"></div>
                
                <!-- Body -->
                <div class="fly-body">
                    <div class="fly-segment" style="top: 0;"></div>
                    <div class="fly-segment" style="top: 33%;"></div>
                    <div class="fly-segment" style="top: 66%;"></div>
                </div>
                
                <!-- Head with eyes and antennae -->
                <div class="fly-head" id="flyHead">
                    <div class="fly-eye left"></div>
                    <div class="fly-eye right"></div>
                    <div class="fly-antenna left" id="antennaLeft"></div>
                    <div class="fly-antenna right" id="antennaRight"></div>
                </div>
                
                <!-- Legs -->
                <div class="fly-leg" id="legFL" style="top: 25px; left: 25px; transform: rotate(-30deg);"></div>
                <div class="fly-leg" id="legFR" style="top: 25px; right: 25px; transform: rotate(30deg) scaleX(-1);"></div>
                <div class="fly-leg" id="legML" style="top: 35px; left: 35px; transform: rotate(-50deg);"></div>
                <div class="fly-leg" id="legMR" style="top: 35px; right: 35px; transform: rotate(50deg) scaleX(-1);"></div>
                <div class="fly-leg" id="legBL" style="top: 45px; left: 45px; transform: rotate(-70deg);"></div>
                <div class="fly-leg" id="legBR" style="top: 45px; right: 45px; transform: rotate(70deg) scaleX(-1);"></div>
            </div>
        </div>
    </div>

    <div class="rupture-flash" id="ruptureFlash"></div>

    <script>
        // ===== BRAIN REGION DEFINITIONS =====
        // Full 43 regions - 140,000 neurons total
        const BRAIN_REGIONS = [
            // OPTIC LOBES (60,000 neurons)
            { name: "Photoreceptors_R1_R6", neurons: 4800, pos: [-160, -100, 45], size: 20, type: "sensory", color: "#FFE66D", omega: 10 },
            { name: "Photoreceptors_R7_R8", neurons: 2200, pos: [-155, -95, 40], size: 18, type: "sensory", color: "#FFD23F", omega: 10 },
            { name: "Lamina", neurons: 12000, pos: [-140, -85, 35], size: 26, type: "visual", color: "#FF6B6B", omega: 15 },
            { name: "Medulla_Outer", neurons: 18000, pos: [-120, -70, 25], size: 32, type: "visual", color: "#FF8E53", omega: 20 },
            { name: "Medulla_Inner", neurons: 15000, pos: [-115, -65, 20], size: 30, type: "visual", color: "#FFA94D", omega: 20 },
            { name: "Lobula", neurons: 8000, pos: [-95, -50, 15], size: 25, type: "visual", color: "#FFD93D", omega: 18 },
            { name: "Lobula_Plate", neurons: 7000, pos: [-90, -45, 12], size: 24, type: "visual", color: "#F9E06B", omega: 18 },
            
            // OLFACTORY SYSTEM (9,300 neurons)
            { name: "Olfactory_Receptors", neurons: 1300, pos: [120, 80, -15], size: 18, type: "sensory", color: "#A8E6CF", omega: 10 },
            { name: "Antennal_Lobe_Glomeruli", neurons: 2000, pos: [100, 65, -10], size: 20, type: "olfactory", color: "#6BCF7F", omega: 12 },
            { name: "Projection_Neurons_Olfactory", neurons: 1000, pos: [85, 50, -5], size: 17, type: "olfactory", color: "#4ECDC4", omega: 15 },
            { name: "Lateral_Horn_Innate", neurons: 3000, pos: [70, 40, 0], size: 21, type: "olfactory", color: "#FF6B9D", omega: 14 },
            { name: "Lateral_Horn_Association", neurons: 2000, pos: [65, 35, 5], size: 19, type: "olfactory", color: "#C44569", omega: 16 },
            
            // MUSHROOM BODY (2,900 neurons)
            { name: "MB_Calyx", neurons: 800, pos: [45, 5, 30], size: 18, type: "learning", color: "#95E1D3", omega: 25 },
            { name: "MB_Kenyon_Alpha", neurons: 600, pos: [30, 0, 25], size: 16, type: "learning", color: "#6FB9D4", omega: 30 },
            { name: "MB_Kenyon_Beta", neurons: 600, pos: [25, -5, 22], size: 16, type: "learning", color: "#5094CE", omega: 30 },
            { name: "MB_Kenyon_Gamma", neurons: 500, pos: [20, -10, 20], size: 15, type: "learning", color: "#3D7EC8", omega: 28 },
            { name: "MB_Output", neurons: 400, pos: [10, -15, 15], size: 14, type: "learning", color: "#2A5EA8", omega: 22 },
            
            // CENTRAL COMPLEX (3,000 neurons)
            { name: "Protocerebral_Bridge", neurons: 800, pos: [0, -25, 45], size: 19, type: "navigation", color: "#C77DFF", omega: 20 },
            { name: "Fan_Shaped_Body_Upper", neurons: 800, pos: [0, -25, 32], size: 19, type: "navigation", color: "#9D4EDD", omega: 18 },
            { name: "Fan_Shaped_Body_Lower", neurons: 600, pos: [0, -25, 25], size: 17, type: "navigation", color: "#7B2CBF", omega: 18 },
            { name: "Ellipsoid_Body", neurons: 500, pos: [0, -25, 18], size: 16, type: "navigation", color: "#5A189A", omega: 22 },
            { name: "Noduli", neurons: 300, pos: [0, -25, 12], size: 14, type: "navigation", color: "#3C096C", omega: 16 },
            
            // PROJECTION & LOCAL INTERNEURONS (40,000 neurons)
            { name: "Local_Interneurons_Visual", neurons: 8000, pos: [-105, -60, 18], size: 25, type: "interneuron", color: "#FFA07A", omega: 15 },
            { name: "Local_Interneurons_Olfactory", neurons: 3000, pos: [80, 55, -3], size: 20, type: "interneuron", color: "#98D8C8", omega: 14 },
            { name: "Projection_Neurons_Visual", neurons: 12000, pos: [-85, -45, 10], size: 28, type: "projection", color: "#FF7F50", omega: 18 },
            { name: "Projection_Neurons_Multimodal", neurons: 10000, pos: [0, 10, 5], size: 27, type: "projection", color: "#FF6347", omega: 20 },
            { name: "Integration_Interneurons", neurons: 7000, pos: [0, 15, -5], size: 24, type: "interneuron", color: "#CD5C5C", omega: 22 },
            
            // MOTOR SYSTEMS (1,100 neurons)
            { name: "Descending_Neurons_Flight", neurons: 400, pos: [-15, -70, -25], size: 14, type: "motor", color: "#4A90E2", omega: 12 },
            { name: "Descending_Neurons_Walking", neurons: 400, pos: [0, -70, -25], size: 14, type: "motor", color: "#357ABD", omega: 12 },
            { name: "Descending_Neurons_Head", neurons: 300, pos: [15, -70, -25], size: 13, type: "motor", color: "#2E6BA8", omega: 12 },
            
            // HIGHER INTEGRATION (20,000 neurons)
            { name: "Superior_Protocerebrum", neurons: 8000, pos: [0, 30, 35], size: 26, type: "integration", color: "#E74C3C", omega: 25 },
            { name: "Posterior_Lateral_Protocerebrum", neurons: 6000, pos: [35, 25, 15], size: 23, type: "integration", color: "#C0392B", omega: 24 },
            { name: "Anterior_Optic_Tubercle", neurons: 3000, pos: [-60, -30, 8], size: 20, type: "integration", color: "#A93226", omega: 20 },
            { name: "Inferior_Protocerebrum", neurons: 3000, pos: [0, 25, -15], size: 20, type: "integration", color: "#922B21", omega: 18 },
            
            // GUSTATORY
            { name: "Gustatory_Neurons", neurons: 500, pos: [110, 75, -20], size: 15, type: "sensory", color: "#FFB6C1", omega: 10 },
            
            // NEUROMODULATION (3,000 neurons)
            { name: "Dopaminergic_Clusters", neurons: 1200, pos: [35, 8, -8], size: 17, type: "neuromod", color: "#9B59B6", omega: 28 },
            { name: "Serotonergic_Neurons", neurons: 800, pos: [30, 12, -5], size: 16, type: "neuromod", color: "#8E44AD", omega: 26 },
            { name: "Octopaminergic_Neurons", neurons: 600, pos: [25, 16, -10], size: 15, type: "neuromod", color: "#6C3483", omega: 24 },
            { name: "Peptidergic_Neurons", neurons: 400, pos: [20, 20, -12], size: 14, type: "neuromod", color: "#5B2C6F", omega: 22 },
            
            // ADDITIONAL PROCESSING (6,600 neurons)
            { name: "Subesophageal_Zone", neurons: 3000, pos: [0, 50, -20], size: 20, type: "feeding", color: "#16A085", omega: 16 },
            { name: "Ventral_Nerve_Cord_Interface", neurons: 2000, pos: [0, -85, -30], size: 19, type: "motor", color: "#138D75", omega: 14 },
            { name: "Circadian_Neurons", neurons: 200, pos: [50, 30, 20], size: 12, type: "timing", color: "#117A65", omega: 35 },
            { name: "Command_Neurons", neurons: 1400, pos: [0, 0, -5], size: 18, type: "command", color: "#0E6655", omega: 20 }
        ];

        // Connectivity graph - Complete biological pathways
        const CONNECTIONS = [
            // VISUAL PATHWAY
            { from: "Photoreceptors_R1_R6", to: "Lamina", strength: 0.95 },
            { from: "Photoreceptors_R7_R8", to: "Lamina", strength: 0.90 },
            { from: "Lamina", to: "Medulla_Outer", strength: 0.85 },
            { from: "Lamina", to: "Medulla_Inner", strength: 0.80 },
            { from: "Lamina", to: "Local_Interneurons_Visual", strength: 0.60 },
            { from: "Medulla_Outer", to: "Lobula", strength: 0.75 },
            { from: "Medulla_Outer", to: "Lobula_Plate", strength: 0.70 },
            { from: "Medulla_Outer", to: "Projection_Neurons_Visual", strength: 0.60 },
            { from: "Medulla_Inner", to: "Lobula", strength: 0.75 },
            { from: "Medulla_Inner", to: "Projection_Neurons_Visual", strength: 0.55 },
            { from: "Local_Interneurons_Visual", to: "Medulla_Outer", strength: 0.50 },
            { from: "Local_Interneurons_Visual", to: "Medulla_Inner", strength: 0.50 },
            { from: "Lobula", to: "Protocerebral_Bridge", strength: 0.50 },
            { from: "Lobula", to: "Superior_Protocerebrum", strength: 0.65 },
            { from: "Lobula", to: "Anterior_Optic_Tubercle", strength: 0.55 },
            { from: "Lobula_Plate", to: "Descending_Neurons_Flight", strength: 0.60 },
            { from: "Lobula_Plate", to: "Superior_Protocerebrum", strength: 0.50 },
            { from: "Projection_Neurons_Visual", to: "Superior_Protocerebrum", strength: 0.70 },
            { from: "Projection_Neurons_Visual", to: "Posterior_Lateral_Protocerebrum", strength: 0.60 },
            { from: "Anterior_Optic_Tubercle", to: "Superior_Protocerebrum", strength: 0.65 },
            
            // OLFACTORY PATHWAY
            { from: "Olfactory_Receptors", to: "Antennal_Lobe_Glomeruli", strength: 0.95 },
            { from: "Antennal_Lobe_Glomeruli", to: "Projection_Neurons_Olfactory", strength: 0.90 },
            { from: "Antennal_Lobe_Glomeruli", to: "Local_Interneurons_Olfactory", strength: 0.70 },
            { from: "Local_Interneurons_Olfactory", to: "Antennal_Lobe_Glomeruli", strength: 0.55 },
            { from: "Projection_Neurons_Olfactory", to: "MB_Calyx", strength: 0.75 },
            { from: "Projection_Neurons_Olfactory", to: "Lateral_Horn_Innate", strength: 0.85 },
            { from: "Projection_Neurons_Olfactory", to: "Lateral_Horn_Association", strength: 0.70 },
            { from: "Lateral_Horn_Innate", to: "Superior_Protocerebrum", strength: 0.60 },
            { from: "Lateral_Horn_Innate", to: "Command_Neurons", strength: 0.55 },
            { from: "Lateral_Horn_Association", to: "Posterior_Lateral_Protocerebrum", strength: 0.65 },
            
            // GUSTATORY PATHWAY
            { from: "Gustatory_Neurons", to: "Subesophageal_Zone", strength: 0.85 },
            { from: "Subesophageal_Zone", to: "Superior_Protocerebrum", strength: 0.50 },
            { from: "Subesophageal_Zone", to: "Command_Neurons", strength: 0.60 },
            
            // MUSHROOM BODY (LEARNING) PATHWAY
            { from: "MB_Calyx", to: "MB_Kenyon_Alpha", strength: 0.70 },
            { from: "MB_Calyx", to: "MB_Kenyon_Beta", strength: 0.70 },
            { from: "MB_Calyx", to: "MB_Kenyon_Gamma", strength: 0.65 },
            { from: "MB_Kenyon_Alpha", to: "MB_Output", strength: 0.85 },
            { from: "MB_Kenyon_Beta", to: "MB_Output", strength: 0.85 },
            { from: "MB_Kenyon_Gamma", to: "MB_Output", strength: 0.80 },
            { from: "MB_Output", to: "Dopaminergic_Clusters", strength: 0.60 },
            { from: "MB_Output", to: "Superior_Protocerebrum", strength: 0.65 },
            { from: "MB_Output", to: "Command_Neurons", strength: 0.70 },
            { from: "Dopaminergic_Clusters", to: "MB_Kenyon_Alpha", strength: 0.70 },
            { from: "Dopaminergic_Clusters", to: "MB_Kenyon_Beta", strength: 0.70 },
            { from: "Dopaminergic_Clusters", to: "MB_Kenyon_Gamma", strength: 0.65 },
            { from: "Dopaminergic_Clusters", to: "MB_Calyx", strength: 0.50 },
            
            // CENTRAL COMPLEX (NAVIGATION) PATHWAY
            { from: "Ellipsoid_Body", to: "Protocerebral_Bridge", strength: 0.85 },
            { from: "Protocerebral_Bridge", to: "Ellipsoid_Body", strength: 0.80 },
            { from: "Protocerebral_Bridge", to: "Fan_Shaped_Body_Upper", strength: 0.75 },
            { from: "Fan_Shaped_Body_Upper", to: "Fan_Shaped_Body_Lower", strength: 0.70 },
            { from: "Fan_Shaped_Body_Upper", to: "Noduli", strength: 0.55 },
            { from: "Fan_Shaped_Body_Lower", to: "Descending_Neurons_Walking", strength: 0.65 },
            { from: "Fan_Shaped_Body_Lower", to: "Descending_Neurons_Flight", strength: 0.50 },
            { from: "Noduli", to: "Fan_Shaped_Body_Lower", strength: 0.60 },
            { from: "Noduli", to: "Descending_Neurons_Walking", strength: 0.55 },
            
            // INTEGRATION PATHWAYS
            { from: "Superior_Protocerebrum", to: "Projection_Neurons_Multimodal", strength: 0.70 },
            { from: "Superior_Protocerebrum", to: "Integration_Interneurons", strength: 0.75 },
            { from: "Superior_Protocerebrum", to: "Command_Neurons", strength: 0.65 },
            { from: "Superior_Protocerebrum", to: "Fan_Shaped_Body_Upper", strength: 0.55 },
            { from: "Posterior_Lateral_Protocerebrum", to: "Superior_Protocerebrum", strength: 0.70 },
            { from: "Posterior_Lateral_Protocerebrum", to: "Integration_Interneurons", strength: 0.65 },
            { from: "Inferior_Protocerebrum", to: "Integration_Interneurons", strength: 0.60 },
            { from: "Inferior_Protocerebrum", to: "Command_Neurons", strength: 0.55 },
            { from: "Integration_Interneurons", to: "Projection_Neurons_Multimodal", strength: 0.65 },
            { from: "Projection_Neurons_Multimodal", to: "Superior_Protocerebrum", strength: 0.60 },
            { from: "Projection_Neurons_Multimodal", to: "Command_Neurons", strength: 0.55 },
            
            // COMMAND TO MOTOR PATHWAYS
            { from: "Command_Neurons", to: "Descending_Neurons_Flight", strength: 0.70 },
            { from: "Command_Neurons", to: "Descending_Neurons_Walking", strength: 0.70 },
            { from: "Command_Neurons", to: "Descending_Neurons_Head", strength: 0.65 },
            { from: "Command_Neurons", to: "Ventral_Nerve_Cord_Interface", strength: 0.60 },
            { from: "Superior_Protocerebrum", to: "Descending_Neurons_Flight", strength: 0.55 },
            { from: "Superior_Protocerebrum", to: "Descending_Neurons_Walking", strength: 0.50 },
            
            // MOTOR OUTPUT
            { from: "Descending_Neurons_Flight", to: "Ventral_Nerve_Cord_Interface", strength: 0.75 },
            { from: "Descending_Neurons_Walking", to: "Ventral_Nerve_Cord_Interface", strength: 0.75 },
            { from: "Descending_Neurons_Head", to: "Ventral_Nerve_Cord_Interface", strength: 0.70 },
            
            // NEUROMODULATION PATHWAYS
            { from: "Serotonergic_Neurons", to: "MB_Kenyon_Alpha", strength: 0.50 },
            { from: "Serotonergic_Neurons", to: "MB_Kenyon_Beta", strength: 0.50 },
            { from: "Serotonergic_Neurons", to: "Superior_Protocerebrum", strength: 0.55 },
            { from: "Serotonergic_Neurons", to: "Fan_Shaped_Body_Upper", strength: 0.45 },
            { from: "Octopaminergic_Neurons", to: "MB_Kenyon_Gamma", strength: 0.60 },
            { from: "Octopaminergic_Neurons", to: "Antennal_Lobe_Glomeruli", strength: 0.55 },
            { from: "Octopaminergic_Neurons", to: "Superior_Protocerebrum", strength: 0.50 },
            { from: "Peptidergic_Neurons", to: "Superior_Protocerebrum", strength: 0.45 },
            { from: "Peptidergic_Neurons", to: "Subesophageal_Zone", strength: 0.50 },
            
            // CIRCADIAN MODULATION
            { from: "Circadian_Neurons", to: "Superior_Protocerebrum", strength: 0.40 },
            { from: "Circadian_Neurons", to: "Lateral_Horn_Association", strength: 0.35 },
            { from: "Circadian_Neurons", to: "Dopaminergic_Clusters", strength: 0.45 }
        ];

        // ===== NEURAL ENSEMBLE CLASS =====
        class NeuralRegion {
            constructor(config) {
                Object.assign(this, config);
                this.activity = 0.1;
                this.coherence = 0;
                this.basisSize = Math.min(100, Math.max(20, Math.floor(this.neurons / 200)));
                this.populationVector = Array(this.basisSize).fill(0).map(() => Math.random() * 0.2);
                this.memoryTraces = [];
                this.connections = [];
            }
            
            update(input, dt, connectedRegions) {
                // Accumulate input from connections
                let totalInput = input;
                this.connections.forEach(conn => {
                    const source = connectedRegions.get(conn.from);
                    if (source) {
                        totalInput += source.activity * conn.strength;
                    }
                });
                
                // Neural dynamics
                const target = Math.tanh(totalInput * 0.8);
                this.activity += (target - this.activity) * 0.15;
                
                // Update population vector
                for (let i = 0; i < this.basisSize; i++) {
                    const noise = (Math.random() - 0.5) * 0.05;
                    this.populationVector[i] += (this.activity - this.populationVector[i]) * 0.1 + noise;
                }
                
                // Coherence integration: C(t) = âˆ« L(x,Ï„) dÏ„
                const memoryDensity = Math.abs(this.activity) * 0.5;
                this.coherence += memoryDensity * dt;
                
                // Store memory trace
                this.memoryTraces.push({
                    t: Date.now(),
                    activity: this.activity,
                    vector: [...this.populationVector]
                });
                if (this.memoryTraces.length > 50) this.memoryTraces.shift();
                
                // Check rupture
                if (this.coherence > 50) {
                    this.regenerate();
                    return true;
                }
                return false;
            }
            
            // Regeneration: R[Ï‡](x,t) = âˆ« Ï†(x,Ï„)Â·e^(C/Î©)Â·Î˜(t-Ï„) dÏ„
            regenerate() {
                const newVector = Array(this.basisSize).fill(0);
                const memoryWeight = Math.exp(this.coherence / this.omega);
                
                this.memoryTraces.forEach((trace, i) => {
                    const temporalWeight = Math.exp(-0.1 * (this.memoryTraces.length - i));
                    for (let j = 0; j < this.basisSize; j++) {
                        newVector[j] += trace.vector[j] * memoryWeight * temporalWeight;
                    }
                });
                
                // Normalize
                const norm = Math.sqrt(newVector.reduce((s, x) => s + x * x, 0));
                if (norm > 0) {
                    this.populationVector = newVector.map(x => x / norm);
                }
                
                this.coherence *= 0.1;
                this.memoryTraces = this.memoryTraces.slice(-5);
            }
        }

        // ===== BRAIN SIMULATION =====
        class FlyBrain {
            constructor() {
                this.regions = new Map();
                BRAIN_REGIONS.forEach(config => {
                    const region = new NeuralRegion(config);
                    this.regions.set(config.name, region);
                });
                
                // Setup connections
                CONNECTIONS.forEach(conn => {
                    const target = this.regions.get(conn.to);
                    if (target) {
                        target.connections.push(conn);
                    }
                });
                
                this.time = 0;
                this.ruptureCount = 0;
                this.odorStimulus = 0.5;
                this.visualStimulus = 0.5;
                this.lightDirection = 0;
            }
            
            update(dt) {
                this.time += dt;
                
                // Apply stimuli to sensory regions
                const photoR1R6 = this.regions.get("Photoreceptors_R1_R6");
                const photoR7R8 = this.regions.get("Photoreceptors_R7_R8");
                const olfactory = this.regions.get("Olfactory_Receptors");
                const gustatory = this.regions.get("Gustatory_Neurons");
                
                if (photoR1R6) photoR1R6.activity = this.visualStimulus;
                if (photoR7R8) photoR7R8.activity = this.visualStimulus * 0.85;
                if (olfactory) olfactory.activity = this.odorStimulus;
                if (gustatory) gustatory.activity = this.odorStimulus * 0.5; // Related to chemical sensing
                
                // Update all regions
                let ruptured = false;
                for (const region of this.regions.values()) {
                    const input = 0;
                    if (region.update(input, dt, this.regions)) {
                        ruptured = true;
                        this.ruptureCount++;
                    }
                }
                
                return ruptured;
            }
            
            getGlobalCoherence() {
                let sum = 0;
                this.regions.forEach(r => sum += r.coherence);
                return sum / this.regions.size;
            }
            
            getActiveNeurons() {
                let count = 0;
                this.regions.forEach(r => {
                    if (r.activity > 0.3) count += r.neurons;
                });
                return count;
            }
            
            getMemoryWeight() {
                const avgCoherence = this.getGlobalCoherence();
                const avgOmega = Array.from(this.regions.values()).reduce((s, r) => s + r.omega, 0) / this.regions.size;
                return Math.exp(avgCoherence / avgOmega);
            }
        }

        // ===== VISUALIZATION =====
        class BrainVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                this.rotation = 0;
                this.autoRotate = true;
            }
            
            project3D(x, y, z, rotation) {
                // Rotate around Y axis
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                const rx = x * cos - z * sin;
                const rz = x * sin + z * cos;
                
                // Perspective projection
                const scale = 300 / (300 + rz);
                const px = rx * scale + this.canvas.width / 2;
                const py = -y * scale + this.canvas.height / 2;
                
                return { x: px, y: py, scale };
            }
            
            draw(brain) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Clear with fade
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, w, h);
                
                if (this.autoRotate) {
                    this.rotation += 0.005;
                }
                
                // Sort regions by depth for proper rendering
                const regions = Array.from(brain.regions.values());
                const projected = regions.map(r => ({
                    region: r,
                    proj: this.project3D(r.pos[0], r.pos[1], r.pos[2], this.rotation)
                })).sort((a, b) => {
                    const zA = a.region.pos[0] * Math.sin(this.rotation) + a.region.pos[2] * Math.cos(this.rotation);
                    const zB = b.region.pos[0] * Math.sin(this.rotation) + b.region.pos[2] * Math.cos(this.rotation);
                    return zA - zB;
                });
                
                // Draw connections
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                CONNECTIONS.forEach(conn => {
                    const from = projected.find(p => p.region.name === conn.from);
                    const to = projected.find(p => p.region.name === conn.to);
                    if (from && to) {
                        const activity = from.region.activity * conn.strength;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${activity * 0.3})`;
                        ctx.lineWidth = activity * 3 + 0.5;
                        ctx.beginPath();
                        ctx.moveTo(from.proj.x, from.proj.y);
                        ctx.lineTo(to.proj.x, to.proj.y);
                        ctx.stroke();
                    }
                });
                
                // Draw regions
                projected.forEach(({ region, proj }) => {
                    const size = region.size * proj.scale;
                    const alpha = 0.3 + region.activity * 0.7;
                    
                    // Glow effect
                    if (region.activity > 0.5) {
                        const glow = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, size * 2);
                        glow.addColorStop(0, region.color + '40');
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.fillRect(proj.x - size * 2, proj.y - size * 2, size * 4, size * 4);
                    }
                    
                    // Main sphere
                    const gradient = ctx.createRadialGradient(
                        proj.x - size * 0.3, proj.y - size * 0.3, size * 0.1,
                        proj.x, proj.y, size
                    );
                    gradient.addColorStop(0, region.color + 'ff');
                    gradient.addColorStop(1, region.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Coherence ring
                    const coherenceAlpha = Math.min(1, region.coherence / 50);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${coherenceAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size + 3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Label for large regions
                    if (size > 15) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = `${Math.floor(size * 0.4)}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(region.name.split('_')[0], proj.x, proj.y + size + 12);
                    }
                });
            }
        }

        class ManifoldVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                this.history = [];
                this.maxHistory = 100;
            }
            
            draw(brain) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, w, h);
                
                const cx = w / 2;
                const cy = h / 2;
                
                // Draw axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, cy);
                ctx.lineTo(w, cy);
                ctx.moveTo(cx, 0);
                ctx.lineTo(cx, h);
                ctx.stroke();
                
                // Project population vectors into 3D space
                const regions = Array.from(brain.regions.values());
                const scale = 180;
                
                // Draw trails
                this.history.push(regions.map(r => ({
                    x: r.populationVector[0],
                    y: r.populationVector[1],
                    z: r.populationVector[2] || 0,
                    color: r.color
                })));
                if (this.history.length > this.maxHistory) this.history.shift();
                
                ctx.globalAlpha = 0.2;
                this.history.forEach((frame, i) => {
                    const alpha = i / this.history.length;
                    frame.forEach(point => {
                        const x = cx + point.x * scale;
                        const y = cy + point.y * scale - point.z * scale * 0.5;
                        ctx.fillStyle = point.color;
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });
                });
                ctx.globalAlpha = 1;
                
                // Draw current positions
                regions.forEach(region => {
                    const x = cx + region.populationVector[0] * scale;
                    const y = cy + region.populationVector[1] * scale;
                    const z = region.populationVector[2] || 0;
                    const py = y - z * scale * 0.5;
                    const size = Math.log(region.neurons + 1) * region.activity;
                    
                    // Glow
                    const glow = ctx.createRadialGradient(x, py, 0, x, py, size * 3);
                    glow.addColorStop(0, region.color + '80');
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.fillRect(x - size * 3, py - size * 3, size * 6, size * 6);
                    
                    // Core
                    ctx.fillStyle = region.color;
                    ctx.beginPath();
                    ctx.arc(x, py, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Connection lines
                    region.connections.forEach(conn => {
                        const target = brain.regions.get(conn.from);
                        if (target) {
                            const tx = cx + target.populationVector[0] * scale;
                            const tz = target.populationVector[2] || 0;
                            const ty = cy + target.populationVector[1] * scale - tz * scale * 0.5;
                            
                            ctx.strokeStyle = `rgba(255, 255, 255, ${conn.strength * region.activity * 0.2})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(x, py);
                            ctx.lineTo(tx, ty);
                            ctx.stroke();
                        }
                    });
                });
            }
        }

        class CoherenceVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                this.history = [];
                this.maxHistory = 300;
            }
            
            draw(brain) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, w, h);
                
                // Add current coherence to history
                const regions = Array.from(brain.regions.values());
                this.history.push(regions.map(r => r.coherence));
                if (this.history.length > this.maxHistory) this.history.shift();
                
                // Draw each region's coherence evolution
                regions.forEach((region, idx) => {
                    ctx.strokeStyle = region.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    
                    for (let i = 0; i < this.history.length; i++) {
                        const x = (i / this.maxHistory) * w;
                        const coherence = this.history[i][idx];
                        const y = h - (coherence / 60) * h * 0.9;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                });
                
                ctx.globalAlpha = 1;
                
                // Draw rupture threshold
                ctx.strokeStyle = 'rgba(255, 69, 96, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                const threshY = h - (50 / 60) * h * 0.9;
                ctx.beginPath();
                ctx.moveTo(0, threshY);
                ctx.lineTo(w, threshY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '14px monospace';
                ctx.fillText('Rupture Threshold (C = 50)', 10, threshY - 5);
                ctx.fillText('Time â†’', w - 70, h - 10);
                ctx.fillText('â†‘ Coherence', 10, 20);
            }
        }

        class ConnectivityVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
            }
            
            draw(brain) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, w, h);
                
                // Layout regions in a circle
                const regions = Array.from(brain.regions.values());
                const radius = Math.min(w, h) * 0.35;
                const cx = w / 2;
                const cy = h / 2;
                
                const positions = new Map();
                regions.forEach((region, i) => {
                    const angle = (i / regions.length) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    positions.set(region.name, { x, y });
                });
                
                // Draw connections with activity
                CONNECTIONS.forEach(conn => {
                    const from = positions.get(conn.from);
                    const to = positions.get(conn.to);
                    const fromRegion = brain.regions.get(conn.from);
                    
                    if (from && to && fromRegion) {
                        const activity = fromRegion.activity * conn.strength;
                        const alpha = activity * 0.8;
                        
                        // Draw flowing activity
                        ctx.strokeStyle = `rgba(233, 69, 96, ${alpha})`;
                        ctx.lineWidth = activity * 4 + 1;
                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();
                        
                        // Draw moving particles
                        if (activity > 0.3) {
                            const numParticles = Math.floor(activity * 5);
                            for (let i = 0; i < numParticles; i++) {
                                const t = (Date.now() * 0.001 + i * 0.2) % 1;
                                const px = from.x + (to.x - from.x) * t;
                                const py = from.y + (to.y - from.y) * t;
                                
                                ctx.fillStyle = `rgba(255, 215, 0, ${activity})`;
                                ctx.beginPath();
                                ctx.arc(px, py, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                });
                
                // Draw regions
                regions.forEach(region => {
                    const pos = positions.get(region.name);
                    const size = Math.log(region.neurons + 1) * 2;
                    
                    // Glow
                    if (region.activity > 0.4) {
                        const glow = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, size * 3);
                        glow.addColorStop(0, region.color + '60');
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.fillRect(pos.x - size * 3, pos.y - size * 3, size * 6, size * 6);
                    }
                    
                    // Node
                    ctx.fillStyle = region.color;
                    ctx.globalAlpha = 0.4 + region.activity * 0.6;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Label
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(region.name.replace(/_/g, ' '), pos.x, pos.y + size + 12);
                });
            }
        }

        // ===== FLY CONTROLLER =====
        class FlyController {
            constructor(brain) {
                this.brain = brain;
                this.fly = document.getElementById('theFly');
                this.flyHead = document.getElementById('flyHead');
                this.wingLeft = document.getElementById('wingLeft');
                this.wingRight = document.getElementById('wingRight');
                this.antennaLeft = document.getElementById('antennaLeft');
                this.antennaRight = document.getElementById('antennaRight');
                this.lightSource = document.getElementById('lightSource');
                this.odorSource = document.getElementById('odorSource');
                this.behaviorLabel = document.getElementById('behaviorLabel');
                this.flyWorld = document.getElementById('flyWorld');
                
                this.position = { x: 50, y: 50 }; // percentage
                this.angle = 0; // degrees
                this.speed = 0;
                this.wingBeatFreq = 0;
            }
            
            update(dt) {
                // Get motor neuron activities
                const flight = this.brain.regions.get('Descending_Neurons_Flight');
                const walking = this.brain.regions.get('Descending_Neurons_Walking');
                const head = this.brain.regions.get('Descending_Neurons_Head');
                
                // Get sensory activities
                const visual = (this.brain.regions.get('Photoreceptors_R1_R6').activity + 
                               this.brain.regions.get('Photoreceptors_R7_R8').activity) / 2;
                const olfactory = this.brain.regions.get('Olfactory_Receptors').activity;
                
                // Get navigation activity
                const ellipsoid = this.brain.regions.get('Ellipsoid_Body');
                const protocerebral = this.brain.regions.get('Protocerebral_Bridge');
                
                // Determine behavior based on neural activity
                let behavior = 'Idle';
                
                // FLIGHT BEHAVIOR
                if (flight && flight.activity > 0.4) {
                    behavior = 'Flying';
                    this.wingBeatFreq = flight.activity * 200; // Hz
                    this.speed = flight.activity * 2;
                    
                    // Wing animation based on activity
                    this.wingLeft.style.animation = `wing-beat ${1/this.wingBeatFreq}s infinite alternate`;
                    this.wingRight.style.animation = `wing-beat ${1/this.wingBeatFreq}s infinite alternate`;
                } else {
                    this.wingLeft.style.animation = 'none';
                    this.wingRight.style.animation = 'none';
                    this.wingBeatFreq = 0;
                }
                
                // WALKING BEHAVIOR
                if (walking && walking.activity > 0.4 && flight.activity < 0.3) {
                    behavior = 'Walking';
                    this.speed = walking.activity * 1;
                }
                
                // PHOTOTAXIS (attracted to light)
                if (visual > 0.6) {
                    behavior = 'Phototaxis';
                    const lightRect = this.lightSource.getBoundingClientRect();
                    const flyRect = this.fly.getBoundingClientRect();
                    const worldRect = this.flyWorld.getBoundingClientRect();
                    
                    const dx = lightRect.left - flyRect.left;
                    const dy = lightRect.top - flyRect.top;
                    const targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Turn towards light
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > 180) angleDiff -= 360;
                    while (angleDiff < -180) angleDiff += 360;
                    
                    this.angle += angleDiff * 0.1 * visual;
                    this.speed = visual * 1.5;
                }
                
                // CHEMOTAXIS (attracted to odor)
                if (olfactory > 0.6) {
                    behavior = 'Odor Tracking';
                    const odorRect = this.odorSource.getBoundingClientRect();
                    const flyRect = this.fly.getBoundingClientRect();
                    
                    const dx = odorRect.left - flyRect.left;
                    const dy = odorRect.top - flyRect.top;
                    const targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Turn towards odor
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > 180) angleDiff -= 360;
                    while (angleDiff < -180) angleDiff += 360;
                    
                    this.angle += angleDiff * 0.08 * olfactory;
                    this.speed = olfactory * 1.2;
                    
                    // Antenna movement
                    const antennaAngle = Math.sin(Date.now() * 0.01) * 30 * olfactory;
                    this.antennaLeft.style.transform = `rotate(${-20 + antennaAngle}deg)`;
                    this.antennaRight.style.transform = `rotate(${20 - antennaAngle}deg)`;
                }
                
                // HEAD TURNING
                if (head && head.activity > 0.3) {
                    const headAngle = (head.activity - 0.5) * 30;
                    this.flyHead.style.transform = `rotate(${headAngle}deg)`;
                }
                
                // NAVIGATION INFLUENCE
                if (protocerebral && protocerebral.activity > 0.4) {
                    behavior += ' (Navigating)';
                    // Compass-like heading changes
                    const compassAngle = protocerebral.coherence * 10;
                    this.angle += Math.sin(compassAngle * Math.PI / 180) * 2;
                }
                
                // COHERENCE EFFECTS (high coherence = more rigid movement)
                const globalCoherence = this.brain.getGlobalCoherence();
                const rigidity = Math.min(1, globalCoherence / 30);
                const flexibility = 1 - rigidity;
                
                // High coherence makes fly move more predictably but less flexibly
                this.speed *= (0.5 + 0.5 * flexibility);
                
                // Update position
                const radAngle = this.angle * Math.PI / 180;
                this.position.x += Math.cos(radAngle) * this.speed * dt * 10;
                this.position.y += Math.sin(radAngle) * this.speed * dt * 10;
                
                // Boundaries
                const worldRect = this.flyWorld.getBoundingClientRect();
                const flyW = 120;
                const flyH = 80;
                
                if (this.position.x < 0) this.position.x = 0;
                if (this.position.x > 100) this.position.x = 100;
                if (this.position.y < 0) this.position.y = 0;
                if (this.position.y > 100) this.position.y = 100;
                
                // Apply transforms
                this.fly.style.left = this.position.x + '%';
                this.fly.style.top = this.position.y + '%';
                this.fly.style.transform = `translate(-50%, -50%) rotate(${this.angle}deg)`;
                
                // Update behavior label
                this.behaviorLabel.textContent = behavior + ` (Coherence: ${globalCoherence.toFixed(1)})`;
            }
        }

        // ===== INITIALIZE =====
        const brain = new FlyBrain();
        const brainViz = new BrainVisualizer(document.getElementById('brainCanvas'));
        const manifoldViz = new ManifoldVisualizer(document.getElementById('manifoldCanvas'));
        const coherenceViz = new CoherenceVisualizer(document.getElementById('coherenceCanvas'));
        const connectViz = new ConnectivityVisualizer(document.getElementById('connectivityCanvas'));
        const flyController = new FlyController(brain);
        
        // Controls
        document.getElementById('odorSlider').oninput = (e) => {
            brain.odorStimulus = parseFloat(e.target.value);
            document.getElementById('odorVal').textContent = brain.odorStimulus.toFixed(2);
            
            // Update odor source intensity
            const odorSource = document.getElementById('odorSource');
            odorSource.style.opacity = brain.odorStimulus;
            odorSource.style.transform = `scale(${0.8 + brain.odorStimulus * 0.4})`;
        };
        
        document.getElementById('visualSlider').oninput = (e) => {
            brain.visualStimulus = parseFloat(e.target.value);
            document.getElementById('visualVal').textContent = brain.visualStimulus.toFixed(2);
            
            // Update light source brightness
            const lightSource = document.getElementById('lightSource');
            lightSource.style.opacity = brain.visualStimulus;
            lightSource.style.boxShadow = `0 0 ${30 * brain.visualStimulus}px rgba(255, 255, 100, ${0.6 * brain.visualStimulus})`;
        };
        
        document.getElementById('lightSlider').oninput = (e) => {
            brain.lightDirection = parseFloat(e.target.value);
            document.getElementById('lightVal').textContent = brain.lightDirection.toFixed(0) + 'Â°';
            
            // Move light source based on angle
            const angle = brain.lightDirection * Math.PI / 180;
            const radius = 150;
            const centerX = 50; // percent
            const centerY = 50; // percent
            const lightX = centerX + Math.cos(angle) * 30; // percent
            const lightY = centerY + Math.sin(angle) * 30; // percent
            
            document.getElementById('lightSource').style.left = lightX + '%';
            document.getElementById('lightSource').style.top = lightY + '%';
        };
        
        const sim = {
            triggerRupture: () => {
                brain.regions.forEach(r => r.coherence = 55);
            },
            reset: () => {
                brain.regions.forEach(r => {
                    r.coherence = 0;
                    r.activity = 0.1;
                    r.memoryTraces = [];
                });
                brain.ruptureCount = 0;
            },
            startLearning: () => {
                // Activate learning regions with correct names
                ['MB_Calyx', 'MB_Kenyon_Alpha', 'MB_Kenyon_Beta', 'MB_Kenyon_Gamma', 
                 'MB_Output', 'Dopaminergic_Clusters'].forEach(name => {
                    const r = brain.regions.get(name);
                    if (r) r.activity = 0.9;
                });
            },
            randomStimuli: () => {
                brain.odorStimulus = Math.random();
                brain.visualStimulus = Math.random();
                document.getElementById('odorSlider').value = brain.odorStimulus;
                document.getElementById('visualSlider').value = brain.visualStimulus;
                document.getElementById('odorVal').textContent = brain.odorStimulus.toFixed(2);
                document.getElementById('visualVal').textContent = brain.visualStimulus.toFixed(2);
            },
            toggleRotation: () => {
                brainViz.autoRotate = !brainViz.autoRotate;
            }
        };
        
        // Animation loop
        let lastTime = Date.now();
        let frameCount = 0;
        let fpsTime = Date.now();
        
        function animate() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;
            
            const ruptured = brain.update(Math.min(dt, 0.05));
            
            if (ruptured) {
                document.getElementById('ruptureFlash').classList.add('active');
                setTimeout(() => {
                    document.getElementById('ruptureFlash').classList.remove('active');
                }, 300);
            }
            
            brainViz.draw(brain);
            manifoldViz.draw(brain);
            coherenceViz.draw(brain);
            connectViz.draw(brain);
            flyController.update(dt);
            
            // Update stats
            document.getElementById('coherenceStat').textContent = brain.getGlobalCoherence().toFixed(2);
            document.getElementById('ruptureStat').textContent = brain.ruptureCount;
            document.getElementById('activeNeurons').textContent = brain.getActiveNeurons().toLocaleString();
            document.getElementById('memoryWeight').textContent = brain.getMemoryWeight().toFixed(2);
            
            frameCount++;
            if (now - fpsTime > 1000) {
                document.getElementById('fpsStat').textContent = frameCount;
                frameCount = 0;
                fpsTime = now;
            }
            
            requestAnimationFrame(animate);
        }
        
        console.log('ðŸ§  Anatomical Fly Brain Simulation Running');
        console.log('============================================');
        console.log(`Total regions: ${BRAIN_REGIONS.length}`);
        console.log(`Total neurons: ${BRAIN_REGIONS.reduce((s, r) => s + r.neurons, 0).toLocaleString()}`);
        console.log(`Total connections: ${CONNECTIONS.length}`);
        console.log('');
        console.log('Brain structure:');
        console.log(`  Optic lobes: ${BRAIN_REGIONS.filter(r => r.type === 'visual' || r.name.includes('Photoreceptor')).reduce((s, r) => s + r.neurons, 0).toLocaleString()} neurons`);
        console.log(`  Olfactory: ${BRAIN_REGIONS.filter(r => r.type === 'olfactory' || r.name.includes('Olfactory')).reduce((s, r) => s + r.neurons, 0).toLocaleString()} neurons`);
        console.log(`  Mushroom body: ${BRAIN_REGIONS.filter(r => r.type === 'learning').reduce((s, r) => s + r.neurons, 0).toLocaleString()} neurons`);
        console.log(`  Central complex: ${BRAIN_REGIONS.filter(r => r.type === 'navigation').reduce((s, r) => s + r.neurons, 0).toLocaleString()} neurons`);
        console.log(`  Integration: ${BRAIN_REGIONS.filter(r => r.type === 'integration').reduce((s, r) => s + r.neurons, 0).toLocaleString()} neurons`);
        console.log(`  Motor: ${BRAIN_REGIONS.filter(r => r.type === 'motor').reduce((s, r) => s + r.neurons, 0).toLocaleString()} neurons`);
        console.log('');
        console.log('âœ… All regions initialized with CRR dynamics');
        console.log('âœ… Biological connectome applied');
        console.log('âœ… Photo-realistic fly controlled by brain');
        console.log('âœ… Ready to simulate!');
        animate();
    </script>
</body>
</html>