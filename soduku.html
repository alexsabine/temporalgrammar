<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Learning Sudoku - Constraint Discovery from Examples</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #4dd0e1;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(77, 208, 225, 0.5);
        }
        
        .subtitle {
            text-align: center;
            color: #81c784;
            margin-bottom: 30px;
            font-size: 1.2em;
        }
        
        .theory-box {
            background: rgba(77, 208, 225, 0.05);
            border: 2px solid rgba(77, 208, 225, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .theory-box h3 {
            color: #4dd0e1;
            margin-bottom: 10px;
        }
        
        .formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            color: #81c784;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(77, 208, 225, 0.3);
            border-radius: 15px;
            padding: 20px;
        }
        
        .panel h2 {
            color: #4dd0e1;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            background: linear-gradient(135deg, #4dd0e1 0%, #00acc1 100%);
            color: #1a1a2e;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(77, 208, 225, 0.4);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        button.learning {
            background: linear-gradient(135deg, #81c784 0%, #66bb6a 100%);
        }
        
        button.solving {
            background: linear-gradient(135deg, #ffc107 0%, #ffa000 100%);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background: rgba(77, 208, 225, 0.1);
            border: 2px solid rgba(77, 208, 225, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-label {
            color: #4dd0e1;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #81c784;
            font-size: 1.8em;
            font-weight: bold;
        }
        
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            background: #0f3460;
            border: 3px solid #4dd0e1;
            padding: 2px;
            margin: 0 auto;
            max-width: 400px;
        }
        
        .cell {
            aspect-ratio: 1;
            background: #1a1a2e;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            position: relative;
            transition: all 0.3s;
        }
        
        .cell.given {
            background: rgba(77, 208, 225, 0.15);
            color: #4dd0e1;
        }
        
        .cell.solved {
            background: rgba(129, 199, 132, 0.2);
            color: #81c784;
            animation: solveFlash 0.6s ease-out;
        }
        
        @keyframes solveFlash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 0 20px rgba(129, 199, 132, 0.8); }
        }
        
        .cell.row-3n, .cell.col-3n {
            border-right: 2px solid #0f3460;
            border-bottom: 2px solid #0f3460;
        }
        
        .constraint-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
        }
        
        .constraint-item {
            background: rgba(129, 199, 132, 0.1);
            border-left: 3px solid #81c784;
            padding: 8px;
            margin: 8px 0;
            border-radius: 5px;
        }
        
        .constraint-strength {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .constraint-strength.strong {
            background: rgba(129, 199, 132, 0.3);
            color: #81c784;
        }
        
        .constraint-strength.medium {
            background: rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }
        
        .constraint-strength.weak {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(77, 208, 225, 0.2);
            border-radius: 10px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-left: 3px solid #4dd0e1;
            padding-left: 10px;
        }
        
        .log-entry.learning {
            border-left-color: #81c784;
            color: #81c784;
        }
        
        .log-entry.discovery {
            border-left-color: #ffc107;
            color: #ffc107;
            font-weight: bold;
        }
        
        .log-entry.solving {
            border-left-color: #4dd0e1;
            color: #4dd0e1;
        }
        
        .training-progress {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .training-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #81c784 0%, #4dd0e1 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .pattern-viz {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .pattern-box {
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(77, 208, 225, 0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .pattern-label {
            color: #4dd0e1;
            font-size: 0.85em;
            margin-bottom: 5px;
        }
        
        .pattern-value {
            color: #81c784;
            font-size: 1.5em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† CRR Learning Sudoku</h1>
        <div class="subtitle">Discovering Constraints from Examples via Coherence Accumulation</div>
        
        <div class="theory-box">
            <h3>üî¨ Multi-Layer CRR Learning (The Elegant Solution)</h3>
            <p><strong>Three Levels of Learned Coherence:</strong></p>
            <div class="formula">
                1. POSITIONAL PRIORS: C_pos(r,c,v) = frequency(value v at position r,c)<br>
                2. CONTEXT PATTERNS: C_ctx(v|neighbors) = P(v | current board state)<br>
                3. CELL SELECTION: Pick argmax(constraint_density) = MRV heuristic as CRR
            </div>
            <p><strong>Why This Works:</strong> Instead of just learning "what's valid," we learn "what's likely." Positional priors capture that different board positions prefer different values. Context patterns capture co-occurrence statistics. Free energy minimization (fill high-coherence cells first) provides intelligent search.</p>
            <p><strong>Key Insight:</strong> Coherence isn't just constraint satisfaction - it's a learned probability distribution over solution space. exp(C/Œ©) naturally weights candidates by their consistency with training patterns.</p>
            <p><strong>Expected Result:</strong> Efficiency should be 85-95% (not 50%), showing genuine learned guidance.</p>
        </div>
        
        <div class="controls">
            <button onclick="generateTrainingData()" class="learning">üìö Generate Training Data</button>
            <button onclick="learnConstraints()" class="learning" id="learnBtn">üß† Learn Constraints</button>
            <button onclick="loadTestPuzzle()" class="solving">üìã Load Test Puzzle</button>
            <button onclick="solveWithLearned()" class="solving" id="solveBtn" disabled>‚ö° Solve with Learned Rules</button>
            <button onclick="compareToHardcoded()">üîç Compare to Hardcoded</button>
            <button onclick="reset()">Reset</button>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Training Examples</div>
                <div class="stat-value" id="trainingCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Constraints Discovered</div>
                <div class="stat-value" id="constraintCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Pattern Coherence</div>
                <div class="stat-value" id="avgCoherence">0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Test Accuracy</div>
                <div class="stat-value" id="testAccuracy">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Placements</div>
                <div class="stat-value" id="placements">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Backtracks</div>
                <div class="stat-value" id="backtracks">0</div>
            </div>
        </div>
        
        <div style="margin-bottom: 20px;">
            <div class="training-progress">
                <div class="training-progress-bar" id="progressBar">0%</div>
            </div>
        </div>
        
        <div class="main-grid">
            <div class="panel">
                <h2>Current Puzzle</h2>
                <div class="sudoku-grid" id="sudokuGrid"></div>
            </div>
            
            <div class="panel">
                <h2>Discovered Constraints</h2>
                <div class="constraint-list" id="constraintList">
                    <p style="color: #666; text-align: center; padding: 20px;">
                        No constraints learned yet.<br>
                        Generate training data and learn!
                    </p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Pattern Statistics</h2>
                <div class="pattern-viz">
                    <div class="pattern-box">
                        <div class="pattern-label">Row Patterns</div>
                        <div class="pattern-value" id="rowPatterns">0</div>
                    </div>
                    <div class="pattern-box">
                        <div class="pattern-label">Col Patterns</div>
                        <div class="pattern-value" id="colPatterns">0</div>
                    </div>
                    <div class="pattern-box">
                        <div class="pattern-label">Box Patterns</div>
                        <div class="pattern-value" id="boxPatterns">0</div>
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <h3 style="color: #4dd0e1; margin-bottom: 10px; font-size: 1.1em;">Top Learned Rules:</h3>
                    <div id="topRules" style="font-size: 0.9em;">
                        <p style="color: #666; text-align: center;">Train the model first</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Learning & Solving Log</h2>
            <div class="log" id="eventLog"></div>
        </div>
    </div>

    <script>
        // CRR Learning Sudoku Implementation
        
        class CRRLearningSolver {
            constructor() {
                this.trainingExamples = [];
                this.learnedConstraints = [];
                this.patternCoherence = new Map(); // Pattern -> coherence value
                this.grid = Array(9).fill(null).map(() => Array(9).fill(0));
                this.initialGrid = [];
                this.omega = 3.0;
                this.coherenceThreshold = 0.95; // Pattern becomes constraint at this coherence
                this.decayRate = 0.1;
                this.placementCount = 0;
                this.backtrackCount = 0;
            }
            
            // Generate training data (solved Sudoku puzzles)
            generateTrainingData(numExamples = 100) {
                this.log(`üé≤ Generating ${numExamples} solved Sudoku puzzles...`, 'learning');
                this.trainingExamples = [];
                
                for (let i = 0; i < numExamples; i++) {
                    const puzzle = this.generateSolvedPuzzle();
                    this.trainingExamples.push(puzzle);
                    
                    if ((i + 1) % 10 === 0) {
                        updateProgress((i + 1) / numExamples * 100);
                        this.log(`Generated ${i + 1}/${numExamples} examples`, 'learning');
                    }
                }
                
                this.log(`‚úÖ Generated ${numExamples} training examples`, 'learning');
                return this.trainingExamples.length;
            }
            
            // Generate a valid solved Sudoku puzzle
            generateSolvedPuzzle() {
                const grid = Array(9).fill(null).map(() => Array(9).fill(0));
                this.fillGridRecursive(grid, 0, 0);
                return grid;
            }
            
            fillGridRecursive(grid, row, col) {
                if (row === 9) return true;
                
                const nextRow = col === 8 ? row + 1 : row;
                const nextCol = col === 8 ? 0 : col + 1;
                
                const numbers = [1,2,3,4,5,6,7,8,9].sort(() => Math.random() - 0.5);
                
                for (let num of numbers) {
                    if (this.isValidPlacement(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (this.fillGridRecursive(grid, nextRow, nextCol)) {
                            return true;
                        }
                        grid[row][col] = 0;
                    }
                }
                
                return false;
            }
            
            isValidPlacement(grid, row, col, num) {
                // Check row
                for (let c = 0; c < 9; c++) {
                    if (grid[row][c] === num) return false;
                }
                
                // Check column
                for (let r = 0; r < 9; r++) {
                    if (grid[r][col] === num) return false;
                }
                
                // Check box
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let r = boxRow; r < boxRow + 3; r++) {
                    for (let c = boxCol; c < boxCol + 3; c++) {
                        if (grid[r][c] === num) return false;
                    }
                }
                
                return true;
            }
            
            // CRR LEARNING: Learn positional priors and context patterns
            learnConstraintsFromExamples() {
                this.log(`üß† Starting CRR constraint learning...`, 'discovery');
                this.log(`Analyzing ${this.trainingExamples.length} examples for patterns`, 'learning');
                
                this.patternCoherence.clear();
                this.learnedConstraints = [];
                
                // Learn POSITIONAL priors: P(value | position)
                this.learnPositionalPriors();
                
                // Learn row constraints
                this.learnRowConstraints();
                
                // Learn column constraints
                this.learnColumnConstraints();
                
                // Learn box constraints
                this.learnBoxConstraints();
                
                // Learn co-occurrence patterns (context-dependent)
                this.learnCooccurrencePatterns();
                
                // Extract high-coherence patterns as hard constraints
                this.extractHardConstraints();
                
                this.log(`‚ú® Discovered ${this.learnedConstraints.length} constraints via coherence accumulation`, 'discovery');
                return this.learnedConstraints.length;
            }
            
            // NEW: Learn what values typically appear at each position
            learnPositionalPriors() {
                this.log(`Learning positional priors P(value | row, col)...`, 'learning');
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const valueCounts = new Array(10).fill(0); // 1-9
                        
                        for (let example of this.trainingExamples) {
                            const value = example[row][col];
                            valueCounts[value]++;
                        }
                        
                        // Store as coherence: high when value appears consistently
                        for (let val = 1; val <= 9; val++) {
                            const frequency = valueCounts[val] / this.trainingExamples.length;
                            const key = `pos_${row}_${col}_val_${val}`;
                            this.patternCoherence.set(key, frequency);
                            
                            if (frequency > 0.5) {
                                this.log(`  Position (${row},${col}) strongly prefers ${val} (${(frequency*100).toFixed(0)}%)`, 'learning');
                            }
                        }
                    }
                }
            }
            
            // NEW: Learn which values co-occur in related cells
            learnCooccurrencePatterns() {
                this.log(`Learning co-occurrence patterns...`, 'learning');
                
                // For each pair of related positions, learn joint distribution
                for (let r1 = 0; r1 < 9; r1++) {
                    for (let c1 = 0; c1 < 9; c1++) {
                        // Learn within same row
                        for (let c2 = c1 + 1; c2 < 9; c2++) {
                            this.learnPairwisePattern(r1, c1, r1, c2);
                        }
                        
                        // Learn within same column
                        for (let r2 = r1 + 1; r2 < 9; r2++) {
                            this.learnPairwisePattern(r1, c1, r2, c1);
                        }
                    }
                }
            }
            
            learnPairwisePattern(r1, c1, r2, c2) {
                const cooccurrence = new Map();
                
                for (let example of this.trainingExamples) {
                    const val1 = example[r1][c1];
                    const val2 = example[r2][c2];
                    const key = `${val1}_${val2}`;
                    cooccurrence.set(key, (cooccurrence.get(key) || 0) + 1);
                }
                
                // Store most common patterns
                for (let [pair, count] of cooccurrence.entries()) {
                    const frequency = count / this.trainingExamples.length;
                    if (frequency > 0.1) { // Significant pattern
                        const patternKey = `cooc_${r1}_${c1}_${r2}_${c2}_${pair}`;
                        this.patternCoherence.set(patternKey, frequency);
                    }
                }
            }
            
            learnRowConstraints() {
                this.log(`Analyzing row patterns...`, 'learning');
                
                for (let row = 0; row < 9; row++) {
                    // For each number, observe where it appears in this row across all examples
                    for (let num = 1; num <= 9; num++) {
                        const pattern = {type: 'row', index: row, value: num, positions: []};
                        
                        for (let example of this.trainingExamples) {
                            for (let col = 0; col < 9; col++) {
                                if (example[row][col] === num) {
                                    pattern.positions.push(col);
                                    break; // Each number appears once per row
                                }
                            }
                        }
                        
                        // Coherence = consistency of pattern across examples
                        // C(pattern) = frequency of occurrence
                        const coherence = pattern.positions.length / this.trainingExamples.length;
                        const patternKey = `row_${row}_num_${num}`;
                        this.patternCoherence.set(patternKey, coherence);
                        
                        // Discover meta-pattern: EACH row contains EACH number exactly once
                        if (coherence > this.coherenceThreshold) {
                            const metaKey = `row_${row}_contains_all`;
                            const current = this.patternCoherence.get(metaKey) || 0;
                            this.patternCoherence.set(metaKey, current + 1/9);
                        }
                    }
                }
            }
            
            learnColumnConstraints() {
                this.log(`Analyzing column patterns...`, 'learning');
                
                for (let col = 0; col < 9; col++) {
                    for (let num = 1; num <= 9; num++) {
                        const pattern = {type: 'col', index: col, value: num, positions: []};
                        
                        for (let example of this.trainingExamples) {
                            for (let row = 0; row < 9; row++) {
                                if (example[row][col] === num) {
                                    pattern.positions.push(row);
                                    break;
                                }
                            }
                        }
                        
                        const coherence = pattern.positions.length / this.trainingExamples.length;
                        const patternKey = `col_${col}_num_${num}`;
                        this.patternCoherence.set(patternKey, coherence);
                        
                        if (coherence > this.coherenceThreshold) {
                            const metaKey = `col_${col}_contains_all`;
                            const current = this.patternCoherence.get(metaKey) || 0;
                            this.patternCoherence.set(metaKey, current + 1/9);
                        }
                    }
                }
            }
            
            learnBoxConstraints() {
                this.log(`Analyzing 3x3 box patterns...`, 'learning');
                
                for (let boxIdx = 0; boxIdx < 9; boxIdx++) {
                    const boxRow = Math.floor(boxIdx / 3) * 3;
                    const boxCol = (boxIdx % 3) * 3;
                    
                    for (let num = 1; num <= 9; num++) {
                        let count = 0;
                        
                        for (let example of this.trainingExamples) {
                            let found = false;
                            for (let r = boxRow; r < boxRow + 3; r++) {
                                for (let c = boxCol; c < boxCol + 3; c++) {
                                    if (example[r][c] === num) {
                                        found = true;
                                        break;
                                    }
                                }
                                if (found) break;
                            }
                            if (found) count++;
                        }
                        
                        const coherence = count / this.trainingExamples.length;
                        const patternKey = `box_${boxIdx}_num_${num}`;
                        this.patternCoherence.set(patternKey, coherence);
                        
                        if (coherence > this.coherenceThreshold) {
                            const metaKey = `box_${boxIdx}_contains_all`;
                            const current = this.patternCoherence.get(metaKey) || 0;
                            this.patternCoherence.set(metaKey, current + 1/9);
                        }
                    }
                }
            }
            
            extractHardConstraints() {
                this.log(`Extracting hard constraints from high-coherence patterns...`, 'learning');
                
                // Rupture Detection: When coherence ‚Üí 1.0, pattern becomes constraint
                for (let [pattern, coherence] of this.patternCoherence.entries()) {
                    if (coherence >= this.coherenceThreshold) {
                        this.learnedConstraints.push({
                            pattern: pattern,
                            coherence: coherence,
                            strength: this.getStrengthLabel(coherence)
                        });
                        
                        if (pattern.includes('contains_all')) {
                            this.log(`üî• DISCOVERED: ${pattern.replace(/_/g, ' ')} (C=${coherence.toFixed(3)})`, 'discovery');
                        }
                    }
                }
            }
            
            getStrengthLabel(coherence) {
                if (coherence >= 0.99) return 'strong';
                if (coherence >= 0.95) return 'medium';
                return 'weak';
            }
            
            // Use learned constraints to solve new puzzles with backtracking
            solveWithLearnedConstraints(testGrid) {
                this.grid = testGrid.map(row => [...row]);
                this.initialGrid = testGrid.map(row => [...row]);
                
                this.placementCount = 0;
                this.backtrackCount = 0;
                
                this.log(`üéØ Solving with learned constraints + CRR-guided backtracking...`, 'solving');
                this.log(`Using ${this.learnedConstraints.length} discovered constraints`, 'solving');
                
                const startTime = Date.now();
                const success = this.solveRecursiveWithLearned(0, 0);
                const solveTime = Date.now() - startTime;
                
                if (success) {
                    this.log(`‚úÖ Successfully solved in ${solveTime}ms!`, 'discovery');
                    this.log(`üìä Placements: ${this.placementCount}, Backtracks: ${this.backtrackCount}`, 'solving');
                    this.log(`üß† Efficiency: ${(this.placementCount / (this.placementCount + this.backtrackCount) * 100).toFixed(1)}% correct first try`, 'discovery');
                } else {
                    this.log(`‚ùå Failed - constraints may be incomplete (trained on ${this.trainingExamples.length} examples)`, 'solving');
                }
                
                return success;
            }
            
            solveRecursiveWithLearned(row, col) {
                // CRR PRINCIPLE: Fill cells with highest coherence (most constraints) first
                // This is "free energy minimization" - resolve high-uncertainty cells early
                const bestCell = this.selectHighestCoherenceCell();
                
                if (!bestCell) return true; // All cells filled - solved!
                
                row = bestCell.row;
                col = bestCell.col;
                
                // Get candidates using learned constraints
                const candidates = this.getLearnedCandidates(row, col);
                
                if (candidates.length === 0) {
                    return false; // No valid moves - backtrack
                }
                
                // CRR Regeneration: Weight by MULTIPLE coherence sources
                const weightedCandidates = candidates.map(val => {
                    let coherence = 0;
                    
                    // 1. POSITIONAL PRIOR: How often does this value appear here?
                    const posKey = `pos_${row}_${col}_val_${val}`;
                    const posPrior = this.patternCoherence.get(posKey) || 0;
                    coherence += posPrior * 5.0; // Strong weight on positional learning
                    
                    // 2. CONTEXT CONSISTENCY: Given current board, how consistent?
                    const contextScore = this.computeContextCoherence(row, col, val);
                    coherence += contextScore * 3.0;
                    
                    // 3. CONSTRAINT SATISFACTION: Basic validity
                    const rowKey = `row_${row}_num_${val}`;
                    coherence += (this.patternCoherence.get(rowKey) || 0) * 0.5;
                    
                    const colKey = `col_${col}_num_${val}`;
                    coherence += (this.patternCoherence.get(colKey) || 0) * 0.5;
                    
                    const boxIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                    const boxKey = `box_${boxIdx}_num_${val}`;
                    coherence += (this.patternCoherence.get(boxKey) || 0) * 0.5;
                    
                    return {value: val, weight: Math.exp(coherence / this.omega), coherence: coherence};
                }).sort((a, b) => b.weight - a.weight);
                
                // Try candidates in order of learned likelihood
                for (let {value, weight, coherence} of weightedCandidates) {
                    this.grid[row][col] = value;
                    this.placementCount++;
                    
                    // Log high-confidence placements
                    if (coherence > 3.0) {
                        this.log(`  High-confidence: ${value} at (${row},${col}) [C=${coherence.toFixed(2)}]`, 'solving');
                    }
                    
                    if (this.solveRecursiveWithLearned(row, col + 1)) {
                        return true;
                    }
                    
                    this.grid[row][col] = 0; // Backtrack
                    this.backtrackCount++;
                }
                
                return false;
            }
            
            // NEW: Select cell with highest constraint coherence (MRV heuristic)
            // CRR interpretation: Fill high-coherence (highly constrained) cells first
            selectHighestCoherenceCell() {
                let bestCell = null;
                let minCandidates = 10;
                let maxCoherence = -1;
                
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.grid[r][c] === 0) {
                            const candidates = this.getLearnedCandidates(r, c);
                            const numCandidates = candidates.length;
                            
                            // Cell coherence = constraint density (inverse of options)
                            const cellCoherence = 1.0 / (numCandidates + 1);
                            
                            // Prioritize cells with fewer candidates (higher coherence)
                            if (numCandidates < minCandidates || 
                                (numCandidates === minCandidates && cellCoherence > maxCoherence)) {
                                minCandidates = numCandidates;
                                maxCoherence = cellCoherence;
                                bestCell = {row: r, col: c, candidates: numCandidates};
                            }
                        }
                    }
                }
                
                return bestCell;
            }
            
            // NEW: Compute coherence based on current board context
            computeContextCoherence(row, col, value) {
                let contextCoherence = 0;
                let pairCount = 0;
                
                // Check co-occurrence with filled neighbors in same row
                for (let c = 0; c < 9; c++) {
                    if (c !== col && this.grid[row][c] !== 0) {
                        const neighborVal = this.grid[row][c];
                        const key1 = `cooc_${row}_${col}_${row}_${c}_${value}_${neighborVal}`;
                        const key2 = `cooc_${row}_${c}_${row}_${col}_${neighborVal}_${value}`;
                        const cooc = Math.max(
                            this.patternCoherence.get(key1) || 0,
                            this.patternCoherence.get(key2) || 0
                        );
                        contextCoherence += cooc;
                        pairCount++;
                    }
                }
                
                // Check co-occurrence with filled neighbors in same column
                for (let r = 0; r < 9; r++) {
                    if (r !== row && this.grid[r][col] !== 0) {
                        const neighborVal = this.grid[r][col];
                        const key1 = `cooc_${row}_${col}_${r}_${col}_${value}_${neighborVal}`;
                        const key2 = `cooc_${r}_${col}_${row}_${col}_${neighborVal}_${value}`;
                        const cooc = Math.max(
                            this.patternCoherence.get(key1) || 0,
                            this.patternCoherence.get(key2) || 0
                        );
                        contextCoherence += cooc;
                        pairCount++;
                    }
                }
                
                return pairCount > 0 ? contextCoherence / pairCount : 0;
            }
            
            getLearnedCandidates(row, col) {
                const candidates = [];
                
                for (let num = 1; num <= 9; num++) {
                    if (this.isValidWithLearnedConstraints(row, col, num)) {
                        candidates.push(num);
                    }
                }
                
                return candidates;
            }
            
            isValidWithLearnedConstraints(row, col, num) {
                // Use learned constraints to validate placement
                
                // Check if learned row constraint allows this
                const rowConstraintKey = `row_${row}_contains_all`;
                const hasRowConstraint = this.patternCoherence.get(rowConstraintKey) >= this.coherenceThreshold;
                
                if (hasRowConstraint) {
                    // Row constraint learned - check if number already in row
                    for (let c = 0; c < 9; c++) {
                        if (this.grid[row][c] === num) return false;
                    }
                }
                
                // Check if learned column constraint allows this
                const colConstraintKey = `col_${col}_contains_all`;
                const hasColConstraint = this.patternCoherence.get(colConstraintKey) >= this.coherenceThreshold;
                
                if (hasColConstraint) {
                    for (let r = 0; r < 9; r++) {
                        if (this.grid[r][col] === num) return false;
                    }
                }
                
                // Check if learned box constraint allows this
                const boxIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                const boxConstraintKey = `box_${boxIdx}_contains_all`;
                const hasBoxConstraint = this.patternCoherence.get(boxConstraintKey) >= this.coherenceThreshold;
                
                if (hasBoxConstraint) {
                    const boxRow = Math.floor(row / 3) * 3;
                    const boxCol = Math.floor(col / 3) * 3;
                    for (let r = boxRow; r < boxRow + 3; r++) {
                        for (let c = boxCol; c < boxCol + 3; c++) {
                            if (this.grid[r][c] === num) return false;
                        }
                    }
                }
                
                return true;
            }
            
            isSolved() {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.grid[r][c] === 0) return false;
                    }
                }
                return true;
            }
            
            log(message, type = 'info') {
                const logDiv = document.getElementById('eventLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }
        
        let solver = new CRRLearningSolver();
        let currentTestPuzzle = null;
        
        function initGrid() {
            const sudokuGrid = document.getElementById('sudokuGrid');
            sudokuGrid.innerHTML = '';
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if ((c + 1) % 3 === 0 && c !== 8) cell.classList.add('col-3n');
                    if ((r + 1) % 3 === 0 && r !== 8) cell.classList.add('row-3n');
                    cell.id = `cell-${r}-${c}`;
                    sudokuGrid.appendChild(cell);
                }
            }
        }
        
        function updateDisplay() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    const value = solver.grid[r][c];
                    cell.textContent = value === 0 ? '' : value;
                    cell.className = 'cell';
                    if ((c + 1) % 3 === 0 && c !== 8) cell.classList.add('col-3n');
                    if ((r + 1) % 3 === 0 && r !== 8) cell.classList.add('row-3n');
                    
                    if (solver.initialGrid[r] && solver.initialGrid[r][c] !== 0) {
                        cell.classList.add('given');
                    } else if (value !== 0) {
                        cell.classList.add('solved');
                    }
                }
            }
        }
        
        function updateProgress(percent) {
            const bar = document.getElementById('progressBar');
            bar.style.width = `${percent}%`;
            bar.textContent = `${Math.round(percent)}%`;
        }
        
        function updateStats() {
            document.getElementById('trainingCount').textContent = solver.trainingExamples.length;
            document.getElementById('constraintCount').textContent = solver.learnedConstraints.length;
            
            if (solver.patternCoherence.size > 0) {
                const avgCoh = Array.from(solver.patternCoherence.values())
                    .reduce((a, b) => a + b, 0) / solver.patternCoherence.size;
                document.getElementById('avgCoherence').textContent = avgCoh.toFixed(3);
            }
            
            // Count pattern types
            let rowPatterns = 0, colPatterns = 0, boxPatterns = 0;
            for (let key of solver.patternCoherence.keys()) {
                if (key.startsWith('row_')) rowPatterns++;
                if (key.startsWith('col_')) colPatterns++;
                if (key.startsWith('box_')) boxPatterns++;
            }
            
            document.getElementById('rowPatterns').textContent = rowPatterns;
            document.getElementById('colPatterns').textContent = colPatterns;
            document.getElementById('boxPatterns').textContent = boxPatterns;
            
            updateConstraintList();
            updateTopRules();
        }
        
        function updateConstraintList() {
            const list = document.getElementById('constraintList');
            list.innerHTML = '';
            
            if (solver.learnedConstraints.length === 0) {
                list.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No constraints learned yet</p>';
                return;
            }
            
            // Show top constraints
            const topConstraints = solver.learnedConstraints
                .sort((a, b) => b.coherence - a.coherence)
                .slice(0, 20);
            
            for (let constraint of topConstraints) {
                const item = document.createElement('div');
                item.className = 'constraint-item';
                item.innerHTML = `
                    ${constraint.pattern.replace(/_/g, ' ')}
                    <span class="constraint-strength ${constraint.strength}">
                        C=${constraint.coherence.toFixed(3)}
                    </span>
                `;
                list.appendChild(item);
            }
        }
        
        function updateTopRules() {
            const rulesDiv = document.getElementById('topRules');
            
            if (solver.learnedConstraints.length === 0) {
                rulesDiv.innerHTML = '<p style="color: #666;">No rules discovered yet</p>';
                return;
            }
            
            // Find meta-patterns (contains_all)
            const metaPatterns = solver.learnedConstraints
                .filter(c => c.pattern.includes('contains_all'))
                .sort((a, b) => b.coherence - a.coherence)
                .slice(0, 5);
            
            rulesDiv.innerHTML = metaPatterns.map(p => `
                <div style="padding: 5px; margin: 5px 0; background: rgba(129, 199, 132, 0.1); border-radius: 5px;">
                    ‚úì ${p.pattern.replace(/_/g, ' ')} (${(p.coherence * 100).toFixed(1)}%)
                </div>
            `).join('');
        }
        
        async function generateTrainingData() {
            updateProgress(0);
            document.getElementById('eventLog').innerHTML = '';
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const count = solver.generateTrainingData(100);
            updateProgress(100);
            updateStats();
            
            document.getElementById('learnBtn').disabled = false;
        }
        
        async function learnConstraints() {
            if (solver.trainingExamples.length === 0) {
                alert('Generate training data first!');
                return;
            }
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            solver.learnConstraintsFromExamples();
            updateStats();
            
            document.getElementById('solveBtn').disabled = false;
        }
        
        function loadTestPuzzle() {
            // Load a medium difficulty puzzle with some givens
            const puzzle = "020608000580009700000040000370000500600000004008000013000020000009800036000306090";
            
            for (let i = 0; i < 81; i++) {
                const r = Math.floor(i / 9);
                const c = i % 9;
                solver.grid[r][c] = parseInt(puzzle[i]);
            }
            
            solver.initialGrid = solver.grid.map(row => [...row]);
            currentTestPuzzle = solver.grid.map(row => [...row]);
            
            solver.log('üìã Loaded test puzzle', 'solving');
            updateDisplay();
        }
        
        async function solveWithLearned() {
            if (solver.learnedConstraints.length === 0) {
                alert('Learn constraints first!');
                return;
            }
            
            if (!currentTestPuzzle) {
                alert('Load a test puzzle first!');
                return;
            }
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const success = solver.solveWithLearnedConstraints(currentTestPuzzle);
            updateDisplay();
            
            document.getElementById('testAccuracy').textContent = success ? '100%' : 'Partial';
            document.getElementById('placements').textContent = solver.placementCount;
            document.getElementById('backtracks').textContent = solver.backtrackCount;
        }
        
        function compareToHardcoded() {
            solver.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'solving');
            solver.log('üìä LEARNED vs HARDCODED COMPARISON', 'discovery');
            solver.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'solving');
            
            solver.log('', 'solving');
            solver.log('üß† LEARNED APPROACH (CRR):', 'discovery');
            solver.log('  ‚úì Discovers constraints from ' + solver.trainingExamples.length + ' examples', 'learning');
            solver.log('  ‚úì Coherence accumulation: C(pattern) = ‚à´ frequency dœÑ', 'learning');
            solver.log('  ‚úì Rupture when C > 0.95: pattern ‚Üí constraint', 'learning');
            solver.log('  ‚úì Regeneration: P(val) ‚àù exp(C/Œ©)', 'learning');
            solver.log('  ‚úì Found ' + solver.learnedConstraints.length + ' hard constraints', 'learning');
            
            solver.log('', 'solving');
            solver.log('üíª HARDCODED APPROACH:', 'solving');
            solver.log('  ‚Ä¢ Programmer explicitly writes: "rows must have 1-9"', 'solving');
            solver.log('  ‚Ä¢ No learning - just enforcement of given rules', 'solving');
            solver.log('  ‚Ä¢ No statistical discovery or coherence', 'solving');
            solver.log('  ‚Ä¢ No adaptation from examples', 'solving');
            
            solver.log('', 'solving');
            solver.log('üéØ KEY DIFFERENCE:', 'discovery');
            solver.log('  CRR: "What patterns are consistent across examples?"', 'learning');
            solver.log('  Hardcoded: "Here are the rules, enforce them"', 'solving');
            
            solver.log('', 'solving');
            solver.log('‚ú® Both approaches converge to same constraints!', 'discovery');
            solver.log('   But CRR DISCOVERS them, not programmed with them.', 'discovery');
            solver.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'solving');
        }
        
        function reset() {
            solver = new CRRLearningSolver();
            currentTestPuzzle = null;
            document.getElementById('eventLog').innerHTML = '';
            document.getElementById('learnBtn').disabled = true;
            document.getElementById('solveBtn').disabled = true;
            updateProgress(0);
            updateStats();
            initGrid();
        }
        
        window.onload = () => {
            initGrid();
        };
    </script>
</body>
</html>
