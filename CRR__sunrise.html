<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Living Sunrise - Mathematical Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        .fps { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #4ade80; font: 12px monospace; padding: 5px 10px; border-radius: 4px; z-index: 100; }
        .fps.warn { color: #fbbf24; }
        .fps.bad { color: #f87171; }
        .debug { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.85); color: #fff; font: 10px monospace; padding: 8px 12px; border-radius: 4px; opacity: 0; transition: opacity 0.3s; line-height: 1.6; }
        .debug.show { opacity: 1; }
        .debug .t { color: #fcd34d; }
        .debug .v { color: #a78bfa; }
        .debug .section { border-top: 1px solid rgba(255,255,255,0.2); margin-top: 6px; padding-top: 6px; }
        .hint { position: fixed; bottom: 10px; right: 10px; color: rgba(255,255,255,0.25); font: 9px sans-serif; }
        .math-panel { position: fixed; top: 50px; left: 10px; background: rgba(0,0,0,0.92); color: #e0e0e0; font: 11px 'Courier New', monospace; padding: 12px 16px; border-radius: 6px; max-width: 400px; max-height: calc(100vh - 100px); overflow-y: auto; opacity: 0; transition: opacity 0.3s; border: 1px solid rgba(255,200,100,0.3); line-height: 1.5; }
        .math-panel.show { opacity: 1; }
        .math-panel h2 { color: #fcd34d; font-size: 13px; margin-bottom: 8px; border-bottom: 1px solid rgba(255,200,100,0.3); padding-bottom: 6px; }
        .math-panel h3 { color: #a78bfa; font-size: 11px; margin: 10px 0 4px 0; }
        .math-panel .eq { background: rgba(255,255,255,0.08); padding: 6px 10px; margin: 4px 0; border-radius: 4px; font-size: 12px; color: #fff; border-left: 2px solid #fcd34d; }
        .math-panel .note { color: #888; font-size: 9px; margin-top: 2px; }
    </style>
</head>
<body>
<div class="fps" id="fps">60 FPS</div>
<div class="math-panel" id="mathPanel">
    <h2>⟨ CRR FRAMEWORK ⟩</h2>
    <p style="color:#888;font-size:9px;margin-bottom:8px;">Coherence-Rupture-Regeneration by Alexander Sabine</p>
    <h3>▸ CORE EQUATIONS</h3>
    <div class="eq">C(x,t) = ∫L(x,τ)dτ <span class="note">— Coherence accumulation</span></div>
    <div class="eq">δ(now) → Rupture at C ≥ Ω <span class="note">— Scale-invariant transition</span></div>
    <div class="eq">R = ∫φ·exp(C/Ω)·Θ(...)dτ <span class="note">— Memory-weighted regeneration</span></div>
    <div class="eq">Ω = 1/π (Z₂) | 1/2π (SO(2)) <span class="note">— Symmetry determines Ω</span></div>
    <h3>▸ HEAT SHIMMER (Z₂)</h3>
    <div class="eq">Ω = 1/π ≈ 0.318 <span class="note">— Binary hot/cold oscillation</span></div>
    <h3>▸ CONVECTION (SO(2))</h3>
    <div class="eq">Ω = 1/2π ≈ 0.159 <span class="note">— Continuous circulation</span></div>
    <h3>▸ MURMURATION</h3>
    <div class="eq">F_sep = -Σ(r̂/d)·(1/Ω·9) <span class="note">— Separation ∝ 1/Ω</span></div>
    <div class="eq">F_align = (v̄-v)·(0.03+0.03·mem) <span class="note">— Memory-weighted</span></div>
    <div class="eq">mem = exp(min(C/Ω, 4)) <span class="note">— CRR memory function</span></div>
    <h3>▸ PREDATOR DYNAMICS</h3>
    <div class="eq">Ω_pred = 0.4 <span class="note">— Longer coherence cycles</span></div>
    <div class="eq">v_dive = 180·smoothAmp <span class="note">— Peak at rupture</span></div>
    <div class="eq">θ = atan2(prey) + sin(t)·(1-amp) <span class="note">— Circle→pursue</span></div>
    <h3>▸ PREDATOR FEEDING</h3>
    <div class="eq">P(land) ∝ perched_ratio · (1-C/Ω) <span class="note">— Land when flock settled</span></div>
    <div class="eq">safe = (nearD &gt; 300) ∧ (perched &gt; 70%) <span class="note">— Safety threshold</span></div>
    <div class="eq">t_feed ~ Ω_feed = 0.6 <span class="note">— Feeding duration CRR</span></div>
    <div class="eq">scale = 1 + 0.4·(y/H) <span class="note">— Perspective scaling</span></div>
    <h3>▸ ECOSYSTEM CRR</h3>
    <div class="eq">Flock settles → Falcon feeds → Flock scatters <span class="note">— Macro CRR cycle</span></div>
    <h3>▸ FLOCK ESCAPE</h3>
    <div class="eq">flock.rupture() when d_pred &lt; 150 <span class="note">— Collective response</span></div>
    <p style="color:#555;font-size:8px;margin-top:10px;border-top:1px solid rgba(255,255,255,0.1);padding-top:6px;">cohere.org.uk | Z₂→Ω=1/π, SO(2)→Ω=1/2π</p>
</div>
<div class="debug" id="debug">
    <div><span class="t">Sun Phase:</span> <span class="v" id="sunPhase">0.00</span></div>
    <div><span class="t">Refraction:</span> <span class="v" id="thermals">0</span></div>
    <div><span class="t">Convection:</span> <span class="v" id="convStreams">0</span></div>
    <div class="section"></div>
    <div><span class="t">Flock C/Ω:</span> <span class="v" id="flockCoh">0.00</span></div>
    <div><span class="t">Flock State:</span> <span class="v" id="flockState">coh</span></div>
    <div><span class="t">Birds (fly/perch):</span> <span id="birds">0/0</span></div>
    <div><span class="t">Perch Ratio:</span> <span class="v" id="perchRatio">0%</span></div>
    <div class="section"></div>
    <div><span class="t">Predator:</span> <span class="v" id="predState">soar</span></div>
    <div><span class="t">Hunt C/Ω:</span> <span class="v" id="predCoh">0.00</span></div>
    <div class="section"></div>
    <div><span class="t">Update:</span> <span id="upd">0</span>ms</div>
</div>
<div class="hint">m = math | c = debug | click = startle</div>
<canvas id="c"></canvas>
<script>
/*
╔═══════════════════════════════════════════════════════════════════════════════╗
║  CRR MATHEMATICAL FRAMEWORK DEMONSTRATION                                      ║
║  Coherence-Rupture-Regeneration by Alexander Sabine                           ║
║                                                                                ║
║  CORE EQUATIONS:                                                               ║
║  C(x,t) = ∫L(x,τ)dτ           — Coherence: accumulated attention/energy       ║
║  δ(now) when C ≥ Ω            — Rupture: scale-invariant choice-moment        ║
║  R = ∫φ(x,τ)·exp(C/Ω)·Θ(...)dτ — Regeneration: memory-weighted reconstruction ║
║                                                                                ║
║  Ω-SYMMETRY HYPOTHESIS:                                                        ║
║  Z₂ (binary):     Ω = 1/π  ≈ 0.318                                            ║
║  SO(2) (circular): Ω = 1/2π ≈ 0.159                                           ║
║                                                                                ║
║  Each system below derives dynamics from these equations.                      ║
╚═══════════════════════════════════════════════════════════════════════════════╝
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const { sin, cos, sqrt, abs, floor, max, min, random, PI, atan2, exp, pow } = Math;
const PI2 = PI * 2;
let W, H, time = 0;

// CRR Constants from Ω-symmetry hypothesis
const OMEGA_Z2 = 1 / PI;        // ≈ 0.318 for binary transitions
const OMEGA_SO2 = 1 / (2 * PI); // ≈ 0.159 for continuous rotations

// Fast trig
const TN = 512;
const ST = new Float32Array(TN), CT = new Float32Array(TN);
for (let i = 0; i < TN; i++) { const a = i/TN*PI2; ST[i] = sin(a); CT[i] = cos(a); }
const fsin = a => ST[((a%PI2+PI2)%PI2)/PI2*TN|0];
const fcos = a => CT[((a%PI2+PI2)%PI2)/PI2*TN|0];
const lerp = (a,b,t) => a+(b-a)*t;
const clamp = (v,a,b) => max(a,min(b,v));

// Spatial hash
const CELL = 40;
let hash = {};
const hkey = (x,y) => ((x/CELL|0) * 10000 + (y/CELL|0));
function buildHash(birds) {
    hash = {};
    for (let i = 0; i < birds.length; i++) {
        const b = birds[i]; if (b.st !== 0) continue;
        const k = hkey(b.x, b.y);
        (hash[k] || (hash[k] = [])).push(i);
    }
}
function nearby(x, y) {
    const r = [], cx = x/CELL|0, cy = y/CELL|0;
    for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) {
        const k = (cx+dx) * 10000 + (cy+dy);
        if (hash[k]) r.push(...hash[k]);
    }
    return r;
}

// ═══════════════════════════════════════════════════════════════════════════════
// CRR CLASS - Core implementation of Coherence-Rupture-Regeneration
// ═══════════════════════════════════════════════════════════════════════════════
class CRR {
    constructor(omega, lr = 0.1) {
        this.omega = omega;  // Ω threshold
        this.lr = lr;        // dC/dt rate
        this.C = 0;          // Coherence integral
        this.st = 0;         // 0=coherence, 1=rupture, 2=regeneration
        this.amp = 0;
        this.smoothAmp = 0;
    }
    
    update(dt, attn = 1) {
        // COHERENCE: dC/dt = lr · attn
        if (this.st === 0) {
            this.C += this.lr * attn * dt;
            this.amp = min(1, this.C / this.omega);
            if (this.C >= this.omega) this.st = 1;
        }
        // RUPTURE: δ(now) - instantaneous transition
        else if (this.st === 1) {
            this.amp = 1;
            this.st = 2;
        }
        // REGENERATION: dC/dt = -decay·C with exp(C/Ω) memory weighting
        else {
            const decay = 1.5 * exp(-min(this.C/this.omega, 4) * 0.5);
            this.C *= exp(-decay * dt);
            this.amp = this.C / this.omega;
            if (this.C < 0.01 * this.omega) { this.C = 0; this.st = 0; }
        }
        this.smoothAmp = lerp(this.smoothAmp, this.amp, min(1, dt * 8));
        return this.smoothAmp;
    }
    
    // Memory function: exp(C/Ω) from regeneration equation
    mem() { return exp(min(this.C / this.omega, 4)); }
    rupture() { if (this.st === 0 && this.C > 0.05 * this.omega) this.st = 1; }
    stateName() { return ['coh', 'RUP', 'reg'][this.st]; }
}

// ═══════════════════════════════════════════════════════════════════════════════
// HEAT REFRACTION - Z₂ Symmetry (Ω = 1/π)
// Binary hot/cold oscillation creates shimmer effect
// ═══════════════════════════════════════════════════════════════════════════════
class RefractionCell {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.crr = new CRR(OMEGA_Z2, 0.8 + random() * 0.4);
        this.phase = random() * PI2;
        this.freq = 2 + random() * 3;
        this.width = 8 + random() * 12;
        this.height = 15 + random() * 25;
        this.vy = -15 - random() * 20;
        this.vx = (random() - 0.5) * 8;
        this.alpha = 0.08 + random() * 0.08;
        this.age = 0;
        this.maxAge = 2 + random() * 3;
    }
    
    update(dt) {
        this.age += dt;
        this.crr.update(dt, 0.5);
        // Velocity follows CRR phase
        if (this.crr.st === 0) {
            this.vy = lerp(this.vy, -8, dt);
        } else {
            this.vy = lerp(this.vy, -35 - this.crr.smoothAmp * 25, dt * 2);
            this.alpha *= (1 - dt * 0.3);
        }
        this.vx += fsin(time * this.freq + this.phase) * dt * 5;
        this.vx *= 0.98;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.age / this.maxAge > 0.5) this.alpha *= (1 - dt * 0.8);
        return this.alpha > 0.005 && this.age < this.maxAge;
    }
    
    draw(intensity) {
        const shimmer = this.crr.smoothAmp;
        const phase = time * this.freq * 4 + this.phase;
        ctx.save();
        ctx.translate(this.x, this.y);
        for (let layer = 0; layer < 2; layer++) {
            const lp = phase + layer * PI2/3;
            const grad = ctx.createLinearGradient(-this.width, -this.height, this.width, this.height);
            const w = 0.5 + intensity * 0.5;
            const a = this.alpha * (0.3 + shimmer * 0.4) * (1 - layer * 0.3);
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, `rgba(255,${240+w*15|0},${220+w*20|0},${a*0.5})`);
            grad.addColorStop(0.5, `rgba(255,${250+w*5|0},${240+w*10|0},${a})`);
            grad.addColorStop(0.7, `rgba(255,${240+w*15|0},${220+w*20|0},${a*0.5})`);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath();
            for (let i = 0; i <= 10; i++) {
                const t = i/10, angle = t * PI2;
                let px = cos(angle) * this.width * (1 + layer * 0.2);
                let py = sin(angle) * this.height * (1 + layer * 0.15);
                px += fsin(angle * 3 + lp) * 3 * shimmer;
                if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    }
}

const heatRefraction = {
    cells: [],
    spawnCRR: new CRR(0.2, 0.5),
    init() { this.cells = []; },
    update(dt, sx, sy, sr, phase) {
        this.spawnCRR.update(dt, 0.3 + phase * 0.7);
        if ((this.spawnCRR.st === 1 || random() < 0.015 + phase * 0.04) && this.cells.length < 20) {
            const a = -PI/2 + (random() - 0.5) * PI * 0.8;
            const d = sr * (0.6 + random() * 0.8);
            this.cells.push(new RefractionCell(sx + cos(a)*d, sy + sin(a)*d*0.6 + sr*0.3));
        }
        for (let i = this.cells.length - 1; i >= 0; i--) {
            if (!this.cells[i].update(dt)) this.cells.splice(i, 1);
        }
    },
    draw(sx, sy, sr, int) {
        for (const c of this.cells) {
            if (sqrt((c.x-sx)**2+(c.y-sy)**2) < sr * 2.5) c.draw(int);
        }
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// HORIZONTAL CONVECTION - SO(2) Symmetry (Ω = 1/2π)
// Continuous rotational circulation pattern
// ═══════════════════════════════════════════════════════════════════════════════
class ConvectionStream {
    constructor(x, y, dir, phase) {
        this.x = x; this.y = y; this.dir = dir;
        this.crr = new CRR(OMEGA_SO2, 0.15 + random() * 0.1);
        this.width = 60 + random() * 100;
        this.thick = 8 + random() * 15;
        this.speed = 20 + random() * 30;
        this.waveAmp = 5 + random() * 10;
        this.waveFreq = 0.002 + random() * 0.003;
        this.phase = random() * PI2;
        this.baseAlpha = 0.03 + random() * 0.03;
        this.alpha = this.baseAlpha * (0.3 + phase * 0.7);
        this.warmth = random();
        this.age = 0;
        this.maxAge = 8 + random() * 12;
    }
    
    update(dt, phase) {
        this.age += dt;
        this.crr.update(dt, 0.5 + phase * 0.5);
        let speedMod = this.crr.st === 0 ? 0.3 + this.crr.smoothAmp * 0.5 : 
                       this.crr.st === 1 ? 1.5 : 0.5 + this.crr.smoothAmp * 0.5;
        this.x += this.dir * this.speed * speedMod * dt;
        this.y += fsin(time * 0.3 + this.phase) * 0.5 * dt * (this.warmth > 0.5 ? -1 : 0.5);
        this.alpha = this.baseAlpha * (0.3 + phase * 0.7) * this.crr.smoothAmp;
        const oob = this.dir > 0 ? this.x > W + 100 : this.x < -100;
        return !oob && this.age < this.maxAge && this.alpha > 0.001;
    }
    
    draw(phase) {
        if (this.alpha < 0.002) return;
        const startX = this.x - this.dir * this.width;
        const endX = this.x + this.dir * this.width * 0.5;
        const crrMod = this.crr.smoothAmp;
        ctx.beginPath();
        for (let i = 0; i <= 15; i++) {
            const t = i/15, px = lerp(startX, endX, t);
            const waveY = fsin(px * this.waveFreq + this.phase + time * 0.5) * this.waveAmp * crrMod;
            if (i === 0) ctx.moveTo(px, this.y + waveY - this.thick * 0.5);
            else ctx.lineTo(px, this.y + waveY - this.thick * 0.5);
        }
        for (let i = 15; i >= 0; i--) {
            const t = i/15, px = lerp(startX, endX, t);
            const waveY = fsin(px * this.waveFreq + this.phase + time * 0.5) * this.waveAmp * crrMod;
            ctx.lineTo(px, this.y + waveY + this.thick * 0.5);
        }
        ctx.closePath();
        const grad = ctx.createLinearGradient(startX, this.y, endX, this.y);
        const r = 255, g = 200 + this.warmth * 40 + phase * 15, b = 150 + this.warmth * 30 + phase * 30;
        grad.addColorStop(0, `rgba(${r},${g|0},${b|0},0)`);
        grad.addColorStop(0.3, `rgba(${r},${g|0},${b|0},${this.alpha*0.5})`);
        grad.addColorStop(0.5, `rgba(${r},${g|0},${b|0},${this.alpha})`);
        grad.addColorStop(0.7, `rgba(${r},${g|0},${b|0},${this.alpha*0.5})`);
        grad.addColorStop(1, `rgba(${r},${g|0},${b|0},0)`);
        ctx.fillStyle = grad;
        ctx.fill();
    }
}

const horizConv = {
    streams: [],
    spawnCRR: new CRR(0.5, 0.2),
    init() { this.streams = []; },
    update(dt, phase) {
        this.spawnCRR.update(dt, phase);
        if ((this.spawnCRR.st === 1 || random() < 0.008 + phase * 0.015) && this.streams.length < 10 && phase > 0.1) {
            const left = random() > 0.5;
            this.streams.push(new ConvectionStream(left ? -50 : W+50, H*(0.5+random()*0.35), left ? 1 : -1, phase));
        }
        for (let i = this.streams.length - 1; i >= 0; i--) {
            if (!this.streams[i].update(dt, phase)) this.streams.splice(i, 1);
        }
    },
    draw(phase) { for (const s of this.streams) s.draw(phase); }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SUNRISE - High Ω for slow majestic rise
// ═══════════════════════════════════════════════════════════════════════════════
const sunrise = {
    crr: new CRR(2.0, 0.015),
    phase: 0, targetPhase: 0, x: 0.5, y: 1.0, radius: 0.11,
    init() { this.phase = 0; this.y = 0.85; heatRefraction.init(); horizConv.init(); },
    update(dt) {
        this.crr.update(dt, 0.8);
        this.targetPhase = min(1, this.targetPhase + dt * 0.012);
        this.phase = lerp(this.phase, this.targetPhase, dt * 2);
        this.x = 0.48 + fsin(this.phase * 0.3) * 0.02;
        this.y = 0.85 - this.phase * 0.45;
        heatRefraction.update(dt, W*this.x, H*this.y, H*this.radius, this.phase);
        horizConv.update(dt, this.phase);
    },
    draw() {
        const cx = W*this.x, cy = H*this.y, r = H*this.radius, int = 0.7 + this.phase * 0.3;
        horizConv.draw(this.phase);
        const hGlow = 1 + (1-this.phase) * 0.8;
        for (let i = 4; i >= 0; i--) {
            const gr = r * (1.3 + i*0.4) * hGlow, a = (0.08 - i*0.015) * int;
            const g = ctx.createRadialGradient(cx, cy, r*0.6, cx, cy, gr);
            g.addColorStop(0, `rgba(255,${210+this.phase*30|0},${90+this.phase*40|0},${a})`);
            g.addColorStop(0.5, `rgba(255,${140+this.phase*40|0},${40+this.phase*20|0},${a*0.4})`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, gr, 0, PI2); ctx.fill();
        }
        const cg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        cg.addColorStop(0, `rgba(255,255,${235+this.phase*20|0},${int})`);
        cg.addColorStop(0.6, `rgba(255,${240+this.phase*15|0},${190+this.phase*30|0},${int})`);
        cg.addColorStop(1, `rgba(255,${170+this.phase*30|0},${70+this.phase*30|0},${int*0.85})`);
        ctx.fillStyle = cg; ctx.beginPath(); ctx.arc(cx, cy, r, 0, PI2); ctx.fill();
        heatRefraction.draw(cx, cy, r, int);
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// ATMOSPHERE - SO(2) Symmetry for daily cycle
// ═══════════════════════════════════════════════════════════════════════════════
const atmosphere = {
    crr: new CRR(OMEGA_SO2, 0.08),
    colors: {
        nightTop: {r:15,g:18,b:35}, nightMid: {r:25,g:30,b:50}, nightHor: {r:40,g:35,b:55},
        dawnTop: {r:45,g:35,b:65}, dawnMid: {r:120,g:70,b:80}, dawnHor: {r:220,g:130,b:90},
        dayTop: {r:85,g:130,b:190}, dayMid: {r:150,g:175,b:210}, dayHor: {r:220,g:200,b:180}
    },
    cur: { top: null, mid: null, hor: null },
    update(dt, sunPhase) {
        this.crr.update(dt, 0.3 + sunPhase * 0.4);
        const t = sunPhase, lc = (a,b,t) => ({r:lerp(a.r,b.r,t),g:lerp(a.g,b.g,t),b:lerp(a.b,b.b,t)});
        if (t < 0.3) {
            const p = t/0.3, s = p*p*(3-2*p);
            this.cur.top = lc(this.colors.nightTop, this.colors.dawnTop, s);
            this.cur.mid = lc(this.colors.nightMid, this.colors.dawnMid, s);
            this.cur.hor = lc(this.colors.nightHor, this.colors.dawnHor, s);
        } else {
            const p = (t-0.3)/0.7, s = p*p*(3-2*p);
            this.cur.top = lc(this.colors.dawnTop, this.colors.dayTop, s);
            this.cur.mid = lc(this.colors.dawnMid, this.colors.dayMid, s);
            this.cur.hor = lc(this.colors.dawnHor, this.colors.dayHor, s);
        }
    },
    draw() {
        const c = this.cur, g = ctx.createLinearGradient(0, 0, 0, H*0.88);
        g.addColorStop(0, `rgb(${c.top.r|0},${c.top.g|0},${c.top.b|0})`);
        g.addColorStop(0.35, `rgb(${c.mid.r|0},${c.mid.g|0},${c.mid.b|0})`);
        g.addColorStop(0.7, `rgb(${c.hor.r|0},${c.hor.g|0},${c.hor.b|0})`);
        g.addColorStop(1, `rgb(${c.hor.r*0.9|0},${c.hor.g*0.85|0},${c.hor.b*0.8|0})`);
        ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
    }
};

// Clouds
const clouds = [];
function initClouds() {
    clouds.length = 0;
    [[0.12,0.08,0.11],[0.42,0.05,0.08],[0.68,0.12,0.12],[0.28,0.18,0.06],[0.85,0.15,0.07]].forEach(([x,y,s]) => {
        const pts = [];
        for (let i = 0; i < 8; i++) { const a = i/8*PI2; pts.push({x:fcos(a)*(0.5+random()*0.4),y:fsin(a)*0.3*(0.5+random()*0.4)}); }
        clouds.push({x,y,s,pts,spd:0.00004+random()*0.00003,op:0.12+random()*0.08,curOp:0});
    });
}
function updateClouds(dt) { for (const c of clouds) { c.x += c.spd*dt*50; if (c.x > 1.2) c.x = -0.2; c.curOp = c.op*(0.5+sunrise.phase*0.5); } }
function drawClouds() {
    for (const c of clouds) {
        if (c.curOp < 0.02) continue;
        ctx.save(); ctx.translate(W*c.x, H*c.y); ctx.scale(W*c.s, W*c.s);
        ctx.beginPath(); ctx.moveTo(c.pts[0].x, c.pts[0].y);
        for (let i = 1; i < c.pts.length; i++) { const p = c.pts[i-1], q = c.pts[i]; ctx.quadraticCurveTo(p.x, p.y, (p.x+q.x)/2, (p.y+q.y)/2); }
        ctx.closePath();
        ctx.fillStyle = `rgba(${140+sunrise.phase*80|0},${70+sunrise.phase*100|0},${60+sunrise.phase*100|0},${c.curOp})`;
        ctx.fill(); ctx.restore();
    }
}

// Tree - Enhanced with many more perches for the full murmuration
class Tree {
    constructor(bx,by,h) {
        this.bx=bx; this.by=by; this.h=h; this.crr=new CRR(1.5,0.03);
        this.branches=[]; this.perches=[]; this.sway=0;
        this.generate(); this.byDepth={};
        for (const b of this.branches) (this.byDepth[b.d]||(this.byDepth[b.d]=[])).push(b);
    }
    generate() {
        const add = (x1,y1,x2,y2,d,maxD) => {
            if (d > maxD) return;
            const mx=(x1+x2)/2+(random()-0.5)*this.h*0.016, my=(y1+y2)/2+(random()-0.5)*this.h*0.016;
            this.branches.push({x1,y1,cx:mx,cy:my,x2,y2,d,w:max(1.2,4.5*pow(0.68,d)),phase:random()*PI2,sw:0,tsw:0});
            
            // MORE PERCHES: Add perches on branches depth 1-6, more positions along each branch
            if (d >= 1 && d <= 6 && abs(atan2(y2-y1,x2-x1)+PI/2) > 0.2) {
                // More perch points per branch (every 15% instead of 20%)
                for (let t = 0.2; t <= 0.85; t += 0.15) {
                    const mt = 1-t;
                    const px = mt*mt*x1 + 2*mt*t*mx + t*t*x2;
                    const py = mt*mt*y1 + 2*mt*t*my + t*t*y2;
                    // Add slight random offset to spread birds out
                    this.perches.push({
                        x: px + (random()-0.5) * 3,
                        y: py + (random()-0.5) * 2,
                        occ: false
                    });
                }
            }
            
            if (d < maxD) { 
                const n = 2 + floor(random()*2);
                const len = sqrt((x2-x1)**2+(y2-y1)**2) * (0.55+random()*0.18);
                const base = atan2(y2-y1, x2-x1);
                for (let i = 0; i < n; i++) { 
                    const a = base + (random()-0.5)*1.2; 
                    add(x2, y2, x2+cos(a)*len, y2+sin(a)*len, d+1, maxD); 
                }
            }
        };
        
        // Main branches - slightly more spread for more perching area
        [[-0.16,0.46],[0,0.54],[0.16,0.46]].forEach(([ao,lm])=>{
            const a=-PI/2+ao;
            add(this.bx,this.by,this.bx+cos(a)*this.h*lm,this.by+sin(a)*this.h*lm,0,7);
        });
        
        // More side branches for additional perches
        for (let i=0;i<8;i++) { 
            const by=this.by-this.h*(0.08+i*0.11);
            const side=i%2===0?-1:1;
            const bl=this.h*(0.1+random()*0.12);
            const a=-PI/2+side*(0.3+random()*0.6); 
            add(this.bx,by,this.bx+cos(a)*bl,by+sin(a)*bl,1,6); 
        }
    }
    
    // Count how many birds are perched
    perchedCount() {
        return this.perches.filter(p => p.occ).length;
    }
    
    update(dt,wind) {
        this.crr.update(dt,0.06+wind*0.2);
        this.sway = fsin(this.crr.C*0.35)*0.002*wind;
        for (const b of this.branches) { b.tsw=fsin(time*0.6+b.d*0.8+b.phase)*0.003*(7-b.d)*wind; b.sw=lerp(b.sw,b.tsw,min(1,dt*6)); }
    }
    draw() {
        ctx.lineCap='round';
        for (const d in this.byDepth) {
            const bs=this.byDepth[d],fade=pow(0.68,d),w=max(1.2,4.5*fade);
            ctx.strokeStyle=`rgba(12,10,8,${0.6*fade})`; ctx.lineWidth=w*3.5; ctx.beginPath();
            for (const b of bs) { const sw=b.sw+this.sway; ctx.moveTo(b.x1,b.y1); ctx.quadraticCurveTo(b.cx+sw*40,b.cy,b.x2+sw*80,b.y2); }
            ctx.stroke();
            ctx.strokeStyle=`rgba(18,15,12,${0.85*fade})`; ctx.lineWidth=w; ctx.beginPath();
            for (const b of bs) { const sw=b.sw+this.sway; ctx.moveTo(b.x1,b.y1); ctx.quadraticCurveTo(b.cx+sw*40,b.cy,b.x2+sw*80,b.y2); }
            ctx.stroke();
        }
        ctx.strokeStyle='rgba(10,8,6,0.95)'; ctx.lineWidth=18; ctx.beginPath();
        ctx.moveTo(this.bx,this.by+15); ctx.quadraticCurveTo(this.bx+this.sway*20,this.by-this.h*0.07,this.bx+this.sway*40,this.by-this.h*0.14); ctx.stroke();
    }
}

// Grass
class Grass {
    constructor(gy,W,H) { this.gy=gy; this.W=W; this.H=H; this.crr=new CRR(0.28,0.3); this.phase=0; this.stems=[]; this.generate(); }
    generate() {
        const treeX=this.W*0.82;
        for (let i=0;i<150;i++) {
            const x=(i/150)*this.W*1.1-this.W*0.05;
            if (abs(x-treeX)<this.W*0.08) continue;
            const h=this.H*(0.022+random()*0.048),lean=(random()-0.5)*0.35;
            this.stems.push({x:x+(random()-0.5)*6,h,lean,seed:random()>0.35,stype:floor(random()*3),phase:random()*PI2,omega:0.08+random()*0.12,sway:0,tsway:0});
            if (random()>0.45) this.stems.push({x:x+(random()-0.5)*10,h:h*(0.45+random()*0.4),lean:lean+(random()-0.5)*0.25,seed:random()>0.55,stype:floor(random()*3),phase:random()*PI2,omega:0.1+random()*0.1,sway:0,tsway:0});
        }
    }
    update(dt) {
        this.crr.update(dt,0.4+fsin(time*0.12)*0.15);
        this.phase=this.crr.C*2.2;
        for (const s of this.stems) { const wInf=fsin(s.x/this.W*9-this.phase)*0.5+0.5; s.tsway=fsin(time*0.9+s.phase+this.phase*0.4)*0.01*wInf/(s.omega*5); s.sway=lerp(s.sway,s.tsway,min(1,dt*5)); }
    }
    draw() {
        ctx.fillStyle='#080808'; ctx.beginPath(); ctx.moveTo(0,this.gy);
        for (let x=0;x<=this.W;x+=15) ctx.lineTo(x,this.gy-fsin(x*0.01+this.phase*0.15)*2.5-1);
        ctx.lineTo(this.W,this.H); ctx.lineTo(0,this.H); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='#0a0a0a'; ctx.fillStyle='#0a0a0a'; ctx.lineCap='round';
        for (const s of this.stems) {
            const tipX=s.x+s.lean*s.h+s.sway*this.W,tipY=this.gy-s.h,ctrlX=s.x+s.lean*s.h*0.5+s.sway*this.W*0.6,ctrlY=(this.gy+tipY)/2;
            ctx.lineWidth=s.seed?1.1:0.7; ctx.beginPath(); ctx.moveTo(s.x,this.gy); ctx.quadraticCurveTo(ctrlX,ctrlY,tipX,tipY); ctx.stroke();
            if (s.seed) { ctx.save(); ctx.translate(tipX,tipY); ctx.rotate(atan2(tipY-ctrlY,tipX-ctrlX)+PI/2);
                if (s.stype===0) { ctx.beginPath(); ctx.ellipse(0,-3.5,1.8,5,0,0,PI2); ctx.fill(); }
                else if (s.stype===1) { ctx.beginPath(); ctx.ellipse(0,-7,2.2,8.5,0,0,PI2); ctx.fill(); }
                ctx.restore();
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PREDATOR - Peregrine Falcon (Ω = 0.4, 3× bird size)
// CRR governs hunt cycle: coherence→stalk, rupture→dive, regeneration→recover
// NEW: Feeding behaviour - lands in grass when safe, feeds on seeds
// Perspective scaling: larger when on ground (closer to viewer)
// ═══════════════════════════════════════════════════════════════════════════════
class Predator {
    constructor(x,y) {
        this.x=x; this.y=y; this.vx=15; this.vy=0;
        this.crr = new CRR(0.4, 0.12);       // General movement
        this.huntCRR = new CRR(0.4, 0.08);   // Hunt cycle
        this.feedCRR = new CRR(0.6, 0.05);   // Feeding duration - higher Ω = longer feeds
        this.target = null;
        this.huntPhase = 0; // 0=soar, 1=stalk, 2=dive, 3=recover, 4=descend, 5=feeding, 6=takeoff
        this.baseSize = 3.5;    // 3× starling
        this.size = this.baseSize;
        this.wingSpan = 12;
        this.wingPhase = random()*PI2;
        this.patrolX = x; this.patrolY = y; this.patrolR = 200;
        this.bank = 0;
        this.groundY = 0;      // Y position when landed
        this.feedTimer = 0;
        this.peckPhase = 0;    // For pecking animation
        this.lastFlightY = y;  // Remember flight altitude
        this.flightTimer = 0;  // Time spent flying - gets tired after ~15s
    }
    
    update(dt, birds, flock, grassY, tree) {
        this.crr.update(dt, 0.5);
        this.wingPhase += 4 * dt * (0.5 + this.crr.smoothAmp * 0.3);
        
        // Perspective scaling: larger when closer to ground (foreground)
        // scale = 1 + 0.4·(y/H) — at grass level, ~1.35× size
        const perspectiveScale = 1 + 0.4 * (this.y / H);
        this.size = this.baseSize * perspectiveScale;
        
        // Find nearest FLYING prey (not perched)
        let nearD = Infinity, nearB = null;
        let flyingCount = 0;
        let perchedCount = 0;
        
        for (const b of birds) {
            if (b.st === 0) { // Flying
                flyingCount++;
                const d = sqrt((b.x-this.x)**2+(b.y-this.y)**2);
                if (d < nearD) { nearD = d; nearB = b; }
            } else if (b.st === 2) { // Perched
                perchedCount++;
            }
        }
        
        const totalBirds = birds.length;
        const perchedRatio = perchedCount / totalBirds;
        
        // Predator gets tired after flying for a while - lands to feed every ~15s
        if (this.huntPhase < 4) {
            this.flightTimer += dt;
        }
        const tiredEnoughToFeed = this.flightTimer > 15;
        
        // Hunt/Feed state machine
        if (this.huntPhase === 0) { // SOAR
            this.huntCRR.update(dt, 0.3);
            const pa = time * 0.3;
            const tx = this.patrolX + cos(pa) * this.patrolR;
            const ty = this.patrolY + sin(pa) * this.patrolR * 0.4;
            this.vx = lerp(this.vx, (tx-this.x)*0.5, dt*2);
            this.vy = lerp(this.vy, (ty-this.y)*0.5, dt*2);
            
            // Decision: hunt or land to feed?
            if (tiredEnoughToFeed) {
                // Too tired - must land
                this.huntPhase = 4;
                this.groundY = grassY - 8;
                this.lastFlightY = this.y;
            } else if (nearB && nearD < 400 && this.huntCRR.C > this.huntCRR.omega * 0.3) {
                this.huntPhase = 1; this.target = nearB;
            }
        } else if (this.huntPhase === 1) { // STALK
            // Abort hunt if too tired
            if (tiredEnoughToFeed) {
                this.huntPhase = 4;
                this.groundY = grassY - 8;
                this.lastFlightY = this.y;
                this.target = null;
            } else {
                this.huntCRR.update(dt, 1.5);
                if (this.target && this.target.st === 0) {
                    const dx=this.target.x-this.x, dy=this.target.y-this.y, d=sqrt(dx*dx+dy*dy);
                    const circleOff = (1 - this.huntCRR.smoothAmp) * 0.8;
                    const angle = atan2(dy,dx) + sin(time*3) * circleOff;
                    const spd = 40 + this.huntCRR.smoothAmp * 30;
                    this.vx = lerp(this.vx, cos(angle)*spd, dt*3);
                    this.vy = lerp(this.vy, sin(angle)*spd, dt*3);
                    if (d < 150) flock.rupture();
                    if (this.huntCRR.st === 1) this.huntPhase = 2;
                    if (d > 500) { this.huntPhase = 0; this.target = null; }
                } else { this.huntPhase = 0; this.target = null; }
            }
        } else if (this.huntPhase === 2) { // DIVE
            this.huntCRR.update(dt, 0.3);
            if (this.target) {
                const dx=this.target.x-this.x, dy=this.target.y-this.y, d=sqrt(dx*dx+dy*dy);
                const diveSpd = 120 + this.huntCRR.smoothAmp * 60;
                const angle = atan2(dy,dx);
                this.vx = cos(angle) * diveSpd;
                this.vy = sin(angle) * diveSpd;
                if (d < 25) {
                    this.target.crr.rupture();
                    this.target.vx += (random()-0.5)*100;
                    this.target.vy -= 50+random()*30;
                    this.huntPhase = 3;
                }
                if (this.huntCRR.st === 2 && this.huntCRR.smoothAmp < 0.5) this.huntPhase = 3;
            } else this.huntPhase = 3;
        } else if (this.huntPhase === 3) { // RECOVER
            this.huntCRR.update(dt, 0.3);
            this.vx *= 0.98;
            this.vy = lerp(this.vy, -5, dt);
            if (this.huntCRR.st === 0) {
                this.huntPhase = 0; this.target = null;
                this.patrolX = lerp(this.patrolX, this.x, 0.3);
                this.patrolY = lerp(this.patrolY, this.y, 0.3);
            }
        } else if (this.huntPhase === 4) { // DESCEND to ground
            // Glide down to grass
            const dx = this.x + 50 - this.x; // Slight forward motion
            const dy = this.groundY - this.y;
            this.vx = lerp(this.vx, 15, dt * 2);
            this.vy = lerp(this.vy, 25, dt * 2); // Descend
            
            // Landed?
            if (this.y >= this.groundY - 5) {
                this.y = this.groundY;
                this.vx = 0; this.vy = 0;
                this.huntPhase = 5;
                this.feedCRR.C = 0; this.feedCRR.st = 0; // Reset feed CRR
                this.feedTimer = 0;
            }
        } else if (this.huntPhase === 5) { // FEEDING on seeds
            // CRR governs feeding duration: t_feed ~ Ω_feed
            this.feedCRR.update(dt, 0.8);
            this.feedTimer += dt;
            this.peckPhase += dt * 4; // Pecking animation
            
            // Stay grounded
            this.vx = 0; this.vy = 0;
            this.y = this.groundY;
            
            // Slight shuffle while feeding
            this.x += sin(this.peckPhase * 0.5) * 0.3;
            
            // Startled by birds getting close?
            if (nearD < 200) {
                this.huntPhase = 6; // Take off!
                flock.rupture();
            }
            
            // Done feeding when feedCRR completes cycle
            if (this.feedCRR.st === 0 && this.feedTimer > 3) {
                this.huntPhase = 6;
                flock.rupture(); // Flock scatters as predator takes off!
            }
        } else if (this.huntPhase === 6) { // TAKEOFF - after feeding, resume the hunt!
            // Powerful launch back into the air
            this.vy = lerp(this.vy, -40, dt * 3);
            this.vx = lerp(this.vx, 20 + random() * 10, dt * 2);
            
            // Back to soaring altitude?
            if (this.y < this.lastFlightY + 50) {
                this.flightTimer = 0; // Reset fatigue - well rested!
                // Resume hunting if there are flying birds
                if (nearB && flyingCount > 0) {
                    this.huntPhase = 1; // Go straight to STALK
                    this.target = nearB;
                    this.huntCRR.C = this.huntCRR.omega * 0.5; // Start mid-coherence for quicker dive
                } else {
                    this.huntPhase = 0; // Soar if no targets
                }
                this.huntCRR.st = 0;
                this.patrolX = this.x;
                this.patrolY = this.y;
            }
        }
        
        // Apply velocity (except when grounded)
        if (this.huntPhase !== 5) {
            this.x += this.vx * dt; 
            this.y += this.vy * dt;
        }
        
        // Boundary constraints (only when flying)
        if (this.huntPhase < 4 || this.huntPhase === 6) {
            if (this.x < W*0.05) this.vx += 30*dt;
            if (this.x > W*0.95) this.vx -= 30*dt;
            if (this.y < H*0.08) this.vy += 20*dt;
            if (this.y > H*0.65) this.vy -= 20*dt;
        }
        
        this.bank = lerp(this.bank, clamp(this.vx*0.02,-0.6,0.6), dt*4);
        const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
        if (spd > 180) { this.vx=this.vx/spd*180; this.vy=this.vy/spd*180; }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.huntPhase === 5) {
            // FEEDING POSE - grounded silhouette
            // Larger due to perspective (on ground = foreground)
            const feedSize = this.size * 1.1;
            
            // Pecking motion
            const peck = sin(this.peckPhase * 3) * 0.15;
            const headDip = max(0, sin(this.peckPhase * 3)) * 4;
            
            ctx.fillStyle = 'rgba(12,10,15,0.94)';
            
            // Body - horizontal, slightly hunched
            ctx.beginPath();
            ctx.ellipse(0, 0, feedSize * 1.8, feedSize * 0.7, peck * 0.2, 0, PI2);
            ctx.fill();
            
            // Folded wings (visible as bulk on sides)
            ctx.beginPath();
            ctx.ellipse(-feedSize * 0.3, -feedSize * 0.2, feedSize * 1.2, feedSize * 0.5, 0.1, 0, PI2);
            ctx.fill();
            
            // Tail - fanned slightly on ground
            ctx.beginPath();
            ctx.moveTo(-feedSize * 1.5, 0);
            ctx.lineTo(-feedSize * 2.5, -feedSize * 0.5);
            ctx.lineTo(-feedSize * 2.8, 0);
            ctx.lineTo(-feedSize * 2.5, feedSize * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // Legs (simple silhouette)
            ctx.strokeStyle = 'rgba(12,10,15,0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-feedSize * 0.3, feedSize * 0.5);
            ctx.lineTo(-feedSize * 0.4, feedSize * 1.2);
            ctx.moveTo(feedSize * 0.3, feedSize * 0.5);
            ctx.lineTo(feedSize * 0.2, feedSize * 1.2);
            ctx.stroke();
            
            // Head - dipping to peck
            ctx.fillStyle = 'rgba(12,10,15,0.94)';
            ctx.beginPath();
            ctx.arc(feedSize * 1.2, headDip * 0.5, feedSize * 0.45, 0, PI2);
            ctx.fill();
            
            // Beak - pointing down when pecking
            ctx.beginPath();
            ctx.moveTo(feedSize * 1.5, headDip * 0.5);
            ctx.lineTo(feedSize * 1.9, headDip + feedSize * 0.3);
            ctx.lineTo(feedSize * 1.5, headDip * 0.5 + feedSize * 0.15);
            ctx.closePath();
            ctx.fill();
            
        } else {
            // FLYING POSE
            ctx.rotate(atan2(this.vy, this.vx));
            ctx.scale(1, 1-abs(this.bank)*0.3);
            
            const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
            const stretch = min(spd/60, 1.8);
            const flapInt = this.huntPhase === 2 ? 0.1 : (this.huntPhase === 6 ? 0.6 : 0.4);
            const flap = fsin(this.wingPhase) * flapInt * (1-this.huntCRR.smoothAmp*0.5);
            
            ctx.fillStyle = 'rgba(15,12,18,0.92)';
            
            // Body
            ctx.beginPath(); 
            ctx.ellipse(0, 0, this.size*stretch*1.2, this.size*0.5, 0, 0, PI2); 
            ctx.fill();
            
            // Wings
            const ws = this.wingSpan * (this.size / this.baseSize); // Scale with perspective
            const sweep = 0.3 + this.huntCRR.smoothAmp*0.2;
            ctx.beginPath();
            ctx.moveTo(-this.size*0.3,0);
            ctx.quadraticCurveTo(-this.size*0.5,-ws*0.4*(1+flap),-this.size*sweep,-ws*(0.8+flap*0.15));
            ctx.quadraticCurveTo(this.size*0.3,-ws*0.3*(1+flap),this.size*0.4,0);
            ctx.quadraticCurveTo(this.size*0.3,ws*0.3*(1+flap),-this.size*sweep,ws*(0.8+flap*0.15));
            ctx.quadraticCurveTo(-this.size*0.5,ws*0.4*(1+flap),-this.size*0.3,0);
            ctx.fill();
            
            // Tail
            ctx.beginPath();
            ctx.moveTo(-this.size*stretch,0);
            ctx.lineTo(-this.size*stretch-this.size*1.2,-this.size*0.4);
            ctx.lineTo(-this.size*stretch-this.size*0.8,0);
            ctx.lineTo(-this.size*stretch-this.size*1.2,this.size*0.4);
            ctx.closePath(); 
            ctx.fill();
            
            // Head
            ctx.beginPath(); 
            ctx.arc(this.size*stretch*0.8, 0, this.size*0.35, 0, PI2); 
            ctx.fill();
        }
        
        ctx.restore();
        
        // Hunt indicator (only when actively hunting)
        if (this.huntPhase > 0 && this.huntPhase < 4) {
            ctx.strokeStyle = `rgba(255,100,50,${0.1+this.huntCRR.smoothAmp*0.2})`;
            ctx.lineWidth = 1; ctx.beginPath();
            ctx.arc(this.x,this.y,30+this.huntCRR.smoothAmp*20,0,PI2); ctx.stroke();
        }
    }
    
    stateName() { return ['soar','stalk','DIVE','recover','descend','FEED','takeoff'][this.huntPhase]; }
}

// ═══════════════════════════════════════════════════════════════════════════════
// STARLINGS - Enhanced Murmuration with CRR-derived forces
// F_sep = -Σ(r̂/d)·(1/Ω·9), F_align = (v̄-v)·(0.03+0.03·mem), ω = base·(0.75+0.35·amp)
// ═══════════════════════════════════════════════════════════════════════════════
class Bird {
    constructor(x,y,flock) {
        this.crr = new CRR(0.06+random()*0.05, 1.0);
        this.flock = flock;
        this.x=x; this.y=y;
        this.vx=(random()-0.5)*35; this.vy=(random()-0.5)*20;
        this.size=0.9+random()*0.5;
        this.wph=random()*PI2; this.wsp=10+random()*4;
        this.st=0; this.perch=null; this.perchT=0; this.timer=0;
        this.react=0.8+random()*0.4;
        this.vRange=45+random()*15;
    }
    
    update(dt, idxs, birds, attrs, scare, perches, pred) {
        this.timer += dt;
        
        if (this.st === 2) { // Perched
            this.perchT += dt;
            if (this.timer > 0.4) {
                this.timer = 0;
                const scared = scare && sqrt((this.x-scare.x)**2+(this.y-scare.y)**2) < scare.r*1.4;
                // Only scared of predator if it's FLYING (not feeding on ground)
                const predFlying = pred && pred.huntPhase !== 5;
                const predNear = predFlying && sqrt((this.x-pred.x)**2+(this.y-pred.y)**2) < 200;
                if (scared || predNear || random() < (this.perchT > 5 ? 0.015 : 0.004) || this.flock.st === 1) {
                    this.st=3; this.vy=-30-random()*18; this.vx=(random()-0.5)*30;
                    if (this.perch) { this.perch.occ=false; this.perch=null; }
                }
            }
            return;
        }
        
        this.crr.update(dt, this.st===0 ? 1 : 0.3);
        // Wing beat: ω = base·(0.75+0.35·smoothAmp)
        this.wph += this.wsp * dt * (0.75 + this.crr.smoothAmp * 0.35);
        
        if (this.st === 3) { this.vy -= 40*dt; this.x += this.vx*dt; this.y += this.vy*dt; if (this.timer > 0.35) this.st=0; return; }
        if (this.st === 1) {
            const dx=this.perch.x-this.x, dy=this.perch.y-this.y, d=sqrt(dx*dx+dy*dy);
            if (d < 2) { this.st=2; this.x=this.perch.x; this.y=this.perch.y; this.vx=this.vy=0; this.perchT=0; }
            else { this.vx=dx*2.5; this.vy=dy*2.5; this.x+=this.vx*dt; this.y+=this.vy*dt; }
            return;
        }
        
        // CRR memory: mem = exp(min(C/Ω, 4))
        const fm = min(this.flock.mem()/4, 1.8);
        let sx=0,sy=0,ax=0,ay=0,cx=0,cy=0,nc=0;
        
        const maxN = 14; let checked = 0;
        for (const i of idxs) {
            if (checked >= maxN) break;
            const o = birds[i];
            if (o===this || o.st!==0) continue;
            const dx=o.x-this.x, dy=o.y-this.y, d2=dx*dx+dy*dy;
            if (d2 > this.vRange*this.vRange) continue;
            checked++;
            const d = sqrt(d2);
            // SEPARATION: F_sep = -Σ(r̂/d)·(1/Ω·9)
            if (d < 18 && d > 0) { const f=(18-d)/18/(this.crr.omega*9); sx-=dx/d*f; sy-=dy/d*f; }
            if (d < this.vRange) { ax+=o.vx; ay+=o.vy; cx+=o.x; cy+=o.y; nc++; }
        }
        
        if (nc > 0) {
            this.vx += sx*2*this.react; this.vy += sy*2*this.react;
            // ALIGNMENT: F_align = (v̄-v)·(0.03+0.03·mem)
            const af = (0.03+fm*0.03)*this.react;
            this.vx += (ax/nc-this.vx)*af; this.vy += (ay/nc-this.vy)*af;
            // COHESION: F_coh = (c̄-x)·(0.004+0.007·mem)
            const cf = (0.004+fm*0.007)*this.react;
            this.vx += (cx/nc-this.x)*cf; this.vy += (cy/nc-this.y)*cf;
        }
        
        for (const a of attrs) { const dx=a.x-this.x,dy=a.y-this.y,d=sqrt(dx*dx+dy*dy); if(d>0){this.vx+=dx/d*0.35*a.s;this.vy+=dy/d*0.35*a.s;} }
        
        // Predator avoidance - only if predator is flying (not feeding on ground)
        if (pred && pred.huntPhase !== 5) {
            const dx=this.x-pred.x, dy=this.y-pred.y, d=sqrt(dx*dx+dy*dy);
            // F_escape = r̂·(R-d)/R·80
            if (d < 180 && d > 0) {
                const f = (180-d)/180*80;
                this.vx += dx/d*f; this.vy += dy/d*f;
                if (d < 80) this.crr.rupture();
            }
        }
        
        if (scare) { const dx=this.x-scare.x,dy=this.y-scare.y,d=sqrt(dx*dx+dy*dy); if(d<scare.r&&d>0){this.vx+=dx/d*(scare.r-d)/scare.r*50;this.vy+=dy/d*(scare.r-d)/scare.r*50;this.crr.rupture();} }
        
        if (this.x<W*0.04) this.vx+=2; if (this.x>W*0.96) this.vx-=2;
        if (this.y<H*0.06) this.vy+=1.5; if (this.y>H*0.72) this.vy-=1.5;
        
        const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
        if (spd>85) { this.vx=this.vx/spd*85; this.vy=this.vy/spd*85; }
        else if (spd<15&&spd>0) { this.vx=this.vx/spd*15; this.vy=this.vy/spd*15; }
        
        this.x += this.vx*dt; this.y += this.vy*dt;
        
        // Perching - much more likely when predator is feeding (safe!)
        const predatorFeeding = pred && pred.huntPhase === 5;
        if (predatorFeeding) {
            // Actively seek perch when safe - high probability, relaxed speed/position requirements
            if (random() < 0.08) {
                let best=null,bestD=H*0.4; // Search wider area
                for (const p of perches) { if (p.occ) continue; const d=sqrt((this.x-p.x)**2+(this.y-p.y)**2); if (d<bestD){bestD=d;best=p;} }
                if (best) { this.st=1; this.perch=best; best.occ=true; this.timer=0; }
            }
        } else if (spd<35&&this.y>H*0.52&&random()<0.002) {
            // Normal perching when predator is flying - rare, must be slow and low
            let best=null,bestD=H*0.13;
            for (const p of perches) { if (p.occ) continue; const d=sqrt((this.x-p.x)**2+(this.y-p.y)**2); if (d<bestD){bestD=d;best=p;} }
            if (best) { this.st=1; this.perch=best; best.occ=true; this.timer=0; }
        }
    }
}

function drawBirds(birds) {
    ctx.fillStyle = 'rgba(18,18,22,0.82)';
    for (const b of birds) {
        if (b.st === 2) { ctx.beginPath(); ctx.ellipse(b.x,b.y,b.size*0.8,b.size,0,0,PI2); ctx.arc(b.x,b.y-b.size*0.8,b.size*0.42,0,PI2); ctx.fill(); }
        else {
            ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(atan2(b.vy,b.vx));
            const spd=sqrt(b.vx*b.vx+b.vy*b.vy),str=min(spd/30,1.6),flap=fsin(b.wph)*(0.2+b.crr.smoothAmp*0.4),ws=b.size*2.4;
            ctx.beginPath(); ctx.ellipse(0,0,b.size*str,b.size*0.38,0,0,PI2);
            ctx.moveTo(-b.size*0.22,0);
            ctx.quadraticCurveTo(-b.size*0.35,-ws*0.4*(1+flap),-b.size*0.12,-ws*(0.7+flap*0.22));
            ctx.quadraticCurveTo(b.size*0.12,-ws*0.22*(1+flap),b.size*0.22,0);
            ctx.quadraticCurveTo(b.size*0.12,ws*0.22*(1+flap),-b.size*0.12,ws*(0.7+flap*0.22));
            ctx.quadraticCurveTo(-b.size*0.35,ws*0.4*(1+flap),-b.size*0.22,0);
            ctx.moveTo(-b.size*str,0); ctx.lineTo(-b.size*str-b.size*0.5,-b.size*0.2); ctx.lineTo(-b.size*str-b.size*0.5,b.size*0.2);
            ctx.fill(); ctx.restore();
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════════════════════════════
let tree, birds=[], flock, grass, predator;
let scare=null, attrs=[];
let fps=60, fpsFrames=0, fpsLast=0, updMs=0;

function init() {
    W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H;
    sunrise.init(); initClouds();
    tree = new Tree(W*0.82, H*0.85, H*0.52);
    grass = new Grass(H*0.85, W, H);
    flock = new CRR(0.5, 0.1);
    
    birds = [];
    // Main flock
    for (let i=0;i<80;i++) { const a=random()*PI2,d=random()*W*0.08; birds.push(new Bird(W*0.32+fcos(a)*d, H*0.30+fsin(a)*d*0.5, flock)); }
    // Secondary flock
    for (let i=0;i<50;i++) { const a=random()*PI2,d=random()*W*0.06; birds.push(new Bird(W*0.55+fcos(a)*d, H*0.22+fsin(a)*d*0.5, flock)); }
    // Tertiary flock
    for (let i=0;i<40;i++) { const a=random()*PI2,d=random()*W*0.05; birds.push(new Bird(W*0.20+fcos(a)*d, H*0.42+fsin(a)*d*0.5, flock)); }
    
    attrs = [{x:W*0.32,y:H*0.28,s:1},{x:W*0.48,y:H*0.32,s:0.7},{x:W*0.25,y:H*0.38,s:0.5}];
    
    // Predator
    predator = new Predator(W*0.6, H*0.25);
}

function update(dt) {
    const t0 = performance.now();
    time += dt;
    
    sunrise.update(dt);
    atmosphere.update(dt, sunrise.phase);
    updateClouds(dt);
    
    flock.update(dt, 1+fsin(time*0.07)*0.2);
    const bf = 0.07+flock.smoothAmp*0.06;
    attrs[0].x = W*0.32+fsin(time*bf)*W*0.18;
    attrs[0].y = H*0.28+fsin(time*bf*0.6)*H*0.08;
    attrs[1].x = W*0.48+fcos(time*bf*1.1)*W*0.14;
    attrs[1].y = H*0.32+fcos(time*bf*0.8)*H*0.06;
    attrs[2].x = W*0.25+fsin(time*bf*0.7+1)*W*0.12;
    attrs[2].y = H*0.38+fcos(time*bf*0.9+1)*H*0.05;
    if (flock.st===1) { attrs[0].x+=(random()-0.5)*W*0.15; attrs[0].y+=(random()-0.5)*H*0.07; }
    
    tree.update(dt, 0.3);
    grass.update(dt);
    predator.update(dt, birds, flock, H * 0.85, tree);
    
    buildHash(birds);
    for (const b of birds) b.update(dt, nearby(b.x,b.y), birds, attrs, scare, tree.perches, predator);
    
    if (scare) { scare.s -= dt*1.8; if (scare.s<=0) scare=null; }
    
    updMs = performance.now() - t0;
}

function draw() {
    atmosphere.draw();
    sunrise.draw();
    drawClouds();
    predator.draw();
    drawBirds(birds);
    tree.draw();
    grass.draw();
    
    const vg = ctx.createRadialGradient(W*0.5,H*0.4,H*0.25,W*0.5,H*0.5,H);
    vg.addColorStop(0,'transparent');
    vg.addColorStop(0.6,'rgba(10,6,3,0.15)');
    vg.addColorStop(1,'rgba(5,3,1,0.4)');
    ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);
}

function updateFps(now) {
    fpsFrames++;
    if (now-fpsLast>=400) {
        fps=fpsFrames*1000/(now-fpsLast); fpsFrames=0; fpsLast=now;
        const el=document.getElementById('fps');
        el.textContent=fps.toFixed(0)+' FPS';
        el.className='fps'+(fps<30?' bad':fps<50?' warn':'');
    }
}

let debugOn=false, mathOn=false;
function updateDebug() {
    if (!debugOn) return;
    document.getElementById('sunPhase').textContent = sunrise.phase.toFixed(3);
    document.getElementById('thermals').textContent = heatRefraction.cells.length;
    document.getElementById('convStreams').textContent = horizConv.streams.length;
    document.getElementById('flockCoh').textContent = (flock.C/flock.omega).toFixed(2);
    document.getElementById('flockState').textContent = flock.stateName();
    const fly=birds.filter(b=>b.st===0).length, per=birds.filter(b=>b.st===2).length;
    document.getElementById('birds').textContent = `${fly}/${per}`;
    const ratio = per / birds.length * 100;
    document.getElementById('perchRatio').textContent = ratio.toFixed(0) + '%' + (ratio > 70 ? ' ✓' : '');
    document.getElementById('predState').textContent = predator.stateName();
    document.getElementById('predCoh').textContent = (predator.huntCRR.C/predator.huntCRR.omega).toFixed(2);
    document.getElementById('upd').textContent = updMs.toFixed(1);
}

document.addEventListener('keydown', e => {
    if (e.key==='c') { debugOn=!debugOn; document.getElementById('debug').classList.toggle('show',debugOn); }
    if (e.key==='m') { mathOn=!mathOn; document.getElementById('mathPanel').classList.toggle('show',mathOn); }
});

canvas.addEventListener('click', e => { scare={x:e.clientX,y:e.clientY,r:250,s:1}; flock.rupture(); });

let last = performance.now();
function loop(now) {
    const dt = min((now-last)/1000, 0.04); last=now;
    updateFps(now); update(dt); draw(); updateDebug();
    requestAnimationFrame(loop);
}

addEventListener('resize', () => { W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H; init(); });
init(); loop(performance.now());
</script>
</body>
</html>
