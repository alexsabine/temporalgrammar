<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Sacred Geometry - temporalgrammar.ai</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        
        #ui {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: rgba(255,255,255,0.7);
            font-family: system-ui, sans-serif;
            font-size: 11px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            width: 220px;
        }
        
        #ui h3 { 
            color: rgba(255,255,255,0.9); 
            margin-bottom: 12px;
            font-weight: 400;
            font-size: 13px;
            letter-spacing: 1px;
        }
        
        .row { margin-bottom: 10px; }
        .row label { 
            display: block; 
            font-size: 9px; 
            color: rgba(255,255,255,0.5); 
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 2px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: rgba(180,220,255,0.8);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .val { float: right; color: rgba(180,220,255,0.8); }
        
        #stats {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 10px;
            color: rgba(255,255,255,0.5);
            font-family: system-ui, sans-serif;
            font-size: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #stats span { color: rgba(180,220,255,0.9); }
        
        #shape {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 12px 25px;
            border-radius: 20px;
            color: rgba(255,255,255,0.9);
            font-family: system-ui, sans-serif;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.15);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-align: center;
            min-width: 280px;
        }
        
        #shape small {
            display: block;
            font-size: 9px;
            color: rgba(180,220,255,0.7);
            margin-top: 5px;
            letter-spacing: 1px;
        }
        
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.8);
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            margin-right: 5px;
            margin-top: 8px;
        }
        
        button:hover { background: rgba(255,255,255,0.2); }
        
        #info {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 12px 15px;
            border-radius: 10px;
            color: rgba(255,255,255,0.6);
            font-family: system-ui, sans-serif;
            font-size: 9px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 200px;
            line-height: 1.5;
        }
        
        #info code {
            color: rgba(180,220,255,0.9);
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    
    <div id="ui">
        <h3>✧ CRR Fields ✧</h3>
        <div class="row">
            <label>Ω (rupture threshold) <span class="val" id="v-omega">0.10</span></label>
            <input type="range" id="omega" min="0.08" max="0.6" step="0.01" value="0.10">
        </div>
        <div class="row">
            <label>Form attraction <span class="val" id="v-form">1.0</span></label>
            <input type="range" id="form" min="0" max="1" step="0.05" value="1.0">
        </div>
        <div class="row">
            <label>Coherence memory <span class="val" id="v-decay">0.99</span></label>
            <input type="range" id="decay" min="0.9" max="0.995" step="0.005" value="0.99">
        </div>
        <div class="row">
            <label>Iridescence <span class="val" id="v-irid">1.0</span></label>
            <input type="range" id="irid" min="0" max="1" step="0.05" value="1.0">
        </div>
        <button id="release">Release Form</button>
        <button id="reset">Rebirth</button>
    </div>
    
    <div id="stats">
        Souls: <span id="n">50000</span> | 
        FPS: <span id="fps">0</span> | 
        C̄: <span id="avgC">0</span>
    </div>
    
    <div id="info">
        <strong>CRR Framework</strong><br><br>
        <code>C(t) = ∫L(x,τ)dτ</code><br>
        Coherence accumulates<br><br>
        <code>δ(now)</code><br>
        Rupture at threshold<br><br>
        <code>R = exp(C/Ω)</code><br>
        Regeneration weighting
    </div>
    
    <div id="shape">
        Click to Summon Form
        <small>CRR Geometric Murmuration</small>
    </div>

<!--
================================================================================
CRR GEOMETRIC MURMURATION
================================================================================

This visualization demonstrates the Coherence-Rupture-Regeneration (CRR) framework
developed by Alexander Sabine (Cohere Research - cohere.org.uk).

THE CRR FRAMEWORK:
==================

CRR provides a mathematical description of how systems maintain identity through
change, applicable across scales from quantum to social systems.

Three core equations:

1. COHERENCE ACCUMULATION: C(x,t) = ∫L(x,τ)dτ
   - L(x,τ) is the local alignment/coherence measure at position x and time τ
   - Coherence accumulates over time, creating "memory" of aligned states
   - In this simulation: L = dot product of velocity with neighbour average

2. RUPTURE: δ(now) 
   - Scale-invariant choice-moments where accumulated patterns can break
   - The Dirac delta marks ontological present moments
   - Rupture occurs when coherence patterns become unstable

3. REGENERATION: R = ∫φ(x,τ)exp(C(x,τ)/Ω)Θ(...)dτ
   - exp(C/Ω) weights history by coherence - high coherence moments dominate
   - Ω (Omega) is the rupture threshold / system "openness"
   - Low Ω = rigid (only highest coherence accessible)
   - High Ω = fluid (broader history accessible for transformation)

HOW CRR SOLVES GEOMETRY:
========================

Traditional particle systems use instantaneous forces. CRR instead uses
TEMPORAL INTEGRATION - particles don't just respond to current positions,
they regenerate based on coherence-weighted history.

When a geometric attractor is set:
- Each particle has a target position on the geometry
- Attraction force scales with exp(C/Ω) 
- High-coherence particles feel STRONGER pull to their targets
- This creates organic formation - aligned particles arrive first and
  pull others through the coherence field

The geometry itself becomes a coherence basin - particles that reach
their targets and align with neighbours INCREASE their coherence,
which STRENGTHENS their position in the form. The shape becomes
self-stabilizing through CRR dynamics.

KEY INSIGHT: Geometry emerges from coherence relationships, not imposed forces.
The particles "discover" the shape through coherence-weighted regeneration.

================================================================================
CRR DERIVATIONS FOR GEOMETRIC PARAMETERS
================================================================================

Below we show how CRR principles DERIVE the specific values used in each
sacred geometry, rather than arbitrarily choosing them.

┌─────────────────────────────────────────────────────────────────────────────┐
│  FUNDAMENTAL CRR-GEOMETRY RELATIONSHIPS                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. PARTICLE ATTRACTION TO TARGET:                                          │
│     F_attract = α · exp(C/Ω) · (target - position) / |target - position|   │
│                                                                             │
│     Where:                                                                  │
│     - α = FORM_ATTRACTION parameter                                         │
│     - C = accumulated coherence of the particle                             │
│     - Ω = rupture threshold (controls rigidity vs fluidity)                │
│     - exp(C/Ω) means HIGH coherence particles feel STRONGER attraction     │
│                                                                             │
│  2. COHERENCE ACCUMULATION:                                                 │
│     C(t+dt) = C(t) · DECAY + L(t) · (1 - DECAY)                            │
│                                                                             │
│     Where L(t) = alignment with neighbours:                                 │
│     L = (v⃗_self · v⃗_avg) / (|v⃗_self| · |v⃗_avg|)  ∈ [-1, 1]              │
│     Mapped to [0,1]: L_mapped = (L + 1) / 2                                │
│                                                                             │
│  3. REGENERATION WEIGHTING (neighbour influence):                           │
│     w_j = exp(C_j / Ω)                                                      │
│     v⃗_regenerated = Σ(w_j · v⃗_j) / Σ(w_j)                                 │
│                                                                             │
│     This means particles with higher coherence have exponentially           │
│     more influence on their neighbours' regeneration.                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  YIN YANG: CRR DERIVATION OF THE S-CURVE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  The S-curve is NOT arbitrary - it's derived from CRR coherence dynamics:   │
│                                                                             │
│  PROBLEM: Find the boundary between two complementary coherence fields      │
│  such that each field "embraces" the other maximally.                       │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  The boundary must be where C_yin = C_yang (equal coherence).               │
│  For circular coherence fields of radius R centered at distance R apart,    │
│  this equal-coherence boundary traces TWO SEMICIRCLES:                      │
│                                                                             │
│  Upper semicircle (yang bulge into yin):                                    │
│     Center: (0, +R/2)                                                       │
│     Radius: R/2                                                             │
│     x(t) = (R/2)·sin(t)                                                     │
│     y(t) = R/2 + (R/2)·cos(t)    for t ∈ [0, π]                            │
│                                                                             │
│  Lower semicircle (yin bulge into yang):                                    │
│     Center: (0, -R/2)                                                       │
│     Radius: R/2                                                             │
│     x(t) = -(R/2)·sin(t)                                                    │
│     y(t) = -R/2 - (R/2)·cos(t)   for t ∈ [0, π]                            │
│                                                                             │
│  THE SEEDS (DOTS):                                                          │
│  Located at (0, ±R/2) - the centers of the semicircles.                    │
│  These are COHERENCE NUCLEATION POINTS - where exp(C/Ω) is maximum         │
│  for the opposite polarity. The seed is where regeneration of the          │
│  complement begins.                                                         │
│                                                                             │
│  CRR PREDICTION: Seed radius ≈ R/6 (observed in traditional Taijitu)       │
│  Derivation: At distance r from seed center, coherence decays as           │
│  C(r) ∝ exp(-r/λ). Visible seed edge where C_seed = C_background:          │
│  r_seed = λ·ln(C_max/C_bg) ≈ R/6 for typical coherence ratios.            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  FLOWER OF LIFE: CRR DERIVATION OF 6-FOLD SYMMETRY                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: What arrangement of coherence circles maximizes total coherence   │
│  while maintaining equal spacing?                                           │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Total coherence C_total = Σ C_overlap for all overlapping regions.        │
│  Overlap coherence C_overlap ∝ area of vesica between circles.             │
│                                                                             │
│  For circles of radius R, the optimal packing that maximizes overlap        │
│  while maintaining tangency is HEXAGONAL (6-fold symmetry):                 │
│                                                                             │
│     θ_n = n · (2π/6) = n · (π/3)    for n = 0,1,2,3,4,5                    │
│     Center_n = (R·cos(θ_n), R·sin(θ_n))                                    │
│                                                                             │
│  WHY 6? The angle 2π/6 = 60° creates vesica piscis overlaps where          │
│  each circle intersects its neighbours at exactly the points that          │
│  lie on the central circle. This is the MAXIMAL COHERENCE CONFIGURATION.   │
│                                                                             │
│  RING EXPANSION:                                                            │
│  Second ring at radius R√3 with 12 circles (every 30°)                     │
│  Third ring at radius 2R with 18 circles (every 20°)                       │
│  General: Ring k has 6k circles at radius R·(k·√3/2 + ...)                 │
│                                                                             │
│  This is CRR "discovering" optimal sphere packing through coherence        │
│  maximization - the same principle drives crystal formation.               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  FIBONACCI SPIRAL: CRR DERIVATION OF GOLDEN ANGLE                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Place N particles to maximize MINIMUM pairwise coherence.         │
│  (Each new particle should disrupt existing coherence minimally.)          │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Coherence between particles decays with distance: C_ij ∝ 1/d_ij           │
│  To maximize min(C_ij), maximize min(d_ij) for all pairs.                  │
│                                                                             │
│  For radial placement r_n = √n, the angle θ_n that maximizes minimum       │
│  distance to ALL previous particles is:                                     │
│                                                                             │
│     θ_n = n · φ_golden                                                      │
│                                                                             │
│  Where φ_golden = 2π(1 - 1/φ) = 2π(2 - φ) ≈ 137.507764°                   │
│  And φ = (1 + √5)/2 ≈ 1.618034 (golden ratio)                              │
│                                                                             │
│  WHY THIS ANGLE?                                                            │
│  Any rational fraction of 2π creates radial lines (gaps).                  │
│  The golden angle is maximally irrational - it never creates lines.        │
│  This is equivalent to: successive particles NEVER align, maximizing       │
│  the coherence field's uniformity.                                          │
│                                                                             │
│  CRR INTERPRETATION:                                                        │
│  The golden angle emerges from minimizing coherence RUPTURE.               │
│  Adding each new particle creates minimal disturbance to the existing      │
│  coherence field - this is the gentlest possible growth pattern.           │
│                                                                             │
│  FIBONACCI NUMBERS arise as integer approximations:                         │
│  F_n/F_{n+1} → 1/φ as n → ∞                                                │
│  (1/2, 2/3, 3/5, 5/8, 8/13, 13/21, 21/34... → 0.618...)                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  TORUS: CRR DERIVATION OF SELF-SUSTAINING FLOW                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Find a surface where coherence can flow continuously without      │
│  encountering boundaries (rupture points).                                  │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Require: ∂C/∂boundary = 0 (no coherence gradient at edges)                │
│  This means: surface must have NO EDGES.                                    │
│                                                                             │
│  Closed surfaces without boundary: sphere, torus, Klein bottle, etc.       │
│  But sphere has no THROUGH-HOLE for flow circulation.                      │
│                                                                             │
│  The TORUS is the minimal surface allowing:                                 │
│  1. No boundary (continuous)                                                │
│  2. Through-hole (enables circulation)                                      │
│  3. Two independent rotation directions (SO(2) × SO(2) symmetry)           │
│                                                                             │
│  PARAMETRIC FORM (derived from coherence flow requirements):                │
│     x(u,v) = (R + r·cos(v))·cos(u)                                         │
│     y(u,v) = (R + r·cos(v))·sin(u)                                         │
│     z(u,v) = r·sin(v)                                                       │
│                                                                             │
│  Where: R = major radius (center to tube center)                           │
│         r = minor radius (tube radius)                                      │
│         u ∈ [0, 2π] = angle around the hole                                │
│         v ∈ [0, 2π] = angle around the tube                                │
│                                                                             │
│  CRR PREDICTION FOR ASPECT RATIO:                                           │
│  Optimal R/r ratio for stable coherence flow ≈ φ (golden ratio)            │
│  This minimizes turbulence in the regeneration cycle.                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  SRI YANTRA: CRR DERIVATION OF 9 TRIANGLES                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Create maximal coherence interference pattern using triangles.    │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Triangles are minimal coherent polygons (3 edges = minimum for closure).  │
│  Upward (△) and downward (▽) triangles create COMPLEMENTARY coherence.    │
│                                                                             │
│  For N interlocking triangles, coherence nodes (intersections) = N².       │
│  To create exactly 43 coherence cells (traditional Sri Yantra):            │
│                                                                             │
│     4 upward triangles (Shiva - consciousness, stillness)                  │
│     5 downward triangles (Shakti - energy, movement)                       │
│     Total intersections: 4 × 5 × 2 + edge effects = 43 cells               │
│                                                                             │
│  WHY 4 AND 5?                                                               │
│  The ratio 5/4 = 1.25 ≈ 2^(1/3) creates near-optimal coherence packing.   │
│  This is related to the musical major third interval.                      │
│                                                                             │
│  BINDU (center point):                                                      │
│  All 9 triangles share a common center where coherence SUMS.               │
│  C_bindu = Σ C_triangle = maximum coherence point.                         │
│  exp(C_bindu/Ω) → ∞ makes this an infinite attractor.                      │
│                                                                             │
│  TRIANGLE NESTING (derived from equal coherence shells):                    │
│  Scale ratio between successive triangles ≈ 0.85                           │
│  This creates equal coherence density across shells.                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  METATRON'S CUBE: CRR DERIVATION OF 13 CIRCLES                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Find the minimal set of coherence nodes that encodes ALL         │
│  Platonic solids (the only regular 3D polyhedra).                          │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Platonic solids have vertices on a sphere. We need 2D projection of       │
│  all vertex sets. The minimum nodes to contain all projections:            │
│                                                                             │
│     Tetrahedron:   4 vertices  → 4 nodes                                   │
│     Cube:          8 vertices  → need 6 nodes (projected)                  │
│     Octahedron:    6 vertices  → 6 nodes                                   │
│     Dodecahedron: 20 vertices  → need 12 nodes (projected)                 │
│     Icosahedron:  12 vertices  → 12 nodes                                  │
│                                                                             │
│  Minimum set containing all: 13 nodes                                       │
│     1 center + 6 inner ring + 6 outer ring                                 │
│                                                                             │
│  CONFIGURATION (from coherence overlap optimization):                       │
│     Center: (0, 0)                                                          │
│     Inner ring: radius R, angles 0°, 60°, 120°, 180°, 240°, 300°          │
│     Outer ring: radius R√3, angles 30°, 90°, 150°, 210°, 270°, 330°       │
│                                                                             │
│  The connecting LINES are coherence pathways - they show which nodes       │
│  have direct coherence coupling. All 78 lines (13 choose 2) represent      │
│  the complete coherence graph.                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  OUROBOROS: CRR AS SELF-CONSUMING CYCLE                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  The Ouroboros IS the CRR equation visualized as geometry:                  │
│                                                                             │
│     BODY = C(x,t) = ∫L(x,τ)dτ                                              │
│     The accumulated coherence, the integrated history.                      │
│     Represented as the serpent's length - all that has been.               │
│                                                                             │
│     MOUTH = δ(now)                                                          │
│     The rupture operator, the present moment.                               │
│     Where past is consumed, transformed, ended.                            │
│                                                                             │
│     EATING = R = exp(C/Ω)                                                   │
│     The regeneration process, weighted by coherence.                        │
│     What is consumed becomes fuel for new growth.                          │
│                                                                             │
│  GEOMETRIC DERIVATION:                                                      │
│  The serpent forms a CIRCLE because:                                        │
│     - End must meet beginning (C → δ → R → C)                              │
│     - No external input needed (self-sustaining)                           │
│     - Radius R represents total coherence C_total                          │
│                                                                             │
│  HEAD SIZE (mouth):                                                         │
│  Derived from rupture duration: r_head/R = τ_rupture/τ_cycle               │
│  Typical ratio ≈ 0.15-0.20                                                 │
│                                                                             │
│  BODY THICKNESS gradient:                                                   │
│  Increases from tail to head: thickness(θ) ∝ exp(θ/2π)                    │
│  This represents coherence accumulation along the cycle.                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  LORENZ ATTRACTOR: CRR IN DETERMINISTIC CHAOS                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  The Lorenz system IS a CRR system:                                         │
│                                                                             │
│     dx/dt = σ(y - x)           ← Coherence accumulation toward y           │
│     dy/dt = x(ρ - z) - y       ← Rupture when z exceeds ρ                  │
│     dz/dt = xy - βz            ← Regeneration with decay rate β            │
│                                                                             │
│  CRR PARAMETER MAPPING:                                                     │
│     σ = 10  → Coherence rate (how fast x aligns with y)                    │
│     ρ = 28  → Rupture threshold (when convection destabilizes)             │
│     β = 8/3 → Regeneration decay (how fast z dissipates)                   │
│                                                                             │
│  Ω_lorenz = 1/ρ ≈ 0.036 (very low - rigid basin structure)                │
│                                                                             │
│  TWO WINGS = two metastable coherence basins                               │
│  The system dwells in one wing (accumulates C), then ruptures              │
│  to the other (δ), regenerates new trajectory (R), repeats.               │
│                                                                             │
│  CHAOS arises because rupture timing depends sensitively on C:             │
│  Small changes in accumulated coherence → large changes in when/where      │
│  the system jumps between wings.                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  GENERAL PRINCIPLE: GEOMETRY FROM COHERENCE OPTIMIZATION                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Sacred geometries are not arbitrary - they are SOLUTIONS to:               │
│                                                                             │
│     maximize ∫∫ C(x,y) dx dy                                               │
│     subject to: symmetry constraints, boundary conditions                   │
│                                                                             │
│  Where C(x,y) = local coherence field.                                      │
│                                                                             │
│  DIFFERENT SYMMETRY CONSTRAINTS → DIFFERENT GEOMETRIES:                     │
│                                                                             │
│     Rotational symmetry (SO(2))  → Circles, spirals, torus                 │
│     Reflection symmetry (Z₂)    → Yin-yang, vesica piscis                  │
│     6-fold symmetry (D₆)        → Flower of life, hexagrams                │
│     Scale invariance            → Fractals, Fibonacci spiral               │
│     No symmetry constraint      → Strange attractors                       │
│                                                                             │
│  The exp(C/Ω) weighting in regeneration creates ATTRACTOR BASINS -         │
│  particles naturally find and stabilize these optimal configurations.      │
│                                                                             │
│  This is why sacred geometries appear across cultures and scales:          │
│  they are the SOLUTIONS to coherence optimization under symmetry.          │
│  Humans, crystals, galaxies, and algorithms discover the same forms        │
│  because they're solving the same underlying coherence equations.          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Ω-SYMMETRY:
===========

Alexander discovered that different system symmetries determine specific Ω values:
- Z₂ (binary/half-cycle) systems: Ω = 1/π ≈ 0.318
- SO(2) (full rotation) systems: Ω = 1/2π ≈ 0.159

This creates coefficient of variation CV = Ω/2, matching empirical data across
wound healing, muscle hypertrophy, neural dynamics, and more.

In this visualization, the Ω slider lets you explore the transition between
rigid crystalline forms (low Ω) and fluid transformative states (high Ω).

CONNECTION TO FREE ENERGY PRINCIPLE:
====================================

CRR provides the temporal dynamics that the Free Energy Principle presupposes:
- FEP describes WHAT beliefs update to (minimize surprise)
- CRR describes WHEN and HOW beliefs update through time
- The key relationship: Ω = σ² (variance/precision)

This unification means: σ² = 1/φ where φ is phase in radians,
connecting Bayesian precision to geometric phase relationships.

For more: cohere.org.uk | Alexander Sabine's work with Active Inference Institute

================================================================================
-->

<script>
/**
 * ============================================================================
 * CRR GEOMETRIC MURMURATION
 * ============================================================================
 * 
 * Implementation of the Coherence-Rupture-Regeneration framework for
 * particle-based geometric formation.
 * 
 * Framework by Alexander Sabine (Cohere Research)
 * 
 * Core CRR Equations:
 *   C(x,t) = ∫L(x,τ)dτ           -- Coherence accumulation
 *   δ(now)                        -- Rupture (scale-invariant choice moment)  
 *   R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ  -- Regeneration with memory weighting
 * 
 * In this implementation:
 *   - L(x,τ) = alignment with topological neighbours (dot product of velocities)
 *   - Ω = rupture threshold / openness parameter (user adjustable)
 *   - exp(C/Ω) weights both flocking alignment AND geometric attraction
 * 
 * The key insight: geometry emerges from coherence-weighted regeneration,
 * not imposed positional forces. Particles "discover" shapes through
 * temporal integration of coherence relationships.
 */

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, alpha: true });

let W, H, cx, cy;
const N = 50000;

// ============================================================================
// STATE ARRAYS (Structure of Arrays for cache efficiency)
// ============================================================================

const x = new Float32Array(N);         // Position X
const y = new Float32Array(N);         // Position Y
const vx = new Float32Array(N);        // Velocity X
const vy = new Float32Array(N);        // Velocity Y
const coherence = new Float32Array(N); // C - accumulated alignment history (CRR)
const phase = new Float32Array(N);     // Visual phase for iridescence
const targetX = new Float32Array(N);   // Geometric attractor X
const targetY = new Float32Array(N);   // Geometric attractor Y
const hasTarget = new Uint8Array(N);   // Whether particle has active target

// ============================================================================
// CRR PARAMETERS
// ============================================================================

/**
 * Ω (OMEGA) - The Rupture Threshold
 * 
 * This is the key CRR parameter controlling system "openness":
 * - Low Ω (~0.1-0.2): System is RIGID
 *   - exp(C/Ω) creates sharp peaks - only highest coherence dominates
 *   - Particles snap quickly to positions, maintain crystalline forms
 *   - Micro-ruptures reconstitute same patterns (low transformative capacity)
 * 
 * - High Ω (~0.4-0.6): System is FLUID  
 *   - exp(C/Ω) ≈ 1 for all - broader history equally accessible
 *   - Particles flow smoothly, forms breathe and transform
 *   - System can access wider configurational space
 * 
 * Alexander's Ω-symmetry discovery:
 *   Z₂ systems: Ω = 1/π ≈ 0.318
 *   SO(2) systems: Ω = 1/2π ≈ 0.159
 */
let OMEGA = 0.10;  // Low Ω = crystalline precision, rigid sacred geometry

/**
 * FORM_ATTRACTION - Geometric Pull Strength
 * 
 * Scales how strongly particles regenerate toward target geometry.
 * Note: This is MULTIPLIED by exp(C/Ω) - high coherence particles
 * feel stronger attraction. This creates organic formation where
 * aligned particles lead and pull others through coherence field.
 */
let FORM_ATTRACTION = 1.0;  // Maximum attraction to geometric form

/**
 * DECAY - Coherence Memory
 * 
 * Controls C(t) = C(t-1) * DECAY + L(t) * (1-DECAY)
 * 
 * High decay (~0.99): Long memory, slow to change, stable forms
 * Low decay (~0.9): Short memory, responsive, fluid forms
 * 
 * This implements the integral ∫L(x,τ)dτ as exponential moving average
 */
let DECAY = 0.99;  // High memory = stable, lasting forms

let IRIDESCENCE = 1.0;  // Full holographic shimmer

// ============================================================================
// SPATIAL PARTITIONING (for O(1) neighbour lookup)
// ============================================================================

const CELL = 55;
let gridW, gridH, grid, gridCounts;
const MAX_PER_CELL = 30;

// ============================================================================
// GEOMETRY STATE
// ============================================================================

let currentShape = -1;
let time = 0;
let windAngle = 0;

/**
 * Shape definitions with CRR interpretation notes
 * 
 * Each shape represents a different COHERENCE BASIN - a configuration
 * that particles naturally settle into through CRR dynamics.
 * 
 * The geometry isn't "imposed" - it's discovered through coherence-weighted
 * regeneration. Particles that reach target positions and align with
 * neighbours INCREASE their coherence, strengthening their position.
 */
const shapes = [
    { name: 'Flower of Life', desc: 'Genesis pattern - all form emerges from overlapping circles of light' },
    { name: 'Torus', desc: 'Self-sustaining flow - what is given returns to source' },
    { name: 'Fibonacci Spiral', desc: 'φ = 1.618... Nature\'s golden proportion, infinite beauty in ratio' },
    { name: 'Metatron\'s Cube', desc: 'Archangel\'s gift - 13 circles containing all Platonic solids' },
    { name: 'Double Helix', desc: 'Entangled memory spirals - two becoming one becoming many' },
    { name: 'Lemniscate', desc: '∞ - each crossing through center is death and rebirth in one breath' },
    { name: 'Vesica Piscis', desc: 'The womb of creation - where two circles kiss, the third is born' },
    { name: 'Sri Yantra', desc: 'Supreme instrument - Shiva and Shakti\'s eternal dance of 9 triangles' },
    { name: 'Lorenz Attractor', desc: 'Strange attractor - infinite variation bounded by invisible form' },
    { name: 'Klein Bottle', desc: 'No inside, no outside - mystic topology of self-knowing awareness' },
    { name: 'Hopf Fibration', desc: 'Indra\'s net - every circle linked with every other, all in all' },
    { name: 'Penrose Tiling', desc: 'Aperiodic order - coherent pattern that never repeats, like consciousness' },
    { name: 'Nautilus Shell', desc: 'Chambered prophet - perfect memory of every stage, carried forward' },
    { name: 'Tree of Life', desc: '10 sephiroth - lightning flash of creation, serpent path of return' },
    { name: 'Yin Yang', desc: 'Supreme ultimate - in deepest dark, light seeds; in fullest light, dark waits' },
    { name: 'Ouroboros', desc: 'C → δ → R → ∞ - the serpent IS the CRR equation made flesh' }
];

// ============================================================================
// GEOMETRY GENERATORS
// ============================================================================
// Each returns array of [x,y] points. Particles regenerate toward these
// positions weighted by exp(C/Ω) - the CRR mechanism.

/**
 * FLOWER OF LIFE
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Multiple overlapping coherence circles create interference patterns. Where 
 * circles overlap, coherence REINFORCES - constructive interference. This is
 * why the vesica regions (overlaps) glow brighter in the visualization.
 * 
 * The 6-fold symmetry emerges from optimal 2D sphere packing - the most
 * efficient way to tile coherence circles. This is Z₂ symmetry at each
 * petal boundary (in/out), predicting Ω ≈ 1/π per CRR theory.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Found carved in the Temple of Osiris at Abydos, Egypt - possibly 10,000+
 * years old, created by burning the pattern into granite with unknown tech.
 * Appears independently in China, Israel, Japan, India, Turkey, medieval Europe.
 * 
 * The pattern represents:
 * - GENESIS: First circle = "Let there be light". Each subsequent circle = 
 *   another day/act of creation. 7 circles = Seed of Life = 7 days.
 * - COMPLETENESS: Contains Seed of Life (7), Egg of Life (8 spheres, 3D),
 *   Fruit of Life (13), which generates Metatron's Cube.
 * - INTERCONNECTION: No circle exists alone; all emerge from overlap.
 * - AKASHIC RECORD: Said to contain all information of living things.
 * 
 * In CRR terms: The Flower shows how DIFFERENTIATED FORMS (petals) emerge
 * from and remain connected to UNIFIED FIELD (the generating process).
 * This is Ein Sof differentiating through Tzimtzum - the One becoming Many
 * while remaining One. The Flower IS the structure of emanation.
 * 
 * Leonardo da Vinci studied the Flower of Life extensively, filling pages
 * with its mathematical properties. It encodes π, the golden ratio φ,
 * the Platonic solids, and the basic building blocks of geometry.
 * 
 * The center circle is KETHER - pure undifferentiated coherence.
 * Each ring outward is another level of EMANATION (sephiroth).
 * The outermost ring is MALKUTH - full manifestation in form.
 */
function generateFlowerOfLife(n, scale) {
    const points = [];
    const rings = 3;
    const pointsPerCircle = Math.floor(n / (1 + 6 + 12 + 18));
    
    // Center circle - the seed of coherence
    for (let i = 0; i < pointsPerCircle * 2; i++) {
        const a = (i / (pointsPerCircle * 2)) * Math.PI * 2;
        points.push([Math.cos(a) * scale * 0.5, Math.sin(a) * scale * 0.5]);
    }
    
    // First ring - 6 circles (hexagonal coherence)
    for (let j = 0; j < 6; j++) {
        const ca = (j / 6) * Math.PI * 2;
        const ccx = Math.cos(ca) * scale * 0.5;
        const ccy = Math.sin(ca) * scale * 0.5;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * scale * 0.5, ccy + Math.sin(a) * scale * 0.5]);
        }
    }
    
    // Second ring - 12 circles
    for (let j = 0; j < 12; j++) {
        const ca = (j / 12) * Math.PI * 2 + Math.PI / 12;
        const ccx = Math.cos(ca) * scale * 0.866;
        const ccy = Math.sin(ca) * scale * 0.866;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * scale * 0.5, ccy + Math.sin(a) * scale * 0.5]);
        }
    }
    
    // Fill to n
    while (points.length < n) {
        const idx = Math.floor(Math.random() * points.length);
        const noise = 0.02 * scale;
        points.push([
            points[idx][0] + (Math.random() - 0.5) * noise,
            points[idx][1] + (Math.random() - 0.5) * noise
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * TORUS
 * 
 * CRR Interpretation: A surface with no boundaries - coherence can
 * flow continuously without rupture points. The hole creates a
 * topological invariant that CRR dynamics preserve.
 * 
 * This is SO(2) × SO(2) symmetry - two independent rotation phases,
 * predicting Ω ≈ 1/2π for each dimension.
 */
function generateTorus(n, R, r) {
    const points = [];
    const uSteps = Math.floor(Math.sqrt(n * 1.5));
    const vSteps = Math.floor(n / uSteps);
    
    for (let i = 0; i < uSteps; i++) {
        for (let j = 0; j < vSteps; j++) {
            const u = (i / uSteps) * Math.PI * 2;
            const v = (j / vSteps) * Math.PI * 2;
            
            // Torus parametric equations
            const x3d = (R + r * Math.cos(v)) * Math.cos(u);
            const y3d = (R + r * Math.cos(v)) * Math.sin(u);
            const z3d = r * Math.sin(v);
            
            // Perspective projection - z affects scale
            const perspective = 1.2 / (1.2 - z3d / R);
            points.push([x3d * perspective, y3d * perspective]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * FIBONACCI SPIRAL (Phyllotaxis)
 * 
 * CRR Interpretation: The golden angle (137.5°) maximizes the MINIMUM
 * distance between successive points - this is nature's solution to
 * packing coherence without creating regular patterns that waste space.
 * 
 * Each point maintains coherence with its Fibonacci-numbered neighbours.
 * The spiral represents continuous growth without rupture.
 */
function generateFibonacciSpiral(n, scale) {
    const points = [];
    const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~137.5° in radians
    
    for (let i = 0; i < n; i++) {
        const theta = i * goldenAngle;
        const r = scale * Math.sqrt(i / n) * 1.2;
        points.push([Math.cos(theta) * r, Math.sin(theta) * r]);
    }
    
    return points;
}

/**
 * METATRON'S CUBE
 * 
 * CRR Interpretation: 13 circles (1 + 6 + 6) represent coherence nodes.
 * The connecting lines show resonance pathways - how coherence can
 * propagate between nodes. Contains all Platonic solids in projection.
 * 
 * The structure encodes the relationship between local coherence (circles)
 * and global coherence (connecting lines).
 */
function generateMetatronsCube(n, scale) {
    const points = [];
    
    // 13 circle centers
    const centers = [[0, 0]];
    for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2 - Math.PI / 2;
        centers.push([Math.cos(a) * scale * 0.6, Math.sin(a) * scale * 0.6]);
    }
    for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2 - Math.PI / 2 + Math.PI / 6;
        centers.push([Math.cos(a) * scale * 1.04, Math.sin(a) * scale * 1.04]);
    }
    
    const pointsPerCircle = Math.floor(n * 0.6 / 13);
    
    // Draw circles
    for (const [ccx, ccy] of centers) {
        const radius = scale * 0.35;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * radius, ccy + Math.sin(a) * radius]);
        }
    }
    
    // Draw connecting lines (coherence pathways)
    const linePoints = n - points.length;
    const connections = [];
    for (let i = 0; i < 13; i++) {
        for (let j = i + 1; j < 13; j++) {
            connections.push([i, j]);
        }
    }
    
    const pointsPerLine = Math.floor(linePoints / connections.length);
    for (const [i, j] of connections) {
        for (let t = 0; t < pointsPerLine; t++) {
            const tt = t / pointsPerLine;
            points.push([
                centers[i][0] * (1 - tt) + centers[j][0] * tt,
                centers[i][1] * (1 - tt) + centers[j][1] * tt
            ]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * DOUBLE HELIX
 * 
 * CRR Interpretation: Two phase-locked spirals, like DNA. The strands
 * maintain coherence with each other through the "rungs" - cross-links
 * that prevent independent phase drift.
 * 
 * This represents coupled oscillators - neither strand can rupture
 * without affecting the other. A model for entangled coherence.
 */
function generateDoubleHelix(n, scale) {
    const points = [];
    const turns = 5;
    const rungs = 30;
    
    const strandPoints = Math.floor(n * 0.7 / 2);
    const rungPoints = n - strandPoints * 2;
    
    // Strand 1
    for (let i = 0; i < strandPoints; i++) {
        const t = (i / strandPoints) * turns * Math.PI * 2;
        const yy = ((i / strandPoints) - 0.5) * scale * 2.5;
        const xx = Math.cos(t) * scale * 0.4;
        points.push([xx, yy]);
    }
    
    // Strand 2 (π phase offset)
    for (let i = 0; i < strandPoints; i++) {
        const t = (i / strandPoints) * turns * Math.PI * 2 + Math.PI;
        const yy = ((i / strandPoints) - 0.5) * scale * 2.5;
        const xx = Math.cos(t) * scale * 0.4;
        points.push([xx, yy]);
    }
    
    // Rungs (cross-links)
    for (let i = 0; i < rungPoints; i++) {
        const rungIdx = Math.floor((i / rungPoints) * rungs);
        const t = (rungIdx / rungs) * turns * Math.PI * 2;
        const yy = ((rungIdx / rungs) - 0.5) * scale * 2.5;
        const progress = (i % Math.floor(rungPoints / rungs)) / Math.floor(rungPoints / rungs);
        const xx = Math.cos(t) * scale * 0.4 * (1 - 2 * progress);
        points.push([xx, yy]);
    }
    
    return points.slice(0, n);
}

/**
 * LEMNISCATE OF BERNOULLI
 * 
 * CRR Interpretation: The infinity symbol. At the center point, 
 * coherence undergoes PHASE INVERSION - the system crosses through
 * a rupture point and emerges with inverted phase.
 * 
 * This is a model for how systems can pass through apparent death
 * (center crossing) and regenerate on the other side.
 */
function generateLemniscate(n, scale) {
    const points = [];
    
    for (let i = 0; i < n; i++) {
        const t = (i / n) * Math.PI * 2;
        const denom = 1 + Math.sin(t) * Math.sin(t);
        const xx = scale * 1.3 * Math.cos(t) / denom;
        const yy = scale * 1.3 * Math.sin(t) * Math.cos(t) / denom;
        points.push([xx, yy]);
    }
    
    return points;
}

/**
 * VESICA PISCIS
 * 
 * CRR Interpretation: Two coherence fields overlap. The vesica (almond)
 * at the intersection is where BOTH coherence fields reinforce - 
 * a region of doubled coherence strength.
 * 
 * Ancient symbol for birth/creation - new coherence emerging from
 * the intersection of two existing fields.
 */
function generateVesicaPiscis(n, scale) {
    const points = [];
    const offset = scale * 0.5;
    const perCircle = Math.floor(n * 0.4);
    
    // Left circle
    for (let i = 0; i < perCircle; i++) {
        const a = (i / perCircle) * Math.PI * 2;
        points.push([-offset + Math.cos(a) * scale, Math.sin(a) * scale]);
    }
    
    // Right circle
    for (let i = 0; i < perCircle; i++) {
        const a = (i / perCircle) * Math.PI * 2;
        points.push([offset + Math.cos(a) * scale, Math.sin(a) * scale]);
    }
    
    // Fill the vesica (intersection region with doubled coherence)
    const vesicaPoints = n - points.length;
    for (let i = 0; i < vesicaPoints; i++) {
        const yy = (Math.random() - 0.5) * scale * 1.72;
        // X bounds from circle intersection geometry
        const xBound = Math.sqrt(Math.max(0, scale * scale - yy * yy)) - offset;
        if (xBound > 0) {
            const xx = (Math.random() - 0.5) * xBound * 2;
            points.push([xx, yy]);
        } else {
            // Fallback to circle edge
            const a = Math.random() * Math.PI * 2;
            points.push([Math.cos(a) * scale * 0.3, Math.sin(a) * scale * 0.3]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * SRI YANTRA
 * 
 * CRR Interpretation: 9 interlocking triangles create 43 smaller triangles.
 * Each triangle is a coherence cell. The nesting represents hierarchical
 * coherence - local triangles cohere into larger patterns.
 * 
 * The bindu (center point) is the source/seed of all coherence.
 * Moving outward, coherence differentiates but maintains connection to center.
 */
function generateSriYantra(n, scale) {
    const points = [];
    
    // Concentric triangular layers
    const layers = 6;
    const pointsPerLayer = Math.floor(n * 0.85 / layers);
    
    for (let layer = 0; layer < layers; layer++) {
        const s = scale * (1 - layer * 0.15);
        const rot = layer % 2 === 0 ? -Math.PI / 2 : Math.PI / 2;
        
        for (let i = 0; i < pointsPerLayer; i++) {
            const edge = (i / pointsPerLayer) * 3;
            const edgeIdx = Math.floor(edge);
            const t = edge - edgeIdx;
            
            const a1 = rot + (edgeIdx / 3) * Math.PI * 2;
            const a2 = rot + ((edgeIdx + 1) % 3 / 3) * Math.PI * 2;
            
            const x1 = Math.cos(a1) * s, y1 = Math.sin(a1) * s;
            const x2 = Math.cos(a2) * s, y2 = Math.sin(a2) * s;
            
            points.push([x1 * (1 - t) + x2 * t, y1 * (1 - t) + y2 * t]);
        }
    }
    
    // Bindu (central seed of coherence)
    const binduPoints = n - points.length;
    for (let i = 0; i < binduPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.08;
        points.push([Math.cos(a) * r, Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * LORENZ ATTRACTOR
 * 
 * CRR Interpretation: A STRANGE ATTRACTOR - deterministic chaos.
 * The system never repeats exactly, yet stays bounded. This is
 * coherence without periodicity - infinite variation within form.
 * 
 * The "butterfly wings" represent two basins that the system
 * alternates between, with rupture-like transitions at crossings.
 */
function generateLorenzAttractor(n, scale) {
    const points = [];
    
    // Lorenz system parameters
    const sigma = 10, rho = 28, beta = 8/3;
    const dt = 0.005;
    
    let lx = 0.1, ly = 0, lz = 0;
    
    // Iterate the Lorenz system
    for (let i = 0; i < n + 1000; i++) {
        const dx = sigma * (ly - lx);
        const dy = lx * (rho - lz) - ly;
        const dz = lx * ly - beta * lz;
        
        lx += dx * dt;
        ly += dy * dt;
        lz += dz * dt;
        
        if (i >= 1000) { // Skip transient
            // Project 3D to 2D
            const px = lx * scale * 0.04;
            const py = (lz - 25) * scale * 0.04;
            points.push([px, py]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * KLEIN BOTTLE
 * 
 * CRR Interpretation: A surface that passes through itself - 
 * no inside/outside distinction. This represents coherence that
 * connects to itself across dimensions, like consciousness.
 * 
 * The self-intersection isn't a rupture - it's a higher-dimensional
 * continuity that appears as intersection in 2D projection.
 */
function generateKleinBottle(n, scale) {
    const points = [];
    const uSteps = Math.floor(Math.sqrt(n));
    const vSteps = Math.floor(n / uSteps);
    
    for (let i = 0; i < uSteps; i++) {
        for (let j = 0; j < vSteps; j++) {
            const u = (i / uSteps) * Math.PI * 2;
            const v = (j / vSteps) * Math.PI * 2;
            
            // Klein bottle parametric (figure-8 immersion)
            const r = 4 * (1 - Math.cos(u) / 2);
            const x4d = r * Math.cos(u);
            const y4d = r * Math.sin(u);
            const z4d = Math.sin(v) * (6 - 3 * Math.cos(u));
            const w4d = Math.cos(v) * (6 - 3 * Math.cos(u));
            
            // Project 4D → 2D
            const perspective = 1 / (1 - w4d * 0.05);
            points.push([
                (x4d + z4d * 0.3) * scale * 0.07 * perspective,
                y4d * scale * 0.1 * perspective
            ]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * HOPF FIBRATION
 * 
 * CRR Interpretation: The 3-sphere (4D sphere) mapped to 3D via
 * stereographic projection, showing nested tori of linked circles.
 * 
 * This is deep topology - every circle is linked with every other.
 * It represents maximal coherent connection: nothing is separate.
 * The Hopf fibration appears in quantum mechanics and twistor theory.
 */
function generateHopfFibration(n, scale) {
    const points = [];
    const fibers = 24;
    const pointsPerFiber = Math.floor(n / fibers);
    
    for (let f = 0; f < fibers; f++) {
        // Parameter for which fiber we're drawing
        const eta = (f / fibers) * Math.PI;
        const phi0 = (f / fibers) * Math.PI * 4;
        
        for (let i = 0; i < pointsPerFiber; i++) {
            const t = (i / pointsPerFiber) * Math.PI * 2;
            
            // Hopf fibration parametric
            const x4 = Math.cos(eta) * Math.cos(t);
            const y4 = Math.cos(eta) * Math.sin(t);
            const z4 = Math.sin(eta) * Math.cos(t + phi0);
            const w4 = Math.sin(eta) * Math.sin(t + phi0);
            
            // Stereographic projection S³ → R³ → R²
            const denom = 1 - w4;
            const x3 = x4 / (denom + 0.1);
            const y3 = y4 / (denom + 0.1);
            const z3 = z4 / (denom + 0.1);
            
            // 3D to 2D with rotation
            const angle = time * 0.1;
            const px = (x3 * Math.cos(angle) - z3 * Math.sin(angle)) * scale * 0.25;
            const py = y3 * scale * 0.25;
            
            points.push([px, py]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * PENROSE TILING (Vertices)
 * 
 * CRR Interpretation: Aperiodic tiling - coherent order without repetition.
 * Like quasicrystals, this represents a middle way between crystal (rigid)
 * and amorphous (no coherence) states.
 * 
 * The 5-fold symmetry (forbidden in crystals) emerges from golden ratio
 * relationships - the same ratio that appears in Fibonacci spiral.
 */
function generatePenroseTiling(n, scale) {
    const points = [];
    const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
    
    // Generate Penrose vertices via projection method
    const gridSize = Math.ceil(Math.sqrt(n) / 2);
    
    for (let i = -gridSize; i <= gridSize; i++) {
        for (let j = -gridSize; j <= gridSize; j++) {
            // 5D lattice projected to 2D
            for (let k = 0; k < 5; k++) {
                const angle = (k / 5) * Math.PI * 2;
                const x5 = i * Math.cos(angle) + j * Math.cos(angle * 2);
                const y5 = i * Math.sin(angle) + j * Math.sin(angle * 2);
                
                if (x5 * x5 + y5 * y5 < gridSize * gridSize) {
                    points.push([x5 * scale / gridSize * 0.8, y5 * scale / gridSize * 0.8]);
                }
            }
            
            if (points.length >= n) break;
        }
        if (points.length >= n) break;
    }
    
    // Fill remaining with slight perturbations
    while (points.length < n) {
        const idx = Math.floor(Math.random() * Math.min(points.length, 1000));
        points.push([
            points[idx][0] + (Math.random() - 0.5) * scale * 0.03,
            points[idx][1] + (Math.random() - 0.5) * scale * 0.03
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * NAUTILUS SHELL (Logarithmic Spiral)
 * 
 * CRR Interpretation: Growth that maintains proportion - each chamber
 * is a scaled version of the last. This is SELF-SIMILAR coherence:
 * the pattern at each scale reflects the whole.
 * 
 * The logarithmic spiral is the only curve that maintains constant
 * angle to radial lines - constant coherence relationship with center.
 */
function generateNautilusShell(n, scale) {
    const points = [];
    const a = 0.17; // Growth rate
    const turns = 3;
    
    // Multiple spiral arms with chambers
    for (let arm = 0; arm < 3; arm++) {
        const armOffset = (arm / 3) * Math.PI * 0.3;
        const armPoints = Math.floor(n / 3);
        
        for (let i = 0; i < armPoints; i++) {
            const t = (i / armPoints) * turns * Math.PI * 2 + armOffset;
            const r = scale * 0.15 * Math.exp(a * t);
            
            // Add chamber structure (thickness varies with radius)
            const thickness = r * 0.15;
            const offset = (Math.random() - 0.5) * thickness;
            
            const px = Math.cos(t) * (r + offset);
            const py = Math.sin(t) * (r + offset);
            
            if (px * px + py * py < scale * scale * 1.5) {
                points.push([px, py]);
            }
        }
    }
    
    // Fill to n
    while (points.length < n) {
        const t = Math.random() * turns * Math.PI * 2;
        const r = scale * 0.15 * Math.exp(a * t);
        const thickness = r * 0.1;
        points.push([
            Math.cos(t) * r + (Math.random() - 0.5) * thickness,
            Math.sin(t) * r + (Math.random() - 0.5) * thickness
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * TREE OF LIFE (Kabbalah)
 * 
 * CRR Interpretation: 10 sephiroth (coherence nodes) connected by
 * 22 paths. Represents hierarchical coherence from unity (Kether)
 * through differentiation to manifestation (Malkuth).
 * 
 * The three pillars represent: Mercy (expansion), Severity (contraction),
 * and the Middle Pillar (balance) - the CRR dynamics of growth, pruning,
 * and integration.
 */
function generateTreeOfLife(n, scale) {
    const points = [];
    
    // 10 Sephiroth positions (traditional layout)
    const sephiroth = [
        [0, -1.2],      // 1. Kether (Crown)
        [-0.5, -0.8],   // 2. Chokmah (Wisdom)
        [0.5, -0.8],    // 3. Binah (Understanding)
        [-0.5, -0.3],   // 4. Chesed (Mercy)
        [0.5, -0.3],    // 5. Geburah (Severity)
        [0, 0],         // 6. Tiphareth (Beauty)
        [-0.5, 0.4],    // 7. Netzach (Victory)
        [0.5, 0.4],     // 8. Hod (Splendor)
        [0, 0.7],       // 9. Yesod (Foundation)
        [0, 1.1]        // 10. Malkuth (Kingdom)
    ].map(([x, y]) => [x * scale * 0.8, y * scale * 0.8]);
    
    // 22 Paths (connecting sephiroth)
    const paths = [
        [0,1], [0,2], [1,2], [1,3], [2,4], [1,5], [2,5], [3,4],
        [3,5], [4,5], [3,6], [4,7], [5,6], [5,7], [5,8], [6,7],
        [6,8], [7,8], [6,9], [7,9], [8,9], [9,9] // 9,9 is Malkuth circle
    ];
    
    const pointsPerSephirah = Math.floor(n * 0.4 / 10);
    const pointsPerPath = Math.floor(n * 0.6 / paths.length);
    
    // Draw sephiroth (circles)
    for (const [sx, sy] of sephiroth) {
        const radius = scale * 0.12;
        for (let i = 0; i < pointsPerSephirah; i++) {
            const a = (i / pointsPerSephirah) * Math.PI * 2;
            const r = radius * (0.8 + Math.random() * 0.2);
            points.push([sx + Math.cos(a) * r, sy + Math.sin(a) * r]);
        }
    }
    
    // Draw paths
    for (const [from, to] of paths) {
        if (from === to) continue; // Skip self-loops
        const [x1, y1] = sephiroth[from];
        const [x2, y2] = sephiroth[to];
        
        for (let i = 0; i < pointsPerPath; i++) {
            const t = i / pointsPerPath;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * YIN YANG (Taijitu)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Two complementary coherence fields, each containing the SEED of the other.
 * This is DUAL COHERENCE - patterns that define each other through boundary.
 * 
 * In CRR terms:
 * - YIN: Receptive, dark, contracting - LOW Ω (form, structure, memory)
 * - YANG: Active, light, expanding - HIGH Ω (energy, transformation, flux)
 * 
 * The S-curve boundary is the INTERFACE where C → δ → R happens continuously.
 * At any point on the boundary, yin is becoming yang or yang is becoming yin.
 * 
 * THE DOTS ARE CRUCIAL: Each half contains a seed of the other. This means:
 * - Maximum yang contains nascent yin (rupture within coherence)
 * - Maximum yin contains nascent yang (regeneration within form)
 * - There is no pure yin or pure yang - polarity implies complementarity
 * 
 * In CRR: exp(C_yin/Ω) and exp(C_yang/Ω) are never zero - each is always
 * present in the regeneration weighting. The dots represent this irreducible
 * presence of the complement within the dominant mode.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * The Taijitu (supreme ultimate diagram) comes from Chinese philosophy
 * spanning Taoism, Confucianism, and Chinese Buddhism. It represents:
 * 
 * NOT OPPOSITION BUT EMBRACE:
 * Yin and yang are not enemies. They are partners in an eternal dance.
 * Dark doesn't fight light; it enables light to be seen.
 * Stillness doesn't oppose movement; it is where movement rests and is born.
 * 
 * THE SEEDS (DOTS):
 * "In the deepest yin, the yang is born. In the fullest yang, yin seeds."
 * At maximum coherence of one polarity, the other begins to emerge. This is:
 * - Midnight births the coming dawn
 * - Summer solstice begins winter's approach  
 * - Full inbreath initiates outbreath
 * - Maximum structure enables transformation
 * - Maximum chaos enables new pattern
 * 
 * THE S-CURVE:
 * The boundary is not straight (pure opposition) but curved (dynamic dance).
 * Each side hugs the other, makes space for the other, is defined BY the other.
 * 
 * WU WEI (effortless action):
 * = Moving along the S-curve, following the natural gradient between coherences
 * rather than forcing straight lines through the field.
 * 
 * In CRR terms: The Yin Yang IS the C → δ → R cycle visualized from above.
 * Coherence (one half) → Rupture (crossing the S) → Regeneration (other half).
 * The whole symbol is ONE PROCESS seen as if frozen in time.
 * The seeds ensure the process never stops - each completion seeds the next.
 */
function generateYinYang(n, scale) {
    const points = [];
    
    // Outer circle - the boundary of the Tao, containing all
    const outerPoints = Math.floor(n * 0.10);
    for (let i = 0; i < outerPoints; i++) {
        const a = (i / outerPoints) * Math.PI * 2;
        points.push([Math.cos(a) * scale, Math.sin(a) * scale]);
    }
    
    // === THE PROPER S-CURVE ===
    // The Yin Yang S-curve is NOT a sine wave - it's TWO SEMICIRCLES:
    // - Upper semicircle: center at (0, +scale/2), radius = scale/2, curving RIGHT
    // - Lower semicircle: center at (0, -scale/2), radius = scale/2, curving LEFT
    // This creates the characteristic "embracing" S shape
    
    const curvePoints = Math.floor(n * 0.12);
    const halfCurve = Math.floor(curvePoints / 2);
    
    // Upper semicircle (yang bulge into yin territory) - curves to the RIGHT
    for (let i = 0; i < halfCurve; i++) {
        const t = (i / halfCurve) * Math.PI; // 0 to π
        const x = Math.sin(t) * scale * 0.5;  // Bulges right (positive x)
        const y = scale * 0.5 - Math.cos(t) * scale * 0.5; // From y=0 to y=scale
        points.push([x, y]);
    }
    
    // Lower semicircle (yin bulge into yang territory) - curves to the LEFT
    for (let i = 0; i < halfCurve; i++) {
        const t = (i / halfCurve) * Math.PI; // 0 to π
        const x = -Math.sin(t) * scale * 0.5;  // Bulges left (negative x)
        const y = -scale * 0.5 + Math.cos(t) * scale * 0.5; // From y=0 to y=-scale
        points.push([x, y]);
    }
    
    // Yang half (light, active, expanding) - RIGHT side, respecting S-curve
    const halfPoints = Math.floor(n * 0.23);
    for (let i = 0; i < halfPoints; i++) {
        const y = (Math.random() * 2 - 1) * scale * 0.95;
        
        // Calculate S-curve boundary at this y value
        let curveX;
        if (y >= 0) {
            // Upper half: semicircle centered at (0, scale/2)
            const dy = y - scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? Math.sqrt(rSq) : 0;
        } else {
            // Lower half: semicircle centered at (0, -scale/2)
            const dy = y + scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? -Math.sqrt(rSq) : 0;
        }
        
        // Yang is to the RIGHT of the S-curve
        const xMin = curveX;
        const xMax = Math.sqrt(Math.max(0, scale * scale - y * y));
        if (xMax > xMin) {
            const x = xMin + Math.random() * (xMax - xMin);
            points.push([x, y]);
        }
    }
    
    // Yin half (dark, receptive, contracting) - LEFT side, respecting S-curve
    for (let i = 0; i < halfPoints; i++) {
        const y = (Math.random() * 2 - 1) * scale * 0.95;
        
        // Calculate S-curve boundary at this y value
        let curveX;
        if (y >= 0) {
            const dy = y - scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? Math.sqrt(rSq) : 0;
        } else {
            const dy = y + scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? -Math.sqrt(rSq) : 0;
        }
        
        // Yin is to the LEFT of the S-curve
        const xMax = curveX;
        const xMin = -Math.sqrt(Math.max(0, scale * scale - y * y));
        if (xMax > xMin) {
            const x = xMin + Math.random() * (xMax - xMin);
            points.push([x, y]);
        }
    }
    
    // === THE SEEDS (DOTS) ===
    // Yang seed within yin (upper dot) and Yin seed within yang (lower dot)
    // These should GLOW with concentrated coherence
    
    const seedPoints = Math.floor(n * 0.16);
    
    // Yang seed (light in dark) - at y = +scale*0.5 (center of upper semicircle)
    for (let i = 0; i < seedPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.pow(Math.random(), 0.5) * scale * 0.17;
        points.push([Math.cos(a) * r, scale * 0.5 + Math.sin(a) * r]);
    }
    
    // Yin seed (dark in light) - at y = -scale*0.5 (center of lower semicircle)
    for (let i = 0; i < seedPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.pow(Math.random(), 0.5) * scale * 0.17;
        points.push([Math.cos(a) * r, -scale * 0.5 + Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * OUROBOROS
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * The serpent eating its own tail - END FEEDS BEGINNING. This is the CRR
 * cycle itself visualized: Coherence → Rupture → Regeneration → Coherence...
 * 
 * In CRR terms:
 * - The BODY is coherence C(x,t) - accumulated pattern, integrated history
 * - The MOUTH is rupture δ(now) - consuming, breaking down, the present
 * - The TAIL is regeneration R - what is consumed becomes new body
 * 
 * There is no beginning and no end. The "oldest" part (tail) is continuously
 * becoming the "newest" part (nourishment for growth). exp(C/Ω) weighting
 * means the WHOLE history is present in each moment of consumption.
 * 
 * The mouth-tail junction is where past meets future - the eternal NOW
 * where accumulated coherence transforms into fresh possibility.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * The Ouroboros appears across civilizations:
 * - Ancient Egypt (~1600 BCE): Earliest known depiction
 * - Ancient Greece: Plato's self-sufficient cosmos
 * - Norse: Jörmungandr, world serpent holding reality together
 * - Gnosticism: The cycle of creation and return
 * - Alchemy: Symbol of the opus, the Great Work
 * - Kundalini: Coiled serpent energy at spine's base
 * 
 * It represents:
 * - ETERNAL RETURN: Everything that has been will be again
 * - SELF-SUFFICIENCY: The cosmos needs nothing outside itself
 * - UNITY OF OPPOSITES: Death IS food for life, end IS beginning
 * - THE GREAT RECYCLING: Matter, energy, form - all transformed, nothing lost
 * - SELF-CREATION: The universe creates itself from itself
 * 
 * In alchemy: "Solve et Coagula" - dissolve and coagulate - the serpent
 * dissolves its tail (solve) and coagulates it as body (coagula). Forever.
 * 
 * In Hinduism: Ananta Shesha, the infinite serpent on which Vishnu rests,
 * representing the endless cycle of creation, preservation, destruction.
 * 
 * In CRR terms: The Ouroboros IS the C → δ → R formula made flesh.
 * What we call "death" is rupture. What we call "life" is coherence.
 * What we call "rebirth" is regeneration. The serpent shows these are one.
 * 
 * The MOMENT OF EATING (where mouth meets tail) is δ(now) - the perpetual
 * present where past becomes future, where accumulated pattern transforms
 * into new possibility, where coherence ruptures into regeneration.
 * 
 * "My end is my beginning" - this is the serpent's teaching.
 */
function generateOuroboros(n, scale) {
    const points = [];
    
    // Main ring (serpent body)
    const ringPoints = Math.floor(n * 0.7);
    const bodyWidth = scale * 0.15;
    
    for (let i = 0; i < ringPoints; i++) {
        const t = (i / ringPoints) * Math.PI * 2;
        const r = scale * 0.7;
        
        // Body thickness varies (thinner at tail, wider at head)
        const progress = i / ringPoints;
        const width = bodyWidth * (0.5 + progress * 0.8);
        
        // Offset from center ring
        const offset = (Math.random() - 0.5) * width;
        
        points.push([
            Math.cos(t) * (r + offset),
            Math.sin(t) * (r + offset)
        ]);
    }
    
    // Head (eating the tail)
    const headPoints = Math.floor(n * 0.2);
    const headAngle = 0;
    const headX = Math.cos(headAngle) * scale * 0.7;
    const headY = Math.sin(headAngle) * scale * 0.7;
    
    for (let i = 0; i < headPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.2;
        points.push([headX + Math.cos(a) * r, headY + Math.sin(a) * r]);
    }
    
    // Scales/texture
    const scalePoints = n - points.length;
    for (let i = 0; i < scalePoints; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = scale * 0.7 + (Math.random() - 0.5) * bodyWidth * 0.5;
        points.push([Math.cos(t) * r, Math.sin(t) * r]);
    }
    
    return points.slice(0, n);
}

// ============================================================================
// GEOMETRY ACTIVATION
// ============================================================================

/**
 * Set active geometry attractor
 * 
 * CRR Mechanism: When geometry changes, we:
 * 1. Generate target positions for each particle
 * 2. Shuffle assignment (so particles don't all go to same spot)
 * 3. Reduce coherence (partial rupture - system must regenerate into new form)
 * 
 * Particles then regenerate toward targets weighted by exp(C/Ω).
 * High-coherence particles lead, pulling others through the coherence field.
 */
function setGeometry(shapeIndex) {
    currentShape = shapeIndex;
    const scale = Math.min(W, H) * 0.35;
    
    let points;
    switch(shapeIndex) {
        case 0: points = generateFlowerOfLife(N, scale); break;
        case 1: points = generateTorus(N, scale * 0.8, scale * 0.3); break;
        case 2: points = generateFibonacciSpiral(N, scale); break;
        case 3: points = generateMetatronsCube(N, scale); break;
        case 4: points = generateDoubleHelix(N, scale); break;
        case 5: points = generateLemniscate(N, scale); break;
        case 6: points = generateVesicaPiscis(N, scale * 0.8); break;
        case 7: points = generateSriYantra(N, scale); break;
        case 8: points = generateLorenzAttractor(N, scale); break;
        case 9: points = generateKleinBottle(N, scale); break;
        case 10: points = generateHopfFibration(N, scale); break;
        case 11: points = generatePenroseTiling(N, scale); break;
        case 12: points = generateNautilusShell(N, scale); break;
        case 13: points = generateTreeOfLife(N, scale); break;
        case 14: points = generateYinYang(N, scale * 0.9); break;
        case 15: points = generateOuroboros(N, scale * 0.9); break;
        default: points = generateFibonacciSpiral(N, scale);
    }
    
    // Shuffle indices for organic assignment
    const indices = Array.from({length: N}, (_, i) => i);
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    
    // Assign targets and induce partial rupture
    for (let i = 0; i < N; i++) {
        const pi = indices[i] % points.length;
        targetX[i] = cx + points[pi][0];
        targetY[i] = cy + points[pi][1];
        hasTarget[i] = 1;
        
        // Partial rupture: reduce coherence to initiate regeneration toward new form
        // Lower coherence = system must rebuild, but retains some history
        coherence[i] *= 0.65;
    }
    
    // Update UI
    document.getElementById('shape').innerHTML = 
        shapes[shapeIndex].name + 
        '<small>' + shapes[shapeIndex].desc + '</small>';
}

/**
 * Release geometry - return to free murmuration
 * 
 * CRR Mechanism: Remove attractor, let system find its own coherence.
 * The flock will naturally organize through neighbour alignment.
 */
function releaseGeometry() {
    currentShape = -1;
    hasTarget.fill(0);
    document.getElementById('shape').innerHTML = 
        'Free Flow<small>Pure CRR flocking dynamics</small>';
}

// ============================================================================
// INITIALIZATION
// ============================================================================

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
    cy = H / 2;
    gl.viewport(0, 0, W, H);
    
    gridW = Math.ceil(W / CELL) + 2;
    gridH = Math.ceil(H / CELL) + 2;
    grid = new Int32Array(gridW * gridH * MAX_PER_CELL);
    gridCounts = new Int32Array(gridW * gridH);
}

function init() {
    // Initialize particles in gentle spiral
    for (let i = 0; i < N; i++) {
        const t = (i / N) * Math.PI * 6;
        const r = (i / N) * Math.min(W, H) * 0.3;
        x[i] = cx + Math.cos(t) * r + (Math.random() - 0.5) * 50;
        y[i] = cy + Math.sin(t) * r + (Math.random() - 0.5) * 50;
        
        const va = t + Math.PI / 2;
        const sp = 1 + Math.random() * 1.5;
        vx[i] = Math.cos(va) * sp;
        vy[i] = Math.sin(va) * sp;
        
        coherence[i] = 0.3 + Math.random() * 0.4;
        phase[i] = Math.random() * Math.PI * 2;
        hasTarget[i] = 0;
    }
    
    currentShape = -1;
    document.getElementById('shape').innerHTML = 
        'Click to Summon Form<small>CRR Geometric Murmuration</small>';
}

// ============================================================================
// SPATIAL PARTITIONING
// ============================================================================

function buildGrid() {
    gridCounts.fill(0);
    
    for (let i = 0; i < N; i++) {
        const gx = Math.floor(x[i] / CELL) + 1;
        const gy = Math.floor(y[i] / CELL) + 1;
        
        if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
            const idx = gy * gridW + gx;
            const count = gridCounts[idx];
            if (count < MAX_PER_CELL) {
                grid[idx * MAX_PER_CELL + count] = i;
                gridCounts[idx] = count + 1;
            }
        }
    }
}

// ============================================================================
// MAIN UPDATE LOOP - CRR DYNAMICS
// ============================================================================

function update() {
    time += 0.016;
    buildGrid();
    
    // Gentle environmental wind
    windAngle += (Math.sin(time * 0.08) * 0.4 - windAngle) * 0.008;
    const windX = Math.cos(windAngle) * 0.25;
    const windY = Math.sin(windAngle) * 0.25;
    
    let totalCoherence = 0;
    
    for (let i = 0; i < N; i++) {
        const px = x[i], py = y[i];
        const pvx = vx[i], pvy = vy[i];
        
        const gx = Math.floor(px / CELL) + 1;
        const gy = Math.floor(py / CELL) + 1;
        
        // ================================================================
        // NEIGHBOUR SEARCH (Topological - based on proximity, not count)
        // ================================================================
        
        let sumVx = 0, sumVy = 0;
        let sepX = 0, sepY = 0;
        let cohX = 0, cohY = 0;
        let nCount = 0;
        let totalCohWeight = 0;
        let weightedVx = 0, weightedVy = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const cxi = gx + dx;
                const cyi = gy + dy;
                if (cxi < 0 || cxi >= gridW || cyi < 0 || cyi >= gridH) continue;
                
                const cellIdx = cyi * gridW + cxi;
                const count = gridCounts[cellIdx];
                const step = count > 6 ? Math.floor(count / 6) : 1;
                
                for (let k = 0; k < count; k += step) {
                    const j = grid[cellIdx * MAX_PER_CELL + k];
                    if (j === i) continue;
                    
                    const ddx = x[j] - px;
                    const ddy = y[j] - py;
                    const d2 = ddx * ddx + ddy * ddy;
                    
                    if (d2 < 2500 && d2 > 0) { // 50² perception radius
                        const d = Math.sqrt(d2);
                        nCount++;
                        sumVx += vx[j];
                        sumVy += vy[j];
                        cohX += x[j];
                        cohY += y[j];
                        
                        // Separation (avoid crowding)
                        if (d2 < 200) { // ~14² separation radius
                            const f = (14 - d) / 14;
                            sepX -= ddx / d * f;
                            sepY -= ddy / d * f;
                        }
                        
                        // ========================================
                        // CRR REGENERATION WEIGHTING: w_j = exp(C_j/Ω)
                        // ========================================
                        // This is the CORE CRR mechanism for regeneration:
                        //
                        //   w_j = exp(C_j / Ω)
                        //   v⃗_regen = Σ(w_j × v⃗_j) / Σ(w_j)
                        //
                        // Neighbours with higher coherence have EXPONENTIALLY
                        // more influence on this particle's regeneration.
                        //
                        // The Ω parameter controls the sharpness:
                        //   Ω = 0.10 (low)  → exp(0.8/0.1)/exp(0.2/0.1) ≈ 403×
                        //   Ω = 0.50 (high) → exp(0.8/0.5)/exp(0.2/0.5) ≈ 3.3×
                        //
                        // Low Ω = only highest-C neighbours matter (RIGID)
                        // High Ω = all neighbours contribute equally (FLUID)
                        //
                        // This is how CRR creates coherence basins:
                        // aligned particles reinforce each other exponentially.
                        
                        const w = Math.exp(coherence[j] / OMEGA);
                        totalCohWeight += w;
                        weightedVx += vx[j] * w;
                        weightedVy += vy[j] * w;
                    }
                }
            }
        }
        
        // ================================================================
        // CRR COHERENCE ACCUMULATION: C(t) = ∫L(x,τ)dτ
        // ================================================================
        // The continuous integral is approximated as exponential moving average:
        //
        //   C(t) = C(t-1) × DECAY + L(t) × (1 - DECAY)
        //
        // Where L(x,t) is the LOCAL ALIGNMENT measure:
        //
        //   L = (v⃗_self · v⃗_neighbours) / (|v⃗_self| × |v⃗_neighbours|)
        //
        // This dot product ∈ [-1, 1], mapped to [0, 1]:
        //   L = 1 when perfectly aligned (moving same direction)
        //   L = 0 when perpendicular
        //   L = 0 (mapped from -1) when opposite
        //
        // DECAY parameter controls memory length:
        //   DECAY = 0.99 → long memory, ~100 frame half-life
        //   DECAY = 0.90 → short memory, ~7 frame half-life
        //   Half-life = ln(0.5) / ln(DECAY)
        
        if (nCount > 0) {
            const speed = Math.sqrt(pvx * pvx + pvy * pvy) + 0.001;
            const avgVx = sumVx / nCount;
            const avgVy = sumVy / nCount;
            const avgSpeed = Math.sqrt(avgVx * avgVx + avgVy * avgVy) + 0.001;
            
            // L(x,t) = normalized dot product, mapped to [0,1]
            const dot = (pvx * avgVx + pvy * avgVy) / (speed * avgSpeed);
            const alignment = (dot + 1) * 0.5;
            
            // Coherence accumulation (temporal integration)
            coherence[i] = coherence[i] * DECAY + alignment * (1 - DECAY);
        }
        
        totalCoherence += coherence[i];
        
        // ================================================================
        // FORCE CALCULATION
        // ================================================================
        
        let ax = 0, ay = 0;
        
        // ================================================================
        // CRR GEOMETRIC REGENERATION: F = α·exp(C/Ω)·(target - pos)/|d|
        // ================================================================
        // This is the CRR regeneration equation applied to geometry:
        //
        //   F_attract = FORM_ATTRACTION × exp(C_i / Ω) × (target_i - pos_i) / d
        //
        // Where:
        //   C_i = this particle's accumulated coherence (from alignment history)
        //   Ω = rupture threshold (slider: low=rigid, high=fluid)
        //   exp(C/Ω) = memory weighting - HIGH coherence → STRONGER attraction
        //
        // This is WHY high-coherence particles arrive at the geometry first:
        // exp(0.8/0.1) ≈ 2981 vs exp(0.3/0.1) ≈ 20
        // A coherent particle feels ~150× more pull than an incoherent one!
        //
        // The geometry becomes self-stabilizing: particles that arrive and
        // align with neighbours INCREASE their C, which INCREASES their
        // attraction, which STABILIZES their position. CRR solves geometry.
        
        if (hasTarget[i]) {
            const dx = targetX[i] - px;
            const dy = targetY[i] - py;
            const d = Math.sqrt(dx * dx + dy * dy) + 0.001;
            
            // exp(C/Ω) weighted attraction - this IS the regeneration term
            const pull = FORM_ATTRACTION * Math.exp(coherence[i] / OMEGA) * 0.012;
            
            // Smooth arrival (stronger when far, gentler when close)
            const distFactor = Math.min(d * 0.008, 1);
            
            ax += dx / d * pull * distFactor;
            ay += dy / d * pull * distFactor;
            
            // Reward coherence near target (stabilizes form)
            if (d < 25) {
                coherence[i] = Math.min(1, coherence[i] + 0.003);
            }
        }
        
        // ================================================================
        // FLOCKING FORCES (also CRR-weighted)
        // ================================================================
        
        if (nCount > 0) {
            // Cohesion - move toward neighbour center
            cohX /= nCount;
            cohY /= nCount;
            ax += (cohX - px) * 0.005;
            ay += (cohY - py) * 0.005;
            
            // CRR-weighted alignment (regeneration toward coherent neighbours)
            if (totalCohWeight > 0) {
                weightedVx /= totalCohWeight;
                weightedVy /= totalCohWeight;
                ax += (weightedVx - pvx) * 0.03;
                ay += (weightedVy - pvy) * 0.03;
            }
            
            // Separation
            ax += sepX * 0.06;
            ay += sepY * 0.06;
        }
        
        // Wind (reduced when following geometry)
        const windFactor = hasTarget[i] ? 0.008 : 0.02;
        ax += windX * windFactor;
        ay += windY * windFactor;
        
        // Boundaries (soft repulsion)
        const margin = 50;
        if (px < margin) ax += (margin - px) * 0.0015;
        if (px > W - margin) ax -= (px - (W - margin)) * 0.0015;
        if (py < margin) ay += (margin - py) * 0.0015;
        if (py > H - margin) ay -= (py - (H - margin)) * 0.0015;
        
        // Individual wander (prevents crystallization)
        ax += Math.sin(time * 1.3 + phase[i]) * 0.006;
        ay += Math.cos(time * 1.5 + phase[i]) * 0.006;
        
        // ================================================================
        // VELOCITY UPDATE
        // ================================================================
        
        let nvx = pvx + ax;
        let nvy = pvy + ay;
        
        // Speed limits
        let sp = Math.sqrt(nvx * nvx + nvy * nvy);
        const maxSpeed = hasTarget[i] ? 5 : 3.5;
        if (sp > maxSpeed) { nvx = nvx / sp * maxSpeed; nvy = nvy / sp * maxSpeed; }
        if (sp < 0.4) { nvx = nvx / (sp + 0.001) * 0.4; nvy = nvy / (sp + 0.001) * 0.4; }
        
        vx[i] = nvx;
        vy[i] = nvy;
        x[i] = px + nvx;
        y[i] = py + nvy;
        
        // Wrap at boundaries
        if (x[i] < -10) x[i] += W + 20;
        if (x[i] > W + 10) x[i] -= W + 20;
        if (y[i] < -10) y[i] += H + 20;
        if (y[i] > H + 10) y[i] -= H + 20;
        
        // Evolve visual phase (iridescence)
        phase[i] += 0.006 + coherence[i] * 0.012;
    }
    
    // Update average coherence display
    if (Math.floor(time * 60) % 30 === 0) {
        document.getElementById('avgC').textContent = (totalCoherence / N).toFixed(3);
    }
}

// ============================================================================
// WEBGL RENDERING
// ============================================================================

const vsrc = `
attribute vec2 a_pos;
attribute float a_coh;
attribute float a_phase;

uniform vec2 u_res;
uniform float u_time;
uniform float u_irid;

varying float v_coh;
varying float v_hue;
varying float v_alpha;

void main() {
    vec2 p = (a_pos / u_res) * 2.0 - 1.0;
    p.y *= -1.0;
    gl_Position = vec4(p, 0.0, 1.0);
    
    // Size scales with coherence (high C = larger, more visible)
    gl_PointSize = 1.6 + a_coh * 2.0;
    
    v_coh = a_coh;
    
    // Iridescent color: base hue shifts with coherence, phase, and position
    // High coherence = blue-violet, low coherence = cyan-green
    float baseHue = 0.52 + a_coh * 0.15;
    float phaseShift = sin(a_phase + u_time * 0.25) * 0.1 * u_irid;
    float posShift = (p.x * 0.35 + p.y * 0.2) * 0.08 * u_irid;
    v_hue = baseHue + phaseShift + posShift;
    
    // Alpha also scales with coherence (coherent particles glow brighter)
    v_alpha = 0.18 + a_coh * 0.55;
}`;

const fsrc = `
precision mediump float;
varying float v_coh;
varying float v_hue;
varying float v_alpha;

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    // Soft circular point
    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
    float r = dot(cxy, cxy);
    if (r > 1.0) discard;
    
    float soft = 1.0 - sqrt(r);
    
    // Saturation and value based on coherence
    float sat = 0.3 + v_coh * 0.5;
    float val = 0.75 + v_coh * 0.25;
    
    vec3 rgb = hsv2rgb(vec3(v_hue, sat, val));
    
    // Bright core for sparkle effect
    rgb = mix(rgb, vec3(1.0), smoothstep(0.5, 0.0, r) * 0.3 * v_coh);
    
    gl_FragColor = vec4(rgb, v_alpha * soft);
}`;

let program, posBuffer, cohBuffer, phaseBuffer;
let posLoc, cohLoc, phaseLoc, resLoc, timeLoc, iridLoc;

function initGL() {
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsrc);
    gl.compileShader(vs);
    
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsrc);
    gl.compileShader(fs);
    
    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);
    
    posLoc = gl.getAttribLocation(program, 'a_pos');
    cohLoc = gl.getAttribLocation(program, 'a_coh');
    phaseLoc = gl.getAttribLocation(program, 'a_phase');
    resLoc = gl.getUniformLocation(program, 'u_res');
    timeLoc = gl.getUniformLocation(program, 'u_time');
    iridLoc = gl.getUniformLocation(program, 'u_irid');
    
    posBuffer = gl.createBuffer();
    cohBuffer = gl.createBuffer();
    phaseBuffer = gl.createBuffer();
    
    // Additive blending for ethereal glow
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
}

const posData = new Float32Array(N * 2);

function render() {
    gl.clearColor(0.006, 0.006, 0.018, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.uniform2f(resLoc, W, H);
    gl.uniform1f(timeLoc, time);
    gl.uniform1f(iridLoc, IRIDESCENCE);
    
    // Pack position data
    for (let i = 0; i < N; i++) {
        posData[i * 2] = x[i];
        posData[i * 2 + 1] = y[i];
    }
    
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, cohBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, coherence, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(cohLoc);
    gl.vertexAttribPointer(cohLoc, 1, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, phaseBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, phase, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(phaseLoc);
    gl.vertexAttribPointer(phaseLoc, 1, gl.FLOAT, false, 0, 0);
    
    gl.drawArrays(gl.POINTS, 0, N);
}

// ============================================================================
// MAIN LOOP
// ============================================================================

let fpsCounter = 0;
let fpsTime = performance.now();

function loop() {
    fpsCounter++;
    const now = performance.now();
    if (now - fpsTime > 1000) {
        document.getElementById('fps').textContent = fpsCounter;
        fpsCounter = 0;
        fpsTime = now;
    }
    
    update();
    render();
    requestAnimationFrame(loop);
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

window.addEventListener('resize', resize);

canvas.addEventListener('click', () => {
    currentShape = (currentShape + 1) % shapes.length;
    setGeometry(currentShape);
});

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    currentShape = (currentShape + 1) % shapes.length;
    setGeometry(currentShape);
});

document.getElementById('omega').oninput = e => {
    OMEGA = parseFloat(e.target.value);
    document.getElementById('v-omega').textContent = OMEGA.toFixed(2);
};

document.getElementById('form').oninput = e => {
    FORM_ATTRACTION = parseFloat(e.target.value);
    document.getElementById('v-form').textContent = FORM_ATTRACTION.toFixed(1);
};

document.getElementById('decay').oninput = e => {
    DECAY = parseFloat(e.target.value);
    document.getElementById('v-decay').textContent = DECAY.toFixed(2);
};

document.getElementById('irid').oninput = e => {
    IRIDESCENCE = parseFloat(e.target.value);
    document.getElementById('v-irid').textContent = IRIDESCENCE.toFixed(1);
};

document.getElementById('release').onclick = releaseGeometry;
document.getElementById('reset').onclick = init;

// ============================================================================
// START
// ============================================================================

resize();
initGL();
init();
loop();

/**
 * ============================================================================
 * END OF CRR GEOMETRIC MURMURATION
 * ============================================================================
 * 
 * This code demonstrates how the Coherence-Rupture-Regeneration framework
 * provides a unified approach to:
 * 
 * 1. FLOCKING: Particles align through coherence accumulation
 * 2. GEOMETRY: Shapes emerge from coherence-weighted regeneration
 * 3. TRANSFORMATION: Form changes occur via partial rupture + regeneration
 * 
 * The key insight is that geometry isn't imposed - it's discovered through
 * temporal integration of coherence relationships. The exp(C/Ω) weighting
 * ensures that high-coherence particles lead formation, creating organic
 * emergence rather than mechanical positioning.
 * 
 * For more on CRR and its applications across physics, biology, and
 * consciousness studies, see: cohere.org.uk
 * 
 * Framework by Alexander Sabine
 * Active Inference Institute Board Member (2026)
 * 
 * Key CRR equations:
 *   C(x,t) = ∫L(x,τ)dτ           -- Coherence accumulates through alignment
 *   δ(now)                        -- Rupture at scale-invariant choice moments
 *   R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ  -- Regeneration weighted by coherence history
 * 
 * The Ω-symmetry discovery:
 *   Z₂ systems: Ω = 1/π ≈ 0.318
 *   SO(2) systems: Ω = 1/2π ≈ 0.159
 *   CV = Ω/2 matches empirical data to ~1%
 * 
 * ============================================================================
 */
</script>
</body>
</html>
