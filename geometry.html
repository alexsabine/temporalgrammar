<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Sacred Geometry - temporalgrammar.ai</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        
        #ui {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: rgba(255,255,255,0.7);
            font-family: system-ui, sans-serif;
            font-size: 11px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            width: 220px;
        }
        
        #ui h3 { 
            color: rgba(255,255,255,0.9); 
            margin-bottom: 12px;
            font-weight: 400;
            font-size: 13px;
            letter-spacing: 1px;
        }
        
        .row { margin-bottom: 10px; }
        .row label { 
            display: block; 
            font-size: 9px; 
            color: rgba(255,255,255,0.5); 
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 2px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: rgba(180,220,255,0.8);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .val { float: right; color: rgba(180,220,255,0.8); }
        
        #stats {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 10px;
            color: rgba(255,255,255,0.5);
            font-family: system-ui, sans-serif;
            font-size: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #stats span { color: rgba(180,220,255,0.9); }
        
        #shape {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 12px 25px;
            border-radius: 20px;
            color: rgba(255,255,255,0.9);
            font-family: system-ui, sans-serif;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.15);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-align: center;
            min-width: 280px;
        }
        
        #shape small {
            display: block;
            font-size: 9px;
            color: rgba(180,220,255,0.7);
            margin-top: 5px;
            letter-spacing: 1px;
        }
        
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.8);
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            margin-right: 5px;
            margin-top: 8px;
        }
        
        button:hover { background: rgba(255,255,255,0.2); }
        
        #shape-select {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.9);
            padding: 6px 8px;
            border-radius: 5px;
            font-size: 10px;
            margin-top: 8px;
            cursor: pointer;
        }
        
        #shape-select option {
            background: #1a1a2e;
            color: rgba(255,255,255,0.9);
        }
        
        #info {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 12px 15px;
            border-radius: 10px;
            color: rgba(255,255,255,0.6);
            font-family: system-ui, sans-serif;
            font-size: 9px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 200px;
            line-height: 1.5;
        }
        
        #info code {
            color: rgba(180,220,255,0.9);
            font-family: monospace;
        }
        
        #theory-toggle {
            position: fixed;
            bottom: 80px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 8px;
            color: rgba(180,220,255,0.9);
            font-family: system-ui, sans-serif;
            font-size: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.15);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #theory-toggle:hover {
            background: rgba(30,30,50,0.9);
            border-color: rgba(180,220,255,0.3);
        }
        
        #theory-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(5,5,15,0.95);
            padding: 30px 40px;
            border-radius: 15px;
            color: rgba(255,255,255,0.85);
            font-family: system-ui, sans-serif;
            font-size: 13px;
            z-index: 200;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(180,220,255,0.2);
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            line-height: 1.7;
        }
        
        #theory-panel.visible {
            display: block;
        }
        
        #theory-panel h2 {
            color: rgba(180,220,255,0.95);
            font-weight: 400;
            font-size: 20px;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-align: center;
            border-bottom: 1px solid rgba(180,220,255,0.2);
            padding-bottom: 15px;
        }
        
        #theory-panel h3 {
            color: rgba(180,220,255,0.9);
            font-weight: 400;
            font-size: 14px;
            margin: 25px 0 12px 0;
            letter-spacing: 1px;
        }
        
        #theory-panel p {
            margin-bottom: 12px;
            color: rgba(255,255,255,0.75);
        }
        
        #theory-panel code {
            background: rgba(180,220,255,0.1);
            color: rgba(180,220,255,0.95);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
        }
        
        #theory-panel .equation {
            background: rgba(180,220,255,0.05);
            border-left: 2px solid rgba(180,220,255,0.3);
            padding: 12px 20px;
            margin: 15px 0;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            color: rgba(180,220,255,0.95);
        }
        
        #theory-panel .derivation {
            background: rgba(100,255,180,0.05);
            border-left: 2px solid rgba(100,255,180,0.3);
            padding: 12px 20px;
            margin: 15px 0;
        }
        
        #theory-panel .derivation-title {
            color: rgba(100,255,180,0.9);
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        #theory-panel .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s;
        }
        
        #theory-panel .close-btn:hover {
            color: rgba(255,255,255,0.9);
        }
        
        #theory-panel ul {
            margin: 10px 0 10px 20px;
            color: rgba(255,255,255,0.7);
        }
        
        #theory-panel li {
            margin-bottom: 6px;
        }
        
        #theory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 150;
            display: none;
        }
        
        #theory-overlay.visible {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    
    <div id="ui">
        <h3>✧ CRR Fields ✧</h3>
        <div class="row">
            <label>Ω (rupture threshold) <span class="val" id="v-omega">0.10</span></label>
            <input type="range" id="omega" min="0.08" max="0.6" step="0.01" value="0.10">
        </div>
        <div class="row">
            <label>Form attraction <span class="val" id="v-form">1.0</span></label>
            <input type="range" id="form" min="0" max="1" step="0.05" value="1.0">
        </div>
        <div class="row">
            <label>Coherence memory <span class="val" id="v-decay">0.99</span></label>
            <input type="range" id="decay" min="0.9" max="0.995" step="0.005" value="0.99">
        </div>
        <div class="row">
            <label>Iridescence <span class="val" id="v-irid">1.0</span></label>
            <input type="range" id="irid" min="0" max="1" step="0.05" value="1.0">
        </div>
        <button id="release">Release Form</button>
        <button id="reset">Rebirth</button>
        <div class="row" style="margin-top: 12px;">
            <label>Summon geometry</label>
            <select id="shape-select">
                <option value="-1">Free Flow</option>
            </select>
        </div>
    </div>
    
    <div id="stats">
        Souls: <span id="n">36000</span> | 
        FPS: <span id="fps">0</span> | 
        C̄: <span id="avgC">0</span>
    </div>
    
    <div id="info">
        <strong>CRR Framework</strong><br><br>
        <code>C(t) = ∫L(x,τ)dτ</code><br>
        Coherence accumulates<br><br>
        <code>δ(now)</code><br>
        Rupture at threshold<br><br>
        <code>R = exp(C/Ω)</code><br>
        Regeneration weighting
    </div>
    
    <div id="shape">
        Click to Summon Form
        <small>CRR Geometric Murmuration</small>
    </div>
    
    <div id="theory-toggle">✧ How CRR Derives Geometry ✧</div>
    
    <div id="theory-overlay"></div>
    
    <div id="theory-panel">
        <button class="close-btn">&times;</button>
        
        <h2>CRR &amp; First Principles Geometry</h2>
        
        <p>This simulation doesn't just <em>display</em> sacred geometries—it uses the Coherence-Rupture-Regeneration framework to <em>derive</em> them from CRR principles. Here's how CRR relates geometry to temporal dynamics.</p>
        
        <h3>The Core CRR Equations</h3>
        
        <div class="equation">
            C(x,t) = ∫L(x,τ)dτ &nbsp;&nbsp;&nbsp; <span style="opacity:0.6">Coherence accumulates through alignment</span><br>
            δ(now) &nbsp;&nbsp;&nbsp; <span style="opacity:0.6">Rupture at scale-invariant choice-moments</span><br>
            R = ∫φ(x,τ)exp(C/Ω)dτ &nbsp;&nbsp;&nbsp; <span style="opacity:0.6">Regeneration weighted by coherence history</span>
        </div>
        
        <h3>The Key Insight: Geometry as Coherence Basin</h3>
        
        <p>Stable geometries are configurations where coherence can accumulate without rupture. They're <strong>fixed points</strong> of CRR dynamics—shapes where the exp(C/Ω) weighting creates self-reinforcing stability.</p>
        
        <p>This suggests geometry is not arbitrary. Certain forms are <em>discovered</em> by coherence optimization:</p>
        
        <ul>
            <li><strong>Circles</strong> emerge because every point has identical local geometry—no preferred direction for rupture</li>
            <li><strong>Hexagonal packing</strong> maximizes local coherence by giving each point 6 equidistant neighbors</li>
            <li><strong>Golden spirals</strong> minimize rupture probability between successive coherence events</li>
        </ul>
        
        <h3>CRR Derivations</h3>
        
        <div class="derivation">
            <div class="derivation-title">→ Golden Angle (137.5°)</div>
            <p style="margin:0;color:rgba(255,255,255,0.7)">When placing points sequentially, what angle maximizes coherence? CRR finds: the angle that maximizes <em>minimum distance</em> between successive points minimizes rupture probability. This optimal angle is 137.5°—the golden angle. <strong>CRR derives it to within 2°.</strong></p>
        </div>
        
        <div class="derivation">
            <div class="derivation-title">→ Hexagonal Packing (Flower of Life)</div>
            <p style="margin:0;color:rgba(255,255,255,0.7)">What arrangement maximizes local coherence uniformity? CRR optimization converges to configurations where each point has 6 equidistant neighbors at 60° apart—hexagonal packing. This is why the Flower of Life appears across cultures: it's a <strong>coherence attractor</strong>.</p>
        </div>
        
        <div class="derivation">
            <div class="derivation-title">→ Circle (SO(2) Symmetry)</div>
            <p style="margin:0;color:rgba(255,255,255,0.7)">For continuous rotational symmetry (Ω = 1/2π), coherence is maximized when all points are equidistant from center. The circle emerges as the unique configuration where no angular position is privileged—<strong>pure SO(2) coherence</strong>.</p>
        </div>
        
        <h3>The Ω-Symmetry Relationship</h3>
        
        <div class="equation">
            Z₂ symmetry (binary/reflection): Ω = 1/π ≈ 0.318<br>
            SO(2) symmetry (continuous rotation): Ω = 1/2π ≈ 0.159
        </div>
        
        <p>Different symmetry classes have different Ω values. This predicts:</p>
        <ul>
            <li>Coefficient of variation CV = Ω/2</li>
            <li>Z₂ systems: CV ≈ 0.159</li>
            <li>SO(2) systems: CV ≈ 0.08</li>
        </ul>
        
        <h3>How This Simulation Works</h3>
        
        <p>Each particle carries a coherence value C that accumulates through alignment with neighbors. When a geometry is summoned:</p>
        
        <ol style="margin: 10px 0 10px 20px; color: rgba(255,255,255,0.7);">
            <li>Target positions are generated (the geometry)</li>
            <li>Coherence drops to 65% (partial rupture)</li>
            <li>Particles regenerate toward targets weighted by <code>exp(C/Ω)</code></li>
            <li>High-coherence particles lead, pulling others through the field</li>
            <li>The geometry becomes self-stabilizing as alignment increases C</li>
        </ol>
        
        <p>The shapes aren't imposed—they're <strong>coherence basins</strong> that the system naturally settles into. In this sim, sacred geometry encodes configurations where CRR dynamics achieve stable equilibrium.</p>
        
        <h3>Why These Shapes Across Cultures?</h3>
        
        <p>The Flower of Life appears in Egypt, China, India, and medieval Europe not because of cultural transmission, but because <strong>coherence optimization converges to the same solutions</strong>. These geometries are mathematical necessities—forms that any coherence-based system will discover.</p>
        
        <p style="text-align: center; margin-top: 25px; color: rgba(180,220,255,0.7); font-style: italic;">
            "Perhaps Geometry is not imposed;it is the form that emerges through the boundary :-)"
        </p>
    </div>

<!--
================================================================================
CRR GEOMETRIC MURMURATION
================================================================================

This visualization demonstrates the Coherence-Rupture-Regeneration (CRR) framework
developed by Alexander Sabine.

THE CRR FRAMEWORK:
==================

CRR provides a mathematical description of how systems maintain identity through
change, applicable across scales from quantum to social systems.

Three core equations:

1. COHERENCE ACCUMULATION: C(x,t) = ∫L(x,τ)dτ
   - L(x,τ) is the local alignment/coherence measure at position x and time τ
   - Coherence accumulates over time, creating "memory" of aligned states
   - In this simulation: L = dot product of velocity with neighbour average

2. RUPTURE: δ(now) 
   - Scale-invariant choice-moments where accumulated patterns can break
   - The Dirac delta marks ontological present moments
   - Rupture occurs when coherence patterns become unstable

3. REGENERATION: R = ∫φ(x,τ)exp(C(x,τ)/Ω)Θ(...)dτ
   - exp(C/Ω) weights history by coherence - high coherence moments dominate
   - Ω (Omega) is the rupture threshold / system "openness"
   - Low Ω = rigid (only highest coherence accessible)
   - High Ω = fluid (broader history accessible for transformation)

HOW CRR WAS USED TO SOLVE THIS GEOMETRY:
========================

Traditional particle systems use instantaneous forces. CRR instead uses
TEMPORAL INTEGRATION - particles don't just respond to current positions,
they regenerate based on coherence-weighted history.

When a geometric attractor is set:
- Each particle has a target position on the geometry
- Attraction force scales with exp(C/Ω) 
- High-coherence particles feel STRONGER pull to their targets
- This creates organic formation - aligned particles arrive first and
  pull others through the coherence field

The geometry itself becomes a coherence basin - particles that reach
their targets and align with neighbours INCREASE their coherence,
which STRENGTHENS their position in the form. The shape becomes
self-stabilizing through CRR dynamics.

KEY INSIGHT: In a temporal grammar (e.g. CRR), Geometry emerges from coherence relationships, not imposed forces.
The particles "discover" the shape through coherence-weighted regeneration.

================================================================================
CRR DERIVATIONS FOR GEOMETRIC PARAMETERS
================================================================================

Below we show how CRR principles derive the specific values used in each
sacred geometry, rather than arbitrarily choosing them.

┌─────────────────────────────────────────────────────────────────────────────┐
│  FUNDAMENTAL CRR-GEOMETRY RELATIONSHIPS                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. PARTICLE ATTRACTION TO TARGET:                                          │
│     F_attract = α · exp(C/Ω) · (target - position) / |target - position|   │
│                                                                             │
│     Where:                                                                  │
│     - α = FORM_ATTRACTION parameter                                         │
│     - C = accumulated coherence of the particle                             │
│     - Ω = rupture threshold (controls rigidity vs fluidity)                │
│     - exp(C/Ω) means HIGH coherence particles feel STRONGER attraction     │
│                                                                             │
│  2. COHERENCE ACCUMULATION:                                                 │
│     C(t+dt) = C(t) · DECAY + L(t) · (1 - DECAY)                            │
│                                                                             │
│     Where L(t) = alignment with neighbours:                                 │
│     L = (v⃗_self · v⃗_avg) / (|v⃗_self| · |v⃗_avg|)  ∈ [-1, 1]              │
│     Mapped to [0,1]: L_mapped = (L + 1) / 2                                │
│                                                                             │
│  3. REGENERATION WEIGHTING (neighbour influence):                           │
│     w_j = exp(C_j / Ω)                                                      │
│     v⃗_regenerated = Σ(w_j · v⃗_j) / Σ(w_j)                                 │
│                                                                             │
│     This means particles with higher coherence have exponentially           │
│     more influence on their neighbours' regeneration.                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  YIN YANG: CRR DERIVATION OF THE S-CURVE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  The S-curve was derived from CRR coherence dynamics:   │
│                                                                             │
│  PROBLEM: Find the boundary between two complementary coherence fields      │
│  such that each field "embraces" the other maximally.                       │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  The boundary must be where C_yin = C_yang (equal coherence).               │
│  For circular coherence fields of radius R centered at distance R apart,    │
│  this equal-coherence boundary traces TWO SEMICIRCLES:                      │
│                                                                             │
│  Upper semicircle (yang bulge into yin):                                    │
│     Center: (0, +R/2)                                                       │
│     Radius: R/2                                                             │
│     x(t) = (R/2)·sin(t)                                                     │
│     y(t) = R/2 + (R/2)·cos(t)    for t ∈ [0, π]                            │
│                                                                             │
│  Lower semicircle (yin bulge into yang):                                    │
│     Center: (0, -R/2)                                                       │
│     Radius: R/2                                                             │
│     x(t) = -(R/2)·sin(t)                                                    │
│     y(t) = -R/2 - (R/2)·cos(t)   for t ∈ [0, π]                            │
│                                                                             │
│  THE SEEDS (DOTS):                                                          │
│  Located at (0, ±R/2) - the centers of the semicircles.                    │
│  These are COHERENCE NUCLEATION POINTS - where exp(C/Ω) is maximum         │
│  for the opposite polarity. The seed is where regeneration of the          │
│  complement begins.                                                         │
│                                                                             │
│  CRR PREDICTION: Seed radius ≈ R/6 (observed in traditional Taijitu)       │
│  Derivation: At distance r from seed center, coherence decays as           │
│  C(r) ∝ exp(-r/λ). Visible seed edge where C_seed = C_background:          │
│  r_seed = λ·ln(C_max/C_bg) ≈ R/6 for typical coherence ratios.            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  FLOWER OF LIFE: CRR DERIVATION OF 6-FOLD SYMMETRY                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: What arrangement of coherence circles maximizes total coherence   │
│  while maintaining equal spacing?                                           │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Total coherence C_total = Σ C_overlap for all overlapping regions.        │
│  Overlap coherence C_overlap ∝ area of vesica between circles.             │
│                                                                             │
│  For circles of radius R, the optimal packing that maximizes overlap        │
│  while maintaining tangency is HEXAGONAL (6-fold symmetry):                 │
│                                                                             │
│     θ_n = n · (2π/6) = n · (π/3)    for n = 0,1,2,3,4,5                    │
│     Center_n = (R·cos(θ_n), R·sin(θ_n))                                    │
│                                                                             │
│  WHY 6? The angle 2π/6 = 60° creates vesica piscis overlaps where          │
│  each circle intersects its neighbours at exactly the points that          │
│  lie on the central circle. This is the MAXIMAL COHERENCE CONFIGURATION.   │
│                                                                             │
│  RING EXPANSION:                                                            │
│  Second ring at radius R√3 with 12 circles (every 30°)                     │
│  Third ring at radius 2R with 18 circles (every 20°)                       │
│  General: Ring k has 6k circles at radius R·(k·√3/2 + ...)                 │
│                                                                             │
│  This is CRR "discovering" optimal sphere packing through coherence        │
│  maximization - the same principle drives crystal formation.               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  FIBONACCI SPIRAL: CRR DERIVATION OF GOLDEN ANGLE                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Place N particles to maximize MINIMUM pairwise coherence.         │
│  (Each new particle should disrupt existing coherence minimally.)          │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Coherence between particles decays with distance: C_ij ∝ 1/d_ij           │
│  To maximize min(C_ij), maximize min(d_ij) for all pairs.                  │
│                                                                             │
│  For radial placement r_n = √n, the angle θ_n that maximizes minimum       │
│  distance to ALL previous particles is:                                     │
│                                                                             │
│     θ_n = n · φ_golden                                                      │
│                                                                             │
│  Where φ_golden = 2π(1 - 1/φ) = 2π(2 - φ) ≈ 137.507764°                   │
│  And φ = (1 + √5)/2 ≈ 1.618034 (golden ratio)                              │
│                                                                             │
│  WHY THIS ANGLE?                                                            │
│  Any rational fraction of 2π creates radial lines (gaps).                  │
│  The golden angle is maximally irrational - it never creates lines.        │
│  This is equivalent to: successive particles NEVER align, maximizing       │
│  the coherence field's uniformity.                                          │
│                                                                             │
│  CRR INTERPRETATION:                                                        │
│  The golden angle emerges from minimizing coherence RUPTURE.               │
│  Adding each new particle creates minimal disturbance to the existing      │
│  coherence field - this is the gentlest possible growth pattern.           │
│                                                                             │
│  FIBONACCI NUMBERS arise as integer approximations:                         │
│  F_n/F_{n+1} → 1/φ as n → ∞                                                │
│  (1/2, 2/3, 3/5, 5/8, 8/13, 13/21, 21/34... → 0.618...)                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  TORUS: CRR DERIVATION OF SELF-SUSTAINING FLOW                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Find a surface where coherence can flow continuously without      │
│  encountering boundaries (rupture points).                                  │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Require: ∂C/∂boundary = 0 (no coherence gradient at edges)                │
│  This means: surface must have NO EDGES.                                    │
│                                                                             │
│  Closed surfaces without boundary: sphere, torus, Klein bottle, etc.       │
│  But sphere has no THROUGH-HOLE for flow circulation.                      │
│                                                                             │
│  The TORUS is the minimal surface allowing:                                 │
│  1. No boundary (continuous)                                                │
│  2. Through-hole (enables circulation)                                      │
│  3. Two independent rotation directions (SO(2) × SO(2) symmetry)           │
│                                                                             │
│  PARAMETRIC FORM (derived from coherence flow requirements):                │
│     x(u,v) = (R + r·cos(v))·cos(u)                                         │
│     y(u,v) = (R + r·cos(v))·sin(u)                                         │
│     z(u,v) = r·sin(v)                                                       │
│                                                                             │
│  Where: R = major radius (center to tube center)                           │
│         r = minor radius (tube radius)                                      │
│         u ∈ [0, 2π] = angle around the hole                                │
│         v ∈ [0, 2π] = angle around the tube                                │
│                                                                             │
│  CRR PREDICTION FOR ASPECT RATIO:                                           │
│  Optimal R/r ratio for stable coherence flow ≈ φ (golden ratio)            │
│  This minimizes turbulence in the regeneration cycle.                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  SRI YANTRA: CRR DERIVATION OF 9 TRIANGLES                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Create maximal coherence interference pattern using triangles.    │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Triangles are minimal coherent polygons (3 edges = minimum for closure).  │
│  Upward (△) and downward (▽) triangles create COMPLEMENTARY coherence.    │
│                                                                             │
│  For N interlocking triangles, coherence nodes (intersections) = N².       │
│  To create exactly 43 coherence cells (traditional Sri Yantra):            │
│                                                                             │
│     4 upward triangles (Shiva - consciousness, stillness)                  │
│     5 downward triangles (Shakti - energy, movement)                       │
│     Total intersections: 4 × 5 × 2 + edge effects = 43 cells               │
│                                                                             │
│  WHY 4 AND 5?                                                               │
│  The ratio 5/4 = 1.25 ≈ 2^(1/3) creates near-optimal coherence packing.   │
│  This is related to the musical major third interval.                      │
│                                                                             │
│  BINDU (center point):                                                      │
│  All 9 triangles share a common center where coherence SUMS.               │
│  C_bindu = Σ C_triangle = maximum coherence point.                         │
│  exp(C_bindu/Ω) → ∞ makes this an infinite attractor.                      │
│                                                                             │
│  TRIANGLE NESTING (derived from equal coherence shells):                    │
│  Scale ratio between successive triangles ≈ 0.85                           │
│  This creates equal coherence density across shells.                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  METATRON'S CUBE: CRR DERIVATION OF 13 CIRCLES                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM: Find the minimal set of coherence nodes that encodes ALL         │
│  Platonic solids (the only regular 3D polyhedra).                          │
│                                                                             │
│  CRR SOLUTION:                                                              │
│  Platonic solids have vertices on a sphere. We need 2D projection of       │
│  all vertex sets. The minimum nodes to contain all projections:            │
│                                                                             │
│     Tetrahedron:   4 vertices  → 4 nodes                                   │
│     Cube:          8 vertices  → need 6 nodes (projected)                  │
│     Octahedron:    6 vertices  → 6 nodes                                   │
│     Dodecahedron: 20 vertices  → need 12 nodes (projected)                 │
│     Icosahedron:  12 vertices  → 12 nodes                                  │
│                                                                             │
│  Minimum set containing all: 13 nodes                                       │
│     1 center + 6 inner ring + 6 outer ring                                 │
│                                                                             │
│  CONFIGURATION (from coherence overlap optimization):                       │
│     Center: (0, 0)                                                          │
│     Inner ring: radius R, angles 0°, 60°, 120°, 180°, 240°, 300°          │
│     Outer ring: radius R√3, angles 30°, 90°, 150°, 210°, 270°, 330°       │
│                                                                             │
│  The connecting LINES are coherence pathways - they show which nodes       │
│  have direct coherence coupling. All 78 lines (13 choose 2) represent      │
│  the complete coherence graph.                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  OUROBOROS: CRR AS SELF-CONSUMING CYCLE                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  The Ouroboros IS the CRR equation visualized as geometry:                  │
│                                                                             │
│     BODY = C(x,t) = ∫L(x,τ)dτ                                              │
│     The accumulated coherence, the integrated history.                      │
│     Represented as the serpent's length - all that has been.               │
│                                                                             │
│     MOUTH = δ(now)                                                          │
│     The rupture operator, the present moment.                               │
│     Where past is consumed, transformed, ended.                            │
│                                                                             │
│     EATING = R = exp(C/Ω)                                                   │
│     The regeneration process, weighted by coherence.                        │
│     What is consumed becomes fuel for new growth.                          │
│                                                                             │
│  GEOMETRIC DERIVATION:                                                      │
│  The serpent forms a CIRCLE because:                                        │
│     - End must meet beginning (C → δ → R → C)                              │
│     - No external input needed (self-sustaining)                           │
│     - Radius R represents total coherence C_total                          │
│                                                                             │
│  HEAD SIZE (mouth):                                                         │
│  Derived from rupture duration: r_head/R = τ_rupture/τ_cycle               │
│  Typical ratio ≈ 0.15-0.20                                                 │
│                                                                             │
│  BODY THICKNESS gradient:                                                   │
│  Increases from tail to head: thickness(θ) ∝ exp(θ/2π)                    │
│  This represents coherence accumulation along the cycle. Hello Plato!       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  LORENZ ATTRACTOR: CRR IN DETERMINISTIC CHAOS                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  The Lorenz system IS a CRR system:                                         │
│                                                                             │
│     dx/dt = σ(y - x)           ← Coherence accumulation toward y           │
│     dy/dt = x(ρ - z) - y       ← Rupture when z exceeds ρ                  │
│     dz/dt = xy - βz            ← Regeneration with decay rate β            │
│                                                                             │
│  CRR PARAMETER MAPPING:                                                     │
│     σ = 10  → Coherence rate (how fast x aligns with y)                    │
│     ρ = 28  → Rupture threshold (when convection destabilizes)             │
│     β = 8/3 → Regeneration decay (how fast z dissipates)                   │
│                                                                             │
│  Ω_lorenz = 1/ρ ≈ 0.036 (very low - rigid basin structure)                │
│                                                                             │
│  TWO WINGS = two metastable coherence basins                               │
│  The system dwells in one wing (accumulates C), then ruptures              │
│  to the other (δ), regenerates new trajectory (R), repeats.               │
│                                                                             │
│  CHAOS arises because rupture timing depends sensitively on C:             │
│  Small changes in accumulated coherence → large changes in when/where      │
│  the system jumps between wings.                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  GENERAL PRINCIPLE: GEOMETRY FROM COHERENCE OPTIMIZATION                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Sacred geometries are not arbitrary - they are SOLUTIONS to:               │
│                                                                             │
│     maximize ∫∫ C(x,y) dx dy                                               │
│     subject to: symmetry constraints, boundary conditions                   │
│                                                                             │
│  Where C(x,y) = local coherence field.                                      │
│                                                                             │
│  DIFFERENT SYMMETRY CONSTRAINTS → DIFFERENT GEOMETRIES:                     │
│                                                                             │
│     Rotational symmetry (SO(2))  → Circles, spirals, torus                 │
│     Reflection symmetry (Z₂)    → Yin-yang, vesica piscis                  │
│     6-fold symmetry (D₆)        → Flower of life, hexagrams                │
│     Scale invariance            → Fractals, Fibonacci spiral               │
│     No symmetry constraint      → Strange attractors                       │
│                                                                             │
│  The exp(C/Ω) weighting in regeneration creates ATTRACTOR BASINS -         │
│  particles naturally find and stabilize these optimal configurations.      │
│                                                                             │
│  This is why sacred geometries appear across cultures and scales:          │
│  they are the SOLUTIONS to coherence optimization under symmetry.          │
│  Humans, crystals, galaxies, and algorithms discover the same forms        │
│  because they're solving the same underlying coherence equations.          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Ω-SYMMETRY:
===========

Alexander found that different system symmetries appear to determine specific Ω values:
- Z₂ (binary/half-cycle) systems: Ω = 1/π ≈ 0.318
- SO(2) (full rotation) systems: Ω = 1/2π ≈ 0.159

This creates coefficient of variation CV = Ω/2, matching empirical data predictions and outcomes.

In this visualization, the Ω slider lets you explore the transition between
rigid crystalline forms (low Ω) and fluid transformative states (high Ω).

CONNECTION TO FREE ENERGY PRINCIPLE:
====================================

CRR provides the temporal dynamics that the Free Energy Principle presupposes:
- FEP describes WHAT beliefs update to (minimize surprise)
- CRR describes WHEN and HOW beliefs update through time
- The key relationship: Ω = σ² (variance/precision)

This unification means: σ² = 1/φ where φ is phase in radians,
connecting Bayesian precision to geometric phase relationships.

For more: www.temporalgrammar.ai | www.cohere.org.uk 

================================================================================
-->

<script>
/**
 * ============================================================================
 * CRR GEOMETRIC MURMURATION
 * ============================================================================
 * 
 * Implementation of the Coherence-Rupture-Regeneration framework for
 * particle-based geometric formation.
 * 
 * Framework by Alexander Sabine (Cohere Research)
 * 
 * Core CRR Equations:
 *   C(x,t) = ∫L(x,τ)dτ           -- Coherence accumulation
 *   δ(now)                        -- Rupture (scale-invariant choice moment)  
 *   R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ  -- Regeneration with memory weighting
 * 
 * In this implementation:
 *   - L(x,τ) = alignment with topological neighbours (dot product of velocities)
 *   - Ω = rupture threshold / openness parameter (user adjustable)
 *   - exp(C/Ω) weights both flocking alignment AND geometric attraction
 * 
 * The key insight: geometry emerges from coherence-weighted regeneration,
 * not imposed positional forces. Particles "discover" shapes through
 * temporal integration of coherence relationships.
 */

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, alpha: true });

let W, H, cx, cy;
const N = 36000;

// ============================================================================
// STATE ARRAYS (Structure of Arrays for cache efficiency)
// ============================================================================

const x = new Float32Array(N);         // Position X
const y = new Float32Array(N);         // Position Y
const vx = new Float32Array(N);        // Velocity X
const vy = new Float32Array(N);        // Velocity Y
const coherence = new Float32Array(N); // C - accumulated alignment history (CRR)
const phase = new Float32Array(N);     // Visual phase for iridescence
const targetX = new Float32Array(N);   // Geometric attractor X
const targetY = new Float32Array(N);   // Geometric attractor Y
const hasTarget = new Uint8Array(N);   // Whether particle has active target

// ============================================================================
// CRR PARAMETERS
// ============================================================================

/**
 * Ω (OMEGA) - The Rupture Threshold
 * 
 * This is the key CRR parameter controlling system "openness":
 * - Low Ω (~0.1-0.2): System is RIGID
 *   - exp(C/Ω) creates sharp peaks - only highest coherence dominates
 *   - Particles snap quickly to positions, maintain crystalline forms
 *   - Micro-ruptures reconstitute same patterns (low transformative capacity)
 * 
 * - High Ω (~0.4-0.6): System is FLUID  
 *   - exp(C/Ω) ≈ 1 for all - broader history equally accessible
 *   - Particles flow smoothly, forms breathe and transform
 *   - System can access wider configurational space
 * 
 * Alexander's Ω-symmetry discovery:
 *   Z₂ systems: Ω = 1/π ≈ 0.318
 *   SO(2) systems: Ω = 1/2π ≈ 0.159
 */
let OMEGA = 0.10;  // Low Ω = crystalline precision, rigid sacred geometry

/**
 * FORM_ATTRACTION - Geometric Pull Strength
 * 
 * Scales how strongly particles regenerate toward target geometry.
 * Note: This is MULTIPLIED by exp(C/Ω) - high coherence particles
 * feel stronger attraction. This creates organic formation where
 * aligned particles lead and pull others through coherence field.
 */
let FORM_ATTRACTION = 1.0;  // Maximum attraction to geometric form

/**
 * DECAY - Coherence Memory
 * 
 * Controls C(t) = C(t-1) * DECAY + L(t) * (1-DECAY)
 * 
 * High decay (~0.99): Long memory, slow to change, stable forms
 * Low decay (~0.9): Short memory, responsive, fluid forms
 * 
 * This implements the integral ∫L(x,τ)dτ as exponential moving average
 */
let DECAY = 0.99;  // High memory = stable, lasting forms

let IRIDESCENCE = 1.0;  // Full holographic shimmer

// ============================================================================
// SPATIAL PARTITIONING (for O(1) neighbour lookup)
// ============================================================================

const CELL = 55;
let gridW, gridH, grid, gridCounts;
const MAX_PER_CELL = 30;

// ============================================================================
// GEOMETRY STATE
// ============================================================================

let currentShape = -1;
let time = 0;
let windAngle = 0;

/**
 * Shape definitions with CRR interpretation notes
 * 
 * Each shape represents a different COHERENCE BASIN - a configuration
 * that particles naturally settle into through CRR dynamics.
 * 
 * The geometry isn't "imposed" - it's discovered through coherence-weighted
 * regeneration. Particles that reach target positions and align with
 * neighbours INCREASE their coherence, strengthening their position.
 */
const shapes = [
    { name: 'Flower of Life', desc: 'Genesis pattern - all form emerges from overlapping circles of light' },
    { name: 'Torus', desc: 'Self-sustaining flow - what is given returns to source' },
    { name: 'Fibonacci Spiral', desc: 'φ = 1.618... Nature\'s golden proportion, infinite beauty in ratio' },
    { name: 'Metatron\'s Cube', desc: 'Archangel\'s gift - 13 circles containing all Platonic solids' },
    { name: 'Double Helix', desc: 'Entangled memory spirals - two becoming one becoming many' },
    { name: 'Lemniscate', desc: '∞ - each crossing through center is death and rebirth in one breath' },
    { name: 'Vesica Piscis', desc: 'The womb of creation - where two circles kiss, the third is born' },
    { name: 'Sri Yantra', desc: 'Supreme instrument - Shiva and Shakti\'s eternal dance of 9 triangles' },
    { name: 'Lorenz Attractor', desc: 'Strange attractor - infinite variation bounded by invisible form' },
    { name: 'Klein Bottle', desc: 'No inside, no outside - mystic topology of self-knowing awareness' },
    { name: 'Hopf Fibration', desc: 'Indra\'s net - every circle linked with every other, all in all' },
    { name: 'Penrose Tiling', desc: 'Aperiodic order - coherent pattern that never repeats, like consciousness' },
    { name: 'Nautilus Shell', desc: 'Chambered prophet - perfect memory of every stage, carried forward' },
    { name: 'Tree of Life', desc: '10 sephiroth - lightning flash of creation, serpent path of return' },
    { name: 'Yin Yang', desc: 'Supreme ultimate - in deepest dark, light seeds; in fullest light, dark waits' },
    { name: 'Ouroboros', desc: 'C → δ → R → ∞ - the serpent IS the CRR equation made flesh' },
    { name: 'Seed of Life', desc: 'Seven days of creation - the first coherence, source of all pattern' },
    { name: 'Fruit of Life', desc: '13 circles - the feminine template from which Metatron emerges' },
    { name: 'Merkaba', desc: 'Chariot of light - counter-rotating tetrahedra, the vehicle of ascension' },
    { name: 'Icosahedron', desc: 'Water element - 20 triangular faces, flow and emotional coherence' },
    { name: 'Dodecahedron', desc: 'Aether/universe - 12 pentagonal faces, Plato\'s cosmic blueprint' },
    { name: 'Tetrahedron', desc: 'Fire element - simplest solid, the spark of manifestation' },
    { name: 'Octahedron', desc: 'Air element - 8 faces, breath between above and below' },
    { name: 'Cube (Hexahedron)', desc: 'Earth element - stability, grounding, crystallized coherence' },
    { name: '64 Tetrahedron Grid', desc: 'Isotropic vector matrix - Buckminster Fuller\'s structure of space' },
    { name: 'Enneagram', desc: 'Nine points of return - Gurdjieff\'s map of process and personality' },
    { name: 'Labyrinth', desc: 'The single path - no choices, only the journey inward and back' },
    { name: 'Torus Knot', desc: 'Coherence wound through itself - the simplest knot on the donut' },
    { name: 'Rose (Rhodonea)', desc: 'Petals from proportion - mathematical roses, nature\'s signature' },
    { name: 'Gordian Knot', desc: 'Complexity from simplicity - the problem that dissolves when reframed' },
    { name: 'Tesseract', desc: '4D hypercube - consciousness transcending dimensional limits' },
    { name: 'Star of David', desc: 'As above, so below - fire and water, spirit and matter unified' },
    { name: 'Ankh', desc: 'Key of life - where eternity touches time, gods offer breath' },
    { name: 'Caduceus', desc: 'Serpents of Hermes - Ida and Pingala dancing around Sushumna' },
    { name: 'Borromean Rings', desc: 'Emergent unity - three linked, yet no two touching' },
    { name: 'Moebius Strip', desc: 'One-sided truth - following self leads through not-self home' },
    { name: 'Apollonian Gasket', desc: 'Fractal nesting - infinite circles, each tangent to eternity' },
    { name: 'Mandelbrot Boundary', desc: 'Edge of chaos - where z² + c decides bounded or infinite' },
    { name: 'Dragon Curve', desc: 'Folded infinity - paper remembers every crease forever' },
    { name: 'Flower of Aphrodite', desc: 'Venus rose - the goddess traces love every eight years' }
];

// ============================================================================
// GEOMETRY GENERATORS
// ============================================================================
// Each returns array of [x,y] points. Particles regenerate toward these
// positions weighted by exp(C/Ω) - the CRR mechanism.

/**
 * FLOWER OF LIFE
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Multiple overlapping coherence circles create interference patterns. Where 
 * circles overlap, coherence REINFORCES - constructive interference. This is
 * why the vesica regions (overlaps) glow brighter in the visualization.
 * 
 * The 6-fold symmetry emerges from optimal 2D sphere packing - the most
 * efficient way to tile coherence circles. This is Z₂ symmetry at each
 * petal boundary (in/out), predicting Ω ≈ 1/π per CRR theory.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Found carved in the Temple of Osiris at Abydos, Egypt - possibly 10,000+
 * years old, created by burning the pattern into granite with unknown tech.
 * Appears independently in China, Israel, Japan, India, Turkey, medieval Europe.
 * 
 * The pattern represents:
 * - GENESIS: First circle = "Let there be light". Each subsequent circle = 
 *   another day/act of creation. 7 circles = Seed of Life = 7 days.
 * - COMPLETENESS: Contains Seed of Life (7), Egg of Life (8 spheres, 3D),
 *   Fruit of Life (13), which generates Metatron's Cube.
 * - INTERCONNECTION: No circle exists alone; all emerge from overlap.
 * - AKASHIC RECORD: Said to contain all information of living things.
 * 
 * In CRR terms: The Flower shows how DIFFERENTIATED FORMS (petals) emerge
 * from and remain connected to UNIFIED FIELD (the generating process).
 * This is Ein Sof differentiating through Tzimtzum - the One becoming Many
 * while remaining One. The Flower IS the structure of emanation.
 * 
 * Leonardo da Vinci studied the Flower of Life extensively, filling pages
 * with its mathematical properties. It encodes π, the golden ratio φ,
 * the Platonic solids, and the basic building blocks of geometry.
 * 
 * The center circle is KETHER - pure undifferentiated coherence.
 * Each ring outward is another level of EMANATION (sephiroth).
 * The outermost ring is MALKUTH - full manifestation in form.
 */
function generateFlowerOfLife(n, scale) {
    const points = [];
    const rings = 3;
    const pointsPerCircle = Math.floor(n / (1 + 6 + 12 + 18));
    
    // Center circle - the seed of coherence
    for (let i = 0; i < pointsPerCircle * 2; i++) {
        const a = (i / (pointsPerCircle * 2)) * Math.PI * 2;
        points.push([Math.cos(a) * scale * 0.5, Math.sin(a) * scale * 0.5]);
    }
    
    // First ring - 6 circles (hexagonal coherence)
    for (let j = 0; j < 6; j++) {
        const ca = (j / 6) * Math.PI * 2;
        const ccx = Math.cos(ca) * scale * 0.5;
        const ccy = Math.sin(ca) * scale * 0.5;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * scale * 0.5, ccy + Math.sin(a) * scale * 0.5]);
        }
    }
    
    // Second ring - 12 circles
    for (let j = 0; j < 12; j++) {
        const ca = (j / 12) * Math.PI * 2 + Math.PI / 12;
        const ccx = Math.cos(ca) * scale * 0.866;
        const ccy = Math.sin(ca) * scale * 0.866;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * scale * 0.5, ccy + Math.sin(a) * scale * 0.5]);
        }
    }
    
    // Fill to n
    while (points.length < n) {
        const idx = Math.floor(Math.random() * points.length);
        const noise = 0.02 * scale;
        points.push([
            points[idx][0] + (Math.random() - 0.5) * noise,
            points[idx][1] + (Math.random() - 0.5) * noise
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * TORUS
 * 
 * CRR Interpretation: A surface with no boundaries - coherence can
 * flow continuously without rupture points. The hole creates a
 * topological invariant that CRR dynamics preserve.
 * 
 * This is SO(2) × SO(2) symmetry - two independent rotation phases,
 * predicting Ω ≈ 1/2π for each dimension.
 */
function generateTorus(n, R, r) {
    const points = [];
    const uSteps = Math.floor(Math.sqrt(n * 1.5));
    const vSteps = Math.floor(n / uSteps);
    
    for (let i = 0; i < uSteps; i++) {
        for (let j = 0; j < vSteps; j++) {
            const u = (i / uSteps) * Math.PI * 2;
            const v = (j / vSteps) * Math.PI * 2;
            
            // Torus parametric equations
            const x3d = (R + r * Math.cos(v)) * Math.cos(u);
            const y3d = (R + r * Math.cos(v)) * Math.sin(u);
            const z3d = r * Math.sin(v);
            
            // Perspective projection - z affects scale
            const perspective = 1.2 / (1.2 - z3d / R);
            points.push([x3d * perspective, y3d * perspective]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * FIBONACCI SPIRAL (Phyllotaxis)
 * 
 * CRR Interpretation: The golden angle (137.5°) maximizes the MINIMUM
 * distance between successive points - this is nature's solution to
 * packing coherence without creating regular patterns that waste space.
 * 
 * Each point maintains coherence with its Fibonacci-numbered neighbours.
 * The spiral represents continuous growth without rupture.
 */
function generateFibonacciSpiral(n, scale) {
    const points = [];
    const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~137.5° in radians
    
    for (let i = 0; i < n; i++) {
        const theta = i * goldenAngle;
        const r = scale * Math.sqrt(i / n) * 1.2;
        points.push([Math.cos(theta) * r, Math.sin(theta) * r]);
    }
    
    return points;
}

/**
 * METATRON'S CUBE
 * 
 * CRR Interpretation: 13 circles (1 + 6 + 6) represent coherence nodes.
 * The connecting lines show resonance pathways - how coherence can
 * propagate between nodes. Contains all Platonic solids in projection.
 * 
 * The structure encodes the relationship between local coherence (circles)
 * and global coherence (connecting lines).
 */
function generateMetatronsCube(n, scale) {
    const points = [];
    
    // 13 circle centers
    const centers = [[0, 0]];
    for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2 - Math.PI / 2;
        centers.push([Math.cos(a) * scale * 0.6, Math.sin(a) * scale * 0.6]);
    }
    for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2 - Math.PI / 2 + Math.PI / 6;
        centers.push([Math.cos(a) * scale * 1.04, Math.sin(a) * scale * 1.04]);
    }
    
    const pointsPerCircle = Math.floor(n * 0.6 / 13);
    
    // Draw circles
    for (const [ccx, ccy] of centers) {
        const radius = scale * 0.35;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * radius, ccy + Math.sin(a) * radius]);
        }
    }
    
    // Draw connecting lines (coherence pathways)
    const linePoints = n - points.length;
    const connections = [];
    for (let i = 0; i < 13; i++) {
        for (let j = i + 1; j < 13; j++) {
            connections.push([i, j]);
        }
    }
    
    const pointsPerLine = Math.floor(linePoints / connections.length);
    for (const [i, j] of connections) {
        for (let t = 0; t < pointsPerLine; t++) {
            const tt = t / pointsPerLine;
            points.push([
                centers[i][0] * (1 - tt) + centers[j][0] * tt,
                centers[i][1] * (1 - tt) + centers[j][1] * tt
            ]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * DOUBLE HELIX
 * 
 * CRR Interpretation: Two phase-locked spirals, like DNA. The strands
 * maintain coherence with each other through the "rungs" - cross-links
 * that prevent independent phase drift.
 * 
 * This represents coupled oscillators - neither strand can rupture
 * without affecting the other. A model for entangled coherence.
 */
function generateDoubleHelix(n, scale) {
    const points = [];
    const turns = 5;
    const rungs = 30;
    
    const strandPoints = Math.floor(n * 0.7 / 2);
    const rungPoints = n - strandPoints * 2;
    
    // Strand 1
    for (let i = 0; i < strandPoints; i++) {
        const t = (i / strandPoints) * turns * Math.PI * 2;
        const yy = ((i / strandPoints) - 0.5) * scale * 2.5;
        const xx = Math.cos(t) * scale * 0.4;
        points.push([xx, yy]);
    }
    
    // Strand 2 (π phase offset)
    for (let i = 0; i < strandPoints; i++) {
        const t = (i / strandPoints) * turns * Math.PI * 2 + Math.PI;
        const yy = ((i / strandPoints) - 0.5) * scale * 2.5;
        const xx = Math.cos(t) * scale * 0.4;
        points.push([xx, yy]);
    }
    
    // Rungs (cross-links)
    for (let i = 0; i < rungPoints; i++) {
        const rungIdx = Math.floor((i / rungPoints) * rungs);
        const t = (rungIdx / rungs) * turns * Math.PI * 2;
        const yy = ((rungIdx / rungs) - 0.5) * scale * 2.5;
        const progress = (i % Math.floor(rungPoints / rungs)) / Math.floor(rungPoints / rungs);
        const xx = Math.cos(t) * scale * 0.4 * (1 - 2 * progress);
        points.push([xx, yy]);
    }
    
    return points.slice(0, n);
}

/**
 * LEMNISCATE OF BERNOULLI
 * 
 * CRR Interpretation: The infinity symbol. At the center point, 
 * coherence undergoes PHASE INVERSION - the system crosses through
 * a rupture point and emerges with inverted phase.
 * 
 * This is a model for how systems can pass through apparent death
 * (center crossing) and regenerate on the other side.
 */
function generateLemniscate(n, scale) {
    const points = [];
    
    for (let i = 0; i < n; i++) {
        const t = (i / n) * Math.PI * 2;
        const denom = 1 + Math.sin(t) * Math.sin(t);
        const xx = scale * 1.3 * Math.cos(t) / denom;
        const yy = scale * 1.3 * Math.sin(t) * Math.cos(t) / denom;
        points.push([xx, yy]);
    }
    
    return points;
}

/**
 * VESICA PISCIS
 * 
 * CRR Interpretation: Two coherence fields overlap. The vesica (almond)
 * at the intersection is where BOTH coherence fields reinforce - 
 * a region of doubled coherence strength.
 * 
 * Ancient symbol for birth/creation - new coherence emerging from
 * the intersection of two existing fields.
 */
function generateVesicaPiscis(n, scale) {
    const points = [];
    const offset = scale * 0.5;
    const perCircle = Math.floor(n * 0.4);
    
    // Left circle
    for (let i = 0; i < perCircle; i++) {
        const a = (i / perCircle) * Math.PI * 2;
        points.push([-offset + Math.cos(a) * scale, Math.sin(a) * scale]);
    }
    
    // Right circle
    for (let i = 0; i < perCircle; i++) {
        const a = (i / perCircle) * Math.PI * 2;
        points.push([offset + Math.cos(a) * scale, Math.sin(a) * scale]);
    }
    
    // Fill the vesica (intersection region with doubled coherence)
    const vesicaPoints = n - points.length;
    for (let i = 0; i < vesicaPoints; i++) {
        const yy = (Math.random() - 0.5) * scale * 1.72;
        // X bounds from circle intersection geometry
        const xBound = Math.sqrt(Math.max(0, scale * scale - yy * yy)) - offset;
        if (xBound > 0) {
            const xx = (Math.random() - 0.5) * xBound * 2;
            points.push([xx, yy]);
        } else {
            // Fallback to circle edge
            const a = Math.random() * Math.PI * 2;
            points.push([Math.cos(a) * scale * 0.3, Math.sin(a) * scale * 0.3]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * SRI YANTRA
 * 
 * CRR Interpretation: 9 interlocking triangles create 43 smaller triangles.
 * Each triangle is a coherence cell. The nesting represents hierarchical
 * coherence - local triangles cohere into larger patterns.
 * 
 * The bindu (center point) is the source/seed of all coherence.
 * Moving outward, coherence differentiates but maintains connection to center.
 */
function generateSriYantra(n, scale) {
    const points = [];
    
    // Concentric triangular layers
    const layers = 6;
    const pointsPerLayer = Math.floor(n * 0.85 / layers);
    
    for (let layer = 0; layer < layers; layer++) {
        const s = scale * (1 - layer * 0.15);
        const rot = layer % 2 === 0 ? -Math.PI / 2 : Math.PI / 2;
        
        for (let i = 0; i < pointsPerLayer; i++) {
            const edge = (i / pointsPerLayer) * 3;
            const edgeIdx = Math.floor(edge);
            const t = edge - edgeIdx;
            
            const a1 = rot + (edgeIdx / 3) * Math.PI * 2;
            const a2 = rot + ((edgeIdx + 1) % 3 / 3) * Math.PI * 2;
            
            const x1 = Math.cos(a1) * s, y1 = Math.sin(a1) * s;
            const x2 = Math.cos(a2) * s, y2 = Math.sin(a2) * s;
            
            points.push([x1 * (1 - t) + x2 * t, y1 * (1 - t) + y2 * t]);
        }
    }
    
    // Bindu (central seed of coherence)
    const binduPoints = n - points.length;
    for (let i = 0; i < binduPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.08;
        points.push([Math.cos(a) * r, Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * LORENZ ATTRACTOR
 * 
 * CRR Interpretation: A STRANGE ATTRACTOR - deterministic chaos.
 * The system never repeats exactly, yet stays bounded. This is
 * coherence without periodicity - infinite variation within form.
 * 
 * The "butterfly wings" represent two basins that the system
 * alternates between, with rupture-like transitions at crossings.
 */
function generateLorenzAttractor(n, scale) {
    const points = [];
    
    // Lorenz system parameters
    const sigma = 10, rho = 28, beta = 8/3;
    const dt = 0.005;
    
    let lx = 0.1, ly = 0, lz = 0;
    
    // Iterate the Lorenz system
    for (let i = 0; i < n + 1000; i++) {
        const dx = sigma * (ly - lx);
        const dy = lx * (rho - lz) - ly;
        const dz = lx * ly - beta * lz;
        
        lx += dx * dt;
        ly += dy * dt;
        lz += dz * dt;
        
        if (i >= 1000) { // Skip transient
            // Project 3D to 2D
            const px = lx * scale * 0.04;
            const py = (lz - 25) * scale * 0.04;
            points.push([px, py]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * KLEIN BOTTLE
 * 
 * CRR Interpretation: A surface that passes through itself - 
 * no inside/outside distinction. This represents coherence that
 * connects to itself across dimensions, like consciousness.
 * 
 * The self-intersection isn't a rupture - it's a higher-dimensional
 * continuity that appears as intersection in 2D projection.
 */
function generateKleinBottle(n, scale) {
    const points = [];
    const uSteps = Math.floor(Math.sqrt(n));
    const vSteps = Math.floor(n / uSteps);
    
    for (let i = 0; i < uSteps; i++) {
        for (let j = 0; j < vSteps; j++) {
            const u = (i / uSteps) * Math.PI * 2;
            const v = (j / vSteps) * Math.PI * 2;
            
            // Klein bottle parametric (figure-8 immersion)
            const r = 4 * (1 - Math.cos(u) / 2);
            const x4d = r * Math.cos(u);
            const y4d = r * Math.sin(u);
            const z4d = Math.sin(v) * (6 - 3 * Math.cos(u));
            const w4d = Math.cos(v) * (6 - 3 * Math.cos(u));
            
            // Project 4D → 2D
            const perspective = 1 / (1 - w4d * 0.05);
            points.push([
                (x4d + z4d * 0.3) * scale * 0.07 * perspective,
                y4d * scale * 0.1 * perspective
            ]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * HOPF FIBRATION
 * 
 * CRR Interpretation: The 3-sphere (4D sphere) mapped to 3D via
 * stereographic projection, showing nested tori of linked circles.
 * 
 * This is deep topology - every circle is linked with every other.
 * It represents maximal coherent connection: nothing is separate.
 * The Hopf fibration appears in quantum mechanics and twistor theory.
 */
function generateHopfFibration(n, scale) {
    const points = [];
    const fibers = 24;
    const pointsPerFiber = Math.floor(n / fibers);
    
    for (let f = 0; f < fibers; f++) {
        // Parameter for which fiber we're drawing
        const eta = (f / fibers) * Math.PI;
        const phi0 = (f / fibers) * Math.PI * 4;
        
        for (let i = 0; i < pointsPerFiber; i++) {
            const t = (i / pointsPerFiber) * Math.PI * 2;
            
            // Hopf fibration parametric
            const x4 = Math.cos(eta) * Math.cos(t);
            const y4 = Math.cos(eta) * Math.sin(t);
            const z4 = Math.sin(eta) * Math.cos(t + phi0);
            const w4 = Math.sin(eta) * Math.sin(t + phi0);
            
            // Stereographic projection S³ → R³ → R²
            const denom = 1 - w4;
            const x3 = x4 / (denom + 0.1);
            const y3 = y4 / (denom + 0.1);
            const z3 = z4 / (denom + 0.1);
            
            // 3D to 2D with rotation
            const angle = time * 0.1;
            const px = (x3 * Math.cos(angle) - z3 * Math.sin(angle)) * scale * 0.25;
            const py = y3 * scale * 0.25;
            
            points.push([px, py]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * PENROSE TILING (Vertices)
 * 
 * CRR Interpretation: Aperiodic tiling - coherent order without repetition.
 * Like quasicrystals, this represents a middle way between crystal (rigid)
 * and amorphous (no coherence) states.
 * 
 * The 5-fold symmetry (forbidden in crystals) emerges from golden ratio
 * relationships - the same ratio that appears in Fibonacci spiral.
 */
function generatePenroseTiling(n, scale) {
    const points = [];
    const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
    
    // Generate Penrose vertices via projection method
    const gridSize = Math.ceil(Math.sqrt(n) / 2);
    
    for (let i = -gridSize; i <= gridSize; i++) {
        for (let j = -gridSize; j <= gridSize; j++) {
            // 5D lattice projected to 2D
            for (let k = 0; k < 5; k++) {
                const angle = (k / 5) * Math.PI * 2;
                const x5 = i * Math.cos(angle) + j * Math.cos(angle * 2);
                const y5 = i * Math.sin(angle) + j * Math.sin(angle * 2);
                
                if (x5 * x5 + y5 * y5 < gridSize * gridSize) {
                    points.push([x5 * scale / gridSize * 0.8, y5 * scale / gridSize * 0.8]);
                }
            }
            
            if (points.length >= n) break;
        }
        if (points.length >= n) break;
    }
    
    // Fill remaining with slight perturbations
    while (points.length < n) {
        const idx = Math.floor(Math.random() * Math.min(points.length, 1000));
        points.push([
            points[idx][0] + (Math.random() - 0.5) * scale * 0.03,
            points[idx][1] + (Math.random() - 0.5) * scale * 0.03
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * NAUTILUS SHELL (Logarithmic Spiral)
 * 
 * CRR Interpretation: Growth that maintains proportion - each chamber
 * is a scaled version of the last. This is SELF-SIMILAR coherence:
 * the pattern at each scale reflects the whole.
 * 
 * The logarithmic spiral is the only curve that maintains constant
 * angle to radial lines - constant coherence relationship with center.
 */
function generateNautilusShell(n, scale) {
    const points = [];
    const a = 0.17; // Growth rate
    const turns = 3;
    
    // Multiple spiral arms with chambers
    for (let arm = 0; arm < 3; arm++) {
        const armOffset = (arm / 3) * Math.PI * 0.3;
        const armPoints = Math.floor(n / 3);
        
        for (let i = 0; i < armPoints; i++) {
            const t = (i / armPoints) * turns * Math.PI * 2 + armOffset;
            const r = scale * 0.15 * Math.exp(a * t);
            
            // Add chamber structure (thickness varies with radius)
            const thickness = r * 0.15;
            const offset = (Math.random() - 0.5) * thickness;
            
            const px = Math.cos(t) * (r + offset);
            const py = Math.sin(t) * (r + offset);
            
            if (px * px + py * py < scale * scale * 1.5) {
                points.push([px, py]);
            }
        }
    }
    
    // Fill to n
    while (points.length < n) {
        const t = Math.random() * turns * Math.PI * 2;
        const r = scale * 0.15 * Math.exp(a * t);
        const thickness = r * 0.1;
        points.push([
            Math.cos(t) * r + (Math.random() - 0.5) * thickness,
            Math.sin(t) * r + (Math.random() - 0.5) * thickness
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * TREE OF LIFE (Kabbalah)
 * 
 * CRR Interpretation: 10 sephiroth (coherence nodes) connected by
 * 22 paths. Represents hierarchical coherence from unity (Kether)
 * through differentiation to manifestation (Malkuth).
 * 
 * The three pillars represent: Mercy (expansion), Severity (contraction),
 * and the Middle Pillar (balance) - the CRR dynamics of growth, pruning,
 * and integration.
 */
function generateTreeOfLife(n, scale) {
    const points = [];
    
    // 10 Sephiroth positions (traditional layout)
    const sephiroth = [
        [0, -1.2],      // 1. Kether (Crown)
        [-0.5, -0.8],   // 2. Chokmah (Wisdom)
        [0.5, -0.8],    // 3. Binah (Understanding)
        [-0.5, -0.3],   // 4. Chesed (Mercy)
        [0.5, -0.3],    // 5. Geburah (Severity)
        [0, 0],         // 6. Tiphareth (Beauty)
        [-0.5, 0.4],    // 7. Netzach (Victory)
        [0.5, 0.4],     // 8. Hod (Splendor)
        [0, 0.7],       // 9. Yesod (Foundation)
        [0, 1.1]        // 10. Malkuth (Kingdom)
    ].map(([x, y]) => [x * scale * 0.8, y * scale * 0.8]);
    
    // 22 Paths (connecting sephiroth)
    const paths = [
        [0,1], [0,2], [1,2], [1,3], [2,4], [1,5], [2,5], [3,4],
        [3,5], [4,5], [3,6], [4,7], [5,6], [5,7], [5,8], [6,7],
        [6,8], [7,8], [6,9], [7,9], [8,9], [9,9] // 9,9 is Malkuth circle
    ];
    
    const pointsPerSephirah = Math.floor(n * 0.4 / 10);
    const pointsPerPath = Math.floor(n * 0.6 / paths.length);
    
    // Draw sephiroth (circles)
    for (const [sx, sy] of sephiroth) {
        const radius = scale * 0.12;
        for (let i = 0; i < pointsPerSephirah; i++) {
            const a = (i / pointsPerSephirah) * Math.PI * 2;
            const r = radius * (0.8 + Math.random() * 0.2);
            points.push([sx + Math.cos(a) * r, sy + Math.sin(a) * r]);
        }
    }
    
    // Draw paths
    for (const [from, to] of paths) {
        if (from === to) continue; // Skip self-loops
        const [x1, y1] = sephiroth[from];
        const [x2, y2] = sephiroth[to];
        
        for (let i = 0; i < pointsPerPath; i++) {
            const t = i / pointsPerPath;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * YIN YANG (Taijitu)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Two complementary coherence fields, each containing the SEED of the other.
 * This is DUAL COHERENCE - patterns that define each other through boundary.
 * 
 * In CRR terms:
 * - YIN: Receptive, dark, contracting - LOW Ω (form, structure, memory)
 * - YANG: Active, light, expanding - HIGH Ω (energy, transformation, flux)
 * 
 * The S-curve boundary is the INTERFACE where C → δ → R happens continuously.
 * At any point on the boundary, yin is becoming yang or yang is becoming yin.
 * 
 * THE DOTS ARE CRUCIAL: Each half contains a seed of the other. This means:
 * - Maximum yang contains nascent yin (rupture within coherence)
 * - Maximum yin contains nascent yang (regeneration within form)
 * - There is no pure yin or pure yang - polarity implies complementarity
 * 
 * In CRR: exp(C_yin/Ω) and exp(C_yang/Ω) are never zero - each is always
 * present in the regeneration weighting. The dots represent this irreducible
 * presence of the complement within the dominant mode.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * The Taijitu (supreme ultimate diagram) comes from Chinese philosophy
 * spanning Taoism, Confucianism, and Chinese Buddhism. It represents:
 * 
 * NOT OPPOSITION BUT EMBRACE:
 * Yin and yang are not enemies. They are partners in an eternal dance.
 * Dark doesn't fight light; it enables light to be seen.
 * Stillness doesn't oppose movement; it is where movement rests and is born.
 * 
 * THE SEEDS (DOTS):
 * "In the deepest yin, the yang is born. In the fullest yang, yin seeds."
 * At maximum coherence of one polarity, the other begins to emerge. This is:
 * - Midnight births the coming dawn
 * - Summer solstice begins winter's approach  
 * - Full inbreath initiates outbreath
 * - Maximum structure enables transformation
 * - Maximum chaos enables new pattern
 * 
 * THE S-CURVE:
 * The boundary is not straight (pure opposition) but curved (dynamic dance).
 * Each side hugs the other, makes space for the other, is defined BY the other.
 * 
 * WU WEI (effortless action):
 * = Moving along the S-curve, following the natural gradient between coherences
 * rather than forcing straight lines through the field.
 * 
 * In CRR terms: The Yin Yang IS the C → δ → R cycle visualized from above.
 * Coherence (one half) → Rupture (crossing the S) → Regeneration (other half).
 * The whole symbol is ONE PROCESS seen as if frozen in time.
 * The seeds ensure the process never stops - each completion seeds the next.
 */
function generateYinYang(n, scale) {
    const points = [];
    
    // Outer circle - the boundary of the Tao, containing all
    const outerPoints = Math.floor(n * 0.10);
    for (let i = 0; i < outerPoints; i++) {
        const a = (i / outerPoints) * Math.PI * 2;
        points.push([Math.cos(a) * scale, Math.sin(a) * scale]);
    }
    
    // === THE PROPER S-CURVE ===
    // The Yin Yang S-curve is NOT a sine wave - it's TWO SEMICIRCLES:
    // - Upper semicircle: center at (0, +scale/2), radius = scale/2, curving RIGHT
    // - Lower semicircle: center at (0, -scale/2), radius = scale/2, curving LEFT
    // This creates the characteristic "embracing" S shape
    
    const curvePoints = Math.floor(n * 0.12);
    const halfCurve = Math.floor(curvePoints / 2);
    
    // Upper semicircle (yang bulge into yin territory) - curves to the RIGHT
    for (let i = 0; i < halfCurve; i++) {
        const t = (i / halfCurve) * Math.PI; // 0 to π
        const x = Math.sin(t) * scale * 0.5;  // Bulges right (positive x)
        const y = scale * 0.5 - Math.cos(t) * scale * 0.5; // From y=0 to y=scale
        points.push([x, y]);
    }
    
    // Lower semicircle (yin bulge into yang territory) - curves to the LEFT
    for (let i = 0; i < halfCurve; i++) {
        const t = (i / halfCurve) * Math.PI; // 0 to π
        const x = -Math.sin(t) * scale * 0.5;  // Bulges left (negative x)
        const y = -scale * 0.5 + Math.cos(t) * scale * 0.5; // From y=0 to y=-scale
        points.push([x, y]);
    }
    
    // Yang half (light, active, expanding) - RIGHT side, respecting S-curve
    const halfPoints = Math.floor(n * 0.23);
    for (let i = 0; i < halfPoints; i++) {
        const y = (Math.random() * 2 - 1) * scale * 0.95;
        
        // Calculate S-curve boundary at this y value
        let curveX;
        if (y >= 0) {
            // Upper half: semicircle centered at (0, scale/2)
            const dy = y - scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? Math.sqrt(rSq) : 0;
        } else {
            // Lower half: semicircle centered at (0, -scale/2)
            const dy = y + scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? -Math.sqrt(rSq) : 0;
        }
        
        // Yang is to the RIGHT of the S-curve
        const xMin = curveX;
        const xMax = Math.sqrt(Math.max(0, scale * scale - y * y));
        if (xMax > xMin) {
            const x = xMin + Math.random() * (xMax - xMin);
            points.push([x, y]);
        }
    }
    
    // Yin half (dark, receptive, contracting) - LEFT side, respecting S-curve
    for (let i = 0; i < halfPoints; i++) {
        const y = (Math.random() * 2 - 1) * scale * 0.95;
        
        // Calculate S-curve boundary at this y value
        let curveX;
        if (y >= 0) {
            const dy = y - scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? Math.sqrt(rSq) : 0;
        } else {
            const dy = y + scale * 0.5;
            const rSq = (scale * 0.5) * (scale * 0.5) - dy * dy;
            curveX = rSq > 0 ? -Math.sqrt(rSq) : 0;
        }
        
        // Yin is to the LEFT of the S-curve
        const xMax = curveX;
        const xMin = -Math.sqrt(Math.max(0, scale * scale - y * y));
        if (xMax > xMin) {
            const x = xMin + Math.random() * (xMax - xMin);
            points.push([x, y]);
        }
    }
    
    // === THE SEEDS (DOTS) ===
    // Yang seed within yin (upper dot) and Yin seed within yang (lower dot)
    // These should GLOW with concentrated coherence
    
    const seedPoints = Math.floor(n * 0.16);
    
    // Yang seed (light in dark) - at y = +scale*0.5 (center of upper semicircle)
    for (let i = 0; i < seedPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.pow(Math.random(), 0.5) * scale * 0.17;
        points.push([Math.cos(a) * r, scale * 0.5 + Math.sin(a) * r]);
    }
    
    // Yin seed (dark in light) - at y = -scale*0.5 (center of lower semicircle)
    for (let i = 0; i < seedPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.pow(Math.random(), 0.5) * scale * 0.17;
        points.push([Math.cos(a) * r, -scale * 0.5 + Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * OUROBOROS
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * The serpent eating its own tail - END FEEDS BEGINNING. This is the CRR
 * cycle itself visualized: Coherence → Rupture → Regeneration → Coherence...
 * 
 * In CRR terms:
 * - The BODY is coherence C(x,t) - accumulated pattern, integrated history
 * - The MOUTH is rupture δ(now) - consuming, breaking down, the present
 * - The TAIL is regeneration R - what is consumed becomes new body
 * 
 * There is no beginning and no end. The "oldest" part (tail) is continuously
 * becoming the "newest" part (nourishment for growth). exp(C/Ω) weighting
 * means the WHOLE history is present in each moment of consumption.
 * 
 * The mouth-tail junction is where past meets future - the eternal NOW
 * where accumulated coherence transforms into fresh possibility.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * The Ouroboros appears across civilizations:
 * - Ancient Egypt (~1600 BCE): Earliest known depiction
 * - Ancient Greece: Plato's self-sufficient cosmos
 * - Norse: Jörmungandr, world serpent holding reality together
 * - Gnosticism: The cycle of creation and return
 * - Alchemy: Symbol of the opus, the Great Work
 * - Kundalini: Coiled serpent energy at spine's base
 * 
 * It represents:
 * - ETERNAL RETURN: Everything that has been will be again
 * - SELF-SUFFICIENCY: The cosmos needs nothing outside itself
 * - UNITY OF OPPOSITES: Death IS food for life, end IS beginning
 * - THE GREAT RECYCLING: Matter, energy, form - all transformed, nothing lost
 * - SELF-CREATION: The universe creates itself from itself
 * 
 * In alchemy: "Solve et Coagula" - dissolve and coagulate - the serpent
 * dissolves its tail (solve) and coagulates it as body (coagula). Forever.
 * 
 * In Hinduism: Ananta Shesha, the infinite serpent on which Vishnu rests,
 * representing the endless cycle of creation, preservation, destruction.
 * 
 * In CRR terms: The Ouroboros IS the C → δ → R formula made flesh.
 * What we call "death" is rupture. What we call "life" is coherence.
 * What we call "rebirth" is regeneration. The serpent shows these are one.
 * 
 * The MOMENT OF EATING (where mouth meets tail) is δ(now) - the perpetual
 * present where past becomes future, where accumulated pattern transforms
 * into new possibility, where coherence ruptures into regeneration.
 * 
 * "My end is my beginning" - this is the serpent's teaching.
 */
function generateOuroboros(n, scale) {
    const points = [];
    
    // Main ring (serpent body)
    const ringPoints = Math.floor(n * 0.7);
    const bodyWidth = scale * 0.15;
    
    for (let i = 0; i < ringPoints; i++) {
        const t = (i / ringPoints) * Math.PI * 2;
        const r = scale * 0.7;
        
        // Body thickness varies (thinner at tail, wider at head)
        const progress = i / ringPoints;
        const width = bodyWidth * (0.5 + progress * 0.8);
        
        // Offset from center ring
        const offset = (Math.random() - 0.5) * width;
        
        points.push([
            Math.cos(t) * (r + offset),
            Math.sin(t) * (r + offset)
        ]);
    }
    
    // Head (eating the tail)
    const headPoints = Math.floor(n * 0.2);
    const headAngle = 0;
    const headX = Math.cos(headAngle) * scale * 0.7;
    const headY = Math.sin(headAngle) * scale * 0.7;
    
    for (let i = 0; i < headPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.2;
        points.push([headX + Math.cos(a) * r, headY + Math.sin(a) * r]);
    }
    
    // Scales/texture
    const scalePoints = n - points.length;
    for (let i = 0; i < scalePoints; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = scale * 0.7 + (Math.random() - 0.5) * bodyWidth * 0.5;
        points.push([Math.cos(t) * r, Math.sin(t) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * SEED OF LIFE
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Seven circles: one center, six surrounding. This is the MINIMAL coherence
 * pattern from which all sacred geometry grows. Like the first seven days
 * of creation, or the first seven cell divisions of an embryo.
 * 
 * In CRR terms: Each circle is a coherence basin. The center circle is
 * maximum Ω (undifferentiated potential). Each surrounding circle is a
 * DIFFERENTIATION - coherence specializing into distinct modes while
 * maintaining connection to center and neighbours.
 * 
 * The 6-fold symmetry is not arbitrary - it's the most efficient packing
 * of equal circles around a center, the same reason honeycombs are hexagonal.
 * This is nature's minimal-energy solution for coherent tiling.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Genesis: Seven days of creation - light, firmament, land/sea, luminaries,
 *   creatures, humanity, rest. Each day is a circle of coherence.
 * - Cellular: The first seven divisions of a fertilized egg mirror this pattern
 * - Musical: Seven notes of the diatonic scale before the octave returns
 * - Chakras: Seven energy centers along the spine
 * - Days: Seven days of the week, the basic cycle of human time
 */
function generateSeedOfLife(n, scale) {
    const points = [];
    const numCircles = 7;
    const pointsPerCircle = Math.floor(n * 0.85 / numCircles);
    const radius = scale * 0.4;
    
    // Center circle - the first coherence, the seed of all
    for (let i = 0; i < pointsPerCircle; i++) {
        const a = (i / pointsPerCircle) * Math.PI * 2;
        points.push([Math.cos(a) * radius, Math.sin(a) * radius]);
    }
    
    // Six surrounding circles - differentiation from unity
    for (let j = 0; j < 6; j++) {
        const ca = (j / 6) * Math.PI * 2;
        const ccx = Math.cos(ca) * radius;
        const ccy = Math.sin(ca) * radius;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * radius, ccy + Math.sin(a) * radius]);
        }
    }
    
    // Fill vesica regions (areas of overlap - enhanced coherence)
    while (points.length < n) {
        const idx = Math.floor(Math.random() * points.length);
        const noise = 0.015 * scale;
        points.push([
            points[idx][0] + (Math.random() - 0.5) * noise,
            points[idx][1] + (Math.random() - 0.5) * noise
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * FRUIT OF LIFE
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 13 circles arranged in the pattern found within the Flower of Life.
 * When you connect the centers of these 13 circles with straight lines,
 * you get Metatron's Cube. The Fruit is the FEMININE template; Metatron's
 * Cube is the MASCULINE structure that emerges from it.
 * 
 * In CRR: The 13 circles are coherence nodes at maximum potential (pure Ω).
 * The lines of Metatron's Cube are what happens when coherence FLOWS between
 * these nodes - the exp(C/Ω) pathways that regeneration follows.
 * 
 * 13 = 1 center + 6 inner ring + 6 outer ring
 * This is the completion of the generative sequence started by Seed of Life.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Sacred feminine: The matrix from which form crystallizes
 * - 13: Often considered unlucky in patriarchal cultures, but 13 is the
 *   number of lunar cycles per year - the goddess's number
 * - Template: Contains the blueprint for all five Platonic solids
 */
function generateFruitOfLife(n, scale) {
    const points = [];
    const numCircles = 13;
    const pointsPerCircle = Math.floor(n * 0.9 / numCircles);
    const radius = scale * 0.25;
    
    // Center circle
    for (let i = 0; i < pointsPerCircle; i++) {
        const a = (i / pointsPerCircle) * Math.PI * 2;
        points.push([Math.cos(a) * radius, Math.sin(a) * radius]);
    }
    
    // Inner ring - 6 circles
    for (let j = 0; j < 6; j++) {
        const ca = (j / 6) * Math.PI * 2;
        const dist = radius * 2;
        const ccx = Math.cos(ca) * dist;
        const ccy = Math.sin(ca) * dist;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * radius, ccy + Math.sin(a) * radius]);
        }
    }
    
    // Outer ring - 6 circles (offset by 30°)
    for (let j = 0; j < 6; j++) {
        const ca = (j / 6) * Math.PI * 2 + Math.PI / 6;
        const dist = radius * 2 * Math.sqrt(3);
        const ccx = Math.cos(ca) * dist;
        const ccy = Math.sin(ca) * dist;
        for (let i = 0; i < pointsPerCircle; i++) {
            const a = (i / pointsPerCircle) * Math.PI * 2;
            points.push([ccx + Math.cos(a) * radius, ccy + Math.sin(a) * radius]);
        }
    }
    
    // Fill remaining
    while (points.length < n) {
        const idx = Math.floor(Math.random() * points.length);
        const noise = 0.02 * scale;
        points.push([
            points[idx][0] + (Math.random() - 0.5) * noise,
            points[idx][1] + (Math.random() - 0.5) * noise
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * MERKABA (Star Tetrahedron)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Two interpenetrating tetrahedra - one pointing up (masculine, reaching
 * toward sky), one pointing down (feminine, grounding to earth).
 * 
 * In CRR: The upward tetrahedron is HIGH Ω coherence (expansion, transformation).
 * The downward tetrahedron is LOW Ω coherence (structure, form, memory).
 * Their interpenetration creates a STABLE VEHICLE for consciousness -
 * balanced between change and continuity.
 * 
 * The counter-rotation in meditation practices represents the C → δ → R cycle:
 * one direction accumulates coherence, the other releases through rupture,
 * and the intersection is continuous regeneration.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Hebrew: Merkaba = "chariot" - the throne-chariot of God in Ezekiel's vision
 * - Egyptian: The Mer-Ka-Ba - Mer (light), Ka (spirit), Ba (body)
 * - Meditation: Visualizing counter-rotating fields to activate light body
 * - 3D Star of David: The union of opposites in dynamic balance
 */
function generateMerkaba(n, scale) {
    const points = [];
    
    // Tetrahedron vertices (up-pointing)
    const h = Math.sqrt(2/3);
    const upVerts = [
        [0, -scale * h * 0.8],                          // top
        [-scale * 0.7, scale * h * 0.4],                // bottom left
        [scale * 0.7, scale * h * 0.4]                  // bottom right
    ];
    
    // Tetrahedron vertices (down-pointing, rotated 60°)
    const downVerts = [
        [0, scale * h * 0.8],                           // bottom
        [-scale * 0.7, -scale * h * 0.4],               // top left
        [scale * 0.7, -scale * h * 0.4]                 // top right
    ];
    
    const edgePoints = Math.floor(n * 0.8 / 6);
    
    // Draw up-pointing triangle edges
    for (let e = 0; e < 3; e++) {
        const [x1, y1] = upVerts[e];
        const [x2, y2] = upVerts[(e + 1) % 3];
        for (let i = 0; i < edgePoints; i++) {
            const t = i / edgePoints;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Draw down-pointing triangle edges
    for (let e = 0; e < 3; e++) {
        const [x1, y1] = downVerts[e];
        const [x2, y2] = downVerts[(e + 1) % 3];
        for (let i = 0; i < edgePoints; i++) {
            const t = i / edgePoints;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Fill center hexagonal region (intersection of triangles)
    const centerPoints = n - points.length;
    for (let i = 0; i < centerPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.35;
        points.push([Math.cos(a) * r, Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * ICOSAHEDRON (Water Element)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 20 equilateral triangular faces, 12 vertices, 30 edges. The Platonic solid
 * with the most faces, closest to a sphere. In elemental theory: WATER.
 * 
 * In CRR: The icosahedron represents MAXIMUM COHERENCE DISTRIBUTION across
 * surface - no point is far from any other. This is why it maps to water:
 * fluid coherence, emotional flow, the ability to take any shape while
 * maintaining internal connection.
 * 
 * The 5-fold symmetry at each vertex connects to φ (golden ratio), linking
 * icosahedron to organic growth patterns and Fibonacci sequences.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Plato: "The form of the icosahedron is assigned to water, because water
 *   is the most mobile and fluid of the elements."
 * - Water of Life: Baptism, purification, emotional cleansing
 * - Subconscious: Water symbolizes the unconscious depths
 */
function generateIcosahedron(n, scale) {
    const points = [];
    const phi = (1 + Math.sqrt(5)) / 2;
    
    // 12 vertices of icosahedron
    const verts = [
        [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],
        [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],
        [phi, 0, 1], [-phi, 0, 1], [phi, 0, -1], [-phi, 0, -1]
    ].map(([x, y, z]) => {
        const len = Math.sqrt(x*x + y*y + z*z);
        return [x/len * scale, y/len * scale, z/len * scale];
    });
    
    // 30 edges
    const edges = [
        [0,1], [0,4], [0,5], [0,8], [0,9],
        [1,6], [1,7], [1,8], [1,9],
        [2,3], [2,4], [2,5], [2,10], [2,11],
        [3,6], [3,7], [3,10], [3,11],
        [4,5], [4,8], [4,10],
        [5,9], [5,11],
        [6,7], [6,8], [6,10],
        [7,9], [7,11],
        [8,10], [9,11]
    ];
    
    const pointsPerEdge = Math.floor(n * 0.9 / edges.length);
    
    // Project 3D to 2D with rotation
    const project = (x, y, z) => {
        const rx = x * 0.866 + z * 0.5;
        const ry = y;
        return [rx, ry];
    };
    
    for (const [i, j] of edges) {
        const [x1, y1, z1] = verts[i];
        const [x2, y2, z2] = verts[j];
        for (let k = 0; k < pointsPerEdge; k++) {
            const t = k / pointsPerEdge;
            const [px, py] = project(
                x1 * (1-t) + x2 * t,
                y1 * (1-t) + y2 * t,
                z1 * (1-t) + z2 * t
            );
            points.push([px, py]);
        }
    }
    
    // Fill vertices more densely
    while (points.length < n) {
        const [x, y, z] = verts[Math.floor(Math.random() * 12)];
        const [px, py] = project(x, y, z);
        const noise = scale * 0.03;
        points.push([px + (Math.random()-0.5)*noise, py + (Math.random()-0.5)*noise]);
    }
    
    return points.slice(0, n);
}

/**
 * DODECAHEDRON (Aether/Universe Element)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 12 pentagonal faces, 20 vertices, 30 edges. The only Platonic solid with
 * pentagonal faces. In elemental theory: AETHER (quintessence, spirit, cosmos).
 * 
 * In CRR: The pentagon's inherent connection to φ means the dodecahedron
 * embodies RECURSIVE SELF-SIMILARITY - each part reflects the whole.
 * This is why Plato assigned it to the cosmos: the universe is self-similar
 * at every scale, coherence patterns repeating from quantum to cosmic.
 * 
 * The dodecahedron is dual to the icosahedron: if you connect the centers
 * of icosahedron faces, you get a dodecahedron. Water and Spirit interconvert.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Plato: "The fifth element is used for embroidering the heavens with
 *   constellations." The dodecahedron = the shape of the cosmos.
 * - 12 faces = 12 zodiac signs, 12 months, 12 apostles
 * - Pentagons = the shape of life (starfish, flowers)
 */
function generateDodecahedron(n, scale) {
    const points = [];
    const phi = (1 + Math.sqrt(5)) / 2;
    const invPhi = 1 / phi;
    
    // 20 vertices of dodecahedron
    const verts = [
        // Cube vertices
        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
        // Rectangle vertices
        [0, phi, invPhi], [0, phi, -invPhi], [0, -phi, invPhi], [0, -phi, -invPhi],
        [invPhi, 0, phi], [-invPhi, 0, phi], [invPhi, 0, -phi], [-invPhi, 0, -phi],
        [phi, invPhi, 0], [phi, -invPhi, 0], [-phi, invPhi, 0], [-phi, -invPhi, 0]
    ].map(([x, y, z]) => {
        const len = Math.sqrt(x*x + y*y + z*z);
        return [x/len * scale * 0.8, y/len * scale * 0.8, z/len * scale * 0.8];
    });
    
    // 30 edges (connecting vertices within edge distance)
    const edges = [];
    const edgeLenSq = (2 / phi) * (2 / phi);
    for (let i = 0; i < verts.length; i++) {
        for (let j = i + 1; j < verts.length; j++) {
            const [x1, y1, z1] = verts[i];
            const [x2, y2, z2] = verts[j];
            const dx = x2-x1, dy = y2-y1, dz = z2-z1;
            const distSq = (dx*dx + dy*dy + dz*dz) / (scale * scale * 0.64);
            if (distSq < edgeLenSq + 0.1 && distSq > edgeLenSq - 0.1) {
                edges.push([i, j]);
            }
        }
    }
    
    const pointsPerEdge = Math.floor(n * 0.9 / Math.max(edges.length, 30));
    
    const project = (x, y, z) => {
        const rx = x * 0.866 + z * 0.5;
        const ry = y;
        return [rx, ry];
    };
    
    for (const [i, j] of edges) {
        const [x1, y1, z1] = verts[i];
        const [x2, y2, z2] = verts[j];
        for (let k = 0; k < pointsPerEdge; k++) {
            const t = k / pointsPerEdge;
            const [px, py] = project(
                x1 * (1-t) + x2 * t,
                y1 * (1-t) + y2 * t,
                z1 * (1-t) + z2 * t
            );
            points.push([px, py]);
        }
    }
    
    // Fill vertices
    while (points.length < n) {
        const [x, y, z] = verts[Math.floor(Math.random() * verts.length)];
        const [px, py] = project(x, y, z);
        const noise = scale * 0.02;
        points.push([px + (Math.random()-0.5)*noise, py + (Math.random()-0.5)*noise]);
    }
    
    return points.slice(0, n);
}

/**
 * TETRAHEDRON (Fire Element)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 4 triangular faces, 4 vertices, 6 edges. The SIMPLEST Platonic solid -
 * the minimum vertices needed to enclose 3D space. Element: FIRE.
 * 
 * In CRR: The tetrahedron represents MINIMAL COHERENCE STRUCTURE - the
 * simplest configuration that creates enclosed space. Fire is transformation,
 * the rupture δ(now) that breaks down complex forms into simpler components.
 * 
 * The tetrahedron is self-dual: connecting face centers gives another
 * tetrahedron. Fire transforms, but the essence of transformation is
 * invariant - rupture itself is a stable pattern.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Plato: "Fire is the most mobile and piercing of the elements."
 * - 4 = stability (4 directions, 4 seasons, 4 elements)
 * - Sharpest solid: points are weapons, transformation is not gentle
 */
function generateTetrahedron(n, scale) {
    const points = [];
    
    // Regular tetrahedron vertices
    const verts = [
        [0, -scale * 0.8, 0],
        [-scale * 0.75, scale * 0.4, -scale * 0.4],
        [scale * 0.75, scale * 0.4, -scale * 0.4],
        [0, scale * 0.4, scale * 0.8]
    ];
    
    const edges = [[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]];
    const pointsPerEdge = Math.floor(n * 0.85 / 6);
    
    const project = (x, y, z) => [x + z * 0.3, y + z * 0.1];
    
    for (const [i, j] of edges) {
        const [x1, y1, z1] = verts[i];
        const [x2, y2, z2] = verts[j];
        for (let k = 0; k < pointsPerEdge; k++) {
            const t = k / pointsPerEdge;
            const [px, py] = project(
                x1 * (1-t) + x2 * t,
                y1 * (1-t) + y2 * t,
                z1 * (1-t) + z2 * t
            );
            points.push([px, py]);
        }
    }
    
    // Fill faces lightly
    while (points.length < n) {
        const faceIdx = Math.floor(Math.random() * 4);
        const faceVerts = [[1,2,3], [0,2,3], [0,1,3], [0,1,2]][faceIdx];
        const u = Math.random(), v = Math.random() * (1 - u);
        const w = 1 - u - v;
        const [i, j, k] = faceVerts;
        const x = verts[i][0]*u + verts[j][0]*v + verts[k][0]*w;
        const y = verts[i][1]*u + verts[j][1]*v + verts[k][1]*w;
        const z = verts[i][2]*u + verts[j][2]*v + verts[k][2]*w;
        const [px, py] = project(x, y, z);
        points.push([px, py]);
    }
    
    return points.slice(0, n);
}

/**
 * OCTAHEDRON (Air Element)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 8 triangular faces, 6 vertices, 12 edges. Dual to the cube.
 * Element: AIR.
 * 
 * In CRR: Air is the MEDIATOR between fire and water, between transformation
 * and flow. The octahedron's symmetry (same from above, below, and all sides)
 * represents balanced coherence - no direction privileged.
 * 
 * The octahedron can be seen as two pyramids base-to-base: one reaching up
 * (spirit), one reaching down (matter). Air moves between heaven and earth.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Plato: "Air is intermediate in mobility and penetrability."
 * - Breath: Prana, ruach, spiritus - the breath of life is air
 * - 6 vertices = 6 directions (N, S, E, W, Up, Down)
 */
function generateOctahedron(n, scale) {
    const points = [];
    
    // 6 vertices
    const verts = [
        [0, -scale * 0.9, 0],  // top
        [0, scale * 0.9, 0],   // bottom
        [-scale * 0.7, 0, 0],  // left
        [scale * 0.7, 0, 0],   // right
        [0, 0, -scale * 0.7],  // back
        [0, 0, scale * 0.7]    // front
    ];
    
    const edges = [
        [0,2], [0,3], [0,4], [0,5],
        [1,2], [1,3], [1,4], [1,5],
        [2,4], [2,5], [3,4], [3,5]
    ];
    
    const pointsPerEdge = Math.floor(n * 0.85 / 12);
    
    const project = (x, y, z) => [x + z * 0.35, y + z * 0.15];
    
    for (const [i, j] of edges) {
        const [x1, y1, z1] = verts[i];
        const [x2, y2, z2] = verts[j];
        for (let k = 0; k < pointsPerEdge; k++) {
            const t = k / pointsPerEdge;
            const [px, py] = project(
                x1 * (1-t) + x2 * t,
                y1 * (1-t) + y2 * t,
                z1 * (1-t) + z2 * t
            );
            points.push([px, py]);
        }
    }
    
    // Fill vertices
    while (points.length < n) {
        const idx = Math.floor(Math.random() * 6);
        const [x, y, z] = verts[idx];
        const [px, py] = project(x, y, z);
        const noise = scale * 0.04;
        points.push([px + (Math.random()-0.5)*noise, py + (Math.random()-0.5)*noise]);
    }
    
    return points.slice(0, n);
}

/**
 * CUBE / HEXAHEDRON (Earth Element)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 6 square faces, 8 vertices, 12 edges. The most STABLE Platonic solid,
 * the only one that tiles 3D space without gaps. Element: EARTH.
 * 
 * In CRR: The cube represents LOW Ω - crystallized coherence, form locked
 * into place. Each face is a boundary (Markov blanket) separating inside
 * from outside. The cube is what remains when transformation (fire) has
 * been fully integrated into stable structure.
 * 
 * The cube tiles infinitely - coherence patterns that stack and replicate.
 * This is maybe why crystals form: minimal-energy coherence = cubic/hexagonal.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Plato: "Earth is the most stable and least mobile element."
 * - Kaaba: The sacred cube at the center of Mecca
 * - Salt crystals: The "alchemical earth" - purified matter
 * - Foundation: Buildings rest on cubic foundations
 */
function generateCube(n, scale) {
    const points = [];
    const s = scale * 0.65;
    
    // 8 vertices
    const verts = [
        [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
        [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
    ];
    
    const edges = [
        [0,1], [1,2], [2,3], [3,0],  // back face
        [4,5], [5,6], [6,7], [7,4],  // front face
        [0,4], [1,5], [2,6], [3,7]   // connecting edges
    ];
    
    const pointsPerEdge = Math.floor(n * 0.85 / 12);
    
    const project = (x, y, z) => [x + z * 0.4, y + z * 0.25];
    
    for (const [i, j] of edges) {
        const [x1, y1, z1] = verts[i];
        const [x2, y2, z2] = verts[j];
        for (let k = 0; k < pointsPerEdge; k++) {
            const t = k / pointsPerEdge;
            const [px, py] = project(
                x1 * (1-t) + x2 * t,
                y1 * (1-t) + y2 * t,
                z1 * (1-t) + z2 * t
            );
            points.push([px, py]);
        }
    }
    
    // Fill vertices
    while (points.length < n) {
        const idx = Math.floor(Math.random() * 8);
        const [x, y, z] = verts[idx];
        const [px, py] = project(x, y, z);
        const noise = scale * 0.035;
        points.push([px + (Math.random()-0.5)*noise, py + (Math.random()-0.5)*noise]);
    }
    
    return points.slice(0, n);
}

/**
 * 64 TETRAHEDRON GRID (Isotropic Vector Matrix)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Buckminster Fuller's "Isotropic Vector Matrix" - the geometry of space
 * itself. 64 tetrahedra arranged in perfect equilibrium, with octahedra
 * in the interstices. This is the GROUND STATE of spatial coherence.
 * 
 * In CRR: 64 = 2^6, the number of hexagrams in the I Ching. Each tetrahedron
 * is a minimal coherence unit; their arrangement is the lowest-energy
 * configuration. This is what remains when all forces balance: pure structure.
 * 
 * The 12-vector equilibrium at each vertex (Vector Equilibrium / Cuboctahedron)
 * represents perfect balance - all vectors equal length, equal angle.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Fuller: "The coordinate system of the universe"
 * - 64 hexagrams: The I Ching's complete set of transformations
 * - Vacuum geometry: Nassim Haramein's unified field theory
 */
function generate64TetrahedronGrid(n, scale) {
    const points = [];
    const s = scale * 0.18;
    
    // Create a grid of points based on close-packed spheres / IVM
    const layers = 4;
    const gridPoints = [];
    
    for (let layer = -layers; layer <= layers; layer++) {
        for (let row = -layers; row <= layers; row++) {
            for (let col = -layers; col <= layers; col++) {
                // FCC lattice coordinates
                const x = col * s + (row % 2) * s * 0.5 + (layer % 2) * s * 0.5;
                const y = row * s * 0.866 + (layer % 2) * s * 0.289;
                const z = layer * s * 0.816;
                
                const dist = Math.sqrt(x*x + y*y + z*z);
                if (dist < scale * 0.95) {
                    gridPoints.push([x, y, z]);
                }
            }
        }
    }
    
    // Project and connect nearby points
    const project = (x, y, z) => [x + z * 0.35, y + z * 0.2];
    
    // Draw edges between close points
    const edgeLenSq = s * s * 1.1;
    let edgeCount = 0;
    const maxEdges = n * 0.8;
    
    for (let i = 0; i < gridPoints.length && edgeCount < maxEdges; i++) {
        for (let j = i + 1; j < gridPoints.length && edgeCount < maxEdges; j++) {
            const [x1, y1, z1] = gridPoints[i];
            const [x2, y2, z2] = gridPoints[j];
            const dx = x2-x1, dy = y2-y1, dz = z2-z1;
            const distSq = dx*dx + dy*dy + dz*dz;
            
            if (distSq < edgeLenSq) {
                const steps = 8;
                for (let k = 0; k < steps; k++) {
                    const t = k / steps;
                    const [px, py] = project(
                        x1 * (1-t) + x2 * t,
                        y1 * (1-t) + y2 * t,
                        z1 * (1-t) + z2 * t
                    );
                    points.push([px, py]);
                    edgeCount++;
                }
            }
        }
    }
    
    // Fill vertices
    while (points.length < n) {
        const [x, y, z] = gridPoints[Math.floor(Math.random() * gridPoints.length)];
        const [px, py] = project(x, y, z);
        const noise = s * 0.15;
        points.push([px + (Math.random()-0.5)*noise, py + (Math.random()-0.5)*noise]);
    }
    
    return points.slice(0, n);
}

/**
 * ENNEAGRAM
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 9 points on a circle, connected by specific internal lines. Introduced to
 * the West by G.I. Gurdjieff as a symbol of cosmic process.
 * 
 * In CRR: The 9 points represent 9 phases of the C → δ → R cycle at
 * different resolutions. The internal lines (the 142857 sequence and the
 * triangle 369) show how coherence flows between phases:
 * - Triangle (3-6-9): The "shock points" where external intervention
 *   can redirect the process - these are the δ(now) moments
 * - Hexad (1-4-2-8-5-7): The natural flow of coherence when uninterrupted
 * 
 * The enneagram encodes 1/7 = 0.142857... (repeating). This connects to
 * musical octaves: the points where "shocks" are needed to complete the scale.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Gurdjieff: Symbol of perpetual motion, the law of seven, the law of three
 * - Personality types: The modern Enneagram of Personality uses this figure
 * - Process: Any complete process (digestion, creation, evolution) follows
 *   the enneagram's flow
 */
function generateEnneagram(n, scale) {
    const points = [];
    const r = scale * 0.85;
    
    // 9 points on circle (starting from top, going clockwise)
    const vertices = [];
    for (let i = 0; i < 9; i++) {
        const a = -Math.PI/2 + (i / 9) * Math.PI * 2;
        vertices.push([Math.cos(a) * r, Math.sin(a) * r]);
    }
    
    // Outer circle
    const circlePoints = Math.floor(n * 0.25);
    for (let i = 0; i < circlePoints; i++) {
        const a = (i / circlePoints) * Math.PI * 2;
        points.push([Math.cos(a) * r, Math.sin(a) * r]);
    }
    
    // Triangle (3-6-9) - the law of three
    const triangleEdges = [[2, 5], [5, 8], [8, 2]]; // 0-indexed: 3=2, 6=5, 9=8
    const trianglePoints = Math.floor(n * 0.15);
    const ptsPerTriEdge = Math.floor(trianglePoints / 3);
    for (const [i, j] of triangleEdges) {
        const [x1, y1] = vertices[i];
        const [x2, y2] = vertices[j];
        for (let k = 0; k < ptsPerTriEdge; k++) {
            const t = k / ptsPerTriEdge;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Hexad (1-4-2-8-5-7) - the law of seven
    const hexadOrder = [0, 3, 1, 7, 4, 6]; // 0-indexed: 1=0, 4=3, 2=1, 8=7, 5=4, 7=6
    const hexadEdges = [];
    for (let i = 0; i < 6; i++) {
        hexadEdges.push([hexadOrder[i], hexadOrder[(i+1) % 6]]);
    }
    const hexadPoints = Math.floor(n * 0.35);
    const ptsPerHexEdge = Math.floor(hexadPoints / 6);
    for (const [i, j] of hexadEdges) {
        const [x1, y1] = vertices[i];
        const [x2, y2] = vertices[j];
        for (let k = 0; k < ptsPerHexEdge; k++) {
            const t = k / ptsPerHexEdge;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Fill vertices with concentration
    while (points.length < n) {
        const idx = Math.floor(Math.random() * 9);
        const [vx, vy] = vertices[idx];
        const noise = scale * 0.04;
        points.push([vx + (Math.random()-0.5)*noise, vy + (Math.random()-0.5)*noise]);
    }
    
    return points.slice(0, n);
}

/**
 * LABYRINTH (Cretan/Classical 7-Circuit)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * A single, winding path from entrance to center and back. Unlike a maze,
 * there are NO CHOICES - you simply follow the path. Yet you cannot see
 * where you're going, cannot shortcut, must trust the process.
 * 
 * In CRR: The labyrinth is COHERENCE AS JOURNEY. Each circuit is a layer
 * of accumulated coherence C(x,t). As you walk inward, coherence deepens.
 * The center is the δ(now) moment - the rupture of arriving, the 
 * transformation at the heart. Walking out is regeneration R, carrying
 * the center's transformation back through each layer.
 * 
 * The 7 circuits correspond to: 7 chakras, 7 days, 7 classical planets.
 * The path crosses the axis 14 times (7 in, 7 out) - lunar fortnight.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Cretan: The labyrinth of King Minos, home of the Minotaur
 * - Chartres: The 11-circuit labyrinth in Chartres Cathedral
 * - Walking meditation: The path as spiritual practice
 * - Birth canal: The journey into and out of matter
 */
function generateLabyrinth(n, scale) {
    const points = [];
    const circuits = 7;
    const r = scale * 0.9;
    const gap = r / (circuits + 1);
    
    // Classical labyrinth pattern - alternating half-circuits
    const pathPoints = Math.floor(n * 0.95);
    let totalLen = 0;
    
    // Calculate total path length first
    for (let c = 0; c < circuits; c++) {
        totalLen += Math.PI * (gap * (c + 1));
    }
    totalLen *= 2; // Both halves
    
    const ptsPerUnit = pathPoints / totalLen;
    
    // Draw the labyrinth path
    // This is a simplified classical labyrinth pattern
    for (let c = circuits; c >= 1; c--) {
        const radius = gap * c;
        const arcLen = Math.PI * radius;
        const arcPts = Math.floor(arcLen * ptsPerUnit);
        
        // Upper half-circle (right side)
        if (c % 2 === 1) {
            for (let i = 0; i < arcPts; i++) {
                const a = -Math.PI/2 + (i / arcPts) * Math.PI;
                points.push([Math.cos(a) * radius, Math.sin(a) * radius]);
            }
        }
        // Lower half-circle (left side)
        else {
            for (let i = 0; i < arcPts; i++) {
                const a = Math.PI/2 + (i / arcPts) * Math.PI;
                points.push([Math.cos(a) * radius, Math.sin(a) * radius]);
            }
        }
    }
    
    // Connecting vertical paths
    const vertPoints = Math.floor(n * 0.03);
    for (let c = 1; c <= circuits; c++) {
        const y1 = gap * c;
        const y2 = gap * (c - 1);
        for (let i = 0; i < vertPoints / circuits; i++) {
            const t = i / (vertPoints / circuits);
            const side = c % 2 === 0 ? 1 : -1;
            points.push([side * gap * 0.1, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Center point
    while (points.length < n) {
        const a = Math.random() * Math.PI * 2;
        const rr = Math.random() * gap * 0.5;
        points.push([Math.cos(a) * rr, Math.sin(a) * rr]);
    }
    
    return points.slice(0, n);
}

/**
 * TORUS KNOT (p=2, q=3 Trefoil)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * A knot that lies on the surface of a torus - the simplest non-trivial knot.
 * The (2,3) torus knot (trefoil) winds 2 times around the hole while looping
 * 3 times through it.
 * 
 * In CRR: The torus knot is COHERENCE ENTANGLED WITH ITSELF. The path
 * crosses over and under, yet never breaks. This is how memory works in
 * CRR: past coherence is woven through present, distinct yet connected.
 * 
 * The 2/3 ratio connects to the harmonic fifth in music, the most consonant
 * interval after the octave. The knot is harmony made visible.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Mathematical: The simplest prime knot, irreducible
 * - Topological: Cannot be unknotted without cutting
 * - Knotwork: Celtic, Islamic, and Buddhist art all feature endless knots
 */
function generateTorusKnot(n, scale) {
    const points = [];
    const p = 2, q = 3; // Trefoil parameters
    const R = scale * 0.6;  // Major radius
    const r = scale * 0.25; // Minor radius
    
    for (let i = 0; i < n; i++) {
        const t = (i / n) * Math.PI * 2 * p;
        
        // Torus knot parametric equations
        const phi = t;
        const theta = q * t / p;
        
        const x = (R + r * Math.cos(theta)) * Math.cos(phi);
        const y = (R + r * Math.cos(theta)) * Math.sin(phi);
        const z = r * Math.sin(theta);
        
        // Project with slight rotation
        const px = x * 0.9 + z * 0.3;
        const py = y;
        
        points.push([px, py]);
    }
    
    return points;
}

/**
 * ROSE (Rhodonea Curve)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Mathematical roses: r = cos(kθ). When k is rational, the curve closes
 * and forms petals. These are RESONANCE PATTERNS - coherence manifesting
 * as discrete harmonic modes.
 * 
 * In CRR: The number of petals depends on k = p/q (fraction in lowest terms):
 * - k integer: k petals if k odd, 2k petals if k even
 * - k rational: (p+q) petals if both odd, 2(p+q) if one even
 * 
 * This connects to standing waves, orbital resonances, and the discrete
 * energy levels of quantum mechanics. Beauty from simple ratios.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Rose symbolism: Love, secrecy (sub rosa), the Virgin Mary
 * - Fibonacci in nature: Many flowers have Fibonacci petal counts
 * - Harmony: Simple ratios create beautiful forms
 */
function generateRose(n, scale) {
    const points = [];
    const k = 5; // 5-petaled rose
    
    for (let i = 0; i < n; i++) {
        const theta = (i / n) * Math.PI * 2 * 2; // Two full rotations for full coverage
        const r = scale * 0.85 * Math.cos(k * theta);
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        points.push([x, y]);
    }
    
    return points;
}

/**
 * GORDIAN KNOT
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Legend: Whoever could untie the Gordian Knot would rule Asia. Alexander
 * the Great "untied" it by cutting it with his sword. Solution by reframing.
 * 
 * In CRR: The Gordian Knot represents COMPLEXITY FROM SIMPLE RULES - many
 * loops of coherence layered upon each other until the structure seems
 * impossibly tangled. Yet the "cut" is δ(now) - the rupture that dissolves
 * the accumulated pattern, allowing regeneration into simpler form.
 * 
 * Sometimes the highest coherence action is NOT to maintain the pattern,
 * but to allow its rupture. Wisdom is knowing when to untie, when to cut.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * - Lateral thinking: Sometimes the rules themselves must be questioned
 * - Karma: Accumulated tangles that seem impossible to unravel
 * - Zen: The koan that cannot be solved by logic alone
 */
function generateGordianKnot(n, scale) {
    const points = [];
    
    // Multiple overlapping loops creating complex tangle
    const loops = 7;
    const pointsPerLoop = Math.floor(n / loops);
    
    for (let loop = 0; loop < loops; loop++) {
        const phase = loop * Math.PI * 2 / 7;
        const tilt = (loop - 3) * 0.3;
        const loopScale = scale * (0.4 + loop * 0.08);
        
        for (let i = 0; i < pointsPerLoop; i++) {
            const t = (i / pointsPerLoop) * Math.PI * 2;
            
            // Lissajous-like curves for each loop
            const a = 3 + (loop % 3);
            const b = 2 + (loop % 2);
            
            const x = loopScale * Math.sin(a * t + phase) * 0.8;
            const y = loopScale * Math.sin(b * t + tilt) * 0.8;
            
            points.push([x, y]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * TESSERACT (Hypercube)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * The 4D cube projected into 2D. Each vertex exists in a higher dimension -
 * coherence that transcends our perceptual plane. The "inner cube" isn't
 * smaller - it's further away in the 4th dimension.
 * 
 * CRR predicts: Systems with higher-dimensional coherence (more state variables)
 * can access transformation paths invisible to lower-dimensional observers.
 * The tesseract shows these hidden connections - edges crossing through
 * hyperspace, linking what appears separate in 3D.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * The tesseract represents:
 * - ACCESS TO HIGHER DIMENSIONS: Consciousness transcending 3D limits
 * - HIDDEN CONNECTIONS: What seems separate is unified in higher space
 * - THE COSMIC CUBE: Container of reality itself
 * - FOLD SPACE: The mystical ability to be in two places at once
 */
function generateTesseract(n, scale) {
    const points = [];
    
    // 16 vertices of a 4D hypercube
    const vertices4D = [];
    for (let i = 0; i < 16; i++) {
        vertices4D.push([
            (i & 1) ? 1 : -1,
            (i & 2) ? 1 : -1,
            (i & 4) ? 1 : -1,
            (i & 8) ? 1 : -1
        ]);
    }
    
    // 32 edges - connect vertices differing in exactly one coordinate
    const edges = [];
    for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
            let diff = 0;
            for (let k = 0; k < 4; k++) {
                if (vertices4D[i][k] !== vertices4D[j][k]) diff++;
            }
            if (diff === 1) edges.push([i, j]);
        }
    }
    
    const pointsPerEdge = Math.floor(n * 0.8 / edges.length);
    const pointsPerVertex = Math.floor(n * 0.2 / 16);
    
    // Project 4D to 2D with rotation
    const project = (v4) => {
        const angle1 = Math.PI * 0.15;
        const angle2 = Math.PI * 0.1;
        
        let x = v4[0] * Math.cos(angle1) - v4[3] * Math.sin(angle1);
        let w = v4[0] * Math.sin(angle1) + v4[3] * Math.cos(angle1);
        let y = v4[1] * Math.cos(angle2) - v4[2] * Math.sin(angle2);
        
        const d = 3;
        const persp = d / (d - w);
        return [x * persp * scale * 0.4, y * persp * scale * 0.4];
    };
    
    for (const [i, j] of edges) {
        const p1 = project(vertices4D[i]);
        const p2 = project(vertices4D[j]);
        
        for (let t = 0; t < pointsPerEdge; t++) {
            const tt = t / pointsPerEdge;
            points.push([p1[0] * (1 - tt) + p2[0] * tt, p1[1] * (1 - tt) + p2[1] * tt]);
        }
    }
    
    for (let i = 0; i < 16; i++) {
        const [px, py] = project(vertices4D[i]);
        for (let j = 0; j < pointsPerVertex; j++) {
            const a = Math.random() * Math.PI * 2;
            const r = Math.random() * scale * 0.04;
            points.push([px + Math.cos(a) * r, py + Math.sin(a) * r]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * STAR OF DAVID (Hexagram)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Two interlocking equilateral triangles - one pointing up (toward spirit),
 * one pointing down (toward matter). Their intersection creates a hexagonal
 * coherence field at the center.
 * 
 * - ASCENDING TRIANGLE: Coherence moving from manifestation toward unity
 * - DESCENDING TRIANGLE: Coherence differentiating into multiplicity
 * - INTERSECTION: The balanced state where ascent and descent harmonize
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Known as Magen David, Shatkona (Hindu), representing perfect balance -
 * "As above, so below" - masculine/feminine, fire/water unified.
 */
function generateStarOfDavid(n, scale) {
    const points = [];
    const trianglePoints = Math.floor(n * 0.7 / 2);
    
    // Upward triangle
    for (let edge = 0; edge < 3; edge++) {
        const a1 = -Math.PI/2 + (edge * 2 * Math.PI / 3);
        const a2 = -Math.PI/2 + ((edge + 1) * 2 * Math.PI / 3);
        const x1 = Math.cos(a1) * scale, y1 = Math.sin(a1) * scale;
        const x2 = Math.cos(a2) * scale, y2 = Math.sin(a2) * scale;
        
        const edgePoints = Math.floor(trianglePoints / 3);
        for (let i = 0; i < edgePoints; i++) {
            const t = i / edgePoints;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Downward triangle
    for (let edge = 0; edge < 3; edge++) {
        const a1 = Math.PI/2 + (edge * 2 * Math.PI / 3);
        const a2 = Math.PI/2 + ((edge + 1) * 2 * Math.PI / 3);
        const x1 = Math.cos(a1) * scale, y1 = Math.sin(a1) * scale;
        const x2 = Math.cos(a2) * scale, y2 = Math.sin(a2) * scale;
        
        const edgePoints = Math.floor(trianglePoints / 3);
        for (let i = 0; i < edgePoints; i++) {
            const t = i / edgePoints;
            points.push([x1 * (1-t) + x2 * t, y1 * (1-t) + y2 * t]);
        }
    }
    
    // Central hexagon fill
    const hexPoints = n - points.length;
    for (let i = 0; i < hexPoints; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.5;
        points.push([Math.cos(a) * r, Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * ANKH (Key of Life)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * The Egyptian hieroglyph for "life" - loop (eternity) meets cross (matter).
 * Where they join is where coherence transforms between eternal and temporal.
 * 
 * - LOOP: C(t) cycling endlessly, memory that never decays
 * - VERTICAL BAR: Spirit descending into matter
 * - HORIZONTAL BAR: The plane of earthly existence
 * - JUNCTION: δ(now) - where eternity touches time
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Held by gods to offer life; received by pharaohs at coronation.
 * The key that unlocks gates between worlds.
 */
function generateAnkh(n, scale) {
    const points = [];
    
    // Loop at top
    const loopPoints = Math.floor(n * 0.35);
    const loopR = scale * 0.35;
    const loopCY = -scale * 0.35;
    
    for (let i = 0; i < loopPoints; i++) {
        const t = (i / loopPoints) * Math.PI * 2;
        const rx = loopR * 0.85;
        const ry = loopR;
        const r = Math.random() * 0.15 * loopR + 0.85 * loopR;
        const rRatio = r / loopR;
        points.push([Math.cos(t) * rx * rRatio, loopCY + Math.sin(t) * ry * rRatio]);
    }
    
    // Vertical bar
    const barPoints = Math.floor(n * 0.30);
    const barTop = loopCY + loopR;
    const barBottom = scale * 0.9;
    const barWidth = scale * 0.12;
    
    for (let i = 0; i < barPoints; i++) {
        const y = barTop + (i / barPoints) * (barBottom - barTop);
        const x = (Math.random() - 0.5) * barWidth;
        points.push([x, y]);
    }
    
    // Horizontal bar
    const armPoints = Math.floor(n * 0.25);
    const armY = scale * 0.1;
    
    for (let i = 0; i < armPoints; i++) {
        const x = (Math.random() - 0.5) * scale * 0.65;
        const y = armY + (Math.random() - 0.5) * scale * 0.12;
        points.push([x, y]);
    }
    
    while (points.length < n) {
        const x = (Math.random() - 0.5) * barWidth * 1.5;
        const y = loopCY + loopR + Math.random() * scale * 0.2;
        points.push([x, y]);
    }
    
    return points.slice(0, n);
}

/**
 * CADUCEUS
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Two serpents spiral around a central staff, meeting at each crossing.
 * This is CRR dynamics made visible: intertwined coherence streams,
 * repeatedly crossing through rupture points, regenerating in new phase.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Hermes' staff, Kundalini's Ida and Pingala, the DNA helix anticipated.
 * Balance through dynamic opposition.
 */
function generateCaduceus(n, scale) {
    const points = [];
    
    // Central staff
    const staffPoints = Math.floor(n * 0.15);
    for (let i = 0; i < staffPoints; i++) {
        const y = -scale * 0.95 + (i / staffPoints) * scale * 1.9;
        const x = (Math.random() - 0.5) * scale * 0.06;
        points.push([x, y]);
    }
    
    // Two serpents
    const turns = 4;
    const serpentPoints = Math.floor(n * 0.30);
    
    for (let i = 0; i < serpentPoints; i++) {
        const t = (i / serpentPoints) * turns * Math.PI * 2;
        const y = -scale * 0.76 + (i / serpentPoints) * scale * 1.62;
        const amplitude = scale * 0.25 * (1 - Math.pow(i / serpentPoints - 0.5, 2) * 1.5);
        const x = Math.sin(t) * amplitude;
        points.push([x + (Math.random() - 0.5) * scale * 0.05, y]);
    }
    
    for (let i = 0; i < serpentPoints; i++) {
        const t = (i / serpentPoints) * turns * Math.PI * 2 + Math.PI;
        const y = -scale * 0.76 + (i / serpentPoints) * scale * 1.62;
        const amplitude = scale * 0.25 * (1 - Math.pow(i / serpentPoints - 0.5, 2) * 1.5);
        const x = Math.sin(t) * amplitude;
        points.push([x + (Math.random() - 0.5) * scale * 0.05, y]);
    }
    
    // Wings
    const wingPoints = Math.floor(n * 0.10);
    for (let i = 0; i < wingPoints; i++) {
        const t = (i / wingPoints) * Math.PI * 0.7 + Math.PI * 0.65;
        const r = scale * 0.35 * (0.6 + 0.4 * Math.sin((i / wingPoints) * Math.PI));
        points.push([-scale * 0.15 + Math.cos(t) * r, -scale * 0.85 + Math.sin(t) * r * 0.4]);
    }
    for (let i = 0; i < wingPoints; i++) {
        const t = (i / wingPoints) * Math.PI * 0.7 + Math.PI * 0.15;
        const r = scale * 0.35 * (0.6 + 0.4 * Math.sin((i / wingPoints) * Math.PI));
        points.push([scale * 0.15 + Math.cos(t) * r, -scale * 0.85 + Math.sin(t) * r * 0.4]);
    }
    
    while (points.length < n) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * scale * 0.08;
        const side = Math.random() < 0.5 ? -1 : 1;
        points.push([side * scale * 0.2 + Math.cos(a) * r, -scale * 0.9 + Math.sin(a) * r]);
    }
    
    return points.slice(0, n);
}

/**
 * BORROMEAN RINGS
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Three rings linked so no two are linked - yet removing any frees the others.
 * EMERGENT COHERENCE: connection exists only through three-way relationship.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Trinity, Valknut (Odin's knot), inseparable unity of mind-body-spirit.
 */
function generateBorromeanRings(n, scale) {
    const points = [];
    const ringPoints = Math.floor(n / 3);
    const R = scale * 0.5;
    const r = scale * 0.08;
    
    const centers = [[0, -R * 0.4], [-R * 0.35, R * 0.2], [R * 0.35, R * 0.2]];
    const tilts = [0, Math.PI * 2/3, Math.PI * 4/3];
    
    for (let ring = 0; ring < 3; ring++) {
        const [cx, cy] = centers[ring];
        const tilt = tilts[ring];
        
        for (let i = 0; i < ringPoints; i++) {
            const theta = (i / ringPoints) * Math.PI * 2;
            let x = R * 0.65 * Math.cos(theta);
            let y = R * 0.65 * Math.sin(theta);
            
            const cosT = Math.cos(tilt), sinT = Math.sin(tilt);
            const xr = x * cosT - y * sinT * 0.5;
            const yr = x * sinT + y * cosT * 0.5;
            
            const tubeAngle = Math.random() * Math.PI * 2;
            const tubeR = Math.random() * r;
            
            points.push([cx + xr + Math.cos(tubeAngle + theta) * tubeR, cy + yr + Math.sin(tubeAngle + theta) * tubeR * 0.5]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * MOEBIUS STRIP
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * One-sided surface - following it traverses both "sides" without crossing.
 * The half-twist is phase inversion; after one cycle, phase-shifted;
 * after two, restored.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Non-duality made manifest - apparent opposites revealed as one surface.
 */
function generateMoebiusStrip(n, scale) {
    const points = [];
    const uSteps = Math.floor(Math.sqrt(n) * 1.5);
    const vSteps = Math.floor(n / uSteps);
    
    for (let i = 0; i < uSteps; i++) {
        const u = (i / uSteps) * Math.PI * 2;
        for (let j = 0; j < vSteps; j++) {
            const v = ((j / vSteps) - 0.5) * scale * 0.4;
            const halfU = u / 2;
            const x = (scale * 0.5 + v * Math.cos(halfU)) * Math.cos(u);
            const y = (scale * 0.5 + v * Math.cos(halfU)) * Math.sin(u);
            const z = v * Math.sin(halfU);
            
            const angle = 0.3;
            points.push([x, y * Math.cos(angle) - z * Math.sin(angle)]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * APOLLONIAN GASKET
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Fractal circle packing - SCALE-INVARIANT COHERENCE. The same pattern
 * appears at every level; coherence relationships are self-similar.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Infinite within finite, nested being, "as above so below" at every scale.
 */
function generateApollonianGasket(n, scale) {
    const points = [];
    
    const circles = [
        { x: 0, y: 0, r: scale * 0.95 },
        { x: -scale * 0.35, y: -scale * 0.2, r: scale * 0.4 },
        { x: scale * 0.35, y: -scale * 0.2, r: scale * 0.4 },
        { x: 0, y: scale * 0.35, r: scale * 0.35 },
        { x: 0, y: -scale * 0.55, r: scale * 0.2 },
        { x: -scale * 0.45, y: scale * 0.35, r: scale * 0.18 },
        { x: scale * 0.45, y: scale * 0.35, r: scale * 0.18 },
        { x: -scale * 0.15, y: scale * 0.1, r: scale * 0.12 },
        { x: scale * 0.15, y: scale * 0.1, r: scale * 0.12 },
        { x: 0, y: -scale * 0.25, r: scale * 0.1 }
    ];
    
    const totalCirc = circles.reduce((sum, c) => sum + c.r, 0);
    
    for (const c of circles) {
        const circlePoints = Math.floor(n * c.r / totalCirc);
        for (let i = 0; i < circlePoints; i++) {
            const a = (i / circlePoints) * Math.PI * 2;
            const rr = c.r * (0.92 + Math.random() * 0.16);
            points.push([c.x + Math.cos(a) * rr, c.y + Math.sin(a) * rr]);
        }
    }
    
    while (points.length < n) {
        const c = circles[Math.floor(Math.random() * circles.length)];
        const a = Math.random() * Math.PI * 2;
        points.push([c.x + Math.cos(a) * c.r, c.y + Math.sin(a) * c.r]);
    }
    
    return points.slice(0, n);
}

/**
 * MANDELBROT SET (Boundary)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * The boundary between coherence (bounded) and chaos (escape to infinity).
 * Infinitely complex - the edge where tiny perturbations determine fate.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Infinite complexity from z → z² + c. The edge of chaos where creativity
 * and order meet. The thumbprint of mathematical divinity.
 */
function generateMandelbrotBoundary(n, scale) {
    const points = [];
    const maxIter = 100;
    
    for (let attempt = 0; attempt < n * 3 && points.length < n; attempt++) {
        const cr = (Math.random() * 3.5 - 2.5);
        const ci = (Math.random() * 2 - 1);
        
        let zr = 0, zi = 0, iter = 0;
        while (zr * zr + zi * zi < 4 && iter < maxIter) {
            const newZr = zr * zr - zi * zi + cr;
            zi = 2 * zr * zi + ci;
            zr = newZr;
            iter++;
        }
        
        if (iter > 10 && iter < maxIter - 10) {
            points.push([(cr + 0.5) * scale * 0.8, ci * scale * 0.8]);
        }
    }
    
    return points.slice(0, n);
}

/**
 * DRAGON CURVE
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * Space-filling fractal from paper folding. The folding IS the CRR cycle:
 * coherent state → rupture (fold) → regeneration (unfold transformed).
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Emergence of complex form from simple rule. The dragon energy flowing.
 */
function generateDragonCurve(n, scale) {
    const points = [];
    
    // Generate via L-system
    let sequence = 'FX';
    for (let i = 0; i < 12; i++) {
        let newSeq = '';
        for (const c of sequence) {
            if (c === 'X') newSeq += 'X+YF+';
            else if (c === 'Y') newSeq += '-FX-Y';
            else newSeq += c;
        }
        sequence = newSeq;
    }
    
    let x = 0, y = 0, angle = 0;
    const step = scale * 2 / Math.sqrt(sequence.replace(/[^F]/g, '').length);
    const pathPoints = [];
    
    for (const c of sequence) {
        if (c === 'F') {
            x += Math.cos(angle) * step;
            y += Math.sin(angle) * step;
            pathPoints.push([x, y]);
        } else if (c === '+') angle += Math.PI / 2;
        else if (c === '-') angle -= Math.PI / 2;
    }
    
    // Center and scale
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const [px, py] of pathPoints) {
        minX = Math.min(minX, px); maxX = Math.max(maxX, px);
        minY = Math.min(minY, py); maxY = Math.max(maxY, py);
    }
    const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
    const rangeScale = scale * 1.6 / Math.max(maxX - minX, maxY - minY);
    
    const step2 = Math.max(1, Math.floor(pathPoints.length / n));
    for (let i = 0; i < pathPoints.length && points.length < n; i += step2) {
        points.push([(pathPoints[i][0] - cx) * rangeScale, (pathPoints[i][1] - cy) * rangeScale]);
    }
    
    while (points.length < n) {
        const i = Math.floor(Math.random() * (pathPoints.length - 1));
        const t = Math.random();
        points.push([
            ((pathPoints[i][0] * (1-t) + pathPoints[i+1][0] * t) - cx) * rangeScale,
            ((pathPoints[i][1] * (1-t) + pathPoints[i+1][1] * t) - cy) * rangeScale
        ]);
    }
    
    return points.slice(0, n);
}

/**
 * FLOWER OF APHRODITE (Decagon Rose)
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * CRR INTERPRETATION:
 * ═══════════════════════════════════════════════════════════════════════════
 * 10-petaled rose from overlapping circles with pentagonal symmetry.
 * The golden ratio encoded in every measurement.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 * SPIRITUAL RESONANCE:
 * ═══════════════════════════════════════════════════════════════════════════
 * Venus traces a 5-petaled rose every 8 years. The feminine divine.
 */
function generateFlowerOfAphrodite(n, scale) {
    const points = [];
    const circlePoints = Math.floor(n * 0.7 / 10);
    const r = scale * 0.4;
    
    // Outer pentagon
    for (let i = 0; i < 5; i++) {
        const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
        const cx = Math.cos(a) * scale * 0.6, cy = Math.sin(a) * scale * 0.6;
        for (let j = 0; j < circlePoints; j++) {
            const ca = (j / circlePoints) * Math.PI * 2;
            points.push([cx + Math.cos(ca) * r, cy + Math.sin(ca) * r]);
        }
    }
    
    // Inner pentagon
    for (let i = 0; i < 5; i++) {
        const a = (i / 5) * Math.PI * 2 - Math.PI / 2 + Math.PI / 5;
        const cx = Math.cos(a) * scale * 0.35, cy = Math.sin(a) * scale * 0.35;
        for (let j = 0; j < circlePoints; j++) {
            const ca = (j / circlePoints) * Math.PI * 2;
            points.push([cx + Math.cos(ca) * r * 0.7, cy + Math.sin(ca) * r * 0.7]);
        }
    }
    
    while (points.length < n) {
        const a = Math.random() * Math.PI * 2;
        const rr = Math.random() * scale * 0.25;
        points.push([Math.cos(a) * rr, Math.sin(a) * rr]);
    }
    
    return points.slice(0, n);
}

// ============================================================================
// GEOMETRY ACTIVATION
// ============================================================================

/**
 * Set active geometry attractor
 * 
 * CRR Mechanism: When geometry changes, we:
 * 1. Generate target positions for each particle
 * 2. Shuffle assignment (so particles don't all go to same spot)
 * 3. Reduce coherence (partial rupture - system must regenerate into new form)
 * 
 * Particles then regenerate toward targets weighted by exp(C/Ω).
 * High-coherence particles lead, pulling others through the coherence field.
 */
function setGeometry(shapeIndex) {
    currentShape = shapeIndex;
    const scale = Math.min(W, H) * 0.35;
    
    let points;
    switch(shapeIndex) {
        case 0: points = generateFlowerOfLife(N, scale); break;
        case 1: points = generateTorus(N, scale * 0.8, scale * 0.3); break;
        case 2: points = generateFibonacciSpiral(N, scale); break;
        case 3: points = generateMetatronsCube(N, scale); break;
        case 4: points = generateDoubleHelix(N, scale); break;
        case 5: points = generateLemniscate(N, scale); break;
        case 6: points = generateVesicaPiscis(N, scale * 0.8); break;
        case 7: points = generateSriYantra(N, scale); break;
        case 8: points = generateLorenzAttractor(N, scale); break;
        case 9: points = generateKleinBottle(N, scale); break;
        case 10: points = generateHopfFibration(N, scale); break;
        case 11: points = generatePenroseTiling(N, scale); break;
        case 12: points = generateNautilusShell(N, scale); break;
        case 13: points = generateTreeOfLife(N, scale); break;
        case 14: points = generateYinYang(N, scale * 0.9); break;
        case 15: points = generateOuroboros(N, scale * 0.9); break;
        case 16: points = generateSeedOfLife(N, scale); break;
        case 17: points = generateFruitOfLife(N, scale); break;
        case 18: points = generateMerkaba(N, scale); break;
        case 19: points = generateIcosahedron(N, scale); break;
        case 20: points = generateDodecahedron(N, scale); break;
        case 21: points = generateTetrahedron(N, scale); break;
        case 22: points = generateOctahedron(N, scale); break;
        case 23: points = generateCube(N, scale); break;
        case 24: points = generate64TetrahedronGrid(N, scale); break;
        case 25: points = generateEnneagram(N, scale); break;
        case 26: points = generateLabyrinth(N, scale); break;
        case 27: points = generateTorusKnot(N, scale); break;
        case 28: points = generateRose(N, scale); break;
        case 29: points = generateGordianKnot(N, scale); break;
        case 30: points = generateTesseract(N, scale); break;
        case 31: points = generateStarOfDavid(N, scale); break;
        case 32: points = generateAnkh(N, scale); break;
        case 33: points = generateCaduceus(N, scale); break;
        case 34: points = generateBorromeanRings(N, scale); break;
        case 35: points = generateMoebiusStrip(N, scale); break;
        case 36: points = generateApollonianGasket(N, scale); break;
        case 37: points = generateMandelbrotBoundary(N, scale); break;
        case 38: points = generateDragonCurve(N, scale); break;
        case 39: points = generateFlowerOfAphrodite(N, scale); break;
        default: points = generateFibonacciSpiral(N, scale);
    }
    
    // Shuffle indices for organic assignment
    const indices = Array.from({length: N}, (_, i) => i);
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    
    // Assign targets and induce partial rupture
    for (let i = 0; i < N; i++) {
        const pi = indices[i] % points.length;
        targetX[i] = cx + points[pi][0];
        targetY[i] = cy + points[pi][1];
        hasTarget[i] = 1;
        
        // Partial rupture: reduce coherence to initiate regeneration toward new form
        // Lower coherence = system must rebuild, but retains some history
        coherence[i] *= 0.65;
    }
    
    // Exit free play mode
    freePlayMode = false;
    
    // Update UI
    document.getElementById('shape').innerHTML = 
        shapes[shapeIndex].name + 
        '<small>' + shapes[shapeIndex].desc + '</small>';
    
    // Sync dropdown
    const shapeSelect = document.getElementById('shape-select');
    if (shapeSelect) shapeSelect.value = shapeIndex;
}

/**
 * Release geometry - return to free murmuration
 * 
 * CRR Mechanism: Remove attractor, let system find its own coherence.
 * The flock will naturally organize through neighbour alignment.
 */
function releaseGeometry() {
    currentShape = -1;
    hasTarget.fill(0);
    freePlayMode = true; // Enable predator interaction
    document.getElementById('shape').innerHTML = 
        'Free Flow<small>Click to scare the flock!</small>';
    
    // Sync dropdown
    const shapeSelect = document.getElementById('shape-select');
    if (shapeSelect) shapeSelect.value = -1;
}

// ============================================================================
// INITIALIZATION
// ============================================================================

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = W / 2;
    cy = H / 2;
    gl.viewport(0, 0, W, H);
    
    gridW = Math.ceil(W / CELL) + 2;
    gridH = Math.ceil(H / CELL) + 2;
    grid = new Int32Array(gridW * gridH * MAX_PER_CELL);
    gridCounts = new Int32Array(gridW * gridH);
}

function init() {
    // Initialize particles in gentle spiral
    for (let i = 0; i < N; i++) {
        const t = (i / N) * Math.PI * 6;
        const r = (i / N) * Math.min(W, H) * 0.3;
        x[i] = cx + Math.cos(t) * r + (Math.random() - 0.5) * 50;
        y[i] = cy + Math.sin(t) * r + (Math.random() - 0.5) * 50;
        
        const va = t + Math.PI / 2;
        const sp = 1 + Math.random() * 1.5;
        vx[i] = Math.cos(va) * sp;
        vy[i] = Math.sin(va) * sp;
        
        coherence[i] = 0.3 + Math.random() * 0.4;
        phase[i] = Math.random() * Math.PI * 2;
        hasTarget[i] = 0;
    }
    
    currentShape = -1;
    freePlayMode = false; // Start in shape cycling mode, not free play
    document.getElementById('shape').innerHTML = 
        'Click to Summon Form<small>CRR Geometric Murmuration</small>';
    
    // Sync dropdown
    const shapeSelect = document.getElementById('shape-select');
    if (shapeSelect) shapeSelect.value = -1;
}

// ============================================================================
// SPATIAL PARTITIONING
// ============================================================================

function buildGrid() {
    gridCounts.fill(0);
    
    for (let i = 0; i < N; i++) {
        const gx = Math.floor(x[i] / CELL) + 1;
        const gy = Math.floor(y[i] / CELL) + 1;
        
        if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
            const idx = gy * gridW + gx;
            const count = gridCounts[idx];
            if (count < MAX_PER_CELL) {
                grid[idx * MAX_PER_CELL + count] = i;
                gridCounts[idx] = count + 1;
            }
        }
    }
}

// ============================================================================
// MAIN UPDATE LOOP - CRR DYNAMICS
// ============================================================================

function update() {
    time += 0.016;
    buildGrid();
    
    // Decay predator influence over time (threat fades)
    if (predatorActive) {
        predatorDecay *= 0.96;
        if (predatorDecay < 0.01) {
            predatorActive = false;
        }
    }
    
    // Gentle environmental wind
    windAngle += (Math.sin(time * 0.08) * 0.4 - windAngle) * 0.008;
    const windX = Math.cos(windAngle) * 0.25;
    const windY = Math.sin(windAngle) * 0.25;
    
    let totalCoherence = 0;
    
    for (let i = 0; i < N; i++) {
        const px = x[i], py = y[i];
        const pvx = vx[i], pvy = vy[i];
        
        const gx = Math.floor(px / CELL) + 1;
        const gy = Math.floor(py / CELL) + 1;
        
        // ================================================================
        // NEIGHBOUR SEARCH (Topological - based on proximity, not count)
        // ================================================================
        
        let sumVx = 0, sumVy = 0;
        let sepX = 0, sepY = 0;
        let cohX = 0, cohY = 0;
        let nCount = 0;
        let totalCohWeight = 0;
        let weightedVx = 0, weightedVy = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const cxi = gx + dx;
                const cyi = gy + dy;
                if (cxi < 0 || cxi >= gridW || cyi < 0 || cyi >= gridH) continue;
                
                const cellIdx = cyi * gridW + cxi;
                const count = gridCounts[cellIdx];
                const step = count > 6 ? Math.floor(count / 6) : 1;
                
                for (let k = 0; k < count; k += step) {
                    const j = grid[cellIdx * MAX_PER_CELL + k];
                    if (j === i) continue;
                    
                    const ddx = x[j] - px;
                    const ddy = y[j] - py;
                    const d2 = ddx * ddx + ddy * ddy;
                    
                    if (d2 < 2500 && d2 > 0) { // 50² perception radius
                        const d = Math.sqrt(d2);
                        nCount++;
                        sumVx += vx[j];
                        sumVy += vy[j];
                        cohX += x[j];
                        cohY += y[j];
                        
                        // Separation (avoid crowding)
                        if (d2 < 200) { // ~14² separation radius
                            const f = (14 - d) / 14;
                            sepX -= ddx / d * f;
                            sepY -= ddy / d * f;
                        }
                        
                        // ========================================
                        // CRR REGENERATION WEIGHTING: w_j = exp(C_j/Ω)
                        // ========================================
                        // This is the CORE CRR mechanism for regeneration:
                        //
                        //   w_j = exp(C_j / Ω)
                        //   v⃗_regen = Σ(w_j × v⃗_j) / Σ(w_j)
                        //
                        // Neighbours with higher coherence have EXPONENTIALLY
                        // more influence on this particle's regeneration.
                        //
                        // The Ω parameter controls the sharpness:
                        //   Ω = 0.10 (low)  → exp(0.8/0.1)/exp(0.2/0.1) ≈ 403×
                        //   Ω = 0.50 (high) → exp(0.8/0.5)/exp(0.2/0.5) ≈ 3.3×
                        //
                        // Low Ω = only highest-C neighbours matter (RIGID)
                        // High Ω = all neighbours contribute equally (FLUID)
                        //
                        // This is how CRR creates coherence basins:
                        // aligned particles reinforce each other exponentially.
                        
                        const w = Math.exp(coherence[j] / OMEGA);
                        totalCohWeight += w;
                        weightedVx += vx[j] * w;
                        weightedVy += vy[j] * w;
                    }
                }
            }
        }
        
        // ================================================================
        // CRR COHERENCE ACCUMULATION: C(t) = ∫L(x,τ)dτ
        // ================================================================
        // The continuous integral is approximated as exponential moving average:
        //
        //   C(t) = C(t-1) × DECAY + L(t) × (1 - DECAY)
        //
        // Where L(x,t) is the LOCAL ALIGNMENT measure:
        //
        //   L = (v⃗_self · v⃗_neighbours) / (|v⃗_self| × |v⃗_neighbours|)
        //
        // This dot product ∈ [-1, 1], mapped to [0, 1]:
        //   L = 1 when perfectly aligned (moving same direction)
        //   L = 0 when perpendicular
        //   L = 0 (mapped from -1) when opposite
        //
        // DECAY parameter controls memory length:
        //   DECAY = 0.99 → long memory, ~100 frame half-life
        //   DECAY = 0.90 → short memory, ~7 frame half-life
        //   Half-life = ln(0.5) / ln(DECAY)
        
        if (nCount > 0) {
            const speed = Math.sqrt(pvx * pvx + pvy * pvy) + 0.001;
            const avgVx = sumVx / nCount;
            const avgVy = sumVy / nCount;
            const avgSpeed = Math.sqrt(avgVx * avgVx + avgVy * avgVy) + 0.001;
            
            // L(x,t) = normalized dot product, mapped to [0,1]
            const dot = (pvx * avgVx + pvy * avgVy) / (speed * avgSpeed);
            const alignment = (dot + 1) * 0.5;
            
            // Coherence accumulation (temporal integration)
            coherence[i] = coherence[i] * DECAY + alignment * (1 - DECAY);
        }
        
        totalCoherence += coherence[i];
        
        // ================================================================
        // FORCE CALCULATION
        // ================================================================
        
        let ax = 0, ay = 0;
        
        // ================================================================
        // CRR GEOMETRIC REGENERATION: F = α·exp(C/Ω)·(target - pos)/|d|
        // ================================================================
        // This is the CRR regeneration equation applied to geometry:
        //
        //   F_attract = FORM_ATTRACTION × exp(C_i / Ω) × (target_i - pos_i) / d
        //
        // Where:
        //   C_i = this particle's accumulated coherence (from alignment history)
        //   Ω = rupture threshold (slider: low=rigid, high=fluid)
        //   exp(C/Ω) = memory weighting - HIGH coherence → STRONGER attraction
        //
        // This is WHY high-coherence particles arrive at the geometry first:
        // exp(0.8/0.1) ≈ 2981 vs exp(0.3/0.1) ≈ 20
        // A coherent particle feels ~150× more pull than an incoherent one!
        //
        // The geometry becomes self-stabilizing: particles that arrive and
        // align with neighbours INCREASE their C, which INCREASES their
        // attraction, which STABILIZES their position. CRR solves geometry.
        
        if (hasTarget[i]) {
            const dx = targetX[i] - px;
            const dy = targetY[i] - py;
            const d = Math.sqrt(dx * dx + dy * dy) + 0.001;
            
            // exp(C/Ω) weighted attraction - this IS the regeneration term
            const pull = FORM_ATTRACTION * Math.exp(coherence[i] / OMEGA) * 0.012;
            
            // Smooth arrival (stronger when far, gentler when close)
            const distFactor = Math.min(d * 0.008, 1);
            
            ax += dx / d * pull * distFactor;
            ay += dy / d * pull * distFactor;
            
            // Reward coherence near target (stabilizes form)
            if (d < 25) {
                coherence[i] = Math.min(1, coherence[i] + 0.003);
            }
        }
        
        // ================================================================
        // FLOCKING FORCES (also CRR-weighted)
        // ================================================================
        
        if (nCount > 0) {
            // Cohesion - move toward neighbour center
            cohX /= nCount;
            cohY /= nCount;
            ax += (cohX - px) * 0.005;
            ay += (cohY - py) * 0.005;
            
            // CRR-weighted alignment (regeneration toward coherent neighbours)
            if (totalCohWeight > 0) {
                weightedVx /= totalCohWeight;
                weightedVy /= totalCohWeight;
                ax += (weightedVx - pvx) * 0.03;
                ay += (weightedVy - pvy) * 0.03;
            }
            
            // Separation
            ax += sepX * 0.06;
            ay += sepY * 0.06;
        }
        
        // Wind (reduced when following geometry)
        const windFactor = hasTarget[i] ? 0.008 : 0.02;
        ax += windX * windFactor;
        ay += windY * windFactor;
        
        // Boundaries (soft repulsion)
        const margin = 50;
        if (px < margin) ax += (margin - px) * 0.0015;
        if (px > W - margin) ax -= (px - (W - margin)) * 0.0015;
        if (py < margin) ay += (margin - py) * 0.0015;
        if (py > H - margin) ay -= (py - (H - margin)) * 0.0015;
        
        // Individual wander (prevents crystallization)
        ax += Math.sin(time * 1.3 + phase[i]) * 0.006;
        ay += Math.cos(time * 1.5 + phase[i]) * 0.006;
        
        // ================================================================
        // PREDATOR AVOIDANCE (free flow mode only)
        // ================================================================
        // CRR interpretation: predator creates sudden RUPTURE in local
        // coherence field. Particles flee, breaking alignment, then
        // gradually regenerate coherent flocking as threat fades.
        
        if (predatorActive && !hasTarget[i]) {
            const pdx = px - predatorX;
            const pdy = py - predatorY;
            const pd2 = pdx * pdx + pdy * pdy;
            const predatorRadius = 250;
            
            if (pd2 < predatorRadius * predatorRadius && pd2 > 0) {
                const pd = Math.sqrt(pd2);
                const fleeStrength = predatorDecay * (1 - pd / predatorRadius) * 0.8;
                ax += (pdx / pd) * fleeStrength;
                ay += (pdy / pd) * fleeStrength;
                
                // Rupture: predator presence disrupts coherence
                coherence[i] *= (1 - fleeStrength * 0.3);
            }
        }
        
        // ================================================================
        // VELOCITY UPDATE
        // ================================================================
        
        let nvx = pvx + ax;
        let nvy = pvy + ay;
        
        // Speed limits
        let sp = Math.sqrt(nvx * nvx + nvy * nvy);
        const maxSpeed = hasTarget[i] ? 5 : 3.5;
        if (sp > maxSpeed) { nvx = nvx / sp * maxSpeed; nvy = nvy / sp * maxSpeed; }
        if (sp < 0.4) { nvx = nvx / (sp + 0.001) * 0.4; nvy = nvy / (sp + 0.001) * 0.4; }
        
        vx[i] = nvx;
        vy[i] = nvy;
        x[i] = px + nvx;
        y[i] = py + nvy;
        
        // Wrap at boundaries
        if (x[i] < -10) x[i] += W + 20;
        if (x[i] > W + 10) x[i] -= W + 20;
        if (y[i] < -10) y[i] += H + 20;
        if (y[i] > H + 10) y[i] -= H + 20;
        
        // Evolve visual phase (iridescence)
        phase[i] += 0.006 + coherence[i] * 0.012;
    }
    
    // Update average coherence display
    if (Math.floor(time * 60) % 30 === 0) {
        document.getElementById('avgC').textContent = (totalCoherence / N).toFixed(3);
    }
}

// ============================================================================
// WEBGL RENDERING
// ============================================================================

const vsrc = `
attribute vec2 a_pos;
attribute float a_coh;
attribute float a_phase;

uniform vec2 u_res;
uniform float u_time;
uniform float u_irid;

varying float v_coh;
varying float v_hue;
varying float v_alpha;

void main() {
    vec2 p = (a_pos / u_res) * 2.0 - 1.0;
    p.y *= -1.0;
    gl_Position = vec4(p, 0.0, 1.0);
    
    // Size scales with coherence (high C = larger, more visible)
    gl_PointSize = 1.6 + a_coh * 2.0;
    
    v_coh = a_coh;
    
    // Iridescent color: base hue shifts with coherence, phase, and position
    // High coherence = blue-violet, low coherence = cyan-green
    float baseHue = 0.52 + a_coh * 0.15;
    float phaseShift = sin(a_phase + u_time * 0.25) * 0.1 * u_irid;
    float posShift = (p.x * 0.35 + p.y * 0.2) * 0.08 * u_irid;
    v_hue = baseHue + phaseShift + posShift;
    
    // Alpha also scales with coherence (coherent particles glow brighter)
    v_alpha = 0.18 + a_coh * 0.55;
}`;

const fsrc = `
precision mediump float;
varying float v_coh;
varying float v_hue;
varying float v_alpha;

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    // Soft circular point
    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
    float r = dot(cxy, cxy);
    if (r > 1.0) discard;
    
    float soft = 1.0 - sqrt(r);
    
    // Saturation and value based on coherence
    float sat = 0.3 + v_coh * 0.5;
    float val = 0.75 + v_coh * 0.25;
    
    vec3 rgb = hsv2rgb(vec3(v_hue, sat, val));
    
    // Bright core for sparkle effect
    rgb = mix(rgb, vec3(1.0), smoothstep(0.5, 0.0, r) * 0.3 * v_coh);
    
    gl_FragColor = vec4(rgb, v_alpha * soft);
}`;

let program, posBuffer, cohBuffer, phaseBuffer;
let posLoc, cohLoc, phaseLoc, resLoc, timeLoc, iridLoc;

function initGL() {
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsrc);
    gl.compileShader(vs);
    
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsrc);
    gl.compileShader(fs);
    
    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);
    
    posLoc = gl.getAttribLocation(program, 'a_pos');
    cohLoc = gl.getAttribLocation(program, 'a_coh');
    phaseLoc = gl.getAttribLocation(program, 'a_phase');
    resLoc = gl.getUniformLocation(program, 'u_res');
    timeLoc = gl.getUniformLocation(program, 'u_time');
    iridLoc = gl.getUniformLocation(program, 'u_irid');
    
    posBuffer = gl.createBuffer();
    cohBuffer = gl.createBuffer();
    phaseBuffer = gl.createBuffer();
    
    // Additive blending for ethereal glow
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
}

const posData = new Float32Array(N * 2);

function render() {
    gl.clearColor(0.006, 0.006, 0.018, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.uniform2f(resLoc, W, H);
    gl.uniform1f(timeLoc, time);
    gl.uniform1f(iridLoc, IRIDESCENCE);
    
    // Pack position data
    for (let i = 0; i < N; i++) {
        posData[i * 2] = x[i];
        posData[i * 2 + 1] = y[i];
    }
    
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, cohBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, coherence, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(cohLoc);
    gl.vertexAttribPointer(cohLoc, 1, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, phaseBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, phase, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(phaseLoc);
    gl.vertexAttribPointer(phaseLoc, 1, gl.FLOAT, false, 0, 0);
    
    gl.drawArrays(gl.POINTS, 0, N);
}

// ============================================================================
// MAIN LOOP
// ============================================================================

let fpsCounter = 0;
let fpsTime = performance.now();

function loop() {
    fpsCounter++;
    const now = performance.now();
    if (now - fpsTime > 1000) {
        document.getElementById('fps').textContent = fpsCounter;
        fpsCounter = 0;
        fpsTime = now;
    }
    
    update();
    render();
    requestAnimationFrame(loop);
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

window.addEventListener('resize', resize);

// Predator state for free flow mode
let predatorX = -1000;
let predatorY = -1000;
let predatorActive = false;
let predatorDecay = 0;
let freePlayMode = false; // Only true when "Release Form" is pressed

// Click behavior depends on mode
canvas.addEventListener('click', e => {
    if (freePlayMode) {
        // Predator scare in free play mode
        predatorX = e.clientX;
        predatorY = e.clientY;
        predatorActive = true;
        predatorDecay = 1.0;
    } else {
        // Cycle through shapes
        currentShape = (currentShape + 1) % shapes.length;
        setGeometry(currentShape);
    }
});

canvas.addEventListener('touchstart', e => {
    if (freePlayMode) {
        e.preventDefault();
        const touch = e.touches[0];
        predatorX = touch.clientX;
        predatorY = touch.clientY;
        predatorActive = true;
        predatorDecay = 1.0;
    } else {
        e.preventDefault();
        currentShape = (currentShape + 1) % shapes.length;
        setGeometry(currentShape);
    }
});

document.getElementById('omega').oninput = e => {
    OMEGA = parseFloat(e.target.value);
    document.getElementById('v-omega').textContent = OMEGA.toFixed(2);
};

document.getElementById('form').oninput = e => {
    FORM_ATTRACTION = parseFloat(e.target.value);
    document.getElementById('v-form').textContent = FORM_ATTRACTION.toFixed(1);
};

document.getElementById('decay').oninput = e => {
    DECAY = parseFloat(e.target.value);
    document.getElementById('v-decay').textContent = DECAY.toFixed(2);
};

document.getElementById('irid').oninput = e => {
    IRIDESCENCE = parseFloat(e.target.value);
    document.getElementById('v-irid').textContent = IRIDESCENCE.toFixed(1);
};

document.getElementById('release').onclick = releaseGeometry;
document.getElementById('reset').onclick = init;

// Populate shape selector dropdown
const shapeSelect = document.getElementById('shape-select');
shapes.forEach((shape, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = shape.name;
    shapeSelect.appendChild(option);
});

// Shape selector handler
shapeSelect.onchange = e => {
    const value = parseInt(e.target.value);
    if (value === -1) {
        releaseGeometry();
    } else {
        currentShape = value;
        setGeometry(value);
    }
};

// ============================================================================
// THEORY PANEL
// ============================================================================

const theoryToggle = document.getElementById('theory-toggle');
const theoryPanel = document.getElementById('theory-panel');
const theoryOverlay = document.getElementById('theory-overlay');
const theoryClose = theoryPanel.querySelector('.close-btn');

function showTheory() {
    theoryPanel.classList.add('visible');
    theoryOverlay.classList.add('visible');
}

function hideTheory() {
    theoryPanel.classList.remove('visible');
    theoryOverlay.classList.remove('visible');
}

theoryToggle.addEventListener('click', showTheory);
theoryOverlay.addEventListener('click', hideTheory);
theoryClose.addEventListener('click', hideTheory);

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') hideTheory();
});

// ============================================================================
// START
// ============================================================================

resize();
initGL();
init();
loop();

/**
 * ============================================================================
 * END OF CRR GEOMETRIC MURMURATION
 * ============================================================================
 * 
 * This code demonstrates how the Coherence-Rupture-Regeneration framework
 * provides a unified approach to:
 * 
 * 1. FLOCKING: Particles align through coherence accumulation
 * 2. GEOMETRY: Shapes emerge from coherence-weighted regeneration
 * 3. TRANSFORMATION: Form changes occur via partial rupture + regeneration
 * 
 * The key insight is that the geometry in this CRR sim was not imposed - it's discovered through
 * temporal integration of coherence relationships. The exp(C/Ω) weighting
 * ensures that high-coherence particles lead formation, creating organic
 * emergence rather than mechanical positioning.
 * 
 * For more on CRR and its applications across physics, biology, and
 * consciousness studies, see: www.temporalgrammar.ai or www.cohere.org.uk
 * 
 * Framework by Alexander Sabine
 * 
 * 
 * Key CRR equations:
 *   C(x,t) = ∫L(x,τ)dτ           -- Coherence accumulates through alignment
 *   δ(now)                        -- Rupture at scale-invariant choice moments
 *   R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ  -- Regeneration weighted by coherence history
 * 
 * The Ω-symmetry discovery:
 *   Z₂ systems: Ω = 1/π ≈ 0.318
 *   SO(2) systems: Ω = 1/2π ≈ 0.159
 *   CV = Ω/2 matches empirical data to ~1%
 * 
 * ============================================================================
 */
</script>
</body>
</html>
