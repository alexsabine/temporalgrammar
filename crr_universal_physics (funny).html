<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Universal Physics â€” Agents Commanding Reality</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Fira+Code:wght@300;400&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --void: #020204;
            --deep-space: #0a0812;
            --quantum-blue: #4488ff;
            --gravity-purple: #8844ff;
            --em-gold: #ffaa22;
            --strong-red: #ff4444;
            --weak-green: #44ff88;
            --coherence: #44ffaa;
            --rupture: #ff6666;
            --hawking: #ffff88;
            --entangle: #ff44ff;
            --dark-energy: #6644aa;
        }
        
        body {
            background: var(--void);
            min-height: 100vh;
            font-family: 'Cinzel', serif;
            color: #a8a0c0;
            overflow-x: hidden;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COSMIC HEADER
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        header {
            text-align: center;
            padding: 25px 20px 15px;
            background: radial-gradient(ellipse at center, rgba(68, 136, 255, 0.1) 0%, transparent 70%);
            position: relative;
        }
        
        h1 {
            font-size: clamp(1.6em, 4vw, 2.4em);
            font-weight: 400;
            letter-spacing: 0.15em;
            background: linear-gradient(135deg, var(--quantum-blue), var(--gravity-purple), var(--em-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 60px rgba(136, 68, 255, 0.5);
        }
        
        .subtitle {
            font-family: 'Fira Code', monospace;
            font-size: 0.85em;
            opacity: 0.7;
            margin-top: 8px;
            letter-spacing: 0.05em;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN LAYOUT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .universe-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 12px;
            padding: 12px;
            max-width: 1900px;
            margin: 0 auto;
        }
        
        @media (max-width: 1400px) {
            .universe-container { grid-template-columns: 260px 1fr 260px; }
        }
        
        @media (max-width: 1100px) {
            .universe-container { grid-template-columns: 1fr; }
            .panel { max-height: none; }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CANVAS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .canvas-wrap {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border-radius: 8px;
            box-shadow: 
                0 0 80px rgba(68, 136, 255, 0.15),
                0 0 160px rgba(136, 68, 255, 0.1),
                inset 0 0 150px rgba(0, 0, 0, 0.8);
            background: radial-gradient(ellipse at center, #0a0815 0%, #020204 100%);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           PANELS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .panel {
            background: rgba(8, 6, 15, 0.95);
            border: 1px solid rgba(68, 136, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Fira Code', monospace;
            font-size: 0.7em;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
        }
        
        .panel::-webkit-scrollbar { width: 5px; }
        .panel::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        .panel::-webkit-scrollbar-thumb { background: rgba(68, 136, 255, 0.3); border-radius: 3px; }
        
        .panel h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            font-weight: 400;
            background: linear-gradient(90deg, var(--quantum-blue), var(--gravity-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(68, 136, 255, 0.3);
        }
        
        .panel h3 {
            font-family: 'Cinzel', serif;
            font-size: 0.95em;
            font-weight: 400;
            color: var(--em-gold);
            margin: 12px 0 6px;
            opacity: 0.9;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }
        
        .metric-label { opacity: 0.6; font-size: 0.95em; }
        .metric-value { font-weight: 400; }
        
        .quantum { color: var(--quantum-blue); }
        .gravity { color: var(--gravity-purple); }
        .em { color: var(--em-gold); }
        .strong { color: var(--strong-red); }
        .weak { color: var(--weak-green); }
        .coherence { color: var(--coherence); }
        .rupture { color: var(--rupture); }
        .hawking { color: var(--hawking); }
        .entangle { color: var(--entangle); }
        .dark { color: var(--dark-energy); }
        
        .equation {
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 8px;
            border-radius: 4px;
            margin: 6px 0;
            font-size: 0.9em;
            border-left: 2px solid var(--quantum-blue);
        }
        
        .eq-gravity { border-left-color: var(--gravity-purple); }
        .eq-em { border-left-color: var(--em-gold); }
        .eq-strong { border-left-color: var(--strong-red); }
        .eq-quantum { border-left-color: var(--quantum-blue); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CONTROLS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            padding: 15px;
            background: rgba(8, 6, 15, 0.8);
            margin-top: 10px;
            border-radius: 8px;
        }
        
        button {
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.2), rgba(136, 68, 255, 0.2));
            border: 1px solid rgba(68, 136, 255, 0.4);
            color: #b0c0e0;
            padding: 8px 14px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 0.85em;
            transition: all 0.3s;
        }
        
        button:hover {
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.4), rgba(136, 68, 255, 0.4));
            box-shadow: 0 0 25px rgba(68, 136, 255, 0.4);
            transform: translateY(-1px);
        }
        
        button.active {
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.5), rgba(136, 68, 255, 0.5));
            box-shadow: 0 0 20px rgba(136, 68, 255, 0.5);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 0.8em;
        }
        
        .control-group label { opacity: 0.7; }
        
        input[type="range"] {
            width: 80px;
            accent-color: var(--quantum-blue);
        }
        
        select {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(68, 136, 255, 0.3);
            color: #b0c0e0;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header>
        <h1>CRR UNIVERSAL PHYSICS</h1>
        <p class="subtitle">Agents Commanding Reality Through Coherence-Rupture-Regeneration</p>
    </header>
    
    <div class="universe-container">
        <!-- LEFT PANEL: Fundamental Forces -->
        <div class="panel">
            <h2>âš› Fundamental Forces</h2>
            
            <h3>Quantum Mechanics</h3>
            <div class="equation eq-quantum">Ïˆ(x) = Î£ aâ‚™Â·exp(iCâ‚™/â„_eff)</div>
            <div class="metric">
                <span class="metric-label">|Ïˆ|Â² (prob)</span>
                <span class="metric-value quantum" id="qmProb">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">â„_eff</span>
                <span class="metric-value quantum" id="hbar">0.100</span>
            </div>
            <div class="metric">
                <span class="metric-label">Tunneling</span>
                <span class="metric-value quantum" id="tunnelCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Superposition</span>
                <span class="metric-value quantum" id="superposCount">0</span>
            </div>
            
            <h3>Gravity (Coherence Curvature)</h3>
            <div class="equation eq-gravity">g_Î¼Î½ âˆ âˆ‡CâŠ—âˆ‡C âˆ’ Â½g|âˆ‡C|Â²</div>
            <div class="metric">
                <span class="metric-label">Total Mass</span>
                <span class="metric-value gravity" id="totalMass">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Curvature R</span>
                <span class="metric-value gravity" id="curvature">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Black Holes</span>
                <span class="metric-value gravity" id="blackHoleCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Hawking Rad</span>
                <span class="metric-value hawking" id="hawkingRate">0.000</span>
            </div>
            
            <h3>Electromagnetism (Phase)</h3>
            <div class="equation eq-em">F_Î¼Î½ = âˆ‚_Î¼A_Î½ âˆ’ âˆ‚_Î½A_Î¼<br>A_Î¼ âˆ âˆ‡Ï†</div>
            <div class="metric">
                <span class="metric-label">Total Charge</span>
                <span class="metric-value em" id="totalCharge">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">|E| field</span>
                <span class="metric-value em" id="eField">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">|B| field</span>
                <span class="metric-value em" id="bField">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Photons</span>
                <span class="metric-value em" id="photonCount">0</span>
            </div>
            
            <h3>Strong Force (Binding)</h3>
            <div class="equation eq-strong">V(r) = âˆ’Î±/r + Ïƒr</div>
            <div class="metric">
                <span class="metric-label">Bound States</span>
                <span class="metric-value strong" id="boundStates">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Binding E</span>
                <span class="metric-value strong" id="bindingEnergy">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Fusions</span>
                <span class="metric-value strong" id="fusionCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Fissions</span>
                <span class="metric-value strong" id="fissionCount">0</span>
            </div>
            
            <h3>Weak Force (Decay)</h3>
            <div class="metric">
                <span class="metric-label">Decays</span>
                <span class="metric-value weak" id="decayCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Transmutations</span>
                <span class="metric-value weak" id="transmuteCount">0</span>
            </div>
        </div>
        
        <!-- CENTER: Canvas -->
        <div class="canvas-wrap">
            <canvas id="canvas"></canvas>
            
            <div class="controls">
                <button onclick="togglePause()" id="pauseBtn">â¸ Pause</button>
                <button onclick="triggerBigBang()">ğŸ’¥ Big Bang</button>
                <button onclick="createBlackHole()">ğŸ•³ Black Hole</button>
                <button onclick="triggerQuantumFluctuation()">âš¡ Quantum Flux</button>
                <button onclick="induceEntanglement()">ğŸ”— Entangle</button>
                <button onclick="triggerSupernova()">ğŸ’« Supernova</button>
                <button onclick="toggleField()" id="fieldBtn">ğŸŒŠ Show Fields</button>
                <button onclick="reset()">ğŸ”„ Reset</button>
                
                <div class="control-group">
                    <label>Î©:</label>
                    <input type="range" min="0.05" max="0.5" step="0.01" value="0.318" 
                           onchange="setOmega(this.value)" id="omegaSlider">
                    <span id="omegaDisp">0.318</span>
                </div>
                
                <div class="control-group">
                    <label>â„:</label>
                    <input type="range" min="0.01" max="0.3" step="0.01" value="0.1" 
                           onchange="setHbar(this.value)" id="hbarSlider">
                    <span id="hbarDisp">0.10</span>
                </div>
                
                <div class="control-group">
                    <label>G:</label>
                    <input type="range" min="0" max="2" step="0.1" value="0.5" 
                           onchange="setGravity(this.value)" id="gravSlider">
                    <span id="gravDisp">0.5</span>
                </div>
                
                <div class="control-group">
                    <label>Î±_EM:</label>
                    <input type="range" min="0" max="1" step="0.05" value="0.3" 
                           onchange="setEM(this.value)" id="emSlider">
                    <span id="emDisp">0.3</span>
                </div>
                
                <div class="control-group">
                    <label>View:</label>
                    <select onchange="setViewMode(this.value)" id="viewSelect">
                        <option value="normal">Normal</option>
                        <option value="quantum">Quantum Ïˆ</option>
                        <option value="gravity">Spacetime</option>
                        <option value="em">EM Fields</option>
                        <option value="phase">Phase Space</option>
                        <option value="energy">Energy Density</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- RIGHT PANEL: CRR & Emergent Phenomena -->
        <div class="panel">
            <h2>âˆ¿ CRR Core & Emergence</h2>
            
            <h3>CRR State</h3>
            <div class="equation">C = âˆ«L(x,Ï„)dÏ„</div>
            <div class="metric">
                <span class="metric-label">âŸ¨CâŸ©</span>
                <span class="metric-value coherence" id="avgC">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">max(C)</span>
                <span class="metric-value coherence" id="maxC">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">|âˆ‡C|</span>
                <span class="metric-value coherence" id="gradC">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Î´ ruptures</span>
                <span class="metric-value rupture" id="ruptures">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">R regen</span>
                <span class="metric-value coherence" id="regen">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Î©</span>
                <span class="metric-value em" id="omega">0.318</span>
            </div>
            
            <h3>Entanglement</h3>
            <div class="equation">|Î¨âŸ© = Î±|00âŸ© + Î²|11âŸ©</div>
            <div class="metric">
                <span class="metric-label">Pairs</span>
                <span class="metric-value entangle" id="entanglePairs">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Concurrence</span>
                <span class="metric-value entangle" id="concurrence">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Bell violation</span>
                <span class="metric-value entangle" id="bellViolation">0.000</span>
            </div>
            
            <h3>Thermodynamics</h3>
            <div class="equation">S = âˆ’Tr(Ï log Ï)</div>
            <div class="metric">
                <span class="metric-label">Entropy S</span>
                <span class="metric-value hawking" id="entropy">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Temperature</span>
                <span class="metric-value hawking" id="temperature">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Free Energy</span>
                <span class="metric-value hawking" id="freeEnergy">0.000</span>
            </div>
            
            <h3>Cosmology</h3>
            <div class="equation">HÂ² = 8Ï€GÏ/3 âˆ’ k/aÂ²</div>
            <div class="metric">
                <span class="metric-label">Scale a(t)</span>
                <span class="metric-value dark" id="scaleFactor">1.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Hubble H</span>
                <span class="metric-value dark" id="hubble">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Dark Energy</span>
                <span class="metric-value dark" id="darkEnergy">0.000</span>
            </div>
            
            <h3>Information</h3>
            <div class="metric">
                <span class="metric-label">Fisher I</span>
                <span class="metric-value quantum" id="fisherInfo">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Mutual Info</span>
                <span class="metric-value quantum" id="mutualInfo">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Complexity</span>
                <span class="metric-value quantum" id="complexity">0.000</span>
            </div>
            
            <h3>Population</h3>
            <div class="metric">
                <span class="metric-label">Agents</span>
                <span class="metric-value coherence" id="agentCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Particles</span>
                <span class="metric-value quantum" id="particleCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Generations</span>
                <span class="metric-value coherence" id="generations">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Cosmic Age</span>
                <span class="metric-value dark" id="cosmicAge">0.00</span>
            </div>
        </div>
    </div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRR UNIVERSAL PHYSICS ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// ALL physics derived from three CRR operations:
//   C(x,t) = âˆ«L(x,Ï„)dÏ„     â€” Coherence accumulation
//   Î´(now)                  â€” Rupture (Dirac delta)  
//   R = âˆ«Ï†Â·exp(C/Î©)Â·Î˜ dÏ„   â€” Memory-weighted regeneration
//
// Physics mappings:
//   QUANTUM: Ïˆ âˆ exp(iC/â„), tunneling via Î´ through barriers
//   GRAVITY: g_Î¼Î½ from âˆ‡CâŠ—âˆ‡C, geodesics follow coherence gradients
//   EM: Phase Ï† â†’ charge, âˆ‡Ï† â†’ E field, âˆ‚Ï†/âˆ‚t â†’ B field  
//   STRONG: Binding from coherence overlap, confinement from C gradients
//   WEAK: Decay via Î´-triggered transmutation
//   THERMO: exp(C/Î©) â†’ Boltzmann factor, partition functions
//   COSMOLOGY: C field â†’ dark energy, expansion from coherence pressure
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNIVERSAL CONSTANTS (CRR-derived)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let Omega = 1 / Math.PI;           // CRR characteristic scale (Zâ‚‚)
let hbar_eff = 0.1;                // Effective Planck constant
let G_eff = 0.5;                   // Effective gravitational constant
let alpha_EM = 0.3;                // EM coupling strength
let alpha_strong = 1.0;            // Strong force coupling
let alpha_weak = 0.1;              // Weak force coupling

// Simulation state
let isPaused = false;
let viewMode = 'normal';
let showFields = false;
let simTime = 0;
let cosmicAge = 0;
let scaleFactor = 1;
let hubbleParam = 0;

// Fields (discretized spacetime)
const GRID = 60;
let coherenceField = [];
let gravitationalPotential = [];
let emPotential = [];              // A_Î¼ (phase gradient)
let quantumField = [];             // Ïˆ amplitude
let energyDensity = [];

// Entities
let agents = [];                   // Primary conscious agents
let particles = [];                // Force carriers, radiation
let blackHoles = [];               // Gravitational singularities
let entangledPairs = [];           // Quantum correlated pairs
let photons = [];                  // EM radiation
let gluons = [];                   // Strong force carriers

// Statistics
let stats = {
    tunnelCount: 0,
    superposCount: 0,
    blackHoleCount: 0,
    hawkingRate: 0,
    fusionCount: 0,
    fissionCount: 0,
    decayCount: 0,
    transmuteCount: 0,
    photonCount: 0,
    ruptures: 0,
    totalRegen: 0
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRR CORE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * KINESIS: K(C,Î©) = exp(C/Î©)
 * Universal activity amplifier â€” appears in ALL physics
 */
function kinesis(C, omega = Omega) {
    if (!isFinite(C) || !isFinite(omega) || omega === 0) return 1;
    return Math.exp(Math.min(C / omega, 6));
}

/**
 * QUANTUM AMPLITUDE: Ïˆ âˆ exp(iC/â„)
 * Complex amplitude from coherence
 */
function quantumAmplitude(C) {
    const phase = C / hbar_eff;
    return {
        re: Math.cos(phase),
        im: Math.sin(phase),
        mag: 1,
        phase: phase
    };
}

/**
 * GRAVITATIONAL POTENTIAL: Î¦_g âˆ -C (coherence as mass)
 */
function gravPotential(C, r) {
    if (r < 0.01) r = 0.01;
    return -G_eff * C / r;
}

/**
 * TUNNELING PROBABILITY: P = exp(-2âˆ«âˆš(V-E)/â„ dx)
 * CRR: Tunneling occurs when Î´ fires across coherence barrier
 */
function tunnelingProb(barrier, width) {
    return Math.exp(-2 * Math.sqrt(Math.max(0, barrier)) * width / hbar_eff);
}

/**
 * HAWKING TEMPERATURE: T_H = â„cÂ³/(8Ï€GM)
 * CRR: T = Î© for black holes, radiation rate âˆ Tâ´
 */
function hawkingTemp(mass) {
    if (!isFinite(mass) || mass <= 0) return 1;
    if (mass < 0.1) return 10;  // Micro black holes are HOT
    return hbar_eff / (8 * Math.PI * G_eff * mass);
}

/**
 * BINDING ENERGY: E_b = -Î±_s/r + Ïƒr (Cornell potential)
 * CRR: Coherence overlap creates binding
 */
function bindingEnergy(r, C1, C2) {
    if (r < 0.01) r = 0.01;
    const coulomb = -alpha_strong * Math.sqrt(C1 * C2) / r;
    const confinement = 0.1 * r * (C1 + C2);  // Linear confinement
    return coulomb + confinement;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIELD INITIALIZATION AND UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initFields() {
    coherenceField = [];
    gravitationalPotential = [];
    emPotential = [];
    quantumField = [];
    energyDensity = [];
    
    for (let i = 0; i < GRID; i++) {
        coherenceField[i] = [];
        gravitationalPotential[i] = [];
        emPotential[i] = [];
        quantumField[i] = [];
        energyDensity[i] = [];
        
        for (let j = 0; j < GRID; j++) {
            coherenceField[i][j] = 0.001 * (Math.random() - 0.5);
            gravitationalPotential[i][j] = 0;
            emPotential[i][j] = { ax: 0, ay: 0, phi: 0 };
            quantumField[i][j] = { re: 0, im: 0 };
            energyDensity[i][j] = 0;
        }
    }
}

function updateFields(dt) {
    const newC = coherenceField.map(row => [...row]);
    const diffusion = 0.1;
    const decay = 0.01;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COHERENCE FIELD DYNAMICS
    // âˆ‚C/âˆ‚t = Dâˆ‡Â²C - Î³C + sources
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for (let i = 1; i < GRID - 1; i++) {
        for (let j = 1; j < GRID - 1; j++) {
            // Laplacian
            const lap = (
                coherenceField[i-1][j] + coherenceField[i+1][j] +
                coherenceField[i][j-1] + coherenceField[i][j+1] -
                4 * coherenceField[i][j]
            );
            
            newC[i][j] += diffusion * lap * dt;
            newC[i][j] *= (1 - decay * dt);
            
            // Dark energy contribution (cosmological constant)
            newC[i][j] += 0.0001 * dt;
        }
    }
    
    // Agent contributions
    agents.forEach(a => {
        const gi = Math.floor(a.x * GRID);
        const gj = Math.floor(a.y * GRID);
        if (gi >= 1 && gi < GRID - 1 && gj >= 1 && gj < GRID - 1) {
            newC[gi][gj] += a.coherence * a.mass * 2 * dt;
        }
    });
    
    // Black hole contributions (massive coherence sinks)
    blackHoles.forEach(bh => {
        const gi = Math.floor(bh.x * GRID);
        const gj = Math.floor(bh.y * GRID);
        for (let di = -3; di <= 3; di++) {
            for (let dj = -3; dj <= 3; dj++) {
                const ni = gi + di;
                const nj = gj + dj;
                if (ni >= 0 && ni < GRID && nj >= 0 && nj < GRID) {
                    const r = Math.sqrt(di*di + dj*dj) + 0.5;
                    newC[ni][nj] += bh.mass * 5 / (r * r) * dt;
                }
            }
        }
    });
    
    coherenceField = newC;
    
    // Clamp and sanitize all fields to prevent NaN
    for (let i = 0; i < GRID; i++) {
        for (let j = 0; j < GRID; j++) {
            if (!isFinite(coherenceField[i][j])) coherenceField[i][j] = 0;
            coherenceField[i][j] = Math.max(-2, Math.min(5, coherenceField[i][j]));
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GRAVITATIONAL POTENTIAL
    // âˆ‡Â²Î¦ = 4Ï€GÏ (Poisson equation)
    // Ï âˆ C (coherence as mass density)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for (let i = 1; i < GRID - 1; i++) {
        for (let j = 1; j < GRID - 1; j++) {
            // Iterative relaxation
            const lap = (
                gravitationalPotential[i-1][j] + gravitationalPotential[i+1][j] +
                gravitationalPotential[i][j-1] + gravitationalPotential[i][j+1]
            ) / 4;
            
            const source = 4 * Math.PI * G_eff * coherenceField[i][j];
            gravitationalPotential[i][j] = lap - source * 0.01;
            if (!isFinite(gravitationalPotential[i][j])) gravitationalPotential[i][j] = 0;
            gravitationalPotential[i][j] = Math.max(-10, Math.min(10, gravitationalPotential[i][j]));
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ELECTROMAGNETIC POTENTIAL
    // A_Î¼ from agent phases, âˆ‡Ã—A = B, -âˆ‡Ï† - âˆ‚A/âˆ‚t = E
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for (let i = 1; i < GRID - 1; i++) {
        for (let j = 1; j < GRID - 1; j++) {
            // Decay
            emPotential[i][j].ax *= 0.99;
            emPotential[i][j].ay *= 0.99;
            emPotential[i][j].phi *= 0.99;
            
            // Safety
            if (!isFinite(emPotential[i][j].ax)) emPotential[i][j].ax = 0;
            if (!isFinite(emPotential[i][j].ay)) emPotential[i][j].ay = 0;
            if (!isFinite(emPotential[i][j].phi)) emPotential[i][j].phi = 0;
        }
    }
    
    // Charged agents create EM potential
    agents.forEach(a => {
        if (Math.abs(a.charge) > 0.01) {
            const gi = Math.floor(a.x * GRID);
            const gj = Math.floor(a.y * GRID);
            if (gi >= 1 && gi < GRID - 1 && gj >= 1 && gj < GRID - 1) {
                emPotential[gi][gj].phi += a.charge * alpha_EM * 0.5;
                emPotential[gi][gj].ax += a.charge * a.vx * alpha_EM * 0.1;
                emPotential[gi][gj].ay += a.charge * a.vy * alpha_EM * 0.1;
            }
        }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // QUANTUM FIELD (SchrÃ¶dinger evolution)
    // iâ„ âˆ‚Ïˆ/âˆ‚t = -â„Â²/2m âˆ‡Â²Ïˆ + VÏˆ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const newPsi = quantumField.map(row => row.map(c => ({...c})));
    
    for (let i = 1; i < GRID - 1; i++) {
        for (let j = 1; j < GRID - 1; j++) {
            const psi = quantumField[i][j];
            
            // Laplacian of Ïˆ
            const lapRe = (
                quantumField[i-1][j].re + quantumField[i+1][j].re +
                quantumField[i][j-1].re + quantumField[i][j+1].re -
                4 * psi.re
            );
            const lapIm = (
                quantumField[i-1][j].im + quantumField[i+1][j].im +
                quantumField[i][j-1].im + quantumField[i][j+1].im -
                4 * psi.im
            );
            
            // Potential from coherence field
            const V = gravitationalPotential[i][j] + coherenceField[i][j] * 0.5;
            
            // SchrÃ¶dinger evolution (split-step approximation)
            const factor = hbar_eff * 0.5 * dt;
            newPsi[i][j].re = psi.re + factor * lapIm - V * psi.im * dt / hbar_eff;
            newPsi[i][j].im = psi.im - factor * lapRe + V * psi.re * dt / hbar_eff;
            
            // Damping for stability
            newPsi[i][j].re *= 0.999;
            newPsi[i][j].im *= 0.999;
            
            // Prevent NaN
            if (!isFinite(newPsi[i][j].re)) newPsi[i][j].re = 0;
            if (!isFinite(newPsi[i][j].im)) newPsi[i][j].im = 0;
            newPsi[i][j].re = Math.max(-10, Math.min(10, newPsi[i][j].re));
            newPsi[i][j].im = Math.max(-10, Math.min(10, newPsi[i][j].im));
        }
    }
    
    quantumField = newPsi;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENERGY DENSITY
    // Ï_E = |âˆ‡C|Â² + |Ïˆ|Â² + CÂ²
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for (let i = 1; i < GRID - 1; i++) {
        for (let j = 1; j < GRID - 1; j++) {
            const dCdx = (coherenceField[i+1][j] - coherenceField[i-1][j]) / 2;
            const dCdy = (coherenceField[i][j+1] - coherenceField[i][j-1]) / 2;
            const gradC2 = dCdx * dCdx + dCdy * dCdy;
            
            const psi2 = quantumField[i][j].re ** 2 + quantumField[i][j].im ** 2;
            const C2 = coherenceField[i][j] ** 2;
            
            energyDensity[i][j] = gradC2 * 10 + psi2 * 5 + C2;
            if (!isFinite(energyDensity[i][j])) energyDensity[i][j] = 0;
            energyDensity[i][j] = Math.max(0, Math.min(100, energyDensity[i][j]));
        }
    }
}

function sampleField(field, x, y) {
    if (!isFinite(x) || !isFinite(y)) return 0;
    const gi = Math.floor(x * GRID);
    const gj = Math.floor(y * GRID);
    if (gi >= 0 && gi < GRID && gj >= 0 && gj < GRID) {
        const val = field[gi][gj];
        return isFinite(val) ? val : 0;
    }
    return 0;
}

function sampleGradient(x, y) {
    if (!isFinite(x) || !isFinite(y)) return { x: 0, y: 0, mag: 0 };
    const gi = Math.floor(x * GRID);
    const gj = Math.floor(y * GRID);
    if (gi >= 1 && gi < GRID - 1 && gj >= 1 && gj < GRID - 1) {
        const dx = (coherenceField[gi+1][gj] - coherenceField[gi-1][gj]) / 2;
        const dy = (coherenceField[gi][gj+1] - coherenceField[gi][gj-1]) / 2;
        if (!isFinite(dx) || !isFinite(dy)) return { x: 0, y: 0, mag: 0 };
        return { x: dx, y: dy, mag: Math.sqrt(dx*dx + dy*dy) };
    }
    return { x: 0, y: 0, mag: 0 };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENT CLASS â€” Conscious Entities Commanding Physics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Agent {
    constructor(x, y, parent = null) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 0.02;
        this.vy = (Math.random() - 0.5) * 0.02;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CRR STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        this.coherence = 0.1 + Math.random() * 0.2;
        this.coherenceHistory = [];
        this.phase = Math.random() * Math.PI * 2;
        this.naturalFreq = 0.3 + Math.random() * 0.4;
        this.ruptureThreshold = 0.3 + Math.random() * 0.3;
        this.lastRupture = 0;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHYSICAL PROPERTIES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        this.mass = 0.5 + Math.random() * 1.5;
        this.charge = (Math.random() - 0.5) * 2;  // Can be + or -
        this.spin = Math.random() < 0.5 ? 0.5 : -0.5;
        this.color_charge = Math.floor(Math.random() * 3);  // RGB for strong force
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // QUANTUM STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        this.wavefunction = {
            amplitude: 1,
            phase: Math.random() * Math.PI * 2,
            spread: 0.05 + Math.random() * 0.05  // Spatial uncertainty
        };
        this.inSuperposition = false;
        this.superpositionStates = [];
        this.entangledWith = null;
        this.measured = false;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MORPHOLOGY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        this.size = 4 + Math.random() * 6;
        this.maxSize = 20 + Math.random() * 20;
        this.generation = parent ? parent.generation + 1 : 0;
        this.age = 0;
        
        // Visual
        this.hue = parent ? (parent.hue + (Math.random() - 0.5) * 30 + 360) % 360 
                         : Math.random() * 360;
        this.orbitals = [];
        this.initOrbitals();
        
        // Binding state
        this.boundTo = null;
        this.bindingStrength = 0;
    }
    
    initOrbitals() {
        const n = 3 + Math.floor(Math.random() * 4);
        for (let i = 0; i < n; i++) {
            this.orbitals.push({
                radius: 0.3 + Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 1,
                tilt: (Math.random() - 0.5) * 0.5
            });
        }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // CRR COHERENCE ACCUMULATION WITH ALL PHYSICS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    accumulate(dt, others, time) {
        // Safety check
        if (!isFinite(this.x) || !isFinite(this.y)) {
            this.x = Math.random();
            this.y = Math.random();
        }
        
        const localC = sampleField(coherenceField, this.x, this.y) || 0;
        const localGrad = sampleGradient(this.x, this.y);
        const localPhi = sampleField(gravitationalPotential, this.x, this.y) || 0;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE EVOLUTION (Kuramoto + EM)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let phaseCoupling = 0;
        let neighborCount = 0;
        
        others.forEach(o => {
            if (o.id === this.id) return;
            const dx = o.x - this.x;
            const dy = o.y - this.y;
            const r = Math.sqrt(dx*dx + dy*dy);
            
            if (r < 0.2 && r > 0) {
                // Kuramoto coupling
                phaseCoupling += Math.sin(o.phase - this.phase) / (1 + r * 5);
                neighborCount++;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // QUANTUM ENTANGLEMENT CHECK
                // High phase correlation â†’ potential entanglement
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (!this.entangledWith && !o.entangledWith) {
                    const phaseDiff = Math.abs((this.phase - o.phase + Math.PI) % (Math.PI * 2) - Math.PI);
                    if (phaseDiff < 0.1 && r < 0.05 && Math.random() < 0.01) {
                        // Entangle!
                        this.entangledWith = o.id;
                        o.entangledWith = this.id;
                        entangledPairs.push({ a: this.id, b: o.id, strength: 1 });
                    }
                }
            }
        });
        
        if (neighborCount > 0) phaseCoupling /= neighborCount;
        
        // EM contribution to phase (charge coupling)
        const emPhase = this.charge * alpha_EM * localC * 0.5;
        
        this.phase += (this.naturalFreq + phaseCoupling * 0.5 + emPhase) * dt;
        this.phase = this.phase % (Math.PI * 2);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LIVING FUNCTION L(x,Ï„)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const baseL = 0.1;
        const fieldL = Math.max(0, localC) * 0.5;
        const phaseL = 0.2 * (1 + Math.sin(this.phase));
        const gravL = -localPhi * 0.1;  // Potential energy contribution
        const kinL = 0.5 * this.mass * (this.vx*this.vx + this.vy*this.vy);
        
        const L = baseL + fieldL + phaseL + gravL + kinL;
        this.coherence += L * dt;
        
        // Prevent NaN/Infinity
        if (!isFinite(this.coherence)) this.coherence = 0.1;
        this.coherence = Math.max(-10, Math.min(10, this.coherence));
        
        // Store history for path integral
        this.coherenceHistory.push({ t: time, C: this.coherence, L });
        if (this.coherenceHistory.length > 100) this.coherenceHistory.shift();
        
        this.age += dt;
        
        return this.coherence;
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // QUANTUM DYNAMICS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    updateQuantum(dt, time) {
        const K = kinesis(this.coherence, Omega);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WAVEFUNCTION EVOLUTION
        // Ïˆ(t) = Ïˆ(0) exp(-iEt/â„)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const energy = this.coherence + 0.5 * this.mass * (this.vx*this.vx + this.vy*this.vy);
        this.wavefunction.phase += energy / hbar_eff * dt;
        
        // Spread increases over time (uncertainty)
        this.wavefunction.spread += 0.001 * dt / this.mass;
        this.wavefunction.spread = Math.min(0.2, this.wavefunction.spread);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SUPERPOSITION
        // Enter superposition at high coherence
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!this.inSuperposition && this.coherence > 0.5 && Math.random() < 0.01 * K) {
            this.enterSuperposition();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TUNNELING CHECK
        // Can tunnel through coherence barriers
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const grad = sampleGradient(this.x, this.y);
        if (grad.mag > 0.1) {  // Near a barrier
            const barrier = grad.mag * 10;
            const width = 0.05;
            const prob = tunnelingProb(barrier, width);
            
            if (Math.random() < prob * K * dt) {
                // TUNNEL!
                const tunnelDist = 0.05 + Math.random() * 0.05;
                this.x += (grad.x / grad.mag) * tunnelDist;
                this.y += (grad.y / grad.mag) * tunnelDist;
                stats.tunnelCount++;
                
                // Visual effect
                particles.push(new Particle(this.x, this.y, 'tunnel', this.hue));
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENTANGLEMENT DYNAMICS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.entangledWith) {
            const partner = agents.find(a => a.id === this.entangledWith);
            if (partner) {
                // Phase correlation (nonlocal!)
                const avgPhase = (this.phase + partner.phase) / 2;
                this.phase += (avgPhase - this.phase) * 0.1 * dt;
                
                // Spin anti-correlation (Bell state)
                if (this.spin === partner.spin) {
                    partner.spin = -this.spin;
                }
            } else {
                // Partner gone, decohere
                this.entangledWith = null;
            }
        }
        
        // Deposit to quantum field
        const gi = Math.floor(this.x * GRID);
        const gj = Math.floor(this.y * GRID);
        if (gi >= 0 && gi < GRID && gj >= 0 && gj < GRID) {
            quantumField[gi][gj].re += this.wavefunction.amplitude * Math.cos(this.wavefunction.phase) * 0.1 * dt;
            quantumField[gi][gj].im += this.wavefunction.amplitude * Math.sin(this.wavefunction.phase) * 0.1 * dt;
        }
    }
    
    enterSuperposition() {
        this.inSuperposition = true;
        this.superpositionStates = [
            { x: this.x - 0.03, y: this.y, amp: 0.707 },
            { x: this.x + 0.03, y: this.y, amp: 0.707 }
        ];
        stats.superposCount++;
    }
    
    collapseSuperposition() {
        if (!this.inSuperposition) return;
        
        // Born rule: probability âˆ |amplitude|Â²
        const probs = this.superpositionStates.map(s => s.amp * s.amp);
        const total = probs.reduce((a, b) => a + b, 0);
        let r = Math.random() * total;
        
        for (let i = 0; i < this.superpositionStates.length; i++) {
            r -= probs[i];
            if (r <= 0) {
                this.x = this.superpositionStates[i].x;
                this.y = this.superpositionStates[i].y;
                break;
            }
        }
        
        this.inSuperposition = false;
        this.superpositionStates = [];
        this.measured = true;
        
        // Visual effect
        particles.push(new Particle(this.x, this.y, 'collapse', this.hue));
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // GRAVITATIONAL DYNAMICS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    applyGravity(dt, others) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GEODESIC MOTION
        // Follows gradient of gravitational potential
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const gi = Math.floor(this.x * GRID);
        const gj = Math.floor(this.y * GRID);
        
        if (gi >= 1 && gi < GRID - 1 && gj >= 1 && gj < GRID - 1) {
            const dPhidx = (gravitationalPotential[gi+1][gj] - gravitationalPotential[gi-1][gj]) / 2;
            const dPhidy = (gravitationalPotential[gi][gj+1] - gravitationalPotential[gi][gj-1]) / 2;
            
            // F = -mâˆ‡Î¦
            this.vx -= dPhidx * G_eff * dt * 0.5;
            this.vy -= dPhidy * G_eff * dt * 0.5;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DIRECT N-BODY GRAVITY
        // F = -Gmâ‚mâ‚‚/rÂ² rÌ‚
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        others.forEach(o => {
            if (o.id === this.id) return;
            
            const dx = o.x - this.x;
            const dy = o.y - this.y;
            const r2 = dx*dx + dy*dy;
            const r = Math.sqrt(r2);
            
            if (r < 0.5 && r > 0.01) {
                const F = G_eff * this.mass * o.mass / (r2 + 0.001);
                this.vx += F * dx / r * dt * 0.1;
                this.vy += F * dy / r * dt * 0.1;
            }
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BLACK HOLE ATTRACTION
        // Strong gravity near event horizon
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        blackHoles.forEach(bh => {
            const dx = bh.x - this.x;
            const dy = bh.y - this.y;
            const r = Math.sqrt(dx*dx + dy*dy);
            
            const rs = bh.schwarzschildRadius;
            
            if (r < rs * 5 && r > rs) {
                // Strong gravity
                const F = G_eff * bh.mass * this.mass / (r * r);
                this.vx += F * dx / r * dt;
                this.vy += F * dy / r * dt;
            }
            
            if (r < rs * 1.5) {
                // Absorbed!
                this.absorbed = true;
                bh.mass += this.mass;
            }
        });
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ELECTROMAGNETIC DYNAMICS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    applyEM(dt, others) {
        if (Math.abs(this.charge) < 0.01) return;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COULOMB FORCE
        // F = kqâ‚qâ‚‚/rÂ² rÌ‚
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        others.forEach(o => {
            if (o.id === this.id || Math.abs(o.charge) < 0.01) return;
            
            const dx = o.x - this.x;
            const dy = o.y - this.y;
            const r2 = dx*dx + dy*dy;
            const r = Math.sqrt(r2);
            
            if (r < 0.3 && r > 0.01) {
                // Coulomb: like charges repel, opposite attract
                const F = -alpha_EM * this.charge * o.charge / (r2 + 0.001);
                this.vx += F * dx / r * dt * 0.3;
                this.vy += F * dy / r * dt * 0.3;
            }
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LORENTZ FORCE
        // F = q(E + vÃ—B)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const gi = Math.floor(this.x * GRID);
        const gj = Math.floor(this.y * GRID);
        
        if (gi >= 1 && gi < GRID - 1 && gj >= 1 && gj < GRID - 1) {
            const em = emPotential[gi][gj];
            
            // E = -âˆ‡Ï† - âˆ‚A/âˆ‚t (approximated)
            const Ex = -(emPotential[gi+1][gj].phi - emPotential[gi-1][gj].phi) / 2;
            const Ey = -(emPotential[gi][gj+1].phi - emPotential[gi][gj-1].phi) / 2;
            
            // B = âˆ‡Ã—A (z-component in 2D)
            const Bz = (emPotential[gi+1][gj].ay - emPotential[gi-1][gj].ay) / 2 -
                       (emPotential[gi][gj+1].ax - emPotential[gi][gj-1].ax) / 2;
            
            // Lorentz force
            this.vx += this.charge * (Ex + this.vy * Bz) * dt * 0.1;
            this.vy += this.charge * (Ey - this.vx * Bz) * dt * 0.1;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHOTON EMISSION
        // Accelerating charge radiates
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const accel = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        if (accel > 0.01 && Math.random() < accel * Math.abs(this.charge) * 0.1) {
            photons.push(new Photon(this.x, this.y, Math.atan2(this.vy, this.vx) + Math.PI));
            stats.photonCount++;
        }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STRONG FORCE DYNAMICS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    applyStrong(dt, others) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLOR FORCE (simplified)
        // Attraction between different color charges
        // Confinement at large distances
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        others.forEach(o => {
            if (o.id === this.id) return;
            
            const dx = o.x - this.x;
            const dy = o.y - this.y;
            const r = Math.sqrt(dx*dx + dy*dy);
            
            if (r < 0.1 && r > 0.005) {
                // Color interaction
                const colorFactor = this.color_charge !== o.color_charge ? 1 : -0.5;
                
                // Cornell potential: V = -Î±/r + Ïƒr
                const coulombPart = -alpha_strong * colorFactor / (r + 0.01);
                const stringPart = 0.5 * r * colorFactor;
                const F = -(coulombPart / r - stringPart) * dt * 0.5;
                
                this.vx += F * dx / r;
                this.vy += F * dy / r;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // BINDING CHECK
                // Can form bound states (hadrons)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (r < 0.02 && !this.boundTo && !o.boundTo) {
                    const bindE = bindingEnergy(r, this.coherence, o.coherence);
                    if (bindE < -0.1 && Math.random() < 0.1) {
                        // Form bound state!
                        this.boundTo = o.id;
                        o.boundTo = this.id;
                        this.bindingStrength = -bindE;
                        o.bindingStrength = -bindE;
                        stats.fusionCount++;
                        
                        // Emit gluon
                        gluons.push(new Particle(
                            (this.x + o.x) / 2,
                            (this.y + o.y) / 2,
                            'gluon',
                            this.hue
                        ));
                    }
                }
            }
        });
        
        // Maintain bound state
        if (this.boundTo) {
            const partner = agents.find(a => a.id === this.boundTo);
            if (partner) {
                const dx = partner.x - this.x;
                const dy = partner.y - this.y;
                const r = Math.sqrt(dx*dx + dy*dy);
                
                // Spring force to maintain binding
                const targetR = 0.015;
                const spring = (r - targetR) * 2;
                this.vx += spring * dx / r * dt;
                this.vy += spring * dy / r * dt;
                
                // Check for fission (rupture breaking bond)
                if (this.coherence > this.ruptureThreshold * 2) {
                    // Enough energy to break!
                    this.boundTo = null;
                    partner.boundTo = null;
                    stats.fissionCount++;
                    
                    // Explosion
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(this.x, this.y, 'fission', 0));
                    }
                }
            } else {
                this.boundTo = null;
            }
        }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WEAK FORCE (DECAY)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    checkWeakDecay(dt, spawnCallback) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SPONTANEOUS DECAY
        // Heavy agents can decay into lighter ones
        // Rate âˆ Î±_weak * mass
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const decayProb = alpha_weak * this.mass * 0.001 * dt;
        
        if (this.mass > 1.5 && Math.random() < decayProb) {
            // Decay!
            stats.decayCount++;
            
            // Create decay products
            const child = new Agent(this.x, this.y, this);
            child.mass = this.mass * 0.6;
            child.vx = this.vx + (Math.random() - 0.5) * 0.05;
            child.vy = this.vy + (Math.random() - 0.5) * 0.05;
            child.charge = -this.charge * 0.5;  // Charge partial conservation
            
            this.mass *= 0.4;
            this.charge *= 0.5;
            
            spawnCallback(child);
            
            // Emit neutrino (escapes)
            particles.push(new Particle(this.x, this.y, 'neutrino', 120));
            
            // Maybe transmutation
            if (Math.random() < 0.3) {
                this.color_charge = (this.color_charge + 1) % 3;
                stats.transmuteCount++;
            }
        }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // CRR RUPTURE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    checkRupture(time) {
        const K = kinesis(this.coherence, Omega);
        const threshold = this.ruptureThreshold / (1 + 0.3 * (K - 1));
        
        if (this.coherence > threshold && time - this.lastRupture > 0.2) {
            this.lastRupture = time;
            stats.ruptures++;
            return true;
        }
        return false;
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // CRR REGENERATION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    regenerate(time, spawnCallback) {
        // Path integral
        let R = 0;
        this.coherenceHistory.forEach(h => {
            const phi = 1 + 0.3 * Math.sin(h.t * 2);
            const weight = Math.exp(Math.min(h.C / Omega, 4));
            R += phi * weight;
        });
        R = R / Math.max(1, this.coherenceHistory.length) * 0.15;
        stats.totalRegen += R;
        
        // Growth
        this.size = Math.min(this.size + R * 4, this.maxSize);
        this.mass += R * 0.1;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SPAWN OFFSPRING (particle creation!)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const spawnProb = 0.2 * Math.exp(Math.min(this.coherence / Omega, 3));
        
        if (this.generation < 6 && Math.random() < spawnProb && agents.length < 150) {
            const grad = sampleGradient(this.x, this.y);
            const angle = grad.mag > 0.01 ? Math.atan2(grad.y, grad.x) : Math.random() * Math.PI * 2;
            const dist = 0.03 + Math.random() * 0.03;
            
            const childX = Math.max(0.02, Math.min(0.98, this.x + Math.cos(angle) * dist));
            const childY = Math.max(0.02, Math.min(0.98, this.y + Math.sin(angle) * dist));
            
            const child = new Agent(childX, childY, this);
            child.charge = -this.charge * 0.8;  // Charge conservation (pair production!)
            spawnCallback(child);
            
            // Pair production visual
            particles.push(new Particle(this.x, this.y, 'creation', this.hue));
        }
        
        // Collapse superposition on rupture
        if (this.inSuperposition) {
            this.collapseSuperposition();
        }
        
        // Reset coherence with memory
        this.coherence *= Omega;
        
        // Visual
        particles.push(new Particle(this.x, this.y, 'rupture', this.hue));
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MOVEMENT
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    move(dt) {
        // Safety check velocities
        if (!isFinite(this.vx)) this.vx = 0;
        if (!isFinite(this.vy)) this.vy = 0;
        
        // Clamp velocities to prevent explosion
        this.vx = Math.max(-0.5, Math.min(0.5, this.vx));
        this.vy = Math.max(-0.5, Math.min(0.5, this.vy));
        
        // Apply all accumulated forces
        this.x += this.vx * dt * 5;
        this.y += this.vy * dt * 5;
        
        // Damping (energy dissipation)
        this.vx *= 0.995;
        this.vy *= 0.995;
        
        // Boundary
        if (this.x < 0.01) { this.x = 0.01; this.vx *= -0.5; }
        if (this.x > 0.99) { this.x = 0.99; this.vx *= -0.5; }
        if (this.y < 0.01) { this.y = 0.01; this.vy *= -0.5; }
        if (this.y > 0.99) { this.y = 0.99; this.vy *= -0.5; }
        
        // Handle superposition states
        if (this.inSuperposition) {
            this.superpositionStates.forEach(s => {
                s.x += this.vx * dt * 5 + (Math.random() - 0.5) * 0.002;
                s.y += this.vy * dt * 5 + (Math.random() - 0.5) * 0.002;
            });
        }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // UPDATE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    update(dt, time) {
        const K = kinesis(this.coherence, Omega);
        
        this.orbitals.forEach(o => {
            o.phase += o.speed * K * dt * 3;
        });
        
        this.wavefunction.spread *= 0.999;  // Localization
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DRAWING
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    draw(ctx, W, H, time) {
        // Safety checks for position
        if (!isFinite(this.x) || !isFinite(this.y)) return;
        
        const px = this.x * W;
        const py = this.y * H;
        const K = Math.max(1, Math.min(10, kinesis(this.coherence, Omega)));  // Clamp kinesis
        
        // Safety check
        if (!isFinite(px) || !isFinite(py) || !isFinite(K)) return;
        
        ctx.save();
        ctx.translate(px, py);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SUPERPOSITION VISUALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.inSuperposition) {
            this.superpositionStates.forEach(s => {
                const sx = (s.x - this.x) * W;
                const sy = (s.y - this.y) * H;
                
                ctx.beginPath();
                ctx.arc(sx, sy, this.size * s.amp * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 70%, 60%, ${0.3 * s.amp})`;
                ctx.fill();
                
                // Interference pattern between states
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(sx, sy);
                ctx.strokeStyle = `hsla(${this.hue}, 80%, 70%, 0.2)`;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENTANGLEMENT VISUALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.entangledWith) {
            const partner = agents.find(a => a.id === this.entangledWith);
            if (partner) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo((partner.x - this.x) * W, (partner.y - this.y) * H);
                ctx.strokeStyle = `hsla(300, 80%, 60%, ${0.3 + 0.2 * Math.sin(time * 5)})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BINDING VISUALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.boundTo) {
            const partner = agents.find(a => a.id === this.boundTo);
            if (partner) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo((partner.x - this.x) * W, (partner.y - this.y) * H);
                ctx.strokeStyle = `hsla(0, 80%, 50%, ${0.5 + this.bindingStrength * 0.3})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WAVEFUNCTION SPREAD (uncertainty cloud)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const spreadRaw = this.wavefunction.spread * W * 3;
        const spreadRadius = Math.max(1, Math.min(200, isFinite(spreadRaw) ? spreadRaw : 10));
        const waveGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, spreadRadius);
        waveGrad.addColorStop(0, `hsla(${this.hue}, 60%, 50%, 0.3)`);
        waveGrad.addColorStop(0.5, `hsla(${this.hue}, 70%, 60%, 0.15)`);
        waveGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = waveGrad;
        ctx.beginPath();
        ctx.arc(0, 0, spreadRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ORBITALS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        this.orbitals.forEach((o, i) => {
            const ox = Math.cos(o.phase) * this.size * o.radius * 1.5;
            const oy = Math.sin(o.phase + o.tilt) * this.size * o.radius * 1.5;
            
            ctx.beginPath();
            ctx.arc(ox, oy, 2 + Math.sin(o.phase) * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${this.hue + i * 30}, 70%, 70%, 0.6)`;
            ctx.fill();
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MAIN BODY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const pulse = 1 + K * 0.1 * Math.sin(this.phase);
        const bodySizeRaw = this.size * pulse;
        const bodySize = Math.max(2, Math.min(100, isFinite(bodySizeRaw) ? bodySizeRaw : 5));
        
        // Charge-dependent glow
        const glowColor = this.charge > 0 ? 
            `hsla(${this.hue}, 80%, 60%, 0.4)` : 
            `hsla(${(this.hue + 180) % 360}, 80%, 60%, 0.4)`;
        
        const glowRadius = Math.max(1, Math.min(200, bodySize * 2));
        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
        glow.addColorStop(0, glowColor);
        glow.addColorStop(0.5, `hsla(${this.hue}, 60%, 40%, 0.2)`);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, bodySize * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.beginPath();
        const points = 16;
        for (let i = 0; i < points; i++) {
            const angle = (i / points) * Math.PI * 2;
            const wobble = 1 + K * 0.08 * Math.sin(angle * 3 + this.phase * 2);
            const r = bodySize * wobble;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        
        const bodyGradRadius = Math.max(1, Math.min(100, bodySize));
        const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, bodyGradRadius);
        bodyGrad.addColorStop(0, `hsla(${this.hue}, 70%, 60%, 0.9)`);
        bodyGrad.addColorStop(0.7, `hsla(${this.hue}, 60%, 45%, 0.8)`);
        bodyGrad.addColorStop(1, `hsla(${this.hue}, 50%, 30%, 0.7)`);
        ctx.fillStyle = bodyGrad;
        ctx.fill();
        
        // Spin indicator
        const spinAngle = this.spin > 0 ? time * 3 : -time * 3;
        ctx.beginPath();
        ctx.arc(0, 0, bodySize * 0.4, spinAngle, spinAngle + Math.PI);
        ctx.strokeStyle = `hsla(${this.hue}, 80%, 80%, 0.6)`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Color charge indicator (for strong force)
        const colorHues = [0, 120, 240];  // RGB
        ctx.beginPath();
        ctx.arc(0, 0, bodySize * 0.2, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${colorHues[this.color_charge]}, 80%, 50%, 0.7)`;
        ctx.fill();
        
        ctx.restore();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BLACK HOLE CLASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BlackHole {
    constructor(x, y, mass) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = x;
        this.y = y;
        this.mass = mass;
        this.spin = Math.random() * 0.99;  // Kerr parameter
        this.age = 0;
        
        // Schwarzschild radius (event horizon)
        this.schwarzschildRadius = 2 * G_eff * mass / 100;  // Scaled
    }
    
    update(dt) {
        this.age += dt;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HAWKING RADIATION
        // T_H = â„cÂ³/(8Ï€GM)
        // Mass loss: dM/dt âˆ -Tâ´ âˆ -1/MÂ²
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const T_H = hawkingTemp(this.mass);
        const radiationRate = T_H * T_H * T_H * T_H * 0.0001 * dt;
        
        this.mass -= radiationRate;
        this.mass = Math.max(0.01, this.mass);  // Prevent negative mass
        this.schwarzschildRadius = Math.max(0.001, 2 * G_eff * this.mass / 100);
        
        stats.hawkingRate = radiationRate / dt;
        
        // Emit Hawking particles
        if (Math.random() < radiationRate * 10) {
            const angle = Math.random() * Math.PI * 2;
            const r = this.schwarzschildRadius * 1.5;
            photons.push(new Photon(
                this.x + Math.cos(angle) * r,
                this.y + Math.sin(angle) * r,
                angle
            ));
            stats.photonCount++;
        }
        
        return this.mass > 0.1;  // Evaporates when too small
    }
    
    draw(ctx, W, H, time) {
        // Safety checks
        if (!isFinite(this.x) || !isFinite(this.y) || !isFinite(this.mass)) return;
        
        const px = this.x * W;
        const py = this.y * H;
        const rsRaw = this.schwarzschildRadius * W;
        const rs = Math.max(3, Math.min(100, isFinite(rsRaw) ? rsRaw : 5));
        
        ctx.save();
        ctx.translate(px, py);
        
        // Accretion disk
        const diskOuter = Math.max(rs + 1, rs * 5);
        const diskGrad = ctx.createRadialGradient(0, 0, rs, 0, 0, diskOuter);
        diskGrad.addColorStop(0, 'rgba(255, 200, 100, 0.8)');
        diskGrad.addColorStop(0.3, 'rgba(255, 150, 50, 0.4)');
        diskGrad.addColorStop(0.6, 'rgba(255, 100, 50, 0.2)');
        diskGrad.addColorStop(1, 'transparent');
        
        ctx.fillStyle = diskGrad;
        ctx.beginPath();
        ctx.ellipse(0, 0, diskOuter, rs * 3, time * 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Event horizon (pure black)
        ctx.beginPath();
        ctx.arc(0, 0, rs, 0, Math.PI * 2);
        ctx.fillStyle = '#000';
        ctx.fill();
        
        // Gravitational lensing ring
        ctx.beginPath();
        ctx.arc(0, 0, rs * 1.5, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(40, 100%, 70%, ${0.5 + 0.3 * Math.sin(time * 2)})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Hawking radiation glow
        const T_H = hawkingTemp(this.mass);
        const glowIntensity = Math.min(1, T_H * 0.3);
        
        ctx.beginPath();
        ctx.arc(0, 0, rs * 2, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(60, 100%, 80%, ${glowIntensity * 0.5})`;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.restore();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHOTON CLASS (EM Radiation)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Photon {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 0.2;  // Speed of light (scaled)
        this.wavelength = 400 + Math.random() * 300;  // nm (for color)
        this.energy = 1;
        this.age = 0;
    }
    
    update(dt) {
        this.x += Math.cos(this.angle) * this.speed * dt;
        this.y += Math.sin(this.angle) * this.speed * dt;
        this.energy *= 0.995;  // Redshift
        this.age += dt;
        
        // Gravitational bending near black holes
        blackHoles.forEach(bh => {
            const dx = bh.x - this.x;
            const dy = bh.y - this.y;
            const r = Math.sqrt(dx*dx + dy*dy);
            
            if (r < bh.schwarzschildRadius * 5 && r > bh.schwarzschildRadius) {
                // Bend toward black hole
                const bendAngle = Math.atan2(dy, dx);
                const bendStrength = G_eff * bh.mass / (r * r) * dt * 2;
                this.angle += (bendAngle - this.angle) * bendStrength;
            }
        });
        
        return this.energy > 0.1 && 
               this.x > 0 && this.x < 1 && 
               this.y > 0 && this.y < 1 &&
               this.age < 5;
    }
    
    draw(ctx, W, H) {
        if (!isFinite(this.x) || !isFinite(this.y) || !isFinite(this.energy)) return;
        
        const px = this.x * W;
        const py = this.y * H;
        const energy = Math.max(0, Math.min(1, this.energy));
        
        // Wavelength to color
        const hue = (this.wavelength - 400) / 300 * 270;  // Violet to red
        
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(
            px - Math.cos(this.angle) * 8 * energy,
            py - Math.sin(this.angle) * 8 * energy
        );
        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${energy})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Photon head
        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${energy})`;
        ctx.fill();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PARTICLE CLASS (General effects)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Particle {
    constructor(x, y, type, hue) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.hue = hue;
        this.life = 1;
        this.vx = (Math.random() - 0.5) * 0.05;
        this.vy = (Math.random() - 0.5) * 0.05;
        this.size = 3;
        
        if (type === 'rupture') {
            this.vx *= 2;
            this.vy *= 2;
            this.size = 5;
        } else if (type === 'tunnel') {
            this.hue = 200;
            this.size = 8;
        } else if (type === 'collapse') {
            this.hue = 280;
            this.size = 10;
        } else if (type === 'creation') {
            this.size = 6;
        } else if (type === 'neutrino') {
            this.speed = 0.15;
            this.angle = Math.random() * Math.PI * 2;
            this.size = 2;
        } else if (type === 'gluon') {
            this.hue = Math.random() * 360;
            this.size = 4;
        } else if (type === 'fission') {
            this.vx *= 4;
            this.vy *= 4;
            this.hue = 30;
            this.size = 8;
        }
    }
    
    update(dt) {
        if (this.type === 'neutrino') {
            this.x += Math.cos(this.angle) * this.speed * dt;
            this.y += Math.sin(this.angle) * this.speed * dt;
        } else {
            this.x += this.vx * dt * 10;
            this.y += this.vy * dt * 10;
            this.vx *= 0.95;
            this.vy *= 0.95;
        }
        
        this.life -= dt * (this.type === 'neutrino' ? 0.3 : 1);
        return this.life > 0;
    }
    
    draw(ctx, W, H) {
        if (!isFinite(this.x) || !isFinite(this.y) || !isFinite(this.life)) return;
        const alpha = Math.max(0, Math.min(1, this.life));
        const radius = Math.max(0.1, Math.min(20, this.size * this.life));
        ctx.beginPath();
        ctx.arc(this.x * W, this.y * H, radius, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${alpha})`;
        ctx.fill();
        
        if (this.type === 'tunnel' || this.type === 'collapse') {
            ctx.beginPath();
            ctx.arc(this.x * W, this.y * H, radius * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `hsla(${this.hue}, 80%, 70%, ${alpha * 0.5})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIELD VISUALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawFields(ctx, W, H, mode) {
    const cellW = W / GRID;
    const cellH = H / GRID;
    
    for (let i = 0; i < GRID; i++) {
        for (let j = 0; j < GRID; j++) {
            let color;
            
            switch (mode) {
                case 'quantum':
                    const psi = quantumField[i][j];
                    const mag2 = psi.re * psi.re + psi.im * psi.im;
                    const phase = Math.atan2(psi.im, psi.re);
                    const hue = ((phase + Math.PI) / (2 * Math.PI)) * 360;
                    color = `hsla(${hue}, 70%, 50%, ${Math.min(0.8, mag2 * 50)})`;
                    break;
                    
                case 'gravity':
                    const phi = gravitationalPotential[i][j];
                    const intensity = Math.min(1, Math.abs(phi) * 5);
                    color = phi < 0 ? 
                        `hsla(260, 70%, ${20 + intensity * 40}%, ${intensity * 0.7})` :
                        `hsla(30, 70%, ${20 + intensity * 40}%, ${intensity * 0.7})`;
                    break;
                    
                case 'em':
                    const em = emPotential[i][j];
                    const emMag = Math.sqrt(em.ax*em.ax + em.ay*em.ay + em.phi*em.phi);
                    const emInt = Math.min(1, emMag * 10);
                    color = `hsla(45, 80%, 50%, ${emInt * 0.6})`;
                    break;
                    
                case 'energy':
                    const E = energyDensity[i][j];
                    const eInt = Math.min(1, E * 2);
                    color = `hsla(${60 - eInt * 60}, 80%, ${30 + eInt * 40}%, ${eInt * 0.8})`;
                    break;
                    
                default:  // Coherence
                    const C = coherenceField[i][j];
                    if (C > 0) {
                        color = `hsla(160, 60%, ${20 + C * 60}%, ${Math.min(0.7, C)})`;
                    } else {
                        color = `hsla(280, 60%, ${20 + Math.abs(C) * 40}%, ${Math.min(0.5, Math.abs(C))})`;
                    }
            }
            
            ctx.fillStyle = color;
            ctx.fillRect(i * cellW, j * cellH, cellW + 1, cellH + 1);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function init() {
    const maxWidth = Math.min(800, window.innerWidth - 650);
    canvas.width = maxWidth;
    canvas.height = maxWidth;
    
    initFields();
    agents = [];
    particles = [];
    blackHoles = [];
    entangledPairs = [];
    photons = [];
    gluons = [];
    
    simTime = 0;
    cosmicAge = 0;
    scaleFactor = 1;
    
    // Reset stats
    Object.keys(stats).forEach(k => stats[k] = 0);
    
    // Initial agents in interesting configuration
    const n = 25;
    for (let i = 0; i < n; i++) {
        const angle = (i / n) * Math.PI * 2;
        const r = 0.2 + Math.random() * 0.2;
        agents.push(new Agent(
            0.5 + Math.cos(angle) * r,
            0.5 + Math.sin(angle) * r
        ));
    }
    
    // Some in center
    for (let i = 0; i < 5; i++) {
        agents.push(new Agent(
            0.5 + (Math.random() - 0.5) * 0.1,
            0.5 + (Math.random() - 0.5) * 0.1
        ));
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastTime = 0;

function animate(currentTime) {
    if (isPaused) {
        requestAnimationFrame(animate);
        return;
    }
    
    const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
    lastTime = currentTime;
    simTime += dt;
    cosmicAge += dt;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COSMOLOGICAL EXPANSION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const darkEnergyDensity = 0.001;
    hubbleParam = Math.sqrt(8 * Math.PI * G_eff * darkEnergyDensity / 3);
    scaleFactor *= (1 + hubbleParam * dt * 0.01);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE FIELDS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    updateFields(dt);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE AGENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const newAgents = [];
    let totalC = 0, maxC = 0, totalGrad = 0;
    
    agents = agents.filter(a => !a.absorbed);
    
    agents.forEach(a => {
        // CRR accumulation
        const C = a.accumulate(dt, agents, simTime);
        totalC += C;
        maxC = Math.max(maxC, C);
        
        // Quantum dynamics
        a.updateQuantum(dt, simTime);
        
        // Apply all forces
        a.applyGravity(dt, agents);
        a.applyEM(dt, agents);
        a.applyStrong(dt, agents);
        
        // Weak decay check
        a.checkWeakDecay(dt, child => newAgents.push(child));
        
        // CRR rupture check
        if (a.checkRupture(simTime)) {
            a.regenerate(simTime, child => newAgents.push(child));
        }
        
        // Move
        a.move(dt);
        
        // Update internals
        a.update(dt, simTime);
        
        totalGrad += sampleGradient(a.x, a.y).mag;
    });
    
    // Add new agents
    if (agents.length < 150) {
        agents.push(...newAgents);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE BLACK HOLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    blackHoles = blackHoles.filter(bh => bh.update(dt));
    stats.blackHoleCount = blackHoles.length;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE PHOTONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    photons = photons.filter(p => p.update(dt));
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE PARTICLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    particles = particles.filter(p => p.update(dt));
    gluons = gluons.filter(g => g.update(dt));
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE ENTANGLEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    entangledPairs = entangledPairs.filter(pair => {
        const a = agents.find(ag => ag.id === pair.a);
        const b = agents.find(ag => ag.id === pair.b);
        return a && b && a.entangledWith === pair.b;
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPUTE STATISTICS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const n = agents.length;
    const avgC = n > 0 ? totalC / n : 0;
    const avgGrad = n > 0 ? totalGrad / n : 0;
    
    // Thermodynamics
    const coherences = agents.map(a => a.coherence);
    const entropy = computeEntropy(coherences);
    const temperature = Omega;  // T âˆ Î©
    const freeEnergy = avgC - temperature * entropy;
    
    // Information measures
    const fisherInfo = computeFisherInfo(coherences);
    const mutualInfo = computeMutualInfo(agents);
    const complexity = entropy * (1 - entropy / Math.log(n + 1));
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DRAW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ctx.fillStyle = '#020204';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Field visualization
    if (showFields || viewMode !== 'normal') {
        drawFields(ctx, canvas.width, canvas.height, viewMode);
    }
    
    // Particles
    particles.forEach(p => p.draw(ctx, canvas.width, canvas.height));
    gluons.forEach(g => g.draw(ctx, canvas.width, canvas.height));
    
    // Photons
    photons.forEach(p => p.draw(ctx, canvas.width, canvas.height));
    
    // Black holes
    blackHoles.forEach(bh => bh.draw(ctx, canvas.width, canvas.height, simTime));
    
    // Agents
    agents.forEach(a => a.draw(ctx, canvas.width, canvas.height, simTime));
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UPDATE UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.getElementById('qmProb').textContent = agents.filter(a => a.inSuperposition).length > 0 ? 
        (agents.filter(a => a.inSuperposition).length / n).toFixed(3) : '0.000';
    document.getElementById('hbar').textContent = hbar_eff.toFixed(3);
    document.getElementById('tunnelCount').textContent = stats.tunnelCount;
    document.getElementById('superposCount').textContent = stats.superposCount;
    
    document.getElementById('totalMass').textContent = agents.reduce((s, a) => s + a.mass, 0).toFixed(2);
    document.getElementById('curvature').textContent = avgGrad.toFixed(4);
    document.getElementById('blackHoleCount').textContent = stats.blackHoleCount;
    document.getElementById('hawkingRate').textContent = stats.hawkingRate.toFixed(5);
    
    document.getElementById('totalCharge').textContent = agents.reduce((s, a) => s + a.charge, 0).toFixed(3);
    document.getElementById('eField').textContent = 'â€”';  // Complex to compute globally
    document.getElementById('bField').textContent = 'â€”';
    document.getElementById('photonCount').textContent = photons.length;
    
    document.getElementById('boundStates').textContent = agents.filter(a => a.boundTo).length / 2;
    document.getElementById('bindingEnergy').textContent = 
        agents.filter(a => a.boundTo).reduce((s, a) => s + a.bindingStrength, 0).toFixed(3);
    document.getElementById('fusionCount').textContent = stats.fusionCount;
    document.getElementById('fissionCount').textContent = stats.fissionCount;
    
    document.getElementById('decayCount').textContent = stats.decayCount;
    document.getElementById('transmuteCount').textContent = stats.transmuteCount;
    
    document.getElementById('avgC').textContent = avgC.toFixed(4);
    document.getElementById('maxC').textContent = maxC.toFixed(4);
    document.getElementById('gradC').textContent = avgGrad.toFixed(5);
    document.getElementById('ruptures').textContent = stats.ruptures;
    document.getElementById('regen').textContent = stats.totalRegen.toFixed(3);
    document.getElementById('omega').textContent = Omega.toFixed(3);
    
    document.getElementById('entanglePairs').textContent = entangledPairs.length;
    document.getElementById('concurrence').textContent = 
        (entangledPairs.length / Math.max(1, n / 2)).toFixed(3);
    document.getElementById('bellViolation').textContent = 
        entangledPairs.length > 0 ? (2 * Math.SQRT2 * entangledPairs.length / n).toFixed(3) : '0.000';
    
    document.getElementById('entropy').textContent = entropy.toFixed(4);
    document.getElementById('temperature').textContent = temperature.toFixed(4);
    document.getElementById('freeEnergy').textContent = freeEnergy.toFixed(4);
    
    document.getElementById('scaleFactor').textContent = scaleFactor.toFixed(4);
    document.getElementById('hubble').textContent = hubbleParam.toFixed(5);
    document.getElementById('darkEnergy').textContent = (darkEnergyDensity * scaleFactor * scaleFactor).toFixed(5);
    
    document.getElementById('fisherInfo').textContent = fisherInfo.toFixed(4);
    document.getElementById('mutualInfo').textContent = mutualInfo.toFixed(4);
    document.getElementById('complexity').textContent = complexity.toFixed(4);
    
    document.getElementById('agentCount').textContent = n;
    document.getElementById('particleCount').textContent = particles.length + photons.length + gluons.length;
    document.getElementById('generations').textContent = Math.max(...agents.map(a => a.generation), 0);
    document.getElementById('cosmicAge').textContent = cosmicAge.toFixed(2);
    
    requestAnimationFrame(animate);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function computeEntropy(values) {
    const n = values.length;
    if (n === 0) return 0;
    const total = values.reduce((a, b) => a + Math.max(0.001, b), 0);
    let S = 0;
    values.forEach(v => {
        const p = Math.max(0.001, v) / total;
        S -= p * Math.log(p);
    });
    return S;
}

function computeFisherInfo(values) {
    const n = values.length;
    if (n === 0) return 0;
    const mean = values.reduce((a, b) => a + b, 0) / n;
    const variance = values.reduce((a, v) => a + (v - mean) ** 2, 0) / n;
    return variance / (Omega * Omega);
}

function computeMutualInfo(agents) {
    // Simplified: correlation between position and coherence
    const n = agents.length;
    if (n < 2) return 0;
    
    let sumXC = 0, sumX = 0, sumC = 0, sumX2 = 0, sumC2 = 0;
    agents.forEach(a => {
        const x = a.x + a.y;  // Combined position
        const c = a.coherence;
        sumXC += x * c;
        sumX += x;
        sumC += c;
        sumX2 += x * x;
        sumC2 += c * c;
    });
    
    const covariance = (sumXC - sumX * sumC / n) / n;
    const varX = sumX2 / n - (sumX / n) ** 2;
    const varC = sumC2 / n - (sumC / n) ** 2;
    
    if (varX < 0.0001 || varC < 0.0001) return 0;
    
    const correlation = covariance / Math.sqrt(varX * varC);
    return Math.abs(correlation);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function togglePause() {
    isPaused = !isPaused;
    document.getElementById('pauseBtn').textContent = isPaused ? 'â–¶ Play' : 'â¸ Pause';
}

function triggerBigBang() {
    // Reset and create explosive expansion
    init();
    
    // All agents start at center with high velocity
    agents.forEach(a => {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.1 + Math.random() * 0.15;
        a.x = 0.5 + (Math.random() - 0.5) * 0.05;
        a.y = 0.5 + (Math.random() - 0.5) * 0.05;
        a.vx = Math.cos(angle) * speed;
        a.vy = Math.sin(angle) * speed;
        a.coherence = 1;  // High initial coherence
    });
    
    // Massive coherence deposit at center
    const center = Math.floor(GRID / 2);
    for (let di = -5; di <= 5; di++) {
        for (let dj = -5; dj <= 5; dj++) {
            const r = Math.sqrt(di*di + dj*dj);
            if (center + di >= 0 && center + di < GRID && center + dj >= 0 && center + dj < GRID) {
                coherenceField[center + di][center + dj] = 2 / (1 + r);
            }
        }
    }
    
    // Big bang particles
    for (let i = 0; i < 50; i++) {
        particles.push(new Particle(0.5, 0.5, 'creation', Math.random() * 360));
    }
}

function createBlackHole() {
    // Create at random position with significant mass
    const bh = new BlackHole(
        0.2 + Math.random() * 0.6,
        0.2 + Math.random() * 0.6,
        3 + Math.random() * 5
    );
    blackHoles.push(bh);
}

function triggerQuantumFluctuation() {
    // Random quantum effects everywhere
    agents.forEach(a => {
        if (Math.random() < 0.3) {
            a.enterSuperposition();
        }
        if (Math.random() < 0.2) {
            a.coherence += (Math.random() - 0.5) * 0.5;
        }
    });
    
    // Vacuum fluctuations in quantum field
    for (let i = 0; i < GRID; i++) {
        for (let j = 0; j < GRID; j++) {
            quantumField[i][j].re += (Math.random() - 0.5) * 0.1;
            quantumField[i][j].im += (Math.random() - 0.5) * 0.1;
        }
    }
}

function induceEntanglement() {
    // Force nearby agents to entangle
    for (let i = 0; i < agents.length; i++) {
        if (agents[i].entangledWith) continue;
        
        for (let j = i + 1; j < agents.length; j++) {
            if (agents[j].entangledWith) continue;
            
            const dx = agents[i].x - agents[j].x;
            const dy = agents[i].y - agents[j].y;
            const r = Math.sqrt(dx*dx + dy*dy);
            
            if (r < 0.15) {
                agents[i].entangledWith = agents[j].id;
                agents[j].entangledWith = agents[i].id;
                entangledPairs.push({ a: agents[i].id, b: agents[j].id, strength: 1 });
                break;
            }
        }
    }
}

function triggerSupernova() {
    // Find most massive agent and explode it
    if (agents.length === 0) return;
    
    let maxMass = 0, target = null;
    agents.forEach(a => {
        if (a.mass > maxMass) {
            maxMass = a.mass;
            target = a;
        }
    });
    
    if (target) {
        // Supernova!
        const x = target.x;
        const y = target.y;
        
        // Create many particles
        for (let i = 0; i < 30; i++) {
            const angle = (i / 30) * Math.PI * 2;
            particles.push(new Particle(x, y, 'fission', 30 + Math.random() * 30));
        }
        
        // Create photon burst
        for (let i = 0; i < 20; i++) {
            photons.push(new Photon(x, y, (i / 20) * Math.PI * 2));
        }
        
        // Maybe leave behind a black hole
        if (maxMass > 2) {
            blackHoles.push(new BlackHole(x, y, maxMass * 0.3));
        }
        
        // Spawn new agents from the debris
        for (let i = 0; i < 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 0.05 + Math.random() * 0.1;
            const child = new Agent(
                Math.max(0.02, Math.min(0.98, x + Math.cos(angle) * r)),
                Math.max(0.02, Math.min(0.98, y + Math.sin(angle) * r))
            );
            child.vx = Math.cos(angle) * 0.1;
            child.vy = Math.sin(angle) * 0.1;
            agents.push(child);
        }
        
        // Remove the exploded agent
        agents = agents.filter(a => a.id !== target.id);
        
        // Massive coherence deposit
        const gi = Math.floor(x * GRID);
        const gj = Math.floor(y * GRID);
        for (let di = -5; di <= 5; di++) {
            for (let dj = -5; dj <= 5; dj++) {
                const ni = gi + di;
                const nj = gj + dj;
                if (ni >= 0 && ni < GRID && nj >= 0 && nj < GRID) {
                    coherenceField[ni][nj] += maxMass / (1 + Math.sqrt(di*di + dj*dj));
                }
            }
        }
    }
}

function toggleField() {
    showFields = !showFields;
    document.getElementById('fieldBtn').classList.toggle('active', showFields);
}

function reset() {
    init();
}

function setOmega(val) {
    Omega = parseFloat(val);
    document.getElementById('omegaDisp').textContent = Omega.toFixed(3);
}

function setHbar(val) {
    hbar_eff = parseFloat(val);
    document.getElementById('hbarDisp').textContent = hbar_eff.toFixed(2);
}

function setGravity(val) {
    G_eff = parseFloat(val);
    document.getElementById('gravDisp').textContent = G_eff.toFixed(1);
}

function setEM(val) {
    alpha_EM = parseFloat(val);
    document.getElementById('emDisp').textContent = alpha_EM.toFixed(2);
}

function setViewMode(mode) {
    viewMode = mode;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('resize', () => {
    const maxWidth = Math.min(800, window.innerWidth - 650);
    if (Math.abs(canvas.width - maxWidth) > 50) {
        canvas.width = maxWidth;
        canvas.height = maxWidth;
    }
});

init();
requestAnimationFrame(animate);

</script>
</body>
</html>
