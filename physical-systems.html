<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physical Systems - Cohere.org.uk - Mathematical Life and Living Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
            font-family: Georgia, serif;
            line-height: 1.6;
            color: #2c2c2c;
            overflow-x: hidden;
        }

        /* Main Container */
        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 60px;
        }

        /* Header Section */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .title-group {
            display: flex;
            flex-direction: column;
        }

        .site-title {
            font-family: Georgia, serif;
            font-size: 48px;
            font-weight: normal;
            color: #1a1a1a;
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .strapline {
            font-family: Georgia, serif;
            font-size: 18px;
            font-style: italic;
            color: #6c757d;
            letter-spacing: 0.5px;
        }

        /* Navigation System */
        .main-nav {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #495057;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #1a1a1a;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: #4a90e2;
            color: white;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .nav-item:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        /* Robust Dropdown Menu System */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 8px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 1000;
            overflow: hidden;
        }

        /* Critical: No gap between nav item and dropdown */
        .nav-item:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Keep dropdown visible when hovering over dropdown itself */
        .dropdown-menu:hover {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Ensure dropdown stays open during mouse travel */
        .nav-item::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-link {
            display: block;
            padding: 12px 20px;
            color: #495057;
            text-decoration: none;
            font-size: 16px;
            font-family: Georgia, serif;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #4a90e2;
            border-left-color: #4a90e2;
        }

        /* Simulation Canvas Section */
        .simulation-section {
            margin: 40px 0;
            padding: 30px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            position: relative;
        }

        .simulation-title {
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
            text-align: center;
        }

        #canvas {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 30%, #cd853f 100%);
            border-top: 4px solid #ffffff;
            border-bottom: 4px solid #ffffff;
            border-left: none;
            border-right: none;
            border-radius: 0;
            width: 100%;
            height: 300px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }

        /* Physics Controls */
        .physics-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .phase-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: Georgia, serif;
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.9);
            color: #495057;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .phase-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .phase-btn.coherence { 
            background: linear-gradient(45deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));
            border-color: rgba(102,126,234,0.4);
            color: #667eea;
        }

        .phase-btn.rupture { 
            background: linear-gradient(45deg, rgba(240,147,251,0.2), rgba(245,87,108,0.2));
            border-color: rgba(240,147,251,0.4);
            color: #f093fb;
        }

        .phase-btn.rebirth { 
            background: linear-gradient(45deg, rgba(67,233,123,0.2), rgba(56,249,215,0.2));
            border-color: rgba(67,233,123,0.4);
            color: #43e97b;
        }

        /* Sliders */
        .sliders {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .slider-label {
            font-size: 12px;
            color: #6c757d;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: Georgia, serif;
        }

        .slider {
            width: 120px;
            height: 4px;
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #357abd;
            transform: scale(1.1);
        }

        .value {
            font-size: 11px;
            color: #6c757d;
            min-width: 30px;
            text-align: center;
            font-family: Georgia, serif;
        }

        /* Metrics */
        .metrics {
            font-style: italic;
            font-size: 13px;
            color: #6c757d;
            text-align: center;
            line-height: 1.6;
            max-width: 90%;
            margin: 20px auto;
            font-family: Georgia, serif;
        }

        .metric-line {
            margin: 6px 0;
        }

        /* Simulation Links Section */
        .simulation-links {
            margin: 60px 0;
            padding: 40px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        .links-title {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .simulation-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
        }

        .simulation-category {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            text-align: center;
        }

        .category-title {
            font-family: Georgia, serif;
            font-size: 20px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
        }

        .simulation-link {
            display: block;
            margin: 10px 0;
            padding: 8px 16px;
            color: #4a90e2;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-family: Georgia, serif;
            border: 1px solid rgba(74, 144, 226, 0.2);
        }

        .simulation-link:hover {
            background: rgba(74, 144, 226, 0.08);
            transform: translateY(-1px);
        }

        .link-description {
            font-size: 12px;
            color: #6c757d;
            font-style: italic;
            margin-top: 4px;
        }

        /* Logo Animation */
        .logo-hive {
            position: relative;
            overflow: visible;
        }

        .logo-bee {
            position: absolute;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .logo-interior {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .logo:hover .logo-interior {
            opacity: 1;
        }

        .logo:hover .logo-bee {
            opacity: 0.3;
        }

        .logo-hive.rupture {
            animation: hiveGlow 3s ease-out;
        }

        @keyframes hiveGlow {
            0% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
            20% { filter: drop-shadow(0 0 20px rgba(74, 144, 226, 0.6)); }
            40% { filter: drop-shadow(0 0 30px rgba(74, 144, 226, 0.4)); }
            70% { filter: drop-shadow(0 0 15px rgba(74, 144, 226, 0.3)); }
            100% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
        }

        /* Footer */
        .footer {
            background: rgba(245, 246, 248, 0.9);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            padding: 50px 0 40px;
            text-align: center;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1000px;
            margin: 0 auto;
        }

        .copyright {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #1a1a1a;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .footer-tech-note {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            font-style: italic;
            line-height: 1.4;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .simulation-categories {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .page-container {
                padding: 0 30px;
            }

            .header {
                flex-direction: column;
                gap: 30px;
                text-align: center;
                padding: 30px 0;
            }

            .logo-section {
                flex-direction: column;
                gap: 15px;
            }

            .logo {
                margin-right: 0;
            }

            .site-title {
                font-size: 36px;
            }

            .main-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            .dropdown-menu {
                position: static;
                opacity: 1;
                visibility: visible;
                transform: none;
                box-shadow: none;
                border: none;
                background: rgba(74, 144, 226, 0.05);
                margin-top: 10px;
                border-radius: 4px;
                display: none;
            }

            .nav-item:hover .dropdown-menu {
                display: block;
            }

            .physics-controls {
                gap: 10px;
            }

            .phase-btn {
                padding: 6px 12px;
                font-size: 11px;
            }

            .sliders {
                gap: 20px;
                flex-direction: column;
                align-items: center;
            }

            .slider-group {
                flex-direction: row;
                gap: 15px;
                width: 100%;
                max-width: 280px;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header class="header">
            <div class="logo-section">
                <svg class="logo logo-hive" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <radialGradient id="hiveGrad" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" style="stop-color:#8B4513;stop-opacity:0.9" />
                            <stop offset="70%" style="stop-color:#A0522D;stop-opacity:0.8" />
                            <stop offset="100%" style="stop-color:#654321;stop-opacity:0.7" />
                        </radialGradient>
                        <radialGradient id="honeyGrad" cx="50%" cy="50%" r="40%">
                            <stop offset="0%" style="stop-color:#FFD700;stop-opacity:0.8" />
                            <stop offset="100%" style="stop-color:#FFA500;stop-opacity:0.6" />
                        </radialGradient>
                    </defs>
                    
                    <ellipse cx="50" cy="55" rx="25" ry="30" fill="url(#hiveGrad)" stroke="#654321" stroke-width="1"/>
                    <ellipse cx="50" cy="75" rx="6" ry="8" fill="#3D2F1F"/>
                    
                    <path d="M30 40 Q50 38 70 40" stroke="#654321" stroke-width="1" fill="none" opacity="0.7"/>
                    <path d="M32 50 Q50 48 68 50" stroke="#654321" stroke-width="1" fill="none" opacity="0.7"/>
                    <path d="M34 60 Q50 58 66 60" stroke="#654321" stroke-width="1" fill="none" opacity="0.7"/>
                    
                    <g class="logo-interior">
                        <polygon points="45,45 47,43 52,43 54,45 52,47 47,47" fill="url(#honeyGrad)" opacity="0.8"/>
                        <polygon points="52,45 54,43 59,43 61,45 59,47 54,47" fill="url(#honeyGrad)" opacity="0.7"/>
                        <polygon points="38,45 40,43 45,43 47,45 45,47 40,47" fill="url(#honeyGrad)" opacity="0.9"/>
                        <polygon points="41,53 43,51 48,51 50,53 48,55 43,55" fill="url(#honeyGrad)" opacity="0.8"/>
                        <polygon points="48,53 50,51 55,51 57,53 55,55 50,55" fill="url(#honeyGrad)" opacity="0.7"/>
                        
                        <ellipse class="interior-bee-1" cx="46" cy="46" rx="2" ry="1.5" fill="#FFD700" opacity="0.8"/>
                        <ellipse class="interior-bee-2" cx="53" cy="52" rx="2" ry="1.5" fill="#FFD700" opacity="0.9"/>
                    </g>
                    
                    <g class="logo-bee bee-1">
                        <ellipse cx="25" cy="35" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="24" cy="35" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="26" cy="33" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="26" cy="37" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                    
                    <g class="logo-bee bee-2">
                        <ellipse cx="75" cy="45" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="74" cy="45" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="76" cy="43" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="76" cy="47" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                    
                    <g class="logo-bee bee-3">
                        <ellipse cx="40" cy="25" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="39" cy="25" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="41" cy="23" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="41" cy="27" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                    
                    <g class="logo-bee bee-4">
                        <ellipse cx="65" cy="25" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="64" cy="25" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="66" cy="23" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="66" cy="27" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                </svg>
                
                <div class="title-group">
                    <h1 class="site-title">Cohere.org.uk</h1>
                    <p class="strapline">Made of Maths</p>
                </div>
            </div>

            <nav class="main-nav">
                <div class="nav-item">
                    <a href="index.html" class="nav-link">Home</a>
                </div>
                <div class="nav-item">
                    <a href="crr-simulations.html" class="nav-link">
                        CRR Simulations
                        <span class="dropdown-arrow">▼</span>
                    </a>
                    <div class="dropdown-menu">
                        <a href="biological-systems.html" class="dropdown-link">Biological Systems</a>
                        <a href="physical-systems.html" class="dropdown-link">Physical Systems</a>
                        <a href="mathematical-life.html" class="dropdown-link">Mathematical Life</a>
                    </div>
                </div>
                <div class="nav-item">
                    <a href="crr-benchmarks.html" class="nav-link">CRR Benchmarks</a>
                </div>
                <div class="nav-item">
                    <a href="crr-explained.html" class="nav-link">CRR Explained</a>
                </div>
                <div class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </div>
            </nav>
        </header>

        <main>
            <section class="simulation-section">
                <h2 class="simulation-title">CRR Physical Systems: Mathematical Physics in Motion</h2>
                
                <canvas id="canvas"></canvas>
                
                <div class="physics-controls">
                    <button class="phase-btn coherence" onclick="setPhase('coherence')">C(x) Coherence</button>
                    <button class="phase-btn rupture" onclick="setPhase('rupture')">δ Rupture (forget coordinates)</button>
                    <button class="phase-btn rebirth" onclick="setPhase('rebirth')">R[x] Regen</button>
                </div>
                
                <div class="sliders">
                    <div class="slider-group">
                        <label class="slider-label">Memory</label>
                        <input type="range" class="slider" id="memorySlider" min="0.2" max="8.0" step="0.1" value="2.5">
                        <span class="value" id="memoryValue">2.5</span>
                    </div>
                    
                    <div class="slider-group">
                        <label class="slider-label">Intensity</label>
                        <input type="range" class="slider" id="intensitySlider" min="0.2" max="5.0" step="0.1" value="1.8">
                        <span class="value" id="intensityValue">1.8</span>
                    </div>
                    
                    <div class="slider-group">
                        <label class="slider-label">Fidelity</label>
                        <input type="range" class="slider" id="fidelitySlider" min="0.2" max="4.0" step="0.1" value="1.2">
                        <span class="value" id="fidelityValue">1.2</span>
                    </div>
                </div>
                
                <div class="metrics">
                    <div class="metric-line">
                        <span id="coherenceMetric">Coherence: 0.245</span> • 
                        <span id="particleMetric">Particles: 400</span> • 
                        <span id="memoryMetric">Memory: 0.156</span>
                    </div>
                    <div class="metric-line">
                        <span id="phaseMetric">Phase transitions: 0</span> • 
                        <span id="qualityMetric">Reconstruction: 0.78</span>
                    </div>
                </div>
            </section>


            <style>
                /* Table Styles */
                .category-header {
                    font-family: Georgia, serif;
                    font-size: 28px;
                    font-weight: normal;
                    color: #1a1a1a;
                    margin: 50px 0 30px 0;
                    padding-bottom: 15px;
                    border-bottom: 2px solid #4a90e2;
                }

                .category-header:first-of-type {
                    margin-top: 20px;
                }

                .simulation-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-bottom: 50px;
                    background: white;
                    border: 2px solid #dee2e6;
                }

                .simulation-table thead {
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                }

                .simulation-table th {
                    font-family: Georgia, serif;
                    font-size: 16px;
                    font-weight: 600;
                    color: #1a1a1a;
                    text-align: left;
                    padding: 18px 20px;
                    border: 1px solid #dee2e6;
                }

                .simulation-table td {
                    font-family: Georgia, serif;
                    font-size: 15px;
                    line-height: 1.7;
                    color: #495057;
                    padding: 20px;
                    border: 1px solid #dee2e6;
                    vertical-align: top;
                }

                .simulation-table tbody tr {
                    transition: background-color 0.2s ease;
                }

                .simulation-table tbody tr:hover {
                    background-color: rgba(74, 144, 226, 0.03);
                }

                .table-simulation-link {
                    color: #4a90e2;
                    text-decoration: none;
                    font-weight: 500;
                    transition: all 0.2s ease;
                }

                .table-simulation-link:hover {
                    color: #2563eb;
                    text-decoration: underline;
                }

                .simulation-table th:first-child,
                .simulation-table td:first-child {
                    width: 20%;
                }

                .simulation-table th:nth-child(2),
                .simulation-table td:nth-child(2) {
                    width: 40%;
                }

                .simulation-table th:nth-child(3),
                .simulation-table td:nth-child(3) {
                    width: 40%;
                }

                .merged-cell {
                    font-style: italic;
                    color: #6c757d;
                }

                .intro-text {
                    font-family: Georgia, serif;
                    font-size: 18px;
                    line-height: 1.8;
                    color: #495057;
                    margin: 40px 0;
                    text-align: center;
                    max-width: 900px;
                    margin-left: auto;
                    margin-right: auto;
                }
            </style>

            <section class="simulation-links">
                <h2 class="links-title">Physical Systems Simulations</h2>
                <p class="intro-text">
                    Explore interactive toy CRR simulations demonstrating physical phenomena across scales; from quantum mechanics to cosmology. Each simulation provides hands-on exploration of dynamical systems, phase transitions, and emergent behaviours. These are provided as proof of concept only and are intended for users to reflect on the role of markovian and non-markovian memory in complex systems over time. 
                </p>

                <h2 class="category-header">Physics & Cosmology</h2>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>Simulation</th>
                            <th>Description</th>
                            <th>Why It Might Matter</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="atom_advanced.html" class="table-simulation-link" target="_blank">Atom</a></td>
                            <td>Interactive atomic structure model with electron orbital dynamics. <strong>CRR implementation:</strong> Coherence C(t) accumulates as deviation from ground state energy; rupture δ(t-t₀) triggers quantum jumps between orbital shells following Fermi's Golden Rule; regeneration uses Boltzmann weighting exp(C/Ω) to determine transition probabilities. Wave-particle duality emerges from tanh(C/C_crit) mixing parameter. We share this as a computational model of interest, noting that CRR memory dynamics can be modelled at this scale</td>
                            <td>Quantum systems exhibit both continuous evolution and discrete jumps. Understanding how coherence relates to observable transitions.</td>
                        </tr>
                        <tr>
                            <td><a href="black_hole.html" class="table-simulation-link" target="_blank">Black Hole (Interactive)</a></td>
                            <td>Simplified black hole system with event horizon and accretion dynamics. <strong>CRR implementation:</strong> Coherence integrates matter-energy density in accretion disk; event horizon acts as rupture boundary (δ(r-R_s)) where spacetime forces discrete transitions; Hawking radiation represents regeneration flux weighted by black hole's accumulated mass history.</td>
                            <td>Black holes represent boundary conditions where spacetime geometry forces discontinuous transitions. Studying these systems may offer insights into fundamental limits of information and causality. We share this because we find it intriguing that black holes seem to share similar memory-based patterns to a surprising number of other physical and biological systems, including human beings!</td>
                        </tr>
                        <tr>
                            <td><a href="blackhole_a.html" class="table-simulation-link" target="_blank">Black Hole (Research)</a></td>
                            <td>Extended black hole simulation with comprehensive CRR mathematics. <strong>Implementation:</strong> Full coherence field calculations for orbiting matter; threshold-triggered rupture events at the event horizon; regeneration operator modelling quantum fluctuations producing Hawking radiation at temperature T_H = ℏc³/(8πGMk_B).</td>
                            <td>The interplay between matter accumulation, horizon physics, and quantum radiation presents a laboratory for studying irreversible processes and thermal equilibrium in gravitational systems. CRR as a coarse-grain approach for understanding how systems maintain identity by changing.</td>
                        </tr>
                        <tr>
                            <td><a href="darkenergy.html" class="table-simulation-link" target="_blank">Dark Energy</a></td>
                            <td>Cosmological evolution with time-varying dark energy. <strong>CRR implementation:</strong> Coherence C(t) accumulates as cosmic age in Gyr; vacuum equation of state w(t) evolves as function of C/Ω ratio; phantom crossing occurs when coherence reaches critical threshold; regeneration term modifies dark energy density ρ_Λ(t) exponentially with accumulated coherence.</td>
                            <td>Recent observational data suggest possible deviations from cosmological constant behaviour. Models that incorporate memory effects in the vacuum may contribute to understanding accelerated expansion and the universe's ultimate fate. The CRR offers a coarse-grain understanding - it is modelled here to demonstrate the principle of systems maintaining identity by changing.</td>
                        </tr>
                        <tr>
                            <td rowspan="2"><a href="sun.html" class="table-simulation-link" target="_blank">Sun Simulation (V1)</a><br><br><a href="sun2.html" class="table-simulation-link" target="_blank">Sun Simulation (V2)</a></td>
                            <td colspan="2" class="merged-cell">Two complementary solar simulations demonstrating stellar dynamics. <strong>CRR implementation:</strong> Nuclear coherence (C_nuclear) accumulates from fusion reactions over stellar lifetime; magnetic coherence follows ~11-year cycles. Rupture events include: solar flares (magnetic reconnection, δ-impulses with τ=5s), coronal mass ejections (plasma expulsion with extended regeneration), and magnetic field reversals (complete coherence reset). Regeneration operator rebuilds corona and magnetic structure with memory of past configurations. We share this to show how even the sun can be thought of, in a coarse-grain way, as a memory-bearing system!</td>
                        </tr>
                        <tr>
                            <td>The Sun exhibits both steady fusion processes and catastrophic magnetic events. Understanding how systems reduce free energy variation through time and reach critical thresholds may be of benefit to systems thinkers.</td>
                        </tr>
                        <tr>
                            <td><a href="crr-thermo-rupture-rate.html" class="table-simulation-link" target="_blank">Thermodynamics</a></td>
                            <td>Thermodynamic CRR system with non-Markovian dynamics. <strong>CRR implementation:</strong> Coherence C accumulates as potential energy at rate L₀=0.6 J/time; rupture δ(t-t₀) activates when C≥threshold, transferring heat Q=C×1.5; regeneration R[χ] extracts work through memory integral ∫φ(τ)·exp(C/Ω)·Θ(t-τ)dτ with causal Heaviside constraint. Demonstrates perfect energy conservation (0.000% error).</td>
                            <td>Non-Markovian thermodynamics with memory effects remains compatible with fundamental conservation laws. This might have implications for understanding far-from-equilibrium processes and energy harvesting in complex systems. Maybe.</td>
                        </tr>
                        <tr>
                            <td><a href="crr_sandpile_sim__2_.html" class="table-simulation-link" target="_blank">Sandpile Modelling</a></td>
                            <td>Self-organised criticality via Bak-Tang-Wiesenfeld cellular automaton. <strong>CRR implementation:</strong> Coherence C_n = ∫(z-z_c/2)dt for each site accumulates height deviation; rupture occurs when grain count z≥4, triggering avalanche; regeneration distributes grains to neighbours weighted by exp(C_n/Ω). System self-organises to critical state C→C* with power-law avalanche distribution P(s)~s^(-1.27).</td>
                            <td>Self-organised critical systems appear across nature—from earthquakes to neural avalanches. Understanding how systems naturally evolve towards critical states may inform prediction of cascading failures and phase transitions.</td>
                        </tr>
                    </tbody>
                </table>

                <h2 class="category-header">Basic Phase Transitions & Interactive Models</h2>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>Simulation</th>
                            <th>Description</th>
                            <th>Why It Might Matter</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="kettle.html" class="table-simulation-link" target="_blank">Kettle</a></td>
                            <td>Water boiling with molecular dynamics and hydrogen bonding. <strong>CRR implementation:</strong> Coherence measured through hydrogen bond network stability and thermal equilibrium; rupture δ(t-t₀) occurs at phase transition threshold (100°C) breaking liquid coherence into chaotic steam; regeneration models atmospheric dispersion and convection currents with memory of thermal history.</td>
                            <td>Phase transitions involve crossing discrete thresholds where coherent structures rupture. Everyday phenomena like boiling provide accessible examples of how accumulated thermal energy triggers sudden reorganisation. We share this as a simple pedagogical model to show how coherence builds over time until rupture/phase transition thresholds are met</td>
                        </tr>
                        <tr>
                            <td><a href="ice.html" class="table-simulation-link" target="_blank">Ice</a></td>
                            <td>Crystallisation dynamics with nucleation and growth. <strong>CRR implementation:</strong> Coherence C(x,t) tracks local molecular organisation through temperature-dependent coupling; nucleation sites emerge when coherence exceeds threshold (rupture points); regeneration operator propagates crystalline order spatially using exp(C/Ω) weighting, with Heaviside causality ensuring crystal grows from established regions. Notice how cohernece also increases in this system, as the system forms a stabilised structure over time. This is why we think of CRR in terms of identity transforming through time, at all scales.</td>
                            <td>Freezing demonstrates how local interactions produce long-range order. Understanding nucleation and crystal growth informs materials science, protein folding, and pattern formation in natural systems.</td>
                        </tr>
                        <tr>
                            <td><a href="Zippo.html" class="table-simulation-link" target="_blank">Zippo Lighter</a></td>
                            <td>Interactive lighter with realistic combustion mechanics. <strong>CRR implementation:</strong> Fuel vapour coherence field tracks butane concentration and mixing; spark field accumulates ignition energy through flint friction; rupture occurs when ignition_energy>threshold AND fuel_density>0.3, triggering flame; regeneration maintains flame through memory-weighted fuel consumption with wind/movement perturbations causing coherence loss.</td>
                            <td>Combustion requires precise conditions—fuel density, ignition energy, and spatial coherence. Small variations determine whether reactions propagate or extinguish, illustrating sensitivity to initial conditions in chemical systems. We like the emergent effects from gas escaping, and the natural "non-markovian" look of the flame!</td>
                        </tr>
                        <tr>
                            <td><a href="atmosphere.html" class="table-simulation-link" target="_blank">Atmosphere</a></td>
                            <td>Molecular-scale atmospheric model with N₂, O₂, CO₂ interactions. <strong>CRR implementation:</strong> Atmospheric coherence field (80 elements) tracks gas mixture organisation; field evolves via temperature/pressure/humidity coupling; molecular collisions create rupture events redistributing momentum; regeneration processes restore equilibrium distributions through Brownian dynamics.</td>
                            <td>Atmospheric chemistry involves countless molecular collisions producing emergent properties like pressure and temperature. Such systems bridge microscopic randomness and macroscopic regularity.</td>
                        </tr>
                        <tr>
                            <td><a href="crr_holographic_final.html" class="table-simulation-link" target="_blank">Holographic</a></td>
                            <td>Thin-film interference and holographic projection. <strong>CRR implementation:</strong> Multi-layer optical path differences create interference patterns; coherence accumulates constructively/destructively across viewing angles; colour regeneration computed through wavelength-dependent phase shifts (400-700nm range); memory effects produce viewing-angle-dependent iridescence.</td>
                            <td>Wave interference creates stable patterns from continuous oscillations. Holography demonstrates how distributed information can encode three-dimensional structure—concepts relevant to both optics and theoretical physics. Upload an image to "rupture" the coherence field and see some stunning holographic effects!</td>
                        </tr>
                        <tr>
                            <td><a href="crr-bubble-simulation__2_.html" class="table-simulation-link" target="_blank">Bubbles</a></td>
                            <td>Soap bubble physics with film drainage and rupture. <strong>CRR implementation:</strong> Coherence L=f_film·f_age·f_structure·f_kinetic accumulates film stability factors; rupture δ(t-t₀) triggers when C<threshold or perturbation exceeds tolerance, creating film shards with retraction velocities; regeneration models droplet spray and surface tension relaxation weighted by pre-rupture coherence exp(C/Ω).</td>
                            <td>Soap films exist at minimal energy configurations until perturbations exceed stability thresholds. Their dynamics illustrate how structures persist through continuous adjustment until catastrophic failure occurs. We know this isn't an NVidia level demonstration, but we found it intriguing!</td>
                        </tr>
                    </tbody>
                </table>

                <h2 class="category-header">Markovian Agents in Non-Markovian Fields (ML Applications)</h2>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>Simulation</th>
                            <th>Description</th>
                            <th>Why It Might Matter</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="room.html" class="table-simulation-link" target="_blank">Room Navigation</a></td>
                            <td>Multi-room exploration with key collection and goal-finding. <strong>CRR implementation:</strong> Agent maintains spatial coherence field C(x,y) through visited locations; local rupture detection via loop threshold breaks exploration cycles; global rupture resets after goal achievement; regeneration operator R[χ] weights actions by spatial memory integral ∫φ(x,τ)·exp(C/Ω)dτ. Intelligence I(t)=tanh(C_global/Ω) emerges from accumulated experience.</td>
                            <td>Intelligent behaviour can emerge from simple principles without explicit programming. Spatial memory accumulated through exploration enables efficient navigation—relevant for robotics, autonomous systems, and understanding biological navigation.</td>
                        </tr>
                        <tr>
                            <td><a href="fish.html" class="table-simulation-link" target="_blank">Fish Schooling</a></td>
                            <td>Single-agent learning with predators and food. <strong>CRR implementation:</strong> Memory trace accumulates position history (max 500 timesteps); coherence C grows via learning density L=reward-baseline; rupture occurs when C>threshold, triggering behavioural reset; regeneration R calculates movement bias from memory-weighted historical states. Avoidance/seeking strength scales with tanh(C/Ω) intelligence factor.</td>
                            <td>Animals adapt continuously to changing environments through memory and learning. Understanding how individual agents balance exploration, exploitation, and threat avoidance may inform reinforcement learning and swarm intelligence.</td>
                        </tr>
                        <tr>
                            <td><a href="Maze.html" class="table-simulation-link" target="_blank">Maze Pathfinding</a></td>
                            <td>Goal-directed maze navigation with emergent intelligence. <strong>CRR implementation:</strong> Global coherence C_global and per-cell coherence fields C(x,y) accumulate from learning density L(reward); spatial memory stores field signals with coherence-weighted history; action selection combines goal distance heuristic with regeneration momentum R·direction; intelligence I=C_global/Ω modulates exploration/exploitation trade-off. Rupture on threshold crossing or timeout.</td>
                            <td>Pathfinding in unknown environments requires balancing memory, exploration, and goal pursuit. Emergent intelligence from accumulated coherence may offer alternatives to traditional planning algorithms in uncertain domains.</td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </main>
    </div>
    </div>

    <footer class="footer">
        <div class="page-container">
            <div class="footer-content">
                <p class="copyright">
                    <strong>Copyright Protected © Alexander Sabine (alexander@cohere.org.uk) Patent Pending with European Patent Office: 25196496.1</strong>
                </p>
                <p class="footer-tech-note">
                    Note: These physics simulations utilise HTML5, WebGL2, and advanced JavaScript. Desktop browsers recommended for optimal performance. They are shared for curiosity building and further discussion about principles of how memory shapes systems through time.
                </p>
            </div>
        </div>
    </footer>

    <script>
        'use strict';

        // =====================================
        // CRR PHYSICAL SYSTEMS - NON-MARKOVIAN MEMORY IMPLEMENTATION
        // =====================================

        // Optimized WebGL2 CRR System
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        // Physical system parameters
        const PARTICLE_COUNT = 400;
        const MEMORY_GRID_SIZE = 64;
        let currentPhase = 'coherence';
        let memoryStrength = 2.5;
        let intensity = 1.8;
        let fidelity = 1.2;
        let globalTime = 0;
        let phaseTransitions = 0;
        
        // Auto-demo variables
        let userInteracted = false;
        let autoSequenceStarted = false;
        let startTime = Date.now();

        // CRITICAL: Non-Markovian memory system - NO coordinates stored after rupture
        const particles = new Float32Array(PARTICLE_COUNT * 12); // pos(2) + vel(2) + state(2) + memoryWeights(6)
        const memoryField = new Float32Array(MEMORY_GRID_SIZE * MEMORY_GRID_SIZE);
        const coherenceMemory = new Array(PARTICLE_COUNT).fill(null).map(() => []); // Historical coherence patterns
        
        // Enhanced shaders with rich color variation for physics
        const vertexShader = `#version 300 es
        in vec2 a_position;
        in vec2 a_velocity;
        in vec2 a_state;
        
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform int u_phase;
        
        out vec4 v_color;
        out float v_size;
        
        void main() {
            vec2 position = (a_position / u_resolution) * 2.0 - 1.0;
            position.y *= -1.0;
            gl_Position = vec4(position, 0.0, 1.0);
            
            float coherence = a_state.x;
            float memoryStrength = a_state.y;
            
            // Determine letter index from position for color variation
            float normalizedX = a_position.x / u_resolution.x;
            int letterIndex = int(normalizedX * 6.0);
            
            if (u_phase == 0) { // Coherence - physics-themed colors
                v_size = (2.0 + coherence * 4.0) * (0.8 + memoryStrength * 0.4);
                
                if (letterIndex == 0) { // C - atomic red
                    v_color = vec4(1.0, 0.3 + coherence * 0.4, 0.2 + coherence * 0.3, 0.8 + coherence * 0.2);
                } else if (letterIndex == 1) { // O - nuclear blue
                    v_color = vec4(0.2 + coherence * 0.3, 0.5 + coherence * 0.4, 1.0, 0.8 + coherence * 0.2);
                } else if (letterIndex == 2) { // H - energy green
                    v_color = vec4(0.1 + coherence * 0.4, 0.8 + coherence * 0.2, 0.3 + coherence * 0.4, 0.8 + coherence * 0.2);
                } else if (letterIndex == 3) { // E - photon yellow
                    v_color = vec4(1.0, 0.8 + coherence * 0.2, 0.1 + coherence * 0.4, 0.8 + coherence * 0.2);
                } else if (letterIndex == 4) { // R - quantum violet
                    v_color = vec4(0.7 + coherence * 0.3, 0.2 + coherence * 0.3, 1.0, 0.8 + coherence * 0.2);
                } else { // E - plasma orange
                    v_color = vec4(1.0, 0.5 + coherence * 0.3, 0.1 + coherence * 0.3, 0.8 + coherence * 0.2);
                }
            } else if (u_phase == 1) { // Rupture - high energy physics
                v_size = (3.0 + memoryStrength * 3.0) * (1.0 + coherence * 0.5);
                float flicker = 0.8 + sin(u_time * 0.1 + a_position.x * 0.01) * 0.2 * memoryStrength;
                v_color = vec4((0.9 + memoryStrength * 0.1) * flicker, (0.3 + memoryStrength * 0.4) * flicker, 0.8 * flicker, 0.7 + memoryStrength * 0.3);
            } else { // Rebirth - reconstruction physics
                v_size = (1.5 + coherence * 5.0) * (0.9 + memoryStrength * 0.3);
                float glow = 0.9 + sin(u_time * 0.05) * 0.1;
                v_color = vec4(0.3 * glow, (0.7 + coherence * 0.3) * glow, (0.5 + coherence * 0.4) * glow, 0.7 + coherence * 0.3);
            }
            
            gl_PointSize = v_size + sin(u_time * 0.002 + a_position.x * 0.01) * 0.5;
        }`;
        
        const fragmentShader = `#version 300 es
        precision mediump float;
        
        in vec4 v_color;
        in float v_size;
        
        out vec4 fragColor;
        
        void main() {
            vec2 coord = gl_PointCoord - 0.5;
            float dist = length(coord);
            
            if (dist > 0.5) discard;
            
            float alpha = 1.0 - smoothstep(0.1, 0.5, dist);
            vec3 glow = v_color.rgb * (1.0 + alpha * 0.5);
            
            fragColor = vec4(glow, alpha * v_color.a);
        }`;
        
        // WebGL setup
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }
        
        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            return program;
        }
        
        const vs = createShader(gl.VERTEX_SHADER, vertexShader);
        const fs = createShader(gl.FRAGMENT_SHADER, fragmentShader);
        const program = createProgram(vs, fs);
        
        // Initialize particles for COHERE with NON-MARKOVIAN MEMORY
        function initializeParticles() {
            const letters = ['C', 'O', 'H', 'E', 'R', 'E'];
            const particlesPerLetter = Math.floor(PARTICLE_COUNT / 6);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const letterIndex = Math.floor(i / particlesPerLetter);
                const particleInLetter = i % particlesPerLetter;
                
                const target = generateLetterTarget(letters[letterIndex], letterIndex, particleInLetter);
                
                const offset = i * 12;
                
                // Random starting position
                particles[offset] = canvas.width * 0.5 + (Math.random() - 0.5) * 200;
                particles[offset + 1] = canvas.height * 0.5 + (Math.random() - 0.5) * 150;
                
                // Initial velocity
                particles[offset + 2] = (Math.random() - 0.5) * 2;
                particles[offset + 3] = (Math.random() - 0.5) * 2;
                
                // State: coherence, memory_strength
                particles[offset + 4] = 0.1; // coherence
                particles[offset + 5] = 0.0; // memory strength
                
                // CRITICAL: Memory weights (6 values) - NOT COORDINATES
                // These weights encode spatial relationships during coherence phase
                for (let j = 6; j < 12; j++) {
                    particles[offset + j] = Math.random() * 0.1; // Initial random memory weights
                }
                
                // Initialize coherence memory for this particle
                coherenceMemory[i] = [];
            }
        }

        function generateLetterTarget(letter, letterIndex, particleIndex) {
            // Arial-style uppercase letters with consistent sizing
            const letterWidth = Math.min(60, canvas.width / 12);
            const letterHeight = Math.min(100, canvas.height * 0.5);
            
            // Tighter, more consistent spacing for Arial look
            const spacing = Math.min(12, canvas.width / 60);
            
            const totalWidth = 6 * letterWidth + 5 * spacing;
            const startX = (canvas.width - totalWidth) / 2;
            
            let letterX = startX + letterIndex * (letterWidth + spacing);
            const startY = (canvas.height - letterHeight) / 2;
            
            const particlesPerLetter = Math.floor(PARTICLE_COUNT / 6);
            const t = particleIndex / Math.max(1, particlesPerLetter - 1);
            
            let x, y;
            
            switch(letter) {
                case 'C':
                    // Clean geometric C
                    const angle = Math.PI * 0.2 + t * Math.PI * 1.6;
                    x = letterX + letterWidth/2 + Math.cos(angle) * letterWidth * 0.4;
                    y = startY + letterHeight/2 + Math.sin(angle) * letterHeight * 0.4;
                    break;
                    
                case 'O':
                    // Perfect circular O
                    const oAngle = t * Math.PI * 2;
                    x = letterX + letterWidth/2 + Math.cos(oAngle) * letterWidth * 0.35;
                    y = startY + letterHeight/2 + Math.sin(oAngle) * letterHeight * 0.4;
                    break;
                    
                case 'H':
                    // Geometric H with straight lines
                    if (t < 0.4) {
                        // Left vertical line
                        x = letterX + letterWidth * 0.15;
                        y = startY + (t / 0.4) * letterHeight;
                    } else if (t < 0.8) {
                        // Right vertical line
                        x = letterX + letterWidth * 0.85;
                        y = startY + ((t - 0.4) / 0.4) * letterHeight;
                    } else {
                        // Horizontal crossbar
                        const crossT = (t - 0.8) / 0.2;
                        x = letterX + letterWidth * 0.15 + crossT * letterWidth * 0.7;
                        y = startY + letterHeight * 0.5;
                    }
                    break;
                    
                case 'E':
                    // Clean geometric E
                    if (t < 0.25) {
                        // Left vertical line
                        x = letterX + letterWidth * 0.15;
                        y = startY + (t / 0.25) * letterHeight;
                    } else if (t < 0.4) {
                        // Top horizontal line
                        const topT = (t - 0.25) / 0.15;
                        x = letterX + letterWidth * 0.15 + topT * letterWidth * 0.7;
                        y = startY + letterHeight * 0.05;
                    } else if (t < 0.6) {
                        // Middle horizontal line
                        const midT = (t - 0.4) / 0.2;
                        x = letterX + letterWidth * 0.15 + midT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.5;
                    } else {
                        // Bottom horizontal line
                        const botT = (t - 0.6) / 0.4;
                        x = letterX + letterWidth * 0.15 + botT * letterWidth * 0.7;
                        y = startY + letterHeight * 0.95;
                    }
                    break;
                    
                case 'R':
                    // Geometric R with clean lines
                    if (t < 0.3) {
                        // Left vertical line
                        x = letterX + letterWidth * 0.15;
                        y = startY + (t / 0.3) * letterHeight;
                    } else if (t < 0.45) {
                        // Top horizontal line
                        const topT = (t - 0.3) / 0.15;
                        x = letterX + letterWidth * 0.15 + topT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.05;
                    } else if (t < 0.6) {
                        // Right side of bowl (vertical)
                        const rightT = (t - 0.45) / 0.15;
                        x = letterX + letterWidth * 0.7;
                        y = startY + letterHeight * 0.05 + rightT * letterHeight * 0.4;
                    } else if (t < 0.75) {
                        // Middle horizontal line
                        const midT = (t - 0.6) / 0.15;
                        x = letterX + letterWidth * 0.7 - midT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.45;
                    } else {
                        // Diagonal leg
                        const legT = (t - 0.75) / 0.25;
                        x = letterX + letterWidth * 0.15 + legT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.45 + legT * letterHeight * 0.5;
                    }
                    break;
                    
                default:
                    x = letterX + letterWidth/2;
                    y = startY + letterHeight/2;
            }
            
            return { x, y };
        }
        
        // CRITICAL: Non-Markovian physics update with memory-based reconstruction
        function updateParticles(dt) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                
                let pos = [particles[offset], particles[offset + 1]];
                let vel = [particles[offset + 2], particles[offset + 3]];
                let state = [particles[offset + 4], particles[offset + 5]]; // coherence, memory_strength
                let memoryWeights = [];
                for (let j = 6; j < 12; j++) {
                    memoryWeights.push(particles[offset + j]);
                }
                
                // Calculate target position for this particle (for reference only)
                const letterIndex = Math.floor(i / Math.floor(PARTICLE_COUNT / 6));
                const particleInLetter = i % Math.floor(PARTICLE_COUNT / 6);
                const letters = ['C', 'O', 'H', 'E', 'R', 'E'];
                const target = generateLetterTarget(letters[letterIndex], letterIndex, particleInLetter);
                
                // Phase-specific NON-MARKOVIAN behavior
                switch(currentPhase) {
                    case 'coherence':
                        // Build coherence and LEARN memory weights (not coordinates!)
                        state[0] += memoryStrength * dt * 0.006;
                        state[0] = Math.min(1.0, state[0]);
                        state[1] = memoryStrength;
                        
                        // CRITICAL: Store coherence patterns in memory (not positions)
                        if (globalTime % 30 === 0) { // Every 30 frames
                            coherenceMemory[i].push({
                                coherence: state[0],
                                time: globalTime,
                                relativeDistances: [] // Store relative distances to nearby particles
                            });
                            
                            // Keep only recent memory
                            if (coherenceMemory[i].length > 20) {
                                coherenceMemory[i].shift();
                            }
                        }
                        
                        // Learn memory weights based on spatial relationships
                        const targetDx = target.x - pos[0];
                        const targetDy = target.y - pos[1];
                        const targetDistance = Math.sqrt(targetDx*targetDx + targetDy*targetDy);
                        
                        if (targetDistance > 2) {
                            const force = (0.2 + state[0] * 0.8) * memoryStrength * 0.8;
                            vel[0] += (targetDx / targetDistance) * force * dt * 0.04;
                            vel[1] += (targetDy / targetDistance) * force * dt * 0.04;
                            
                            // LEARN memory weights from successful movements
                            const learningRate = 0.001 * state[0];
                            for (let j = 0; j < 6; j++) {
                                memoryWeights[j] += learningRate * Math.sin(globalTime * 0.01 + j);
                                memoryWeights[j] = Math.max(0, Math.min(1, memoryWeights[j]));
                            }
                        }
                        
                        // Memory affects stability vs chaos
                        const randomFactor = Math.max(0.05, 0.4 / memoryStrength);
                        vel[0] += (Math.random() - 0.5) * randomFactor * dt;
                        vel[1] += (Math.random() - 0.5) * randomFactor * dt;
                        
                        // Memory affects damping
                        const dampingFactor = 0.9 + memoryStrength * 0.02;
                        vel[0] *= Math.min(0.98, dampingFactor);
                        vel[1] *= Math.min(0.98, dampingFactor);
                        break;
                        
                    case 'rupture':
                        // CRITICAL: NO coordinates stored! Only memory weights persist
                        state[1] = intensity;
                        
                        // Dramatic chaos - particles lose spatial coherence
                        const chaosForce = intensity * intensity * 2.0;
                        vel[0] += (Math.random() - 0.5) * chaosForce * dt;
                        vel[1] += (Math.random() - 0.5) * chaosForce * dt;
                        
                        // Coherence rapidly decays
                        state[0] *= (1.0 - intensity * 0.01);
                        
                        // Memory weights become noisy but are NOT destroyed
                        for (let j = 0; j < 6; j++) {
                            memoryWeights[j] += (Math.random() - 0.5) * intensity * 0.02;
                            memoryWeights[j] = Math.max(0, Math.min(1, memoryWeights[j]));
                        }
                        
                        // High intensity reduces damping
                        const ruptureRamping = Math.max(0.85, 0.98 - intensity * 0.1);
                        vel[0] *= ruptureRamping;
                        vel[1] *= ruptureRamping;
                        break;
                        
                    case 'rebirth':
                        // CRITICAL: Reconstruct position from MEMORY WEIGHTS, not stored coordinates
                        let reconstructedX = 0;
                        let reconstructedY = 0;
                        
                        // Use coherence memory and weights to reconstruct target position
                        if (coherenceMemory[i].length > 0) {
                            let totalWeight = 0;
                            
                            for (let memIdx = 0; memIdx < coherenceMemory[i].length; memIdx++) {
                                const memory = coherenceMemory[i][memIdx];
                                const timeWeight = Math.exp(-(globalTime - memory.time) * 0.001); // Recent memories weighted higher
                                const coherenceWeight = memory.coherence;
                                
                                // Use memory weights to influence reconstruction
                                for (let j = 0; j < 6; j++) {
                                    const weight = memoryWeights[j] * timeWeight * coherenceWeight * fidelity;
                                    totalWeight += weight;
                                    
                                    // Reconstruct position using trigonometric basis functions
                                    reconstructedX += weight * target.x * Math.cos(j * Math.PI / 3);
                                    reconstructedY += weight * target.y * Math.sin(j * Math.PI / 3);
                                }
                            }
                            
                            if (totalWeight > 0) {
                                reconstructedX /= totalWeight;
                                reconstructedY /= totalWeight;
                            } else {
                                // Fallback to target if no memory
                                reconstructedX = target.x;
                                reconstructedY = target.y;
                            }
                        } else {
                            reconstructedX = target.x;
                            reconstructedY = target.y;
                        }
                        
                        // Move towards reconstructed position
                        const dx = reconstructedX - pos[0];
                        const dy = reconstructedY - pos[1];
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance > 1) {
                            // Fidelity affects reconstruction precision and speed
                            const rebirthForce = fidelity * fidelity * 0.5;
                            vel[0] += (dx / distance) * rebirthForce * dt;
                            vel[1] += (dy / distance) * rebirthForce * dt;
                        }
                        
                        // Restore coherence
                        state[0] += fidelity * dt * 0.004;
                        state[0] = Math.min(1.0, state[0]);
                        
                        // High fidelity creates precise reconstruction
                        const precisionDamping = 0.85 + fidelity * 0.08;
                        vel[0] *= Math.min(0.95, precisionDamping);
                        vel[1] *= Math.min(0.95, precisionDamping);
                        
                        // Minimal noise for clean reconstruction
                        const rebirthNoise = Math.max(0.02, 0.15 / fidelity);
                        vel[0] += (Math.random() - 0.5) * rebirthNoise * dt;
                        vel[1] += (Math.random() - 0.5) * rebirthNoise * dt;
                        break;
                }
                
                // Update position
                pos[0] += vel[0] * dt;
                pos[1] += vel[1] * dt;
                
                // Boundary conditions
                if (pos[0] < 0 || pos[0] > canvas.width) vel[0] *= -0.8;
                if (pos[1] < 0 || pos[1] > canvas.height) vel[1] *= -0.8;
                pos[0] = Math.max(2, Math.min(canvas.width - 2, pos[0]));
                pos[1] = Math.max(2, Math.min(canvas.height - 2, pos[1]));
                
                // Write back to array
                particles[offset] = pos[0];
                particles[offset + 1] = pos[1];
                particles[offset + 2] = vel[0];
                particles[offset + 3] = vel[1];
                particles[offset + 4] = state[0];
                particles[offset + 5] = state[1];
                
                // Write back memory weights
                for (let j = 0; j < 6; j++) {
                    particles[offset + 6 + j] = memoryWeights[j];
                }
            }
        }
        
        // Rendering setup
        const positionBuffer = gl.createBuffer();
        const velocityBuffer = gl.createBuffer();
        const stateBuffer = gl.createBuffer();
        
        // Initialize canvas size
        function initializeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // Render function
        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            gl.useProgram(program);
            
            // Update buffers
            const positions = new Float32Array(PARTICLE_COUNT * 2);
            const velocities = new Float32Array(PARTICLE_COUNT * 2);
            const states = new Float32Array(PARTICLE_COUNT * 2);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                positions[i * 2] = particles[offset];
                positions[i * 2 + 1] = particles[offset + 1];
                velocities[i * 2] = particles[offset + 2];
                velocities[i * 2 + 1] = particles[offset + 3];
                states[i * 2] = particles[offset + 4];
                states[i * 2 + 1] = particles[offset + 5];
            }
            
            // Bind buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
            const a_position = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.DYNAMIC_DRAW);
            const a_velocity = gl.getAttribLocation(program, 'a_velocity');
            gl.enableVertexAttribArray(a_velocity);
            gl.vertexAttribPointer(a_velocity, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, stateBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, states, gl.DYNAMIC_DRAW);
            const a_state = gl.getAttribLocation(program, 'a_state');
            gl.enableVertexAttribArray(a_state);
            gl.vertexAttribPointer(a_state, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvas.width, canvas.height);
            gl.uniform1f(gl.getUniformLocation(program, 'u_time'), globalTime);
            gl.uniform1i(gl.getUniformLocation(program, 'u_phase'), currentPhase === 'coherence' ? 0 : currentPhase === 'rupture' ? 1 : 2);
            
            gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);
        }
        
        // Animation loop
        function animate() {
            globalTime += 16.67;
            updateParticles(1.0);
            render();
            updateMetrics();
            checkAutoSequence();
            requestAnimationFrame(animate);
        }
        
        // Auto-demo sequence
        function checkAutoSequence() {
            if (userInteracted || autoSequenceStarted) return;
            
            const elapsed = Date.now() - startTime;
            
            // After 8 seconds, start auto sequence
            if (elapsed > 8000) {
                autoSequenceStarted = true;
                console.log('Starting physics auto-demo sequence...');
                
                // Trigger rupture
                setPhase('rupture');
                
                // Trigger rebirth a couple seconds later
                setTimeout(() => {
                    setPhase('rebirth');
                }, 2500);
            }
        }
        
        // UI Functions
        function setPhase(phase) {
            currentPhase = phase;
            phaseTransitions++;
            
            // Mark that user has interacted (unless this is auto-sequence)
            if (!autoSequenceStarted) {
                userInteracted = true;
            }
            
            // Reset some particles for visual effect
            if (phase === 'coherence') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const offset = i * 12;
                    particles[offset + 4] = 0.1; // Reset coherence
                }
            }
        }
        
        function updateMetrics() {
            let totalCoherence = 0;
            let memoryValue = 0;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                totalCoherence += particles[offset + 4];
            }
            
            const avgCoherence = totalCoherence / PARTICLE_COUNT;
            memoryValue = avgCoherence * memoryStrength * 0.1;
            
            document.getElementById('coherenceMetric').textContent = `Coherence: ${avgCoherence.toFixed(3)}`;
            document.getElementById('particleMetric').textContent = `Particles: ${PARTICLE_COUNT}`;
            document.getElementById('memoryMetric').textContent = `Memory: ${memoryValue.toFixed(3)}`;
            document.getElementById('phaseMetric').textContent = `Phase transitions: ${phaseTransitions}`;
            document.getElementById('qualityMetric').textContent = `Reconstruction: ${(avgCoherence * fidelity * 0.5).toFixed(2)}`;
        }
        
        // Slider controls
        document.getElementById('memorySlider').addEventListener('input', (e) => {
            memoryStrength = parseFloat(e.target.value);
            document.getElementById('memoryValue').textContent = memoryStrength.toFixed(1);
            userInteracted = true;
        });
        
        document.getElementById('intensitySlider').addEventListener('input', (e) => {
            intensity = parseFloat(e.target.value);
            document.getElementById('intensityValue').textContent = intensity.toFixed(1);
            userInteracted = true;
        });
        
        document.getElementById('fidelitySlider').addEventListener('input', (e) => {
            fidelity = parseFloat(e.target.value);
            document.getElementById('fidelityValue').textContent = fidelity.toFixed(1);
            userInteracted = true;
        });

        // Logo animation system
        class CRRHomepage {
            constructor() {
                this.animationTime = 0;
                this.isAnimating = true;
                this.rafId = null;
                this.elements = this.cacheElements();
                this.ruptureActive = false;
                this.ruptureStartTime = 0;
                this.init();
            }

            cacheElements() {
                return {
                    logo: document.querySelector('.logo'),
                    logoHive: document.querySelector('.logo-hive'),
                    bees: document.querySelectorAll('.logo-bee'),
                    interiorBees: document.querySelectorAll('[class*="interior-bee"]'),
                    navLinks: document.querySelectorAll('.nav-link')
                };
            }

            init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.start());
                } else {
                    this.start();
                }
            }

            start() {
                try {
                    this.setupLogoInteractions();
                    this.setupNavigationInteractions();
                    
                    if (!this.respectsReducedMotion()) {
                        this.startAnimation();
                    }
                    
                    this.setupVisibilityChange();
                } catch (error) {
                    console.error('Logo animation error:', error);
                }
            }

            setupLogoInteractions() {
                if (!this.elements.logo) return;

                this.elements.logo.addEventListener('click', () => {
                    this.triggerDiracRupture();
                });
            }

            triggerDiracRupture() {
                if (this.ruptureActive) return;

                this.ruptureActive = true;
                this.ruptureStartTime = this.animationTime;
                
                this.elements.logoHive.classList.add('rupture');
                
                setTimeout(() => {
                    this.elements.logoHive.classList.remove('rupture');
                }, 3000);

                setTimeout(() => {
                    this.ruptureActive = false;
                }, 4000);
            }

            setupNavigationInteractions() {
                this.elements.navLinks.forEach((link) => {
                    link.addEventListener('mouseenter', () => {
                        if (!link.classList.contains('active')) {
                            link.style.transform = 'translateY(-2px)';
                        }
                    });
                    
                    link.addEventListener('mouseleave', () => {
                        link.style.transform = 'translateY(0)';
                    });
                });
            }

            startAnimation() {
                const animate = () => {
                    if (!this.isAnimating) return;
                    
                    this.animationTime += 0.025;
                    this.animateBees();
                    this.animateInteriorBees();
                    
                    this.rafId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            animateBees() {
                this.elements.bees.forEach((bee, index) => {
                    if (this.ruptureActive) {
                        this.animateRuptureBees(bee, index);
                    } else {
                        this.animateNormalBees(bee, index);
                    }
                });
            }

            animateNormalBees(bee, index) {
                const baseAngle = (index * Math.PI * 0.5) + this.animationTime * (0.4 + index * 0.15);
                const radius = 20 + Math.sin(this.animationTime * 0.7 + index) * 6;
                
                const figure8 = Math.sin(this.animationTime * 0.6 + index * 0.8) * 8;
                
                const x = 50 + Math.cos(baseAngle) * radius + figure8 * Math.cos(baseAngle * 2);
                const y = 50 + Math.sin(baseAngle) * radius * 0.8 + figure8 * 0.3 * Math.sin(baseAngle * 3);
                
                bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                
                const wingBeat = 0.6 + 0.4 * Math.sin(this.animationTime * 12 + index * 2.5);
                bee.style.opacity = wingBeat;
            }

            animateRuptureBees(bee, index) {
                const elapsedTime = this.animationTime - this.ruptureStartTime;
                
                if (elapsedTime < 60) {
                    const disperseProgress = elapsedTime / 60;
                    const disperseAngle = (index * Math.PI * 0.5) + this.animationTime * (2.5 + index * 0.6);
                    const disperseRadius = 20 + disperseProgress * (70 + index * 12);
                    
                    const x = 50 + Math.cos(disperseAngle) * disperseRadius;
                    const y = 50 + Math.sin(disperseAngle) * disperseRadius;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.2 + 0.8 * Math.sin(this.animationTime * 25 + index * 3.5);
                    
                } else if (elapsedTime < 140) {
                    const recohereProgress = (elapsedTime - 60) / 80;
                    const smoothProgress = 1 - Math.pow(1 - recohereProgress, 3);
                    
                    const currentRadius = 90 - smoothProgress * 70;
                    const angle = (index * Math.PI * 0.5) + this.animationTime * (1.8 - smoothProgress * 1.4);
                    
                    const x = 50 + Math.cos(angle) * currentRadius;
                    const y = 50 + Math.sin(angle) * currentRadius * 0.8;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.6 + 0.4 * Math.sin(this.animationTime * (15 - smoothProgress * 5) + index * 2.5);
                }
            }

            animateInteriorBees() {
                this.elements.interiorBees.forEach((bee, index) => {
                    const movement = Math.sin(this.animationTime * 2.5 + index * 3.5) * 2;
                    const rotation = Math.sin(this.animationTime * 2 + index * 2.5) * 8;
                    
                    bee.setAttribute('transform', `translate(${movement}, ${movement * 0.6}) rotate(${rotation})`);
                });
            }

            setupVisibilityChange() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.isAnimating = false;
                        if (this.rafId) {
                            cancelAnimationFrame(this.rafId);
                        }
                    } else if (!this.respectsReducedMotion()) {
                        this.isAnimating = true;
                        this.startAnimation();
                    }
                });
            }

            respectsReducedMotion() {
                return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }

            destroy() {
                this.isAnimating = false;
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                }
            }
        }
        
        // Initialize
        gl.clearColor(0.545, 0.271, 0.075, 1.0); // Deep burnt orange
        gl.enable(gl.PROGRAM_POINT_SIZE);
        
        initializeCanvas();
        initializeParticles();
        animate();
        
        // Event handlers
        window.addEventListener('resize', () => {
            initializeCanvas();
            initializeParticles();
        });
        
        window.addEventListener('load', () => {
            setTimeout(initializeCanvas, 100);
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeCanvas, 50);
        });

        // Initialize logo animation
        const logoApp = new CRRHomepage();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (logoApp) logoApp.destroy();
        });
    </script>
</body>
</html>
