<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physical Systems - Cohere.org.uk - Mathematical Life and Living Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
            font-family: Georgia, serif;
            line-height: 1.6;
            color: #2c2c2c;
            overflow-x: hidden;
        }

        /* Main Container */
        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 60px;
        }

        /* Header Section */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        /* ════════════════════════════════════════════════════════════════════════
           ☉ THE ALCHEMICAL SUN — CRR Logo Styles
           ════════════════════════════════════════════════════════════════════════ */
        
        .crr-sun {
            width: 62px;
            height: 62px;
            margin-right: 18px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .crr-sun-svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }
        
        .photosphere {
            animation: photospherePulse 6s ease-in-out infinite;
        }
        
        @keyframes photospherePulse {
            0%, 100% { filter: brightness(1) saturate(1); }
            42% { filter: brightness(1.03) saturate(1.05); }
            48% { filter: brightness(1.08) saturate(1.12); }
            55% { filter: brightness(0.97) saturate(0.95); }
        }
        
        .granule {
            animation: granuleLife 4s ease-in-out infinite;
        }
        
        .granule-1 { animation-delay: 0s; animation-duration: 3.2s; }
        .granule-2 { animation-delay: -1.1s; animation-duration: 4.1s; }
        .granule-3 { animation-delay: -2.3s; animation-duration: 3.6s; }
        .granule-4 { animation-delay: -0.5s; animation-duration: 4.4s; }
        .granule-5 { animation-delay: -2.8s; animation-duration: 3s; }
        .granule-6 { animation-delay: -1.7s; animation-duration: 3.9s; }
        
        @keyframes granuleLife {
            0% { 
                opacity: 0.08; 
                transform: scale(0.5) translateY(1px);
                filter: brightness(0.8);
            }
            45% { 
                opacity: 0.45; 
                transform: scale(1.15) translateY(-0.5px);
                filter: brightness(1.2);
            }
            55% { 
                opacity: 0.4; 
                transform: scale(1.1) translateY(0);
                filter: brightness(1.1);
            }
            80% { 
                opacity: 0.15; 
                transform: scale(0.7) translateY(0.5px);
                filter: brightness(0.9);
            }
            100% { 
                opacity: 0.08; 
                transform: scale(0.5) translateY(1px);
                filter: brightness(0.8);
            }
        }
        
        .corona-ray {
            opacity: 0.88;
            transform-origin: center;
            animation: flameDance 1.2s ease-in-out infinite;
        }
        
        .ray-1 { animation-duration: 1.1s; animation-delay: 0s; }
        .ray-2 { animation-duration: 1.3s; animation-delay: -0.2s; }
        .ray-3 { animation-duration: 1.0s; animation-delay: -0.5s; }
        .ray-4 { animation-duration: 1.25s; animation-delay: -0.15s; }
        .ray-5 { animation-duration: 1.15s; animation-delay: -0.4s; }
        .ray-6 { animation-duration: 1.35s; animation-delay: -0.3s; }
        .ray-7 { animation-duration: 1.05s; animation-delay: -0.55s; }
        .ray-8 { animation-duration: 1.2s; animation-delay: -0.1s; }
        
        @keyframes flameDance {
            0%, 100% { 
                opacity: 0.8;
                filter: brightness(0.95);
            }
            25% { 
                opacity: 0.92;
                filter: brightness(1.08);
            }
            50% { 
                opacity: 0.85;
                filter: brightness(1.0);
            }
            75% { 
                opacity: 0.95;
                filter: brightness(1.12);
            }
        }
        
        .corona-ray-minor {
            opacity: 0.5;
            animation: flameDanceMinor 1.5s ease-in-out infinite;
        }
        
        .corona-ray-minor:nth-child(1) { animation-duration: 1.4s; animation-delay: 0s; }
        .corona-ray-minor:nth-child(2) { animation-duration: 1.6s; animation-delay: -0.3s; }
        .corona-ray-minor:nth-child(3) { animation-duration: 1.3s; animation-delay: -0.6s; }
        .corona-ray-minor:nth-child(4) { animation-duration: 1.55s; animation-delay: -0.2s; }
        .corona-ray-minor:nth-child(5) { animation-duration: 1.45s; animation-delay: -0.5s; }
        .corona-ray-minor:nth-child(6) { animation-duration: 1.35s; animation-delay: -0.4s; }
        .corona-ray-minor:nth-child(7) { animation-duration: 1.5s; animation-delay: -0.15s; }
        .corona-ray-minor:nth-child(8) { animation-duration: 1.4s; animation-delay: -0.45s; }
        
        @keyframes flameDanceMinor {
            0%, 100% { 
                opacity: 0.4;
                filter: brightness(0.9);
            }
            50% { 
                opacity: 0.6;
                filter: brightness(1.1);
            }
        }
        
        .coronal-loop {
            opacity: 0;
            animation: loopMemory 6s ease-in-out infinite;
        }
        
        @keyframes loopMemory {
            0%, 48% { 
                opacity: 0;
                stroke-dashoffset: 15;
            }
            55% { 
                opacity: 0.5;
                stroke-dashoffset: 8;
            }
            72% { 
                opacity: 0.75;
                stroke-dashoffset: 0;
            }
            90% { 
                opacity: 0.25;
                stroke-dashoffset: 0;
            }
            100% { 
                opacity: 0;
                stroke-dashoffset: 15;
            }
        }
        
        .chromosphere-ring {
            animation: limbGlow 6s ease-in-out infinite;
        }
        
        @keyframes limbGlow {
            0%, 100% { opacity: 0.25; }
            42% { opacity: 0.4; }
            48% { opacity: 0.7; }
            55% { opacity: 0.35; }
        }
        
        .solar-flare {
            opacity: 0;
            animation: flareRupture 6s ease-out infinite;
        }
        
        @keyframes flareRupture {
            0%, 44% { 
                opacity: 0; 
                transform: scale(0.5);
            }
            48% { 
                opacity: 0.9; 
                transform: scale(1.12);
            }
            52% { 
                opacity: 0.55; 
                transform: scale(1);
            }
            62% { 
                opacity: 0.15; 
                transform: scale(0.88);
            }
            72%, 100% { 
                opacity: 0; 
                transform: scale(0.6);
            }
        }
        
        .core-glow {
            animation: coreIntensity 6s ease-in-out infinite;
        }
        
        @keyframes coreIntensity {
            0%, 100% { opacity: 0.45; transform: scale(1); }
            42% { opacity: 0.7; transform: scale(1.03); }
            48% { opacity: 0.92; transform: scale(1.08); }
            55% { opacity: 0.55; transform: scale(0.97); }
        }
        
        .crr-sun:hover .corona-ray {
            animation-duration: 0.6s;
        }
        
        .crr-sun:hover .corona-ray-minor {
            animation-duration: 0.8s;
        }
        
        .crr-sun:hover .solar-flare,
        .crr-sun:hover .coronal-loop,
        .crr-sun:hover .photosphere,
        .crr-sun:hover .core-glow,
        .crr-sun:hover .chromosphere-ring {
            animation-duration: 3s;
        }
        
        .crr-sun:hover .granule {
            animation-duration: 1.8s !important;
        }
        
        .crr-sun:hover .crr-sun-svg {
            filter: drop-shadow(0 0 8px rgba(255, 180, 60, 0.6));
        }
        
        .crr-sun.erupting .solar-flare {
            animation: cmeNow 0.6s ease-out forwards !important;
        }
        
        .crr-sun.erupting .corona-ray {
            animation: flameSurge 0.5s ease-out !important;
        }
        
        .crr-sun.erupting .corona-ray-minor {
            animation: flameSurgeMinor 0.4s ease-out !important;
        }
        
        .crr-sun.erupting .coronal-loop {
            animation: loopFlash 0.8s ease-out forwards !important;
        }
        
        @keyframes cmeNow {
            0% { opacity: 0; transform: scale(0.4); }
            20% { opacity: 1; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(0.65); }
        }
        
        @keyframes flameSurge {
            0% { 
                opacity: 0.88;
                filter: brightness(1); 
            }
            25% { 
                opacity: 1;
                filter: brightness(1.4); 
            }
            100% { 
                opacity: 0.75;
                filter: brightness(0.85); 
            }
        }
        
        @keyframes flameSurgeMinor {
            0% { opacity: 0.5; }
            25% { opacity: 0.85; }
            100% { opacity: 0.4; }
        }
        
        @keyframes loopFlash {
            0% { opacity: 0; stroke-dashoffset: 15; }
            25% { opacity: 1; stroke-dashoffset: 0; }
            100% { opacity: 0; stroke-dashoffset: -10; }
        }
        
        @media (prefers-reduced-motion: reduce) {
            .photosphere, .granule, .corona-ray, .corona-ray-minor,
            .solar-flare, .core-glow, .coronal-loop, .chromosphere-ring {
                animation: none !important;
            }
            .corona-ray { opacity: 0.88; filter: brightness(1); }
            .corona-ray-minor { opacity: 0.5; }
            .granule { opacity: 0.25; }
            .coronal-loop { opacity: 0.4; stroke-dashoffset: 0; }
            .chromosphere-ring { opacity: 0.4; }
        }

        .title-group {
            display: flex;
            flex-direction: column;
        }

        .site-title {
            font-family: Georgia, serif;
            font-size: 48px;
            font-weight: normal;
            color: #1a1a1a;
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .strapline {
            font-family: Georgia, serif;
            font-size: 18px;
            font-style: italic;
            color: #6c757d;
            letter-spacing: 0.5px;
        }

        /* Navigation System */
        .main-nav {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #495057;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: rgba(184, 134, 11, 0.08);
            color: #1a1a1a;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: linear-gradient(135deg, #D4A012 0%, #B8860B 100%);
            color: white;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .nav-item:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        /* Robust Dropdown Menu System */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 8px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 1000;
            overflow: hidden;
        }

        /* Critical: No gap between nav item and dropdown */
        .nav-item:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Keep dropdown visible when hovering over dropdown itself */
        .dropdown-menu:hover {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Ensure dropdown stays open during mouse travel */
        .nav-item::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-link {
            display: block;
            padding: 12px 20px;
            color: #495057;
            text-decoration: none;
            font-size: 16px;
            font-family: Georgia, serif;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-link:hover {
            background: rgba(184, 134, 11, 0.08);
            color: #B8860B;
            border-left-color: #D4A012;
        }

        /* Simulation Canvas Section */
        .simulation-section {
            margin: 40px 0;
            padding: 30px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            position: relative;
        }

        .simulation-title {
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
            text-align: center;
        }

        #canvas {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 30%, #cd853f 100%);
            border-top: 4px solid #ffffff;
            border-bottom: 4px solid #ffffff;
            border-left: none;
            border-right: none;
            border-radius: 0;
            width: 100%;
            height: 300px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }

        /* Physics Controls */
        .physics-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .phase-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: Georgia, serif;
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.9);
            color: #495057;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .phase-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .phase-btn.coherence { 
            background: linear-gradient(45deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));
            border-color: rgba(102,126,234,0.4);
            color: #667eea;
        }

        .phase-btn.rupture { 
            background: linear-gradient(45deg, rgba(240,147,251,0.2), rgba(245,87,108,0.2));
            border-color: rgba(240,147,251,0.4);
            color: #f093fb;
        }

        .phase-btn.rebirth { 
            background: linear-gradient(45deg, rgba(67,233,123,0.2), rgba(56,249,215,0.2));
            border-color: rgba(67,233,123,0.4);
            color: #43e97b;
        }

        /* Sliders */
        .sliders {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .slider-label {
            font-size: 12px;
            color: #6c757d;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: Georgia, serif;
        }

        .slider {
            width: 120px;
            height: 4px;
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #B8860B;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #8B6914;
            transform: scale(1.1);
        }

        .value {
            font-size: 11px;
            color: #6c757d;
            min-width: 30px;
            text-align: center;
            font-family: Georgia, serif;
        }

        /* Metrics */
        .metrics {
            font-style: italic;
            font-size: 13px;
            color: #6c757d;
            text-align: center;
            line-height: 1.6;
            max-width: 90%;
            margin: 20px auto;
            font-family: Georgia, serif;
        }

        .metric-line {
            margin: 6px 0;
        }

        /* Simulation Links Section */
        .simulation-links {
            margin: 60px 0;
            padding: 40px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        .links-title {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .simulation-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
        }

        .simulation-category {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            text-align: center;
        }

        .category-title {
            font-family: Georgia, serif;
            font-size: 20px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
        }

        .simulation-link {
            display: block;
            margin: 10px 0;
            padding: 8px 16px;
            color: #B8860B;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-family: Georgia, serif;
            border: 1px solid rgba(184, 134, 11, 0.3);
        }

        .simulation-link:hover {
            background: rgba(184, 134, 11, 0.08);
            transform: translateY(-1px);
        }

        .link-description {
            font-size: 12px;
            color: #6c757d;
            font-style: italic;
            margin-top: 4px;
        }

        /* Footer */
        .footer {
            background: rgba(245, 246, 248, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            padding: 50px 0 40px;
            text-align: center;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .footer-sections {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            margin-bottom: 35px;
            text-align: left;
        }

        .footer-section h4 {
            font-family: Georgia, serif;
            font-size: 14px;
            font-weight: normal;
            font-variant: small-caps;
            letter-spacing: 0.05em;
            color: #1a1a1a;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(184, 134, 11, 0.3);
        }

        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .footer-section li {
            margin-bottom: 10px;
        }

        .footer-section a {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #4a4a4a;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .footer-section a:hover {
            color: #B8860B;
        }

        .footer-section.aliboo h4 {
            color: #B8860B;
        }

        .footer-section.aliboo a {
            color: #6a5a3a;
        }

        .footer-section.aliboo a:hover {
            color: #B8860B;
        }

        .footer-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(184, 134, 11, 0.3), transparent);
            margin: 30px 0;
        }

        .footer-repo-note {
            font-family: Georgia, serif;
            font-size: 13px;
            color: #6c757d;
            font-style: italic;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto 25px;
        }

        .footer-author {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #4a4a4a;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .footer-author a {
            color: #B8860B;
            text-decoration: none;
        }

        .footer-author a:hover {
            text-decoration: underline;
        }

        .copyright {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #1a1a1a;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .footer-tech-note {
            font-family: Georgia, serif;
            font-size: 12px;
            color: #8c8c8c;
            font-style: italic;
            line-height: 1.4;
        }

        .sitemap-header {
            font-family: Georgia, serif;
            font-size: 16px;
            font-style: italic;
            color: #5a5a5a;
            margin: 30px 0 20px;
            text-align: center;
        }

        .anthill-container {
            background: linear-gradient(180deg, #7a6548 0%, #5c4a35 8%, #4a3728 25%, #3d2a1a 60%, #2e1f12 100%);
            border-radius: 0;
            padding: 0;
            margin: 20px auto 30px;
            max-width: 950px;
            height: 420px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.3);
            box-shadow: inset 0 0 60px rgba(0,0,0,0.5), 0 4px 20px rgba(0,0,0,0.3);
        }

        .anthill-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .colony-stats {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-family: Georgia, serif;
            font-size: 10px;
            color: rgba(255, 248, 220, 0.6);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        @media (max-width: 768px) {
            .anthill-container {
                height: 380px;
            }
            
            .footer-sections {
                grid-template-columns: 1fr;
                gap: 30px;
                text-align: center;
            }
            
            .footer-section h4 {
                border-bottom: none;
                padding-bottom: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .simulation-categories {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .page-container {
                padding: 0 30px;
            }

            .header {
                flex-direction: column;
                gap: 30px;
                text-align: center;
                padding: 30px 0;
            }

            .logo-section {
                flex-direction: column;
                gap: 15px;
            }

            .logo {
                margin-right: 0;
            }

            .site-title {
                font-size: 36px;
            }

            .main-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            .dropdown-menu {
                position: static;
                opacity: 1;
                visibility: visible;
                transform: none;
                box-shadow: none;
                border: none;
                background: rgba(74, 144, 226, 0.05);
                margin-top: 10px;
                border-radius: 4px;
                display: none;
            }

            .nav-item:hover .dropdown-menu {
                display: block;
            }

            .physics-controls {
                gap: 10px;
            }

            .phase-btn {
                padding: 6px 12px;
                font-size: 11px;
            }

            .sliders {
                gap: 20px;
                flex-direction: column;
                align-items: center;
            }

            .slider-group {
                flex-direction: row;
                gap: 15px;
                width: 100%;
                max-width: 280px;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header class="header">
            <div class="logo-section">
                <!-- ☉ THE ALCHEMICAL SUN — Blake's Vision in CRR ☉ -->
                <div class="crr-sun" id="crrSun" title="Sol Invictus — The Alchemical Furnace">
                    <svg class="crr-sun-svg" viewBox="0 0 52 52" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <filter id="plasmaTurbulence" x="-20%" y="-20%" width="140%" height="140%">
                                <feTurbulence type="fractalNoise" baseFrequency="0.08" numOctaves="3" seed="42" result="noise"/>
                                <feDisplacementMap in="SourceGraphic" in2="noise" scale="1.5" xChannelSelector="R" yChannelSelector="G"/>
                            </filter>
                            <filter id="coronaGlow" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="1" result="blur"/>
                                <feMerge>
                                    <feMergeNode in="blur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                            <filter id="flareBloom" x="-100%" y="-100%" width="300%" height="300%">
                                <feGaussianBlur stdDeviation="2" result="blur"/>
                                <feComposite in="SourceGraphic" in2="blur" operator="over"/>
                            </filter>
                            <radialGradient id="photosphereGrad" cx="35%" cy="35%" r="60%">
                                <stop offset="0%" stop-color="#FFFDE7"/>
                                <stop offset="20%" stop-color="#FFE082"/>
                                <stop offset="45%" stop-color="#FFB300"/>
                                <stop offset="70%" stop-color="#E65100"/>
                                <stop offset="90%" stop-color="#BF360C"/>
                                <stop offset="100%" stop-color="#8D1F09"/>
                            </radialGradient>
                            <radialGradient id="limbDarkening" cx="50%" cy="50%" r="50%">
                                <stop offset="0%" stop-color="transparent"/>
                                <stop offset="60%" stop-color="transparent"/>
                                <stop offset="85%" stop-color="rgba(139, 31, 9, 0.3)"/>
                                <stop offset="100%" stop-color="rgba(89, 20, 5, 0.5)"/>
                            </radialGradient>
                            <linearGradient id="coronaGrad" x1="50%" y1="100%" x2="50%" y2="0%">
                                <stop offset="0%" stop-color="#FFB300"/>
                                <stop offset="30%" stop-color="#FF8F00"/>
                                <stop offset="60%" stop-color="#E65100"/>
                                <stop offset="100%" stop-color="#BF360C" stop-opacity="0.4"/>
                            </linearGradient>
                            <linearGradient id="coronaGradSoft" x1="50%" y1="100%" x2="50%" y2="0%">
                                <stop offset="0%" stop-color="#FFCA28" stop-opacity="0.8"/>
                                <stop offset="50%" stop-color="#FF9800" stop-opacity="0.5"/>
                                <stop offset="100%" stop-color="#E65100" stop-opacity="0.2"/>
                            </linearGradient>
                            <radialGradient id="chromosphereGrad" cx="50%" cy="50%" r="55%">
                                <stop offset="70%" stop-color="transparent"/>
                                <stop offset="85%" stop-color="rgba(255, 138, 101, 0.4)"/>
                                <stop offset="100%" stop-color="rgba(255, 87, 34, 0.2)"/>
                            </radialGradient>
                            <radialGradient id="flareGrad" cx="50%" cy="50%" r="50%">
                                <stop offset="0%" stop-color="#FFFFFF"/>
                                <stop offset="30%" stop-color="#FFF9C4"/>
                                <stop offset="70%" stop-color="#FFE082" stop-opacity="0.6"/>
                                <stop offset="100%" stop-color="#FFB300" stop-opacity="0"/>
                            </radialGradient>
                            <radialGradient id="coreGlow" cx="50%" cy="50%" r="40%">
                                <stop offset="0%" stop-color="#FFFFFF" stop-opacity="0.9"/>
                                <stop offset="50%" stop-color="#FFF59D" stop-opacity="0.5"/>
                                <stop offset="100%" stop-color="#FFE082" stop-opacity="0"/>
                            </radialGradient>
                        </defs>
                        <g filter="url(#coronaGlow)">
                            <path class="corona-ray ray-1" fill="url(#coronaGrad)" d="M26 3 Q28 8 28.5 13 Q27 15.5 26 16 Q25 15.5 23.5 13 Q24 8 26 3"/>
                            <path class="corona-ray ray-2" fill="url(#coronaGrad)" d="M42 10 Q38 13 34 18 Q33 17 33 16.5 Q34.5 15 35 14 Q37 11 42 10"/>
                            <path class="corona-ray ray-3" fill="url(#coronaGrad)" d="M49 26 Q44 24 38 23.5 Q36.5 25 36 26 Q36.5 27 38 28.5 Q44 28 49 26"/>
                            <path class="corona-ray ray-4" fill="url(#coronaGrad)" d="M42 42 Q38 39 34 34 Q33 35 33 35.5 Q34.5 37 35 38 Q37 41 42 42"/>
                            <path class="corona-ray ray-5" fill="url(#coronaGrad)" d="M26 49 Q24 44 23.5 39 Q25 36.5 26 36 Q27 36.5 28.5 39 Q28 44 26 49"/>
                            <path class="corona-ray ray-6" fill="url(#coronaGrad)" d="M10 42 Q14 39 18 34 Q19 35 19 35.5 Q17.5 37 17 38 Q15 41 10 42"/>
                            <path class="corona-ray ray-7" fill="url(#coronaGrad)" d="M3 26 Q8 24 14 23.5 Q15.5 25 16 26 Q15.5 27 14 28.5 Q8 28 3 26"/>
                            <path class="corona-ray ray-8" fill="url(#coronaGrad)" d="M10 10 Q14 13 18 18 Q19 17 19 16.5 Q17.5 15 17 14 Q15 11 10 10"/>
                        </g>
                        <g>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M31 6 Q30 10 29 14 Q28 15 27.5 15.5 Q28 14 28.5 12 Q29.5 9 31 6"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M46 21 Q42 22 38 23 Q37 24 36.5 23.5 Q38 23 39 22 Q42 20.5 46 21"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M46 31 Q42 30 38 29 Q37 28 36.5 28.5 Q38 29 39 30 Q42 31.5 46 31"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M31 46 Q30 42 29 38 Q28 37 27.5 36.5 Q28 38 28.5 40 Q29.5 43 31 46"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M21 46 Q22 42 23 38 Q24 37 24.5 36.5 Q24 38 23.5 40 Q22.5 43 21 46"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M6 31 Q10 30 14 29 Q15 28 15.5 28.5 Q14 29 13 30 Q10 31.5 6 31"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M6 21 Q10 22 14 23 Q15 24 15.5 23.5 Q14 23 13 22 Q10 20.5 6 21"/>
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" d="M21 6 Q22 10 23 14 Q24 15 24.5 15.5 Q24 14 23.5 12 Q22.5 9 21 6"/>
                        </g>
                        <circle cx="26" cy="26" r="11" fill="url(#chromosphereGrad)"/>
                        <circle class="chromosphere-ring" cx="26" cy="26" r="10.5" fill="none" stroke="rgba(255, 120, 60, 0.4)" stroke-width="0.8"/>
                        <g class="photosphere">
                            <circle cx="26" cy="26" r="10" fill="url(#photosphereGrad)"/>
                            <circle cx="26" cy="26" r="10" fill="url(#limbDarkening)"/>
                        </g>
                        <g>
                            <circle class="granule granule-1" cx="23" cy="24" r="1.6" fill="rgba(255, 248, 210, 0.5)"/>
                            <circle class="granule granule-2" cx="28" cy="25" r="1.3" fill="rgba(255, 245, 195, 0.45)"/>
                            <circle class="granule granule-3" cx="25" cy="28" r="1.4" fill="rgba(255, 242, 180, 0.4)"/>
                            <circle class="granule granule-4" cx="29" cy="28" r="1.1" fill="rgba(255, 248, 200, 0.45)"/>
                            <circle class="granule granule-5" cx="24" cy="22" r="1" fill="rgba(255, 252, 220, 0.5)"/>
                            <circle class="granule granule-6" cx="27" cy="22" r="0.9" fill="rgba(255, 250, 215, 0.42)"/>
                        </g>
                        <path class="coronal-loop" d="M20 22 Q16 26 20 30" fill="none" stroke="rgba(255, 180, 100, 0.8)" stroke-width="1" stroke-linecap="round" stroke-dasharray="15 5"/>
                        <path class="coronal-loop" d="M32 23 Q36 26 32 29" fill="none" stroke="rgba(255, 160, 80, 0.7)" stroke-width="0.8" stroke-linecap="round" stroke-dasharray="12 4" style="animation-delay: -1s;"/>
                        <circle class="solar-flare" cx="26" cy="26" r="12" fill="url(#flareGrad)" filter="url(#flareBloom)"/>
                        <circle class="core-glow" cx="26" cy="26" r="4" fill="url(#coreGlow)"/>
                        <ellipse cx="23" cy="23" rx="2" ry="1.5" fill="rgba(255, 255, 255, 0.35)" transform="rotate(-30 23 23)"/>
                    </svg>
                </div>
               
                <div class="title-group">
                    <h1 class="site-title">CRR</h1>
                    <p class="strapline">A Temporal Grammar</p>
                </div>
            </div>

            <nav class="main-nav">
                <div class="nav-item">
                    <a href="index.html" class="nav-link">Home</a>
                </div>
                <div class="nav-item">
                    <a href="crr-simulations.html" class="nav-link active">
                        CRR Simulations
                        <span class="dropdown-arrow">▼</span>
                    </a>
                    <div class="dropdown-menu">
                        <a href="biological-systems.html" class="dropdown-link">Biological Systems</a>
                        <a href="physical-systems.html" class="dropdown-link">Physical Systems</a>
                        <a href="mathematical-life.html" class="dropdown-link">Mathematical Life</a>
                    </div>
                </div>
                <div class="nav-item">
                    <a href="crr-benchmarks.html" class="nav-link">CRR Benchmarks</a>
                </div>
                <div class="nav-item">
                    <a href="crr-explained.html" class="nav-link">CRR Explained</a>
                </div>
                <div class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </div>
            </nav>
        </header>

        <main>
            <section class="simulation-section">
                <h2 class="simulation-title">CRR Physical Systems: Mathematical Physics in Motion</h2>
                
                <canvas id="canvas"></canvas>
                
                <div class="physics-controls">
                    <button class="phase-btn coherence" onclick="setPhase('coherence')">C(x) Coherence</button>
                    <button class="phase-btn rupture" onclick="setPhase('rupture')">δ Rupture (forget coordinates)</button>
                    <button class="phase-btn rebirth" onclick="setPhase('rebirth')">R[x] Regen</button>
                </div>
                
                <div class="sliders">
                    <div class="slider-group">
                        <label class="slider-label">Memory</label>
                        <input type="range" class="slider" id="memorySlider" min="0.2" max="8.0" step="0.1" value="2.5">
                        <span class="value" id="memoryValue">2.5</span>
                    </div>
                    
                    <div class="slider-group">
                        <label class="slider-label">Intensity</label>
                        <input type="range" class="slider" id="intensitySlider" min="0.2" max="5.0" step="0.1" value="1.8">
                        <span class="value" id="intensityValue">1.8</span>
                    </div>
                    
                    <div class="slider-group">
                        <label class="slider-label">Fidelity</label>
                        <input type="range" class="slider" id="fidelitySlider" min="0.2" max="4.0" step="0.1" value="1.2">
                        <span class="value" id="fidelityValue">1.2</span>
                    </div>
                </div>
                
                <div class="metrics">
                    <div class="metric-line">
                        <span id="coherenceMetric">Coherence: 0.245</span> • 
                        <span id="particleMetric">Particles: 400</span> • 
                        <span id="memoryMetric">Memory: 0.156</span>
                    </div>
                    <div class="metric-line">
                        <span id="phaseMetric">Phase transitions: 0</span> • 
                        <span id="qualityMetric">Reconstruction: 0.78</span>
                    </div>
                </div>
            </section>


            <style>
                /* Table Styles */
                .category-header {
                    font-family: Georgia, serif;
                    font-size: 28px;
                    font-weight: normal;
                    color: #1a1a1a;
                    margin: 50px 0 30px 0;
                    padding-bottom: 15px;
                    border-bottom: 2px solid #B8860B;
                }

                .category-header:first-of-type {
                    margin-top: 20px;
                }

                .simulation-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-bottom: 50px;
                    background: white;
                    border: 2px solid #dee2e6;
                }

                .simulation-table thead {
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                }

                .simulation-table th {
                    font-family: Georgia, serif;
                    font-size: 16px;
                    font-weight: 600;
                    color: #1a1a1a;
                    text-align: left;
                    padding: 18px 20px;
                    border: 1px solid #dee2e6;
                }

                .simulation-table td {
                    font-family: Georgia, serif;
                    font-size: 15px;
                    line-height: 1.7;
                    color: #495057;
                    padding: 20px;
                    border: 1px solid #dee2e6;
                    vertical-align: top;
                }

                .simulation-table tbody tr {
                    transition: background-color 0.2s ease;
                }

                .simulation-table tbody tr:hover {
                    background-color: rgba(184, 134, 11, 0.03);
                }

                .table-simulation-link {
                    color: #B8860B;
                    text-decoration: none;
                    font-weight: 500;
                    transition: all 0.2s ease;
                }

                .table-simulation-link:hover {
                    color: #8B6914;
                    text-decoration: underline;
                }

                .simulation-table th:first-child,
                .simulation-table td:first-child {
                    width: 20%;
                }

                .simulation-table th:nth-child(2),
                .simulation-table td:nth-child(2) {
                    width: 40%;
                }

                .simulation-table th:nth-child(3),
                .simulation-table td:nth-child(3) {
                    width: 40%;
                }

                .merged-cell {
                    font-style: italic;
                    color: #6c757d;
                }

                .intro-text {
                    font-family: Georgia, serif;
                    font-size: 18px;
                    line-height: 1.8;
                    color: #495057;
                    margin: 40px 0;
                    text-align: center;
                    max-width: 900px;
                    margin-left: auto;
                    margin-right: auto;
                }
            </style>

            <section class="simulation-links">
                <h2 class="links-title">Physical Systems Simulations</h2>
                <p class="intro-text">
                    Explore interactive toy CRR simulations demonstrating physical phenomena across scales; from quantum mechanics to cosmology. Each simulation provides hands-on exploration of dynamical systems, phase transitions, and emergent behaviours. These are provided as proof of concept only and are intended for users to reflect on the role of markovian and non-markovian memory in complex systems over time. 
                </p>

                <h2 class="category-header">Physics & Cosmology</h2>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>Simulation</th>
                            <th>Description</th>
                            <th>Why It Might Matter</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="atom_advanced.html" class="table-simulation-link" target="_blank">Atom</a></td>
                            <td>Interactive atomic structure model with electron orbital dynamics. <strong>CRR implementation:</strong> Coherence C(t) accumulates as deviation from ground state energy; rupture δ(t-t₀) triggers quantum jumps between orbital shells following Fermi's Golden Rule; regeneration uses Boltzmann weighting exp(C/Ω) to determine transition probabilities. Wave-particle duality emerges from tanh(C/C_crit) mixing parameter. We share this as a computational model of interest, noting that CRR memory dynamics can be modelled at this scale</td>
                            <td>Quantum systems exhibit both continuous evolution and discrete jumps. Understanding how coherence relates to observable transitions.</td>
                        </tr>
                        <tr>
                            <td><a href="black_hole.html" class="table-simulation-link" target="_blank">Black Hole (Interactive)</a></td>
                            <td>Simplified black hole system with event horizon and accretion dynamics. <strong>CRR implementation:</strong> Coherence integrates matter-energy density in accretion disk; event horizon acts as rupture boundary (δ(r-R_s)) where spacetime forces discrete transitions; Hawking radiation represents regeneration flux weighted by black hole's accumulated mass history.</td>
                            <td>Black holes represent boundary conditions where spacetime geometry forces discontinuous transitions. Studying these systems may offer insights into fundamental limits of information and causality. We share this because we find it intriguing that black holes seem to share similar memory-based patterns to a surprising number of other physical and biological systems, including human beings!</td>
                        </tr>
                        <tr>
                            <td><a href="blackhole_a.html" class="table-simulation-link" target="_blank">Black Hole (Research)</a></td>
                            <td>Extended black hole simulation with comprehensive CRR mathematics. <strong>Implementation:</strong> Full coherence field calculations for orbiting matter; threshold-triggered rupture events at the event horizon; regeneration operator modelling quantum fluctuations producing Hawking radiation at temperature T_H = ℏc³/(8πGMk_B).</td>
                            <td>The interplay between matter accumulation, horizon physics, and quantum radiation presents a laboratory for studying irreversible processes and thermal equilibrium in gravitational systems. CRR as a coarse-grain approach for understanding how systems maintain identity by changing.</td>
                        </tr>
                        <tr>
                            <td><a href="darkenergy.html" class="table-simulation-link" target="_blank">Dark Energy</a></td>
                            <td>Cosmological evolution with time-varying dark energy. <strong>CRR implementation:</strong> Coherence C(t) accumulates as cosmic age in Gyr; vacuum equation of state w(t) evolves as function of C/Ω ratio; phantom crossing occurs when coherence reaches critical threshold; regeneration term modifies dark energy density ρ_Λ(t) exponentially with accumulated coherence.</td>
                            <td>Recent observational data suggest possible deviations from cosmological constant behaviour. Models that incorporate memory effects in the vacuum may contribute to understanding accelerated expansion and the universe's ultimate fate. The CRR offers a coarse-grain understanding - it is modelled here to demonstrate the principle of systems maintaining identity by changing.</td>
                        </tr>
                        <tr>
                            <td><a href="crr_gravitational_waves.html" class="table-simulation-link" target="_blank">Gravitational waves</a></td>
                            <td>Gravitational Waves. <strong>CRR implementation:</strong> Coherence C(t) accumulates as orbital phase through inspiral via C(t) = ∫ω(τ)dτ following post-Newtonian evolution f(τ) ∝ τ⁻³/⁸; rupture δ(t_merger) marks the irreversible topology change from binary to single black hole; regeneration R(t) describes quasi-normal mode ringdown with damping τ_QNM determined by the memory kernel exp(C/Ω). The precision parameter Ω derives from mass ratio symmetry: Z₂ symmetric binaries (q=1) have Ω = 1/π ≈ 0.318, while broken symmetry increases Ω. QNM frequencies use Berti et al. fits; final state parameters from NR fits (Healy et al.). See <a href="crr_gravitational_waves.py">crr_gravitational_waves.py</a> for complete derivations.</td>
                            <td>Gravitational waves from binary black hole mergers naturally decompose into CRR's three phases. The inspiral chirp represents coherence accumulation as C approaches C* = Ω⁻¹. The merger is a true δ-function rupture—instantaneous, irreversible, scale-invariant. The ringdown represents regeneration toward equilibrium, with τ_QNM ∝ Ω⁻¹ confirming symmetric mergers decay faster. The CRR-BH correspondence yields C = S = 4πM², Ω = T = 1/(8πM), recovering the Sekino-Susskind scrambling time exactly: t_scr = Ω⁻¹log(C). The ringdown is the scrambling process made audible.</td>
                        </tr>                        
                        <tr>
                            <td rowspan="2"><a href="sun.html" class="table-simulation-link" target="_blank">Sun Simulation (V1)</a><br><br><a href="sun2.html" class="table-simulation-link" target="_blank">Sun Simulation (V2)</a></td>
                            <td colspan="2" class="merged-cell">Two complementary solar simulations demonstrating stellar dynamics. <strong>CRR implementation:</strong> Nuclear coherence (C_nuclear) accumulates from fusion reactions over stellar lifetime; magnetic coherence follows ~11-year cycles. Rupture events include: solar flares (magnetic reconnection, δ-impulses with τ=5s), coronal mass ejections (plasma expulsion with extended regeneration), and magnetic field reversals (complete coherence reset). Regeneration operator rebuilds corona and magnetic structure with memory of past configurations. We share this to show how even the sun can be thought of, in a coarse-grain way, as a memory-bearing system!</td>
                        </tr>
                        <tr>
                            <td>The Sun exhibits both steady fusion processes and catastrophic magnetic events. Understanding how systems reduce free energy variation through time and reach critical thresholds may be of benefit to systems thinkers.</td>
                        </tr>
                        <tr>
                            <td><a href="crr-thermo-rupture-rate.html" class="table-simulation-link" target="_blank">Thermodynamics</a></td>
                            <td>Thermodynamic CRR system with non-Markovian dynamics. <strong>CRR implementation:</strong> Coherence C accumulates as potential energy at rate L₀=0.6 J/time; rupture δ(t-t₀) activates when C≥threshold, transferring heat Q=C×1.5; regeneration R[χ] extracts work through memory integral ∫φ(τ)·exp(C/Ω)·Θ(t-τ)dτ with causal Heaviside constraint. Demonstrates perfect energy conservation (0.000% error).</td>
                            <td>Non-Markovian thermodynamics with memory effects remains compatible with fundamental conservation laws. This might have implications for understanding far-from-equilibrium processes and energy harvesting in complex systems. Maybe.</td>
                        </tr>
                        <tr>
                            <td><a href="crr_sandpile_sim__2_.html" class="table-simulation-link" target="_blank">Sandpile Modelling</a></td>
                            <td>Self-organised criticality via Bak-Tang-Wiesenfeld cellular automaton. <strong>CRR implementation:</strong> Coherence C_n = ∫(z-z_c/2)dt for each site accumulates height deviation; rupture occurs when grain count z≥4, triggering avalanche; regeneration distributes grains to neighbours weighted by exp(C_n/Ω). System self-organises to critical state C→C* with power-law avalanche distribution P(s)~s^(-1.27).</td>
                            <td>Self-organised critical systems appear across nature—from earthquakes to neural avalanches. Understanding how systems naturally evolve towards critical states may inform prediction of cascading failures and phase transitions.</td>
                        </tr>
                    </tbody>
                </table>

                <h2 class="category-header">Basic Phase Transitions & Interactive Models</h2>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>Simulation</th>
                            <th>Description</th>
                            <th>Why It Might Matter</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="kettle.html" class="table-simulation-link" target="_blank">Kettle</a></td>
                            <td>Water boiling with molecular dynamics and hydrogen bonding. <strong>CRR implementation:</strong> Coherence measured through hydrogen bond network stability and thermal equilibrium; rupture δ(t-t₀) occurs at phase transition threshold (100°C) breaking liquid coherence into chaotic steam; regeneration models atmospheric dispersion and convection currents with memory of thermal history.</td>
                            <td>Phase transitions involve crossing discrete thresholds where coherent structures rupture. Everyday phenomena like boiling provide accessible examples of how accumulated thermal energy triggers sudden reorganisation. We share this as a simple pedagogical model to show how coherence builds over time until rupture/phase transition thresholds are met</td>
                        </tr>
                        <tr>
                            <td><a href="ice.html" class="table-simulation-link" target="_blank">Ice</a></td>
                            <td>Crystallisation dynamics with nucleation and growth. <strong>CRR implementation:</strong> Coherence C(x,t) tracks local molecular organisation through temperature-dependent coupling; nucleation sites emerge when coherence exceeds threshold (rupture points); regeneration operator propagates crystalline order spatially using exp(C/Ω) weighting, with Heaviside causality ensuring crystal grows from established regions. Notice how cohernece also increases in this system, as the system forms a stabilised structure over time. This is why we think of CRR in terms of identity transforming through time, at all scales.</td>
                            <td>Freezing demonstrates how local interactions produce long-range order. Understanding nucleation and crystal growth informs materials science, protein folding, and pattern formation in natural systems.</td>
                        </tr>
                        <tr>
                            <td><a href="Zippo.html" class="table-simulation-link" target="_blank">Zippo Lighter</a></td>
                            <td>Interactive lighter with realistic combustion mechanics. <strong>CRR implementation:</strong> Fuel vapour coherence field tracks butane concentration and mixing; spark field accumulates ignition energy through flint friction; rupture occurs when ignition_energy>threshold AND fuel_density>0.3, triggering flame; regeneration maintains flame through memory-weighted fuel consumption with wind/movement perturbations causing coherence loss.</td>
                            <td>Combustion requires precise conditions—fuel density, ignition energy, and spatial coherence. Small variations determine whether reactions propagate or extinguish, illustrating sensitivity to initial conditions in chemical systems. We like the emergent effects from gas escaping, and the natural "non-markovian" look of the flame!</td>
                        </tr>
                        <tr>
                            <td><a href="atmosphere.html" class="table-simulation-link" target="_blank">Atmosphere</a></td>
                            <td>Molecular-scale atmospheric model with N₂, O₂, CO₂ interactions. <strong>CRR implementation:</strong> Atmospheric coherence field (80 elements) tracks gas mixture organisation; field evolves via temperature/pressure/humidity coupling; molecular collisions create rupture events redistributing momentum; regeneration processes restore equilibrium distributions through Brownian dynamics.</td>
                            <td>Atmospheric chemistry involves countless molecular collisions producing emergent properties like pressure and temperature. Such systems bridge microscopic randomness and macroscopic regularity.</td>
                        </tr>
                        <tr>
                            <td><a href="crr_holographic_final.html" class="table-simulation-link" target="_blank">Holographic</a></td>
                            <td>Thin-film interference and holographic projection. <strong>CRR implementation:</strong> Multi-layer optical path differences create interference patterns; coherence accumulates constructively/destructively across viewing angles; colour regeneration computed through wavelength-dependent phase shifts (400-700nm range); memory effects produce viewing-angle-dependent iridescence.</td>
                            <td>Wave interference creates stable patterns from continuous oscillations. Holography demonstrates how distributed information can encode three-dimensional structure—concepts relevant to both optics and theoretical physics. Upload an image to "rupture" the coherence field and see some stunning holographic effects!</td>
                        </tr>
                        <tr>
                            <td><a href="crr-bubble-simulation__2_.html" class="table-simulation-link" target="_blank">Bubbles</a></td>
                            <td>Soap bubble physics with film drainage and rupture. <strong>CRR implementation:</strong> Coherence L=f_film·f_age·f_structure·f_kinetic accumulates film stability factors; rupture δ(t-t₀) triggers when C<threshold or perturbation exceeds tolerance, creating film shards with retraction velocities; regeneration models droplet spray and surface tension relaxation weighted by pre-rupture coherence exp(C/Ω).</td>
                            <td>Soap films exist at minimal energy configurations until perturbations exceed stability thresholds. Their dynamics illustrate how structures persist through continuous adjustment until catastrophic failure occurs. We know this isn't an NVidia level demonstration, but we found it intriguing!</td>
                        </tr>
                    </tbody>
                </table>

                <h2 class="category-header">Markovian Agents in Non-Markovian Fields (ML Applications)</h2>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>Simulation</th>
                            <th>Description</th>
                            <th>Why It Might Matter</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><a href="room.html" class="table-simulation-link" target="_blank">Room Navigation</a></td>
                            <td>Multi-room exploration with key collection and goal-finding. <strong>CRR implementation:</strong> Agent maintains spatial coherence field C(x,y) through visited locations; local rupture detection via loop threshold breaks exploration cycles; global rupture resets after goal achievement; regeneration operator R[χ] weights actions by spatial memory integral ∫φ(x,τ)·exp(C/Ω)dτ. Intelligence I(t)=tanh(C_global/Ω) emerges from accumulated experience.</td>
                            <td>Intelligent behaviour can emerge from simple principles without explicit programming. Spatial memory accumulated through exploration enables efficient navigation—relevant for robotics, autonomous systems, and understanding biological navigation.</td>
                        </tr>
                        <tr>
                            <td><a href="fish.html" class="table-simulation-link" target="_blank">Fish Schooling</a></td>
                            <td>Single-agent learning with predators and food. <strong>CRR implementation:</strong> Memory trace accumulates position history (max 500 timesteps); coherence C grows via learning density L=reward-baseline; rupture occurs when C>threshold, triggering behavioural reset; regeneration R calculates movement bias from memory-weighted historical states. Avoidance/seeking strength scales with tanh(C/Ω) intelligence factor.</td>
                            <td>Animals adapt continuously to changing environments through memory and learning. Understanding how individual agents balance exploration, exploitation, and threat avoidance may inform reinforcement learning and swarm intelligence.</td>
                        </tr>
                        <tr>
                            <td><a href="Maze.html" class="table-simulation-link" target="_blank">Maze Pathfinding</a></td>
                            <td>Goal-directed maze navigation with emergent intelligence. <strong>CRR implementation:</strong> Global coherence C_global and per-cell coherence fields C(x,y) accumulate from learning density L(reward); spatial memory stores field signals with coherence-weighted history; action selection combines goal distance heuristic with regeneration momentum R·direction; intelligence I=C_global/Ω modulates exploration/exploitation trade-off. Rupture on threshold crossing or timeout.</td>
                            <td>Pathfinding in unknown environments requires balancing memory, exploration, and goal pursuit. Emergent intelligence from accumulated coherence may offer alternatives to traditional planning algorithms in uncertain domains.</td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </main>
    </div>
    </div>

    <footer class="footer">
        <div class="page-container">
            <div class="footer-content">
                
                <div class="footer-sections">
                    <div class="footer-section">
                        <h4>Core Resources</h4>
                        <ul>
                            <li><a href="https://github.com/alexsabine/CRR/" target="_blank" rel="noopener noreferrer">GitHub Repository</a></li>
                            <li><a href="https://github.com/alexsabine/CRR/blob/main/CRR_Repository_Catalogue.md" target="_blank" rel="noopener noreferrer">Repository Catalogue</a> <span style="font-size: 12px; color: #888;">(67+ demos)</span></li>
                            <li><a href="https://www.cohere.org.uk/guide.html" target="_blank" rel="noopener noreferrer">Guide</a></li>
                            <li><a href="https://github.com/alexsabine/CRR/blob/main/CRR_COMPREHENSIVE_SUMMARY.md" target="_blank" rel="noopener noreferrer">Comprehensive Summary</a></li>
                            <li><a href="https://github.com/alexsabine/CRR/blob/main/README.md" target="_blank" rel="noopener noreferrer">README</a></li>
                            <li><a href="https://www.cohere.org.uk/CRR_Plenary.html" target="_blank" rel="noopener noreferrer">CRR in 5-Mins</a></li>
                        </ul>
                    </div>
                    
                    <div class="footer-section">
                        <h4>Theory & Proof Sketches</h4>
                        <ul>
                            <li><a href="https://www.cohere.org.uk/Maths.html" target="_blank" rel="noopener noreferrer">Mathematical Foundations</a></li>
                            <li><a href="https://github.com/alexsabine/CRR/blob/main/crr_martingale_derivation.pdf" target="_blank" rel="noopener noreferrer">Martingale Derivation</a></li>
                            <li><a href="https://github.com/alexsabine/CRR/blob/main/canonical_crr_rigorous_proof_sketch.md" target="_blank" rel="noopener noreferrer">Canonical Proof Sketch</a></li>
                            <li><a href="https://www.cohere.org.uk/crr_first_principles_proofs.md" target="_blank" rel="noopener noreferrer">First Principles (12 domains)</a></li>
                            <li><a href="https://www.cohere.org.uk/16_nats_identity.pdf" target="_blank" rel="noopener noreferrer">16 Nats exploration</a></li>
                            <li><a href="https://www.cohere.org.uk/16nats_simulation.html" target="_blank" rel="noopener noreferrer">16 Nats System 1-2 Demo</a></li>
                            <li><a href="https://www.cohere.org.uk/CRR_Flatness_Commentary.pdf" target="_blank" rel="noopener noreferrer">Response to Mounier, Parr & Friston (2026)</a></li>
                            <li><a href="https://www.cohere.org.uk/CRR_Response_Tucker+Luu.pdf" target="_blank" rel="noopener noreferrer">Response to Tucker & Luu (2025)</a></li>
                            <li><a href="https://www.cohere.org.uk/Tolchinksy.pdf" target="_blank" rel="noopener noreferrer">Response to Tolchinsky et al (2025)</a></li>
                            <li><a href="https://www.cohere.org.uk/CRR_Lateralization_Thesis.pdf" target="_blank" rel="noopener noreferrer">L-R Brain Laterilisation (CRR)</a></li>
                        </ul>
                    </div>
                    
                    <div class="footer-section aliboo">
                        <h4>Aliboo's Wacky Workshop</h4>
                        <ul>
                            <li><a href="https://www.cohere.org.uk/crr-forest-seasonal.html" target="_blank" rel="noopener noreferrer">Season's Forest</a> <span style="font-size: 12px; color: #888;">(no CRR here, just a nice demo)</span></li>
                            <li><a href="https://www.cohere.org.uk/aurora_campfire.html" target="_blank" rel="noopener noreferrer">Aurora Campfire</a></li>
                            <li><a href="https://www.cohere.org.uk/siren-song.html" target="_blank" rel="noopener noreferrer">Siren Song</a></li>
                            <li><a href="https://www.cohere.org.uk/nostalgia_trap.html" target="_blank" rel="noopener noreferrer">Nostalgia Trap</a></li>
                            <li><a href="https://www.cohere.org.uk/CRR_Art.html" target="_blank" rel="noopener noreferrer">CRR Art Gallery</a></li>
                            <li><a href="https://www.cohere.org.uk/crr-explained.html" target="_blank" rel="noopener noreferrer">CRR Explained</a></li>
                            <li><a href="https://www.cohere.org.uk/brain_scientist_v2.html" target="_blank" rel="noopener noreferrer">FEP+CRR Brain (Pedagogical)</a></li>
                            <li><a href="https://www.cohere.org.uk/water-droplet-translucent.html" target="_blank" rel="noopener noreferrer">CRR Water Droplet</a></li>
                            <li><a href="https://www.cohere.org.uk/crr_star.html" target="_blank" rel="noopener noreferrer">CRR Star</a></li>
                            <li><a href="https://www.cohere.org.uk/crr_veil.html" target="_blank" rel="noopener noreferrer">CRR Veil Nebula</a></li>
                            <li><a href="https://www.cohere.org.uk/fep_ink_with_karl.html" target="_blank" rel="noopener noreferrer">The Classic Karl Series - Living Ink Demo</a></li>
                        </ul>
                    </div>
                </div>
                
                <div class="footer-divider"></div>
                
                <p class="sitemap-header">Site Map (it's a bit of a Labyrinth!)</p>
                
                <div class="anthill-container" id="anthillContainer">
                    <canvas class="anthill-canvas" id="anthillCanvas"></canvas>
                    <div class="colony-stats" id="colonyStats"></div>
                </div>
                
                <script>
                (function() {
                    const container = document.getElementById('anthillContainer');
                    const canvas = document.getElementById('anthillCanvas');
                    const ctx = canvas.getContext('2d');
                    const statsEl = document.getElementById('colonyStats');
                    
                    let W, H, dpr;
                    
                    const sections = [
                        { id: 'home', name: 'Home', url: 'index.html', x: 0.5, y: 0.08 },
                        { id: 'simulations', name: 'Simulations', url: 'crr-simulations.html', x: 0.22, y: 0.25 },
                        { id: 'biological', name: 'Biological', url: 'biological-systems.html', x: 0.10, y: 0.50 },
                        { id: 'physical', name: 'Physical', url: 'physical-systems.html', x: 0.28, y: 0.52 },
                        { id: 'mathematical', name: 'Mathematical', url: 'mathematical-life.html', x: 0.18, y: 0.78 },
                        { id: 'benchmarks', name: 'Benchmarks', url: 'crr-benchmarks.html', x: 0.50, y: 0.38 },
                        { id: 'explained', name: 'Explained', url: 'crr-explained.html', x: 0.78, y: 0.25 },
                        { id: 'about', name: 'About', url: 'about.html', x: 0.90, y: 0.50 },
                        { id: 'workshop', name: 'Workshop', url: 'CRR_Art.html', x: 0.70, y: 0.78 },
                        { id: 'maths', name: 'Maths', url: 'Maths.html', x: 0.50, y: 0.62 }
                    ];
                    
                    const resourceTypes = [
                        { symbol: '∫', name: 'integral', color: '#FFD700' },
                        { symbol: 'Ω', name: 'omega', color: '#FFA500' },
                        { symbol: 'δ', name: 'delta', color: '#FF6B6B' },
                        { symbol: 'C', name: 'coherence', color: '#90EE90' },
                        { symbol: 'R', name: 'regeneration', color: '#87CEEB' },
                        { symbol: 'π', name: 'pi', color: '#DDA0DD' },
                        { symbol: 'e', name: 'euler', color: '#F0E68C' },
                        { symbol: '∂', name: 'partial', color: '#98FB98' },
                        { symbol: 'Σ', name: 'sum', color: '#FFC0CB' },
                        { symbol: '∞', name: 'infinity', color: '#E6E6FA' }
                    ];
                    
                    let chambers = [];
                    let tunnels = [];
                    let ants = [];
                    let totalResourcesDelivered = 0;
                    
                    function resize() {
                        const rect = container.getBoundingClientRect();
                        dpr = window.devicePixelRatio || 1;
                        W = rect.width;
                        H = rect.height;
                        canvas.width = W * dpr;
                        canvas.height = H * dpr;
                        ctx.scale(dpr, dpr);
                        canvas.style.width = W + 'px';
                        canvas.style.height = H + 'px';
                        initChambers();
                    }
                    
                    function initChambers() {
                        chambers = sections.map((s, i) => ({
                            ...s,
                            px: s.x * W,
                            py: s.y * H,
                            radius: Math.min(W, H) * 0.052,
                            resources: [],
                            activity: 0
                        }));
                        
                        tunnels = [
                            { from: 0, to: 1 }, { from: 0, to: 5 }, { from: 0, to: 6 },
                            { from: 1, to: 2 }, { from: 1, to: 3 }, { from: 1, to: 5 },
                            { from: 2, to: 4 }, { from: 3, to: 4 }, { from: 3, to: 9 },
                            { from: 5, to: 9 }, { from: 6, to: 7 }, { from: 6, to: 5 },
                            { from: 7, to: 8 }, { from: 8, to: 9 }, { from: 4, to: 8 },
                            { from: 9, to: 8 }, { from: 5, to: 6 }
                        ].map(t => ({
                            ...t,
                            strength: 0.2 + Math.random() * 0.3,
                            pheromone: 0.4 + Math.random() * 0.2
                        }));
                    }
                    
                    class Ant {
                        constructor() { this.reset(); }
                        reset() {
                            const startChamber = chambers[Math.floor(Math.random() * chambers.length)];
                            this.x = startChamber.px + (Math.random() - 0.5) * startChamber.radius * 0.5;
                            this.y = startChamber.py + (Math.random() - 0.5) * startChamber.radius * 0.5;
                            this.homeChamber = startChamber;
                            this.targetChamber = null;
                            this.carrying = null;
                            this.coherence = 0;
                            this.omega = 0.25 + Math.random() * 0.5;
                            this.speed = 0.5 + Math.random() * 0.4;
                            this.angle = Math.random() * Math.PI * 2;
                            this.waitTime = 0;
                            this.decideAction();
                        }
                        decideAction() { this.pickForagingTarget(); this.coherence = 0; }
                        pickForagingTarget() {
                            const currentChamberIdx = this.nearestChamberIndex();
                            const connections = tunnels.filter(t => (t.from === currentChamberIdx || t.to === currentChamberIdx) && t.strength > 0.2);
                            if (connections.length > 0 && Math.random() > 0.2) {
                                connections.sort((a, b) => b.pheromone - a.pheromone);
                                const conn = connections[Math.random() < 0.3 ? Math.floor(Math.random() * connections.length) : 0];
                                const targetIdx = conn.from === currentChamberIdx ? conn.to : conn.from;
                                this.targetChamber = chambers[targetIdx];
                            } else {
                                this.targetChamber = chambers[Math.floor(Math.random() * chambers.length)];
                            }
                        }
                        nearestChamberIndex() {
                            let nearest = 0, minDist = Infinity;
                            chambers.forEach((ch, i) => { const d = Math.hypot(ch.px - this.x, ch.py - this.y); if (d < minDist) { minDist = d; nearest = i; } });
                            return nearest;
                        }
                        update() {
                            this.waitTime = Math.max(0, this.waitTime - 1);
                            if (this.waitTime > 0) return;
                            this.coherence += 0.006 * this.speed;
                            const effectiveOmega = this.carrying ? this.omega * 2.2 : this.omega;
                            if (this.coherence > effectiveOmega) {
                                if (this.carrying) {
                                    const nearIdx = this.nearestChamberIndex();
                                    const nearCh = chambers[nearIdx];
                                    if (Math.hypot(nearCh.px - this.x, nearCh.py - this.y) < nearCh.radius * 0.8) {
                                        nearCh.resources.push(this.carrying); nearCh.activity += 0.1; totalResourcesDelivered++; this.carrying = null;
                                    }
                                }
                                this.waitTime = 8 + Math.random() * 15; this.decideAction(); return;
                            }
                            if (this.targetChamber) this.moveTowardTarget(); else this.wander();
                            this.x = Math.max(12, Math.min(W - 12, this.x)); this.y = Math.max(12, Math.min(H - 12, this.y));
                        }
                        moveTowardTarget() {
                            const dx = this.targetChamber.px - this.x, dy = this.targetChamber.py - this.y, dist = Math.hypot(dx, dy);
                            if (dist < this.targetChamber.radius * 0.6) {
                                this.targetChamber.activity += 0.05;
                                if (this.carrying) { this.targetChamber.resources.push(this.carrying); totalResourcesDelivered++; this.carrying = null; this.waitTime = 12; }
                                else if (this.targetChamber.resources.length > 2) { this.carrying = this.targetChamber.resources.pop(); this.waitTime = 8; }
                                else if (Math.random() < 0.35) { this.carrying = resourceTypes[Math.floor(Math.random() * resourceTypes.length)]; }
                                const fromIdx = this.nearestChamberIndex();
                                tunnels.forEach(t => { if ((t.from === fromIdx && chambers[t.to] === this.targetChamber) || (t.to === fromIdx && chambers[t.from] === this.targetChamber)) { t.pheromone = Math.min(1, t.pheromone + 0.02); t.strength = Math.min(1, t.strength + 0.003); } });
                                this.pickForagingTarget(); return;
                            }
                            const targetAngle = Math.atan2(dy, dx), memoryWeight = Math.exp(this.coherence / this.omega), angleBlend = Math.min(0.12 * memoryWeight, 0.35);
                            this.angle += (targetAngle - this.angle) * angleBlend; this.angle += (Math.random() - 0.5) * 0.2;
                            const currentSpeed = this.carrying ? this.speed * 0.65 : this.speed;
                            this.x += Math.cos(this.angle) * currentSpeed; this.y += Math.sin(this.angle) * currentSpeed;
                        }
                        wander() { this.angle += (Math.random() - 0.5) * 0.35; this.x += Math.cos(this.angle) * this.speed * 0.4; this.y += Math.sin(this.angle) * this.speed * 0.4; if (Math.random() < 0.015) this.decideAction(); }
                        draw(ctx) {
                            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#1a0a00';
                            ctx.beginPath(); ctx.ellipse(3.5, 0, 2, 1.6, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.ellipse(-0.5, 0, 2.5, 2, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.ellipse(-5, 0, 3.5, 2.5, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.strokeStyle = '#1a0a00'; ctx.lineWidth = 0.6;
                            const legPhase = Date.now() * 0.012 + this.x * 0.1;
                            for (let i = -1; i <= 1; i++) { const lx = -0.5 + i * 2, legWave = Math.sin(legPhase + i * 1.1) * 1.8; ctx.beginPath(); ctx.moveTo(lx, 1.6); ctx.quadraticCurveTo(lx + 1.2, 2.8 + legWave, lx + 2.5, 4.5 + legWave * 0.5); ctx.stroke(); ctx.beginPath(); ctx.moveTo(lx, -1.6); ctx.quadraticCurveTo(lx + 1.2, -2.8 - legWave, lx + 2.5, -4.5 - legWave * 0.5); ctx.stroke(); }
                            ctx.beginPath(); ctx.moveTo(4.5, 0.7); ctx.quadraticCurveTo(6, 1.3, 7.5, 2.5 + Math.sin(Date.now() * 0.007 + this.y) * 0.6); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(4.5, -0.7); ctx.quadraticCurveTo(6, -1.3, 7.5, -2.5 + Math.sin(Date.now() * 0.007 + this.y + 1) * 0.6); ctx.stroke();
                            if (this.carrying) { ctx.fillStyle = this.carrying.color; ctx.font = 'bold 7px Georgia'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 2; ctx.fillText(this.carrying.symbol, 0, -5); ctx.shadowBlur = 0; }
                            ctx.restore();
                        }
                    }
                    
                    function evaporate() { tunnels.forEach(t => { t.pheromone *= 0.9992; }); }
                    
                    function drawNest() {
                        ctx.clearRect(0, 0, W, H);
                        ctx.fillStyle = 'rgba(55, 38, 22, 0.25)';
                        for (let i = 0; i < 40; i++) { ctx.beginPath(); ctx.arc(Math.random() * W, Math.random() * H, 1 + Math.random() * 2.5, 0, Math.PI * 2); ctx.fill(); }
                        ctx.lineCap = 'round';
                        tunnels.forEach(t => {
                            const fromCh = chambers[t.from], toCh = chambers[t.to], tunnelWidth = 10 + t.strength * 12;
                            ctx.strokeStyle = 'rgba(28, 16, 6, ' + (0.35 + t.strength * 0.4) + ')'; ctx.lineWidth = tunnelWidth + 5;
                            ctx.beginPath(); ctx.moveTo(fromCh.px, fromCh.py);
                            const midX = (fromCh.px + toCh.px) / 2 + (t.from - t.to) * 6, midY = (fromCh.py + toCh.py) / 2 + (t.from + t.to) * 2;
                            ctx.quadraticCurveTo(midX, midY, toCh.px, toCh.py); ctx.stroke();
                            const bright = 50 + t.strength * 35 + t.pheromone * 18;
                            ctx.strokeStyle = 'rgb(' + (bright + 12) + ',' + (bright - 6) + ',' + (bright - 18) + ')'; ctx.lineWidth = tunnelWidth; ctx.stroke();
                            if (t.pheromone > 0.35) { ctx.strokeStyle = 'rgba(170, 130, 55, ' + (t.pheromone * 0.12) + ')'; ctx.lineWidth = tunnelWidth + 3; ctx.stroke(); }
                        });
                        chambers.forEach(ch => {
                            const glowInt = Math.min(ch.activity, 1);
                            const glow = ctx.createRadialGradient(ch.px, ch.py, 0, ch.px, ch.py, ch.radius * 1.4);
                            glow.addColorStop(0, 'rgba(115, 85, 48, ' + (0.88 + glowInt * 0.1) + ')'); glow.addColorStop(0.55, 'rgba(80, 55, 32, ' + (0.82 + glowInt * 0.1) + ')'); glow.addColorStop(1, 'rgba(45, 28, 12, 0)');
                            ctx.fillStyle = glow; ctx.beginPath(); ctx.ellipse(ch.px, ch.py, ch.radius * 1.35, ch.radius * 1.15, 0, 0, Math.PI * 2); ctx.fill();
                            const interior = ctx.createRadialGradient(ch.px - ch.radius * 0.18, ch.py - ch.radius * 0.18, 0, ch.px, ch.py, ch.radius);
                            interior.addColorStop(0, 'rgba(' + (100 + glowInt * 18) + ',' + (70 + glowInt * 12) + ',' + (42 + glowInt * 8) + ', 0.94)'); interior.addColorStop(0.7, 'rgba(70, 48, 28, 0.88)'); interior.addColorStop(1, 'rgba(55, 35, 20, 0.82)');
                            ctx.fillStyle = interior; ctx.beginPath(); ctx.ellipse(ch.px, ch.py, ch.radius, ch.radius * 0.82, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = 'rgba(255, 246, 218, 0.88)'; ctx.font = '10px Georgia'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.75)'; ctx.shadowBlur = 3; ctx.fillText(ch.name, ch.px, ch.py); ctx.shadowBlur = 0;
                            ch.resources.slice(-5).forEach((res, ri) => { const resAngle = (ri / 5) * Math.PI * 2 + Date.now() * 0.00025, resX = ch.px + Math.cos(resAngle) * (ch.radius * 0.55), resY = ch.py + Math.sin(resAngle) * (ch.radius * 0.45); ctx.fillStyle = res.color; ctx.font = '6px Georgia'; ctx.fillText(res.symbol, resX, resY); });
                            ch.activity *= 0.985;
                        });
                        ants.forEach(ant => ant.draw(ctx));
                        statsEl.textContent = 'Resources moved: ' + totalResourcesDelivered + ' | Carriers: ' + ants.filter(a => a.carrying).length;
                    }
                    
                    let frameCount = 0;
                    function animate() { frameCount++; ants.forEach(ant => ant.update()); if (frameCount % 4 === 0) evaporate(); drawNest(); requestAnimationFrame(animate); }
                    
                    resize();
                    for (let i = 0; i < 22; i++) ants.push(new Ant());
                    chambers.forEach(ch => { for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) ch.resources.push(resourceTypes[Math.floor(Math.random() * resourceTypes.length)]); });
                    canvas.addEventListener('click', (e) => { const rect = canvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top; chambers.forEach(ch => { if (Math.hypot(ch.px - mx, ch.py - my) < ch.radius) window.location.href = ch.url; }); });
                    canvas.style.cursor = 'pointer'; window.addEventListener('resize', resize); animate();
                })();
                </script>
                
                <div class="footer-divider"></div>
                
                <p class="footer-repo-note">
                    This repository is an explorable treatise: 67+ interactive demonstrations alongside mathematical documentation. The unusual structure is intentional. Think exhibition space, not code library.
                </p>
                
                <p class="footer-author">
                    <strong>Alexander Sabine</strong> · Board of Directors, <a href="https://activeinference.org/" target="_blank" rel="noopener noreferrer">Active Inference Institute</a> (2026)<br>
                    Doctoral studies in participatory action mapping (maps and territories)<br>
                    Contact: Alexander [at] active-inference [dot] co [dot] uk
                </p>
                
                <p class="footer-tech-note">
                    Simulations utilise HTML5, WebGL2, and advanced JavaScript. Desktop browsers recommended for optimal performance.<br>
                    Site coded by Claude, with thanks to Anthropic. 
                </p>
                
            </div>
        </div>
    </footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        'use strict';

        // =====================================
        // CRR PHYSICAL SYSTEMS - NON-MARKOVIAN MEMORY IMPLEMENTATION
        // =====================================

        // Optimized WebGL2 CRR System
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        // Physical system parameters
        const PARTICLE_COUNT = 400;
        const MEMORY_GRID_SIZE = 64;
        let currentPhase = 'coherence';
        let memoryStrength = 2.5;
        let intensity = 1.8;
        let fidelity = 1.2;
        let globalTime = 0;
        let phaseTransitions = 0;
        
        // Auto-demo variables
        let userInteracted = false;
        let autoSequenceStarted = false;
        let startTime = Date.now();

        // CRITICAL: Non-Markovian memory system - NO coordinates stored after rupture
        const particles = new Float32Array(PARTICLE_COUNT * 12); // pos(2) + vel(2) + state(2) + memoryWeights(6)
        const memoryField = new Float32Array(MEMORY_GRID_SIZE * MEMORY_GRID_SIZE);
        const coherenceMemory = new Array(PARTICLE_COUNT).fill(null).map(() => []); // Historical coherence patterns
        
        // Enhanced shaders with rich color variation for physics
        const vertexShader = `#version 300 es
        in vec2 a_position;
        in vec2 a_velocity;
        in vec2 a_state;
        
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform int u_phase;
        
        out vec4 v_color;
        out float v_size;
        
        void main() {
            vec2 position = (a_position / u_resolution) * 2.0 - 1.0;
            position.y *= -1.0;
            gl_Position = vec4(position, 0.0, 1.0);
            
            float coherence = a_state.x;
            float memoryStrength = a_state.y;
            
            // Determine letter index from position for color variation
            float normalizedX = a_position.x / u_resolution.x;
            int letterIndex = int(normalizedX * 6.0);
            
            if (u_phase == 0) { // Coherence - physics-themed colors
                v_size = (2.0 + coherence * 4.0) * (0.8 + memoryStrength * 0.4);
                
                if (letterIndex == 0) { // C - atomic red
                    v_color = vec4(1.0, 0.3 + coherence * 0.4, 0.2 + coherence * 0.3, 0.8 + coherence * 0.2);
                } else if (letterIndex == 1) { // O - nuclear blue
                    v_color = vec4(0.2 + coherence * 0.3, 0.5 + coherence * 0.4, 1.0, 0.8 + coherence * 0.2);
                } else if (letterIndex == 2) { // H - energy green
                    v_color = vec4(0.1 + coherence * 0.4, 0.8 + coherence * 0.2, 0.3 + coherence * 0.4, 0.8 + coherence * 0.2);
                } else if (letterIndex == 3) { // E - photon yellow
                    v_color = vec4(1.0, 0.8 + coherence * 0.2, 0.1 + coherence * 0.4, 0.8 + coherence * 0.2);
                } else if (letterIndex == 4) { // R - quantum violet
                    v_color = vec4(0.7 + coherence * 0.3, 0.2 + coherence * 0.3, 1.0, 0.8 + coherence * 0.2);
                } else { // E - plasma orange
                    v_color = vec4(1.0, 0.5 + coherence * 0.3, 0.1 + coherence * 0.3, 0.8 + coherence * 0.2);
                }
            } else if (u_phase == 1) { // Rupture - high energy physics
                v_size = (3.0 + memoryStrength * 3.0) * (1.0 + coherence * 0.5);
                float flicker = 0.8 + sin(u_time * 0.1 + a_position.x * 0.01) * 0.2 * memoryStrength;
                v_color = vec4((0.9 + memoryStrength * 0.1) * flicker, (0.3 + memoryStrength * 0.4) * flicker, 0.8 * flicker, 0.7 + memoryStrength * 0.3);
            } else { // Rebirth - reconstruction physics
                v_size = (1.5 + coherence * 5.0) * (0.9 + memoryStrength * 0.3);
                float glow = 0.9 + sin(u_time * 0.05) * 0.1;
                v_color = vec4(0.3 * glow, (0.7 + coherence * 0.3) * glow, (0.5 + coherence * 0.4) * glow, 0.7 + coherence * 0.3);
            }
            
            gl_PointSize = v_size + sin(u_time * 0.002 + a_position.x * 0.01) * 0.5;
        }`;
        
        const fragmentShader = `#version 300 es
        precision mediump float;
        
        in vec4 v_color;
        in float v_size;
        
        out vec4 fragColor;
        
        void main() {
            vec2 coord = gl_PointCoord - 0.5;
            float dist = length(coord);
            
            if (dist > 0.5) discard;
            
            float alpha = 1.0 - smoothstep(0.1, 0.5, dist);
            vec3 glow = v_color.rgb * (1.0 + alpha * 0.5);
            
            fragColor = vec4(glow, alpha * v_color.a);
        }`;
        
        // WebGL setup
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }
        
        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            return program;
        }
        
        const vs = createShader(gl.VERTEX_SHADER, vertexShader);
        const fs = createShader(gl.FRAGMENT_SHADER, fragmentShader);
        const program = createProgram(vs, fs);
        
        // Initialize particles for COHERE with NON-MARKOVIAN MEMORY
        function initializeParticles() {
            const letters = ['C', 'O', 'H', 'E', 'R', 'E'];
            const particlesPerLetter = Math.floor(PARTICLE_COUNT / 6);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const letterIndex = Math.floor(i / particlesPerLetter);
                const particleInLetter = i % particlesPerLetter;
                
                const target = generateLetterTarget(letters[letterIndex], letterIndex, particleInLetter);
                
                const offset = i * 12;
                
                // Random starting position
                particles[offset] = canvas.width * 0.5 + (Math.random() - 0.5) * 200;
                particles[offset + 1] = canvas.height * 0.5 + (Math.random() - 0.5) * 150;
                
                // Initial velocity
                particles[offset + 2] = (Math.random() - 0.5) * 2;
                particles[offset + 3] = (Math.random() - 0.5) * 2;
                
                // State: coherence, memory_strength
                particles[offset + 4] = 0.1; // coherence
                particles[offset + 5] = 0.0; // memory strength
                
                // CRITICAL: Memory weights (6 values) - NOT COORDINATES
                // These weights encode spatial relationships during coherence phase
                for (let j = 6; j < 12; j++) {
                    particles[offset + j] = Math.random() * 0.1; // Initial random memory weights
                }
                
                // Initialize coherence memory for this particle
                coherenceMemory[i] = [];
            }
        }

        function generateLetterTarget(letter, letterIndex, particleIndex) {
            // Arial-style uppercase letters with consistent sizing
            const letterWidth = Math.min(60, canvas.width / 12);
            const letterHeight = Math.min(100, canvas.height * 0.5);
            
            // Tighter, more consistent spacing for Arial look
            const spacing = Math.min(12, canvas.width / 60);
            
            const totalWidth = 6 * letterWidth + 5 * spacing;
            const startX = (canvas.width - totalWidth) / 2;
            
            let letterX = startX + letterIndex * (letterWidth + spacing);
            const startY = (canvas.height - letterHeight) / 2;
            
            const particlesPerLetter = Math.floor(PARTICLE_COUNT / 6);
            const t = particleIndex / Math.max(1, particlesPerLetter - 1);
            
            let x, y;
            
            switch(letter) {
                case 'C':
                    // Clean geometric C
                    const angle = Math.PI * 0.2 + t * Math.PI * 1.6;
                    x = letterX + letterWidth/2 + Math.cos(angle) * letterWidth * 0.4;
                    y = startY + letterHeight/2 + Math.sin(angle) * letterHeight * 0.4;
                    break;
                    
                case 'O':
                    // Perfect circular O
                    const oAngle = t * Math.PI * 2;
                    x = letterX + letterWidth/2 + Math.cos(oAngle) * letterWidth * 0.35;
                    y = startY + letterHeight/2 + Math.sin(oAngle) * letterHeight * 0.4;
                    break;
                    
                case 'H':
                    // Geometric H with straight lines
                    if (t < 0.4) {
                        // Left vertical line
                        x = letterX + letterWidth * 0.15;
                        y = startY + (t / 0.4) * letterHeight;
                    } else if (t < 0.8) {
                        // Right vertical line
                        x = letterX + letterWidth * 0.85;
                        y = startY + ((t - 0.4) / 0.4) * letterHeight;
                    } else {
                        // Horizontal crossbar
                        const crossT = (t - 0.8) / 0.2;
                        x = letterX + letterWidth * 0.15 + crossT * letterWidth * 0.7;
                        y = startY + letterHeight * 0.5;
                    }
                    break;
                    
                case 'E':
                    // Clean geometric E
                    if (t < 0.25) {
                        // Left vertical line
                        x = letterX + letterWidth * 0.15;
                        y = startY + (t / 0.25) * letterHeight;
                    } else if (t < 0.4) {
                        // Top horizontal line
                        const topT = (t - 0.25) / 0.15;
                        x = letterX + letterWidth * 0.15 + topT * letterWidth * 0.7;
                        y = startY + letterHeight * 0.05;
                    } else if (t < 0.6) {
                        // Middle horizontal line
                        const midT = (t - 0.4) / 0.2;
                        x = letterX + letterWidth * 0.15 + midT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.5;
                    } else {
                        // Bottom horizontal line
                        const botT = (t - 0.6) / 0.4;
                        x = letterX + letterWidth * 0.15 + botT * letterWidth * 0.7;
                        y = startY + letterHeight * 0.95;
                    }
                    break;
                    
                case 'R':
                    // Geometric R with clean lines
                    if (t < 0.3) {
                        // Left vertical line
                        x = letterX + letterWidth * 0.15;
                        y = startY + (t / 0.3) * letterHeight;
                    } else if (t < 0.45) {
                        // Top horizontal line
                        const topT = (t - 0.3) / 0.15;
                        x = letterX + letterWidth * 0.15 + topT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.05;
                    } else if (t < 0.6) {
                        // Right side of bowl (vertical)
                        const rightT = (t - 0.45) / 0.15;
                        x = letterX + letterWidth * 0.7;
                        y = startY + letterHeight * 0.05 + rightT * letterHeight * 0.4;
                    } else if (t < 0.75) {
                        // Middle horizontal line
                        const midT = (t - 0.6) / 0.15;
                        x = letterX + letterWidth * 0.7 - midT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.45;
                    } else {
                        // Diagonal leg
                        const legT = (t - 0.75) / 0.25;
                        x = letterX + letterWidth * 0.15 + legT * letterWidth * 0.55;
                        y = startY + letterHeight * 0.45 + legT * letterHeight * 0.5;
                    }
                    break;
                    
                default:
                    x = letterX + letterWidth/2;
                    y = startY + letterHeight/2;
            }
            
            return { x, y };
        }
        
        // CRITICAL: Non-Markovian physics update with memory-based reconstruction
        function updateParticles(dt) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                
                let pos = [particles[offset], particles[offset + 1]];
                let vel = [particles[offset + 2], particles[offset + 3]];
                let state = [particles[offset + 4], particles[offset + 5]]; // coherence, memory_strength
                let memoryWeights = [];
                for (let j = 6; j < 12; j++) {
                    memoryWeights.push(particles[offset + j]);
                }
                
                // Calculate target position for this particle (for reference only)
                const letterIndex = Math.floor(i / Math.floor(PARTICLE_COUNT / 6));
                const particleInLetter = i % Math.floor(PARTICLE_COUNT / 6);
                const letters = ['C', 'O', 'H', 'E', 'R', 'E'];
                const target = generateLetterTarget(letters[letterIndex], letterIndex, particleInLetter);
                
                // Phase-specific NON-MARKOVIAN behavior
                switch(currentPhase) {
                    case 'coherence':
                        // Build coherence and LEARN memory weights (not coordinates!)
                        state[0] += memoryStrength * dt * 0.006;
                        state[0] = Math.min(1.0, state[0]);
                        state[1] = memoryStrength;
                        
                        // CRITICAL: Store coherence patterns in memory (not positions)
                        if (globalTime % 30 === 0) { // Every 30 frames
                            coherenceMemory[i].push({
                                coherence: state[0],
                                time: globalTime,
                                relativeDistances: [] // Store relative distances to nearby particles
                            });
                            
                            // Keep only recent memory
                            if (coherenceMemory[i].length > 20) {
                                coherenceMemory[i].shift();
                            }
                        }
                        
                        // Learn memory weights based on spatial relationships
                        const targetDx = target.x - pos[0];
                        const targetDy = target.y - pos[1];
                        const targetDistance = Math.sqrt(targetDx*targetDx + targetDy*targetDy);
                        
                        if (targetDistance > 2) {
                            const force = (0.2 + state[0] * 0.8) * memoryStrength * 0.8;
                            vel[0] += (targetDx / targetDistance) * force * dt * 0.04;
                            vel[1] += (targetDy / targetDistance) * force * dt * 0.04;
                            
                            // LEARN memory weights from successful movements
                            const learningRate = 0.001 * state[0];
                            for (let j = 0; j < 6; j++) {
                                memoryWeights[j] += learningRate * Math.sin(globalTime * 0.01 + j);
                                memoryWeights[j] = Math.max(0, Math.min(1, memoryWeights[j]));
                            }
                        }
                        
                        // Memory affects stability vs chaos
                        const randomFactor = Math.max(0.05, 0.4 / memoryStrength);
                        vel[0] += (Math.random() - 0.5) * randomFactor * dt;
                        vel[1] += (Math.random() - 0.5) * randomFactor * dt;
                        
                        // Memory affects damping
                        const dampingFactor = 0.9 + memoryStrength * 0.02;
                        vel[0] *= Math.min(0.98, dampingFactor);
                        vel[1] *= Math.min(0.98, dampingFactor);
                        break;
                        
                    case 'rupture':
                        // CRITICAL: NO coordinates stored! Only memory weights persist
                        state[1] = intensity;
                        
                        // Dramatic chaos - particles lose spatial coherence
                        const chaosForce = intensity * intensity * 2.0;
                        vel[0] += (Math.random() - 0.5) * chaosForce * dt;
                        vel[1] += (Math.random() - 0.5) * chaosForce * dt;
                        
                        // Coherence rapidly decays
                        state[0] *= (1.0 - intensity * 0.01);
                        
                        // Memory weights become noisy but are NOT destroyed
                        for (let j = 0; j < 6; j++) {
                            memoryWeights[j] += (Math.random() - 0.5) * intensity * 0.02;
                            memoryWeights[j] = Math.max(0, Math.min(1, memoryWeights[j]));
                        }
                        
                        // High intensity reduces damping
                        const ruptureRamping = Math.max(0.85, 0.98 - intensity * 0.1);
                        vel[0] *= ruptureRamping;
                        vel[1] *= ruptureRamping;
                        break;
                        
                    case 'rebirth':
                        // CRITICAL: Reconstruct position from MEMORY WEIGHTS, not stored coordinates
                        let reconstructedX = 0;
                        let reconstructedY = 0;
                        
                        // Use coherence memory and weights to reconstruct target position
                        if (coherenceMemory[i].length > 0) {
                            let totalWeight = 0;
                            
                            for (let memIdx = 0; memIdx < coherenceMemory[i].length; memIdx++) {
                                const memory = coherenceMemory[i][memIdx];
                                const timeWeight = Math.exp(-(globalTime - memory.time) * 0.001); // Recent memories weighted higher
                                const coherenceWeight = memory.coherence;
                                
                                // Use memory weights to influence reconstruction
                                for (let j = 0; j < 6; j++) {
                                    const weight = memoryWeights[j] * timeWeight * coherenceWeight * fidelity;
                                    totalWeight += weight;
                                    
                                    // Reconstruct position using trigonometric basis functions
                                    reconstructedX += weight * target.x * Math.cos(j * Math.PI / 3);
                                    reconstructedY += weight * target.y * Math.sin(j * Math.PI / 3);
                                }
                            }
                            
                            if (totalWeight > 0) {
                                reconstructedX /= totalWeight;
                                reconstructedY /= totalWeight;
                            } else {
                                // Fallback to target if no memory
                                reconstructedX = target.x;
                                reconstructedY = target.y;
                            }
                        } else {
                            reconstructedX = target.x;
                            reconstructedY = target.y;
                        }
                        
                        // Move towards reconstructed position
                        const dx = reconstructedX - pos[0];
                        const dy = reconstructedY - pos[1];
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance > 1) {
                            // Fidelity affects reconstruction precision and speed
                            const rebirthForce = fidelity * fidelity * 0.5;
                            vel[0] += (dx / distance) * rebirthForce * dt;
                            vel[1] += (dy / distance) * rebirthForce * dt;
                        }
                        
                        // Restore coherence
                        state[0] += fidelity * dt * 0.004;
                        state[0] = Math.min(1.0, state[0]);
                        
                        // High fidelity creates precise reconstruction
                        const precisionDamping = 0.85 + fidelity * 0.08;
                        vel[0] *= Math.min(0.95, precisionDamping);
                        vel[1] *= Math.min(0.95, precisionDamping);
                        
                        // Minimal noise for clean reconstruction
                        const rebirthNoise = Math.max(0.02, 0.15 / fidelity);
                        vel[0] += (Math.random() - 0.5) * rebirthNoise * dt;
                        vel[1] += (Math.random() - 0.5) * rebirthNoise * dt;
                        break;
                }
                
                // Update position
                pos[0] += vel[0] * dt;
                pos[1] += vel[1] * dt;
                
                // Boundary conditions
                if (pos[0] < 0 || pos[0] > canvas.width) vel[0] *= -0.8;
                if (pos[1] < 0 || pos[1] > canvas.height) vel[1] *= -0.8;
                pos[0] = Math.max(2, Math.min(canvas.width - 2, pos[0]));
                pos[1] = Math.max(2, Math.min(canvas.height - 2, pos[1]));
                
                // Write back to array
                particles[offset] = pos[0];
                particles[offset + 1] = pos[1];
                particles[offset + 2] = vel[0];
                particles[offset + 3] = vel[1];
                particles[offset + 4] = state[0];
                particles[offset + 5] = state[1];
                
                // Write back memory weights
                for (let j = 0; j < 6; j++) {
                    particles[offset + 6 + j] = memoryWeights[j];
                }
            }
        }
        
        // Rendering setup
        const positionBuffer = gl.createBuffer();
        const velocityBuffer = gl.createBuffer();
        const stateBuffer = gl.createBuffer();
        
        // Initialize canvas size
        function initializeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // Render function
        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            gl.useProgram(program);
            
            // Update buffers
            const positions = new Float32Array(PARTICLE_COUNT * 2);
            const velocities = new Float32Array(PARTICLE_COUNT * 2);
            const states = new Float32Array(PARTICLE_COUNT * 2);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                positions[i * 2] = particles[offset];
                positions[i * 2 + 1] = particles[offset + 1];
                velocities[i * 2] = particles[offset + 2];
                velocities[i * 2 + 1] = particles[offset + 3];
                states[i * 2] = particles[offset + 4];
                states[i * 2 + 1] = particles[offset + 5];
            }
            
            // Bind buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
            const a_position = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.DYNAMIC_DRAW);
            const a_velocity = gl.getAttribLocation(program, 'a_velocity');
            gl.enableVertexAttribArray(a_velocity);
            gl.vertexAttribPointer(a_velocity, 2, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, stateBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, states, gl.DYNAMIC_DRAW);
            const a_state = gl.getAttribLocation(program, 'a_state');
            gl.enableVertexAttribArray(a_state);
            gl.vertexAttribPointer(a_state, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvas.width, canvas.height);
            gl.uniform1f(gl.getUniformLocation(program, 'u_time'), globalTime);
            gl.uniform1i(gl.getUniformLocation(program, 'u_phase'), currentPhase === 'coherence' ? 0 : currentPhase === 'rupture' ? 1 : 2);
            
            gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);
        }
        
        // Animation loop
        function animate() {
            globalTime += 16.67;
            updateParticles(1.0);
            render();
            updateMetrics();
            checkAutoSequence();
            requestAnimationFrame(animate);
        }
        
        // Auto-demo sequence
        function checkAutoSequence() {
            if (userInteracted || autoSequenceStarted) return;
            
            const elapsed = Date.now() - startTime;
            
            // After 8 seconds, start auto sequence
            if (elapsed > 8000) {
                autoSequenceStarted = true;
                console.log('Starting physics auto-demo sequence...');
                
                // Trigger rupture
                setPhase('rupture');
                
                // Trigger rebirth a couple seconds later
                setTimeout(() => {
                    setPhase('rebirth');
                }, 2500);
            }
        }
        
        // UI Functions - attached to window for onclick access
        window.setPhase = function(phase) {
            currentPhase = phase;
            phaseTransitions++;
            
            // Mark that user has interacted (unless this is auto-sequence)
            if (!autoSequenceStarted) {
                userInteracted = true;
            }
            
            // Reset some particles for visual effect
            if (phase === 'coherence') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const offset = i * 12;
                    particles[offset + 4] = 0.1; // Reset coherence
                }
            }
        }
        
        function updateMetrics() {
            let totalCoherence = 0;
            let memoryValue = 0;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const offset = i * 12;
                totalCoherence += particles[offset + 4];
            }
            
            const avgCoherence = totalCoherence / PARTICLE_COUNT;
            memoryValue = avgCoherence * memoryStrength * 0.1;
            
            document.getElementById('coherenceMetric').textContent = `Coherence: ${avgCoherence.toFixed(3)}`;
            document.getElementById('particleMetric').textContent = `Particles: ${PARTICLE_COUNT}`;
            document.getElementById('memoryMetric').textContent = `Memory: ${memoryValue.toFixed(3)}`;
            document.getElementById('phaseMetric').textContent = `Phase transitions: ${phaseTransitions}`;
            document.getElementById('qualityMetric').textContent = `Reconstruction: ${(avgCoherence * fidelity * 0.5).toFixed(2)}`;
        }
        
        // Slider controls
        document.getElementById('memorySlider').addEventListener('input', (e) => {
            memoryStrength = parseFloat(e.target.value);
            document.getElementById('memoryValue').textContent = memoryStrength.toFixed(1);
            userInteracted = true;
        });
        
        document.getElementById('intensitySlider').addEventListener('input', (e) => {
            intensity = parseFloat(e.target.value);
            document.getElementById('intensityValue').textContent = intensity.toFixed(1);
            userInteracted = true;
        });
        
        document.getElementById('fidelitySlider').addEventListener('input', (e) => {
            fidelity = parseFloat(e.target.value);
            document.getElementById('fidelityValue').textContent = fidelity.toFixed(1);
            userInteracted = true;
        });

        // Sun logo click handler
        (function() {
            const sun = document.getElementById('crrSun');
            if (!sun) return;
            
            sun.addEventListener('click', function() {
                sun.classList.remove('erupting');
                void sun.offsetWidth;
                sun.classList.add('erupting');
                setTimeout(() => sun.classList.remove('erupting'), 800);
            });
        })();
        
        // Initialize
        gl.clearColor(0.545, 0.271, 0.075, 1.0); // Deep burnt orange
        gl.enable(gl.PROGRAM_POINT_SIZE);
        
        initializeCanvas();
        initializeParticles();
        animate();
        
        // Event handlers
        window.addEventListener('resize', () => {
            initializeCanvas();
            initializeParticles();
        });
        
        window.addEventListener('load', () => {
            setTimeout(initializeCanvas, 100);
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeCanvas, 50);
        });
    </script>
</body>
</html>
