<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Phase Dynamics — Proper Implementation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=IBM+Plex+Mono:wght@300;400&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #050508;
            min-height: 100vh;
            font-family: 'IBM Plex Mono', monospace;
            color: #a0a8b8;
            overflow: hidden;
        }
        
        .wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .header {
            position: absolute;
            top: 2.5rem;
            left: 3rem;
        }
        
        .header h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.2rem;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.02em;
        }
        
        .header .sub {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.35);
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-top: 0.3rem;
        }
        
        .header .equations {
            margin-top: 1rem;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.25);
            line-height: 1.6;
        }
        
        .header .equations .eq {
            font-family: 'Cormorant Garamond', serif;
            font-style: italic;
            color: rgba(255, 255, 255, 0.4);
        }
        
        .phase-display {
            position: absolute;
            top: 2.5rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .phase-name {
            font-family: 'Cormorant Garamond', serif;
            font-size: 3.5rem;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.85);
            transition: all 0.5s ease;
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }
        
        .phase-name.ice { color: #a8d4ff; text-shadow: 0 0 40px rgba(168, 212, 255, 0.3); }
        .phase-name.water { color: #4da6ff; text-shadow: 0 0 40px rgba(77, 166, 255, 0.3); }
        .phase-name.steam { color: #ffb366; text-shadow: 0 0 40px rgba(255, 179, 102, 0.3); }
        
        .omega-readout {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 0.5rem;
            font-family: 'Cormorant Garamond', serif;
        }
        
        .omega-readout span {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .metrics {
            position: absolute;
            top: 2.5rem;
            right: 3rem;
            text-align: right;
        }
        
        .metric {
            margin-bottom: 1rem;
        }
        
        .metric .value {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .metric .label {
            font-size: 0.55rem;
            color: rgba(255, 255, 255, 0.35);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }
        
        .crr-states {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 1rem;
        }
        
        .state-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 3px;
            font-size: 0.6rem;
            letter-spacing: 0.1em;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
        }
        
        .state-badge.c.active {
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(100, 200, 255, 0.4);
            color: #7dd3fc;
        }
        
        .state-badge.d.active {
            background: rgba(255, 100, 100, 0.15);
            border-color: rgba(255, 100, 100, 0.4);
            color: #fca5a5;
        }
        
        .state-badge.r.active {
            background: rgba(200, 100, 255, 0.15);
            border-color: rgba(200, 100, 255, 0.4);
            color: #d8b4fe;
        }
        
        .crr-graph {
            position: absolute;
            top: 12rem;
            right: 3rem;
            width: 200px;
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .crr-graph canvas {
            width: 100%;
            height: 100%;
        }
        
        .crr-graph .graph-label {
            position: absolute;
            bottom: -1.2rem;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.5rem;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .memory-indicator {
            position: absolute;
            top: 14.5rem;
            right: 3rem;
            width: 200px;
        }
        
        .memory-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .memory-fill {
            height: 100%;
            background: linear-gradient(90deg, #4da6ff, #d8b4fe);
            transition: width 0.3s;
        }
        
        .memory-label {
            font-size: 0.5rem;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            justify-content: space-between;
        }
        
        .controls {
            position: absolute;
            bottom: 2.5rem;
            left: 3rem;
            right: 3rem;
            display: flex;
            align-items: flex-end;
            gap: 3rem;
            pointer-events: auto;
        }
        
        .omega-control {
            flex: 1;
            max-width: 500px;
        }
        
        .omega-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }
        
        .omega-slider-wrap {
            position: relative;
            height: 8px;
            background: linear-gradient(90deg, 
                #a8d4ff 0%, 
                #4da6ff 35%, 
                #4da6ff 65%, 
                #ff8844 85%,
                #ff6633 100%
            );
            border-radius: 4px;
            overflow: visible;
        }
        
        .omega-slider-wrap::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(255,255,255,0.3) 0%,
                rgba(255,255,255,0) 20%,
                rgba(255,255,255,0) 80%,
                rgba(255,255,255,0.2) 100%
            );
            border-radius: 4px;
        }
        
        #omegaSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: transparent;
            cursor: pointer;
            position: relative;
        }
        
        #omegaSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4), 0 0 20px rgba(255,255,255,0.2);
            border: 3px solid rgba(0,0,0,0.2);
        }
        
        #omegaSlider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4), 0 0 20px rgba(255,255,255,0.2);
            border: 3px solid rgba(0,0,0,0.2);
        }
        
        .phase-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.55rem;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .other-controls {
            display: flex;
            gap: 1.5rem;
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .control-item label {
            font-size: 0.55rem;
            color: rgba(255, 255, 255, 0.35);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .control-item input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 3px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .hint {
            position: absolute;
            bottom: 7rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.2);
            letter-spacing: 0.1em;
        }
        
        .transition-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 5;
        }
        
        .transition-flash.melt {
            background: radial-gradient(circle, rgba(100, 180, 255, 0.3) 0%, transparent 70%);
        }
        
        .transition-flash.boil {
            background: radial-gradient(circle, rgba(255, 150, 100, 0.3) 0%, transparent 70%);
        }
        
        .transition-flash.rupture {
            background: radial-gradient(circle, rgba(255, 100, 150, 0.4) 0%, transparent 70%);
        }
        
        .transition-flash.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="wrapper">
        <canvas id="canvas"></canvas>
        
        <div class="transition-flash melt" id="meltFlash"></div>
        <div class="transition-flash boil" id="boilFlash"></div>
        <div class="transition-flash rupture" id="ruptureFlash"></div>
        
        <div class="ui">
            <div class="header">
                <h1>CRR Phases</h1>
                <div class="sub">Coherence · Rupture · Regeneration</div>
                <div class="equations">
                    <div><span class="eq">C(t) = ∫L(τ)dτ</span> — temporal integration</div>
                    <div><span class="eq">δ(now)</span> — rupture marker</div>
                    <div><span class="eq">R = ∫φ(τ)·exp(C/Ω)dτ</span> — memory-weighted regeneration</div>
                </div>
            </div>
            
            <div class="phase-display">
                <div class="phase-name" id="phaseName">WATER</div>
                <div class="omega-readout">Ω = <span id="omegaValue">0.50</span></div>
            </div>
            
            <div class="metrics">
                <div class="metric">
                    <div class="value" id="coherenceValue">0.00</div>
                    <div class="label">∫C(t) Integrated</div>
                </div>
                <div class="metric">
                    <div class="value" id="memoryDepthValue">0.00</div>
                    <div class="label">exp(C/Ω) Weight</div>
                </div>
                <div class="metric">
                    <div class="value" id="tempValue">20°</div>
                    <div class="label">Effective Temp</div>
                </div>
                <div class="crr-states">
                    <span class="state-badge c" id="stateC">C</span>
                    <span class="state-badge d" id="stateD">δ</span>
                    <span class="state-badge r" id="stateR">R</span>
                </div>
            </div>
            
            <div class="crr-graph">
                <canvas id="graphCanvas"></canvas>
                <div class="graph-label">C(t) over time — ruptures marked</div>
            </div>
            
            <div class="memory-indicator">
                <div class="memory-label">
                    <span>Memory Depth</span>
                    <span id="memoryPercent">50%</span>
                </div>
                <div class="memory-bar">
                    <div class="memory-fill" id="memoryFill" style="width: 50%"></div>
                </div>
            </div>
            
            <div class="hint">Click to induce rupture · Drag to stir · Ω controls memory depth</div>
            
            <div class="controls">
                <div class="omega-control">
                    <div class="omega-label">
                        <span>Thin Present (peaked memory)</span>
                        <span>Thick Present (full history)</span>
                    </div>
                    <div class="omega-slider-wrap">
                        <input type="range" id="omegaSlider" min="0.05" max="1.0" step="0.01" value="0.5">
                    </div>
                    <div class="phase-markers">
                        <span>Low Ω · Rigid</span>
                        <span>Mid Ω · Fluid</span>
                        <span>High Ω · Dissolved</span>
                    </div>
                </div>
                
                <div class="other-controls">
                    <div class="control-item">
                        <label>Flow</label>
                        <input type="range" id="flowSlider" min="0" max="3" step="0.1" value="1">
                    </div>
                    <div class="control-item">
                        <label>Gravity</label>
                        <input type="range" id="gravSlider" min="0" max="0.3" step="0.01" value="0.1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CRR MATHEMATICAL IMPLEMENTATION
        // ============================================
        // 
        // Core equations:
        // 1. C(x,t) = ∫L(x,τ)dτ  — Coherence as temporal integration
        // 2. δ(now)              — Dirac delta marking rupture/choice-points
        // 3. R = ∫φ(x,τ)·exp(C/Ω)·Θ(...)dτ — Regeneration with memory weighting
        //
        // Key insight: Ω controls "thickness of present"
        // - Low Ω: exp(C/Ω) varies dramatically → peaked selection (only high-C moments matter)
        // - High Ω: exp(C/Ω) ≈ 1 for all → flat weighting (full historical field accessible)
        //
        // This creates non-Markovian dynamics where past states influence present
        // based on their accumulated coherence, modulated by Ω.
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        
        let W, H, dpr;
        function resize() {
            dpr = window.devicePixelRatio || 1;
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Graph canvas
            graphCanvas.width = 200 * dpr;
            graphCanvas.height = 100 * dpr;
            graphCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        resize();
        window.addEventListener('resize', resize);
        
        // ============================================
        // CRR PARAMETERS
        // ============================================
        let omega = 0.5;          // Ω: controls memory depth / thickness of present
        let flowRate = 1;
        let gravity = 0.1;
        
        // Phase thresholds (visual mapping, but Ω is the real control)
        const ICE_THRESHOLD = 0.25;
        const STEAM_THRESHOLD = 0.75;
        
        // History parameters
        const MAX_HISTORY = 120;   // Temporal depth for integration
        const DT = 1/60;           // Time step
        
        // ============================================
        // CRR STATE
        // ============================================
        let globalCoherenceIntegral = 0;    // C(t) = ∫L(τ)dτ
        let coherenceHistory = [];           // L(τ) values over time
        let globalCoherenceHistory = [];     // For graph
        let ruptureMarkers = [];             // δ(now) events
        let currentPhase = 'water';
        let previousPhase = 'water';
        
        // CRR cycle detection
        let isCoherencePhase = false;
        let isRupturePhase = false;
        let isRegenerationPhase = false;
        let lastRuptureTime = 0;
        let previousCoherenceDerivative = 0;
        
        // Rupture threshold (when dC/dt drops below this, we rupture)
        const RUPTURE_THRESHOLD = -0.015;
        
        // ============================================
        // PARTICLE CLASS WITH CRR STATE
        // ============================================
        class Particle {
            constructor(x, y, vx = 0, vy = 0) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                
                // CRR state per particle
                this.localCoherence = 0;              // L(x,t) instantaneous
                this.coherenceHistory = [];           // L(x,τ) over time
                this.integratedCoherence = 0;         // C(x,t) = ∫L(x,τ)dτ
                
                // State history for regeneration: φ(x,τ)
                this.stateHistory = [];
                
                // Visual
                this.heat = 0;
            }
            
            // Calculate local order parameter L(x,t)
            // Based on alignment with neighbors
            calculateLocalCoherence(neighbors) {
                if (neighbors.length === 0) return 0;
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed < 0.01) return 0.5; // Stationary = neutral coherence
                
                let alignment = 0;
                for (const n of neighbors) {
                    const nSpeed = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
                    if (nSpeed < 0.01) continue;
                    
                    // Dot product of normalized velocities
                    const dot = (this.vx * n.vx + this.vy * n.vy) / (speed * nSpeed);
                    alignment += (dot + 1) / 2; // Map [-1,1] to [0,1]
                }
                
                return alignment / neighbors.length;
            }
            
            // Update CRR state
            updateCRR(neighbors, omega, isRupturing) {
                // Calculate instantaneous local coherence L(x,t)
                this.localCoherence = this.calculateLocalCoherence(neighbors);
                
                // Store in history
                this.coherenceHistory.push(this.localCoherence);
                if (this.coherenceHistory.length > MAX_HISTORY) {
                    this.coherenceHistory.shift();
                }
                
                // Integrate coherence: C(x,t) = ∫L(x,τ)dτ
                // Using exponential decay for numerical stability
                this.integratedCoherence = 0;
                for (let i = 0; i < this.coherenceHistory.length; i++) {
                    const age = this.coherenceHistory.length - 1 - i;
                    const decayWeight = Math.exp(-age * 0.02); // Soft decay
                    this.integratedCoherence += this.coherenceHistory[i] * decayWeight * DT;
                }
                
                // Store state for regeneration
                this.stateHistory.push({
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    vy: this.vy,
                    C: this.integratedCoherence
                });
                if (this.stateHistory.length > MAX_HISTORY) {
                    this.stateHistory.shift();
                }
                
                // If rupturing, mark discontinuity (partial reset)
                if (isRupturing) {
                    // δ(now) fires: partially reset coherence integral
                    // This creates the "choice-point" where past becomes future
                    this.integratedCoherence *= 0.3;
                }
            }
            
            // Regeneration: R = ∫φ(x,τ)·exp(C/Ω)·dτ
            // Returns influence vector from memory-weighted past states
            getRegenerationInfluence(omega) {
                if (this.stateHistory.length < 2) return { dvx: 0, dvy: 0 };
                
                let totalWeight = 0;
                let weightedVx = 0;
                let weightedVy = 0;
                
                for (let i = 0; i < this.stateHistory.length; i++) {
                    const pastState = this.stateHistory[i];
                    
                    // exp(C/Ω) — THE KEY CRR MEMORY AMPLIFICATION
                    // Large Ω: exp(C/Ω) ≈ 1 + C/Ω for all values → flat weighting
                    // Small Ω: exp(C/Ω) varies dramatically → peaked at high C
                    const memoryWeight = Math.exp(pastState.C / omega);
                    
                    // Temporal decay (more recent = stronger)
                    const age = this.stateHistory.length - 1 - i;
                    const temporalWeight = Math.exp(-age * 0.03);
                    
                    const weight = memoryWeight * temporalWeight;
                    
                    weightedVx += pastState.vx * weight;
                    weightedVy += pastState.vy * weight;
                    totalWeight += weight;
                }
                
                if (totalWeight > 0) {
                    // Influence toward memory-weighted average
                    const targetVx = weightedVx / totalWeight;
                    const targetVy = weightedVy / totalWeight;
                    
                    return {
                        dvx: (targetVx - this.vx) * 0.05,
                        dvy: (targetVy - this.vy) * 0.05
                    };
                }
                
                return { dvx: 0, dvy: 0 };
            }
        }
        
        // ============================================
        // PARTICLE SYSTEMS
        // ============================================
        let particles = [];
        const MAX_PARTICLES = 1200;
        
        let steamParticles = [];
        const MAX_STEAM = 200;
        
        let bubbles = [];
        const MAX_BUBBLES = 50;
        
        let iceGrid = [];
        let iceConnections = [];
        
        let mouse = { x: W/2, y: H/2, down: false, px: W/2, py: H/2 };
        
        const GRID_SCALE = 5;
        let gridW, gridH;
        let densityField;
        
        // Spatial hash for neighbor queries
        const CELL_SIZE = 30;
        let spatialHash = new Map();
        
        class SteamParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = -1 - Math.random() * 2;
                this.life = 1;
                this.size = 3 + Math.random() * 8;
                this.wiggle = Math.random() * Math.PI * 2;
            }
        }
        
        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vy = -0.5 - Math.random() * 1.5;
                this.size = 3 + Math.random() * 12;
                this.wobble = Math.random() * Math.PI * 2;
                this.life = 1;
            }
        }
        
        function init() {
            gridW = Math.ceil(W / GRID_SCALE);
            gridH = Math.ceil(H / GRID_SCALE);
            densityField = new Float32Array(gridW * gridH);
            
            particles = [];
            steamParticles = [];
            bubbles = [];
            
            const spacing = 14;
            for (let x = spacing; x < W - spacing; x += spacing) {
                for (let y = H * 0.3; y < H - spacing; y += spacing) {
                    if (particles.length < MAX_PARTICLES) {
                        const p = new Particle(
                            x + (Math.random() - 0.5) * 4,
                            y + (Math.random() - 0.5) * 4
                        );
                        particles.push(p);
                    }
                }
            }
            
            buildIceGrid();
        }
        
        function buildIceGrid() {
            iceGrid = [];
            iceConnections = [];
            
            const spacing = 18;
            const rows = Math.ceil(H / (spacing * 0.866));
            const cols = Math.ceil(W / spacing);
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * spacing + (row % 2) * spacing * 0.5;
                    const y = row * spacing * 0.866 + H * 0.3;
                    
                    if (y < H - 20) {
                        iceGrid.push({ x, y, offsetX: 0, offsetY: 0 });
                    }
                }
            }
            
            for (let i = 0; i < iceGrid.length; i++) {
                for (let j = i + 1; j < iceGrid.length; j++) {
                    const dx = iceGrid[j].x - iceGrid[i].x;
                    const dy = iceGrid[j].y - iceGrid[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < spacing * 1.2) {
                        iceConnections.push([i, j]);
                    }
                }
            }
        }
        
        // Spatial hashing for efficient neighbor queries
        function updateSpatialHash() {
            spatialHash.clear();
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const cellX = Math.floor(p.x / CELL_SIZE);
                const cellY = Math.floor(p.y / CELL_SIZE);
                const key = `${cellX},${cellY}`;
                
                if (!spatialHash.has(key)) {
                    spatialHash.set(key, []);
                }
                spatialHash.get(key).push(i);
            }
        }
        
        function getNeighbors(particle, radius = CELL_SIZE) {
            const neighbors = [];
            const cellX = Math.floor(particle.x / CELL_SIZE);
            const cellY = Math.floor(particle.y / CELL_SIZE);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${cellX + dx},${cellY + dy}`;
                    const cell = spatialHash.get(key);
                    if (cell) {
                        for (const idx of cell) {
                            const other = particles[idx];
                            if (other === particle) continue;
                            
                            const distX = other.x - particle.x;
                            const distY = other.y - particle.y;
                            if (distX * distX + distY * distY < radius * radius) {
                                neighbors.push(other);
                            }
                        }
                    }
                }
            }
            return neighbors;
        }
        
        function getPhase() {
            if (omega < ICE_THRESHOLD) return 'ice';
            if (omega > STEAM_THRESHOLD) return 'steam';
            return 'water';
        }
        
        // ============================================
        // GLOBAL CRR CALCULATION
        // ============================================
        function calculateGlobalCRR() {
            // Calculate global coherence as average of local coherences
            let totalL = 0;
            for (const p of particles) {
                totalL += p.localCoherence;
            }
            const instantL = particles.length > 0 ? totalL / particles.length : 0;
            
            // Store in history
            coherenceHistory.push(instantL);
            if (coherenceHistory.length > MAX_HISTORY) {
                coherenceHistory.shift();
            }
            
            // Integrate global coherence: C(t) = ∫L(τ)dτ
            globalCoherenceIntegral = 0;
            for (let i = 0; i < coherenceHistory.length; i++) {
                const age = coherenceHistory.length - 1 - i;
                const decayWeight = Math.exp(-age * 0.015);
                globalCoherenceIntegral += coherenceHistory[i] * decayWeight * DT;
            }
            
            // Store for graph
            globalCoherenceHistory.push({
                C: globalCoherenceIntegral,
                L: instantL,
                t: Date.now()
            });
            if (globalCoherenceHistory.length > 200) {
                globalCoherenceHistory.shift();
            }
            
            // ============================================
            // RUPTURE DETECTION: δ(now)
            // ============================================
            // Rupture occurs when coherence derivative crosses threshold
            // This is the Dirac delta marking the "now" choice-point
            
            if (coherenceHistory.length >= 10) {
                const recent = coherenceHistory.slice(-5);
                const older = coherenceHistory.slice(-10, -5);
                
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                
                const derivative = (recentAvg - olderAvg) / (5 * DT);
                
                // Detect rupture: sharp negative derivative
                const wasRupturing = isRupturePhase;
                
                if (derivative < RUPTURE_THRESHOLD && previousCoherenceDerivative >= RUPTURE_THRESHOLD) {
                    // δ(now) fires!
                    isRupturePhase = true;
                    lastRuptureTime = Date.now();
                    ruptureMarkers.push(globalCoherenceHistory.length - 1);
                    
                    // Visual feedback
                    const flash = document.getElementById('ruptureFlash');
                    flash.classList.add('active');
                    setTimeout(() => flash.classList.remove('active'), 200);
                }
                
                previousCoherenceDerivative = derivative;
                
                // Rupture phase lasts briefly
                if (isRupturePhase && Date.now() - lastRuptureTime > 300) {
                    isRupturePhase = false;
                }
                
                // Regeneration phase follows rupture
                isRegenerationPhase = !isRupturePhase && (Date.now() - lastRuptureTime < 2000);
                
                // Coherence phase when stable and building
                isCoherencePhase = !isRupturePhase && !isRegenerationPhase && derivative > 0;
            }
        }
        
        // ============================================
        // MAIN UPDATE LOOP
        // ============================================
        function updateParticles() {
            const phase = getPhase();
            
            // Detect phase transition (also triggers rupture)
            if (phase !== previousPhase) {
                triggerPhaseTransition(previousPhase, phase);
                previousPhase = phase;
            }
            
            currentPhase = phase;
            
            // Update spatial hash for neighbor queries
            updateSpatialHash();
            
            // Update CRR state for each particle
            for (const p of particles) {
                const neighbors = getNeighbors(p);
                p.updateCRR(neighbors, omega, isRupturePhase);
            }
            
            // Calculate global CRR metrics
            calculateGlobalCRR();
            
            // Phase-specific physics with CRR influence
            if (phase === 'ice') {
                updateIce();
            } else if (phase === 'steam') {
                updateSteam();
            } else {
                updateWater();
            }
        }
        
        function updateIce() {
            const freezeStrength = 1 - (omega / ICE_THRESHOLD);
            
            for (const p of particles) {
                // Find nearest lattice point
                let nearestDist = Infinity;
                let nearestPoint = null;
                
                for (const point of iceGrid) {
                    const dx = point.x - p.x;
                    const dy = point.y - p.y;
                    const dist = dx * dx + dy * dy;
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestPoint = point;
                    }
                }
                
                if (nearestPoint && nearestDist < 900) {
                    const pullStrength = 0.1 * freezeStrength;
                    p.vx += (nearestPoint.x - p.x) * pullStrength;
                    p.vy += (nearestPoint.y - p.y) * pullStrength;
                    
                    // CRR regeneration influence (memory of past motion)
                    // At low Ω, this is peaked → strong attractor to lattice
                    const regen = p.getRegenerationInfluence(omega);
                    p.vx += regen.dvx * 0.2;
                    p.vy += regen.dvy * 0.2;
                    
                    p.vx *= 0.85;
                    p.vy *= 0.85;
                }
                
                p.vy += gravity * 0.1;
                
                p.x += p.vx * 0.5;
                p.y += p.vy * 0.5;
                
                // Boundaries
                if (p.y > H - 10) { p.y = H - 10; p.vy *= -0.3; }
                if (p.y < 10) { p.y = 10; p.vy *= -0.3; }
                if (p.x < 10) { p.x = 10; p.vx *= -0.3; }
                if (p.x > W - 10) { p.x = W - 10; p.vx *= -0.3; }
            }
            
            // Crystalline vibration
            const time = Date.now() * 0.002;
            for (const point of iceGrid) {
                point.offsetX = Math.sin(time + point.x * 0.05) * 0.5;
                point.offsetY = Math.cos(time + point.y * 0.05) * 0.5;
            }
        }
        
        function updateWater() {
            // Viscosity modulated by Ω
            // Higher Ω = more fluid (dissolved boundaries)
            const visc = 0.2 * (1 - omega * 0.6);
            
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const neighbors = getNeighbors(p, 20);
                
                // Gravity
                p.vy += gravity;
                
                // Flow
                p.vx += flowRate * 0.02;
                
                // CRR Regeneration Influence
                // This is where non-Markovian dynamics emerge:
                // High Ω → flat memory weighting → behavior influenced by full history
                // Low Ω → peaked memory → behavior dominated by high-coherence moments
                const regen = p.getRegenerationInfluence(omega);
                
                // Regeneration strength scales with how "thick" the present is
                const regenStrength = isRegenerationPhase ? 0.15 : 0.05;
                p.vx += regen.dvx * regenStrength;
                p.vy += regen.dvy * regenStrength;
                
                // Particle interactions
                for (const q of neighbors) {
                    const dx = q.x - p.x;
                    const dy = q.y - p.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = 14;
                    
                    if (distSq < minDist * minDist && distSq > 0.1) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        
                        // Pressure
                        const repel = overlap * 0.08;
                        p.vx -= nx * repel;
                        p.vy -= ny * repel;
                        
                        // Viscosity
                        const avgVx = (p.vx + q.vx) * 0.5;
                        const avgVy = (p.vy + q.vy) * 0.5;
                        p.vx += (avgVx - p.vx) * visc;
                        p.vy += (avgVy - p.vy) * visc;
                    }
                }
                
                // Mouse interaction (can induce rupture)
                if (mouse.down) {
                    const dx = p.x - mouse.x;
                    const dy = p.y - mouse.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 80 && dist > 1) {
                        const mvx = mouse.x - mouse.px;
                        const mvy = mouse.y - mouse.py;
                        const factor = (1 - dist / 80) * 0.4;
                        p.vx += mvx * factor;
                        p.vy += mvy * factor;
                    }
                }
                
                // Damping
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                // Speed limit
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                if (speed > 6) {
                    p.vx = (p.vx / speed) * 6;
                    p.vy = (p.vy / speed) * 6;
                }
                
                // Integrate
                p.x += p.vx;
                p.y += p.vy;
                
                // Boundaries
                if (p.y > H - 10) { p.y = H - 10; p.vy *= -0.4; }
                if (p.y < H * 0.1) { p.y = H * 0.1; p.vy *= -0.4; }
                if (p.x < 10) { p.x = W - 10; }
                if (p.x > W - 10) { p.x = 10; }
            }
        }
        
        function updateSteam() {
            const boilIntensity = (omega - STEAM_THRESHOLD) / (1 - STEAM_THRESHOLD);
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                // Chaotic thermal motion
                p.vx += (Math.random() - 0.5) * boilIntensity * 1.5;
                p.vy += (Math.random() - 0.5) * boilIntensity * 1.5;
                
                // CRR at high Ω: full historical field accessible
                // Particles can "remember" their entire trajectory
                const regen = p.getRegenerationInfluence(omega);
                p.vx += regen.dvx * 0.1;
                p.vy += regen.dvy * 0.1;
                
                // Upward convection
                p.vy -= gravity * boilIntensity * 0.8;
                p.vy += gravity * 0.5;
                
                p.vx *= 0.95;
                p.vy *= 0.95;
                
                p.x += p.vx;
                p.y += p.vy;
                
                // Evaporate particles at surface
                if (p.y < H * 0.35 && Math.random() < boilIntensity * 0.05) {
                    steamParticles.push(new SteamParticle(p.x, p.y));
                    particles.splice(i, 1);
                    continue;
                }
                
                if (p.y > H - 10) { p.y = H - 10; p.vy *= -0.5; }
                if (p.x < 10) p.x = W - 10;
                if (p.x > W - 10) p.x = 10;
            }
            
            // Spawn bubbles
            if (bubbles.length < MAX_BUBBLES && Math.random() < boilIntensity * 0.3) {
                bubbles.push(new Bubble(
                    Math.random() * W,
                    H - 20 - Math.random() * 100
                ));
            }
            
            // Update bubbles
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.y += b.vy * (1 + boilIntensity);
                b.wobble += 0.1;
                b.x += Math.sin(b.wobble) * 0.5;
                
                if (b.y < H * 0.35) {
                    for (let j = 0; j < 3; j++) {
                        if (steamParticles.length < MAX_STEAM) {
                            steamParticles.push(new SteamParticle(b.x, b.y));
                        }
                    }
                    bubbles.splice(i, 1);
                }
            }
            
            // Update steam
            for (let i = steamParticles.length - 1; i >= 0; i--) {
                const s = steamParticles[i];
                s.vy -= 0.02;
                s.wiggle += 0.05;
                s.x += Math.sin(s.wiggle) * 0.3;
                s.x += s.vx;
                s.y += s.vy;
                s.life -= 0.008;
                
                if (s.life <= 0 || s.y < -50) {
                    steamParticles.splice(i, 1);
                }
            }
            
            // Replenish water
            if (particles.length < MAX_PARTICLES * 0.7) {
                for (let i = 0; i < 3; i++) {
                    particles.push(new Particle(
                        Math.random() * W,
                        H - 20 - Math.random() * 50
                    ));
                }
            }
        }
        
        function triggerPhaseTransition(from, to) {
            // Phase transition IS a rupture event
            isRupturePhase = true;
            lastRuptureTime = Date.now();
            ruptureMarkers.push(globalCoherenceHistory.length - 1);
            
            if (to === 'water' && from === 'ice') {
                const flash = document.getElementById('meltFlash');
                flash.classList.add('active');
                setTimeout(() => flash.classList.remove('active'), 300);
            } else if (to === 'steam') {
                const flash = document.getElementById('boilFlash');
                flash.classList.add('active');
                setTimeout(() => flash.classList.remove('active'), 300);
            }
        }
        
        // ============================================
        // RENDERING
        // ============================================
        function buildDensityField() {
            densityField.fill(0);
            
            const radius = 25 / GRID_SCALE;
            const radiusSq = radius * radius;
            
            for (const p of particles) {
                const gx = Math.floor(p.x / GRID_SCALE);
                const gy = Math.floor(p.y / GRID_SCALE);
                
                const r = Math.ceil(radius);
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        const nx = gx + dx;
                        const ny = gy + dy;
                        
                        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                            const distSq = dx * dx + dy * dy;
                            if (distSq < radiusSq) {
                                const w = Math.pow(1 - distSq / radiusSq, 2);
                                densityField[ny * gridW + nx] += w;
                            }
                        }
                    }
                }
            }
        }
        
        function render() {
            // Background
            let bgGrad;
            if (currentPhase === 'ice') {
                bgGrad = ctx.createLinearGradient(0, 0, 0, H);
                bgGrad.addColorStop(0, '#0a1525');
                bgGrad.addColorStop(0.5, '#0d1a2d');
                bgGrad.addColorStop(1, '#0a1220');
            } else if (currentPhase === 'steam') {
                bgGrad = ctx.createLinearGradient(0, 0, 0, H);
                bgGrad.addColorStop(0, '#1a1008');
                bgGrad.addColorStop(0.5, '#201510');
                bgGrad.addColorStop(1, '#150a05');
            } else {
                bgGrad = ctx.createLinearGradient(0, 0, 0, H);
                bgGrad.addColorStop(0, '#080c15');
                bgGrad.addColorStop(0.5, '#0a1020');
                bgGrad.addColorStop(1, '#060a12');
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);
            
            buildDensityField();
            
            if (currentPhase === 'ice') {
                renderIce();
            } else if (currentPhase === 'steam') {
                renderSteam();
            } else {
                renderWater();
            }
            
            // Render CRR graph
            renderGraph();
        }
        
        function renderIce() {
            const imageData = ctx.createImageData(gridW, gridH);
            const data = imageData.data;
            
            const threshold = 0.4;
            
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const idx = y * gridW + x;
                    const density = densityField[idx];
                    const pixelIdx = idx * 4;
                    
                    if (density > threshold) {
                        const depth = Math.min(1, (density - threshold) / 2);
                        
                        let r = 150 + depth * 80;
                        let g = 200 + depth * 40;
                        let b = 255;
                        
                        const edge = Math.min(1, (density - threshold) / 0.3);
                        if (edge < 0.3) {
                            const h = (0.3 - edge) / 0.3;
                            r += h * 50;
                            g += h * 30;
                        }
                        
                        const a = 180 + depth * 50;
                        
                        data[pixelIdx] = Math.min(255, r);
                        data[pixelIdx + 1] = Math.min(255, g);
                        data[pixelIdx + 2] = Math.min(255, b);
                        data[pixelIdx + 3] = Math.min(255, a);
                    }
                }
            }
            
            const offscreen = document.createElement('canvas');
            offscreen.width = gridW;
            offscreen.height = gridH;
            const offCtx = offscreen.getContext('2d');
            offCtx.putImageData(imageData, 0, 0);
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(offscreen, 0, 0, gridW, gridH, 0, 0, W, H);
            
            // Crystalline overlay
            ctx.globalCompositeOperation = 'screen';
            const time = Date.now() * 0.0005;
            
            for (let i = 0; i < 8; i++) {
                const cx = W * (0.1 + i * 0.1);
                const cy = H * 0.5 + Math.sin(time + i) * 50;
                
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 80);
                grad.addColorStop(0, 'rgba(200, 230, 255, 0.08)');
                grad.addColorStop(1, 'transparent');
                
                ctx.fillStyle = grad;
                ctx.fillRect(cx - 80, cy - 80, 160, 160);
            }
            
            ctx.globalCompositeOperation = 'source-over';
        }
        
        function renderWater() {
            const imageData = ctx.createImageData(gridW, gridH);
            const data = imageData.data;
            
            const threshold = 0.5;
            
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const idx = y * gridW + x;
                    const density = densityField[idx];
                    const pixelIdx = idx * 4;
                    
                    if (density > threshold) {
                        const depth = Math.min(1, (density - threshold) / 2);
                        const edge = Math.min(1, (density - threshold) / 0.3);
                        
                        let r = 30 + depth * 60;
                        let g = 80 + depth * 100;
                        let b = 180 + depth * 60;
                        
                        if (edge < 0.3) {
                            const h = (0.3 - edge) / 0.3;
                            r += h * 80;
                            g += h * 120;
                            b += h * 60;
                        }
                        
                        const a = 160 + depth * 70;
                        
                        data[pixelIdx] = Math.min(255, r);
                        data[pixelIdx + 1] = Math.min(255, g);
                        data[pixelIdx + 2] = Math.min(255, b);
                        data[pixelIdx + 3] = Math.min(255, a);
                    }
                }
            }
            
            const offscreen = document.createElement('canvas');
            offscreen.width = gridW;
            offscreen.height = gridH;
            const offCtx = offscreen.getContext('2d');
            offCtx.putImageData(imageData, 0, 0);
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(offscreen, 0, 0, gridW, gridH, 0, 0, W, H);
            
            // Caustics
            renderCaustics();
        }
        
        function renderCaustics() {
            const time = Date.now() * 0.001;
            ctx.globalCompositeOperation = 'screen';
            
            for (let i = 0; i < 12; i++) {
                const x = (Math.sin(time * 0.5 + i * 0.6) * 0.35 + 0.5) * W;
                const y = (Math.cos(time * 0.3 + i * 0.9) * 0.25 + 0.6) * H;
                
                const gx = Math.floor(x / GRID_SCALE);
                const gy = Math.floor(y / GRID_SCALE);
                
                if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
                    if (densityField[gy * gridW + gx] > 0.8) {
                        const size = 40 + Math.sin(time + i) * 15;
                        const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                        grad.addColorStop(0, 'rgba(150, 200, 255, 0.06)');
                        grad.addColorStop(1, 'transparent');
                        
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fillStyle = grad;
                        ctx.fill();
                    }
                }
            }
            
            ctx.globalCompositeOperation = 'source-over';
        }
        
        function renderSteam() {
            const imageData = ctx.createImageData(gridW, gridH);
            const data = imageData.data;
            
            const threshold = 0.5;
            const boilIntensity = (omega - STEAM_THRESHOLD) / (1 - STEAM_THRESHOLD);
            
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const idx = y * gridW + x;
                    const density = densityField[idx];
                    const pixelIdx = idx * 4;
                    
                    if (density > threshold) {
                        const depth = Math.min(1, (density - threshold) / 2);
                        const edge = Math.min(1, (density - threshold) / 0.3);
                        
                        let r = 80 + depth * 100 + boilIntensity * 60;
                        let g = 90 + depth * 70;
                        let b = 140 + depth * 40;
                        
                        if (edge < 0.3) {
                            const h = (0.3 - edge) / 0.3;
                            r += h * 150;
                            g += h * 80;
                            b += h * 40;
                        }
                        
                        const a = 160 + depth * 60;
                        
                        data[pixelIdx] = Math.min(255, r);
                        data[pixelIdx + 1] = Math.min(255, g);
                        data[pixelIdx + 2] = Math.min(255, b);
                        data[pixelIdx + 3] = Math.min(255, a);
                    }
                }
            }
            
            const offscreen = document.createElement('canvas');
            offscreen.width = gridW;
            offscreen.height = gridH;
            const offCtx = offscreen.getContext('2d');
            offCtx.putImageData(imageData, 0, 0);
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(offscreen, 0, 0, gridW, gridH, 0, 0, W, H);
            
            // Render bubbles
            for (const b of bubbles) {
                const grad = ctx.createRadialGradient(
                    b.x - b.size * 0.2, b.y - b.size * 0.2, 0,
                    b.x, b.y, b.size
                );
                grad.addColorStop(0, 'rgba(255, 200, 150, 0.4)');
                grad.addColorStop(0.5, 'rgba(255, 150, 100, 0.2)');
                grad.addColorStop(1, 'rgba(255, 100, 50, 0.05)');
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 180, 130, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Render steam particles
            ctx.globalCompositeOperation = 'screen';
            
            for (const s of steamParticles) {
                const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size);
                grad.addColorStop(0, `rgba(255, 240, 230, ${s.life * 0.3})`);
                grad.addColorStop(0.5, `rgba(200, 180, 170, ${s.life * 0.15})`);
                grad.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            }
            
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // ============================================
        // CRR GRAPH
        // ============================================
        function renderGraph() {
            const gW = 200;
            const gH = 100;
            
            graphCtx.clearRect(0, 0, gW, gH);
            
            // Background
            graphCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            graphCtx.fillRect(0, 0, gW, gH);
            
            if (globalCoherenceHistory.length < 2) return;
            
            // Find max for scaling
            let maxC = 0.1;
            for (const h of globalCoherenceHistory) {
                if (h.C > maxC) maxC = h.C;
            }
            
            // Draw coherence line
            graphCtx.beginPath();
            graphCtx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            graphCtx.lineWidth = 1.5;
            
            for (let i = 0; i < globalCoherenceHistory.length; i++) {
                const x = (i / globalCoherenceHistory.length) * gW;
                const y = gH - (globalCoherenceHistory[i].C / maxC) * gH * 0.9;
                
                if (i === 0) {
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
            }
            graphCtx.stroke();
            
            // Draw rupture markers (δ events)
            graphCtx.fillStyle = 'rgba(255, 100, 100, 0.8)';
            for (const marker of ruptureMarkers) {
                if (marker < globalCoherenceHistory.length) {
                    const x = (marker / globalCoherenceHistory.length) * gW;
                    graphCtx.beginPath();
                    graphCtx.arc(x, 10, 3, 0, Math.PI * 2);
                    graphCtx.fill();
                    
                    // Vertical line
                    graphCtx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                    graphCtx.lineWidth = 1;
                    graphCtx.beginPath();
                    graphCtx.moveTo(x, 0);
                    graphCtx.lineTo(x, gH);
                    graphCtx.stroke();
                }
            }
            
            // Clean up old markers
            while (ruptureMarkers.length > 20) {
                ruptureMarkers.shift();
            }
        }
        
        // ============================================
        // UI UPDATE
        // ============================================
        function updateUI() {
            const phaseEl = document.getElementById('phaseName');
            phaseEl.textContent = currentPhase.toUpperCase();
            phaseEl.className = 'phase-name ' + currentPhase;
            
            document.getElementById('omegaValue').textContent = omega.toFixed(2);
            document.getElementById('coherenceValue').textContent = globalCoherenceIntegral.toFixed(2);
            
            // Calculate exp(C/Ω) average for display
            const expWeight = Math.exp(globalCoherenceIntegral / omega);
            document.getElementById('memoryDepthValue').textContent = expWeight.toFixed(2);
            
            // Effective temperature
            const temp = Math.round(-20 + omega * 140);
            document.getElementById('tempValue').textContent = temp + '°';
            
            // Memory depth indicator
            // At low Ω, memory is peaked; at high Ω, memory is flat (full access)
            const memoryDepth = Math.min(100, omega * 100);
            document.getElementById('memoryPercent').textContent = Math.round(memoryDepth) + '%';
            document.getElementById('memoryFill').style.width = memoryDepth + '%';
            
            // CRR states
            document.getElementById('stateC').classList.toggle('active', isCoherencePhase);
            document.getElementById('stateD').classList.toggle('active', isRupturePhase);
            document.getElementById('stateR').classList.toggle('active', isRegenerationPhase);
        }
        
        // ============================================
        // CONTROLS
        // ============================================
        document.getElementById('omegaSlider').addEventListener('input', e => {
            omega = parseFloat(e.target.value);
        });
        
        document.getElementById('flowSlider').addEventListener('input', e => {
            flowRate = parseFloat(e.target.value);
        });
        
        document.getElementById('gravSlider').addEventListener('input', e => {
            gravity = parseFloat(e.target.value);
        });
        
        // Mouse - click induces rupture
        canvas.addEventListener('mousedown', e => {
            mouse.down = true;
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.px = mouse.x;
            mouse.py = mouse.y;
            
            // Click induces local rupture
            isRupturePhase = true;
            lastRuptureTime = Date.now();
            ruptureMarkers.push(globalCoherenceHistory.length - 1);
            
            const flash = document.getElementById('ruptureFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 150);
        });
        
        canvas.addEventListener('mousemove', e => {
            mouse.px = mouse.x;
            mouse.py = mouse.y;
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => mouse.down = false);
        canvas.addEventListener('mouseleave', () => mouse.down = false);
        
        // Touch
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            mouse.down = true;
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            mouse.px = mouse.x;
            mouse.py = mouse.y;
            
            isRupturePhase = true;
            lastRuptureTime = Date.now();
            ruptureMarkers.push(globalCoherenceHistory.length - 1);
        });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            mouse.px = mouse.x;
            mouse.py = mouse.y;
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        });
        
        canvas.addEventListener('touchend', () => mouse.down = false);
        
        // ============================================
        // ANIMATION LOOP
        // ============================================
        function loop() {
            updateParticles();
            render();
            updateUI();
            requestAnimationFrame(loop);
        }
        
        init();
        loop();
    </script>
</body>
</html>
