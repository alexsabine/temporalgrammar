<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Fish Scale Iridescence - Seamless Coverage</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fafafa;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
        }
        
        .demo-area {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .controls-area {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        h1 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 24px;
        }
        
        h2 {
            color: #34495e;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .crr-explanation {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .equation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }
        
        #canvas {
            width: 500px;
            height: 500px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
            margin: 20px auto;
        }
        
        .slider-group {
            margin-bottom: 20px;
        }
        
        .slider-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }
        
        .slider {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .slider-value {
            font-family: monospace;
            color: #666;
            font-size: 12px;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        
        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }
        
        .status {
            padding: 12px;
            background: #e8f4f8;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        
        .parameter-section {
            border-top: 1px solid #eee;
            padding-top: 15px;
            margin-top: 15px;
        }
        
        .mouse-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #95a5a6;
        }
        
        .memory-indicator {
            color: #27ae60;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="demo-area">
            <h1>CRR Fish Scale Iridescence</h1>
            
            <div class="crr-explanation">
                <strong>Seamless Scale Coverage with Non-Markovian Memory</strong><br>
                Complete canvas coverage with uniformly spaced semi-circular scales. Memory creates coherent temporal patterns:
                
                <div class="equation">
                    <strong>Coherence Integration:</strong> C(x) = ∫ L(x,τ) dτ
                </div>
                <div class="equation">
                    <strong>Memory Dynamics:</strong> m<sub>t</sub> = (1-λ)m<sub>t-1</sub> + λU<sub>t</sub>
                </div>
                <div class="equation">
                    <strong>Regeneration:</strong> R[χ] = ∫ φ(x,τ)·e^(C(x)/Ω)·Θ(t-τ) dτ
                </div>
                
                <span class="memory-indicator">Complete seamless coverage</span> with memory-coherent iridescence across all scales.
            </div>
            
            <canvas id="canvas" width="512" height="512"></canvas>
            
            <div class="mouse-info">
                Move mouse to observe viewing angle iridescence effects.
                Click and drag to create memory ruptures that propagate through the field.
            </div>
        </div>
        
        <div class="controls-area">
            <h2>CRR Memory Parameters</h2>
            
            <div class="status" id="status">
                Memory System: ACTIVE | Coverage: SEAMLESS | View: 0°
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="reset()">Reset Memory Field</button>
            </div>
            
            <div class="slider-group">
                <label class="slider-label">Memory Rate (λ)</label>
                <input type="range" class="slider" id="lambda" min="0.008" max="0.06" step="0.002" value="0.028">
                <div class="slider-value" id="lambda-value">0.028</div>
            </div>
            
            <div class="slider-group">
                <label class="slider-label">Memory Coupling (β)</label>
                <input type="range" class="slider" id="beta" min="0.08" max="0.35" step="0.01" value="0.20">
                <div class="slider-value" id="beta-value">0.20</div>
            </div>
            
            <div class="slider-group">
                <label class="slider-label">Rupture Sensitivity</label>
                <input type="range" class="slider" id="rupture" min="0.4" max="1.5" step="0.1" value="0.8">
                <div class="slider-value" id="rupture-value">0.8</div>
            </div>
            
            <div class="parameter-section">
                <h2>Scale Properties</h2>
                
                <div class="slider-group">
                    <label class="slider-label">Scale Density</label>
                    <input type="range" class="slider" id="scales" min="8" max="16" step="1" value="12">
                    <div class="slider-value" id="scales-value">12</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Surface Imperfection</label>
                    <input type="range" class="slider" id="imperfection" min="0.005" max="0.08" step="0.005" value="0.025">
                    <div class="slider-value" id="imperfection-value">0.025</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Ridge Detail</label>
                    <input type="range" class="slider" id="ridge-detail" min="4" max="12" step="1" value="8">
                    <div class="slider-value" id="ridge-detail-value">8</div>
                </div>
            </div>
            
            <div class="parameter-section">
                <h2>Optical Effects</h2>
                
                <div class="slider-group">
                    <label class="slider-label">Iridescence Strength</label>
                    <input type="range" class="slider" id="interference" min="1.0" max="2.8" step="0.1" value="1.8">
                    <div class="slider-value" id="interference-value">1.8</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Evolution Speed</label>
                    <input type="range" class="slider" id="phase-speed" min="0.02" max="0.12" step="0.01" value="0.07">
                    <div class="slider-value" id="phase-speed-value">0.07</div>
                </div>
            </div>
            
            <div class="parameter-section">
                <h2>Substrate Dynamics</h2>
                
                <div class="slider-group">
                    <label class="slider-label">Feed Rate</label>
                    <input type="range" class="slider" id="feed" min="0.025" max="0.065" step="0.002" value="0.040">
                    <div class="slider-value" id="feed-value">0.040</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Kill Rate</label>
                    <input type="range" class="slider" id="kill" min="0.045" max="0.08" step="0.002" value="0.064">
                    <div class="slider-value" id="kill-value">0.064</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL2 not supported');
        }
        
        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = (a_position + 1.0) * 0.5;
            }
        `;
        
        // Main rendering shader
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 fragColor;
            
            uniform sampler2D u_texture;
            uniform sampler2D u_memory;
            uniform float u_time;
            uniform vec2 u_mouse;
            uniform float u_interference;
            uniform float u_scales;
            uniform float u_phaseSpeed;
            uniform float u_ridgeDetail;
            uniform float u_imperfection;
            
            // Hash functions
            float hash21(vec2 p) {
                p = fract(p * vec2(233.34, 851.73));
                p += dot(p, p + 23.45);
                return fract(p.x * p.y);
            }
            
            vec2 hash22(vec2 p) {
                p = fract(p * vec2(233.34, 851.73));
                p += dot(p, p + 23.45);
                return fract(vec2(p.x * p.y, p.x + p.y));
            }
            
            // Smooth noise
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = hash21(i);
                float b = hash21(i + vec2(1.0, 0.0));
                float c = hash21(i + vec2(0.0, 1.0));
                float d = hash21(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            // Calculate seamless scale coverage
            vec3 calculateSeamlessScales(vec2 coord) {
                // Create overlapping grid that ensures full coverage
                vec2 grid = coord * u_scales;
                
                vec3 finalColor = vec3(0.0);
                float totalWeight = 0.0;
                
                // Sample multiple overlapping layers to ensure no gaps
                for (int offsetY = -1; offsetY <= 1; offsetY++) {
                    for (int offsetX = -1; offsetX <= 1; offsetX++) {
                        vec2 sampleGrid = grid + vec2(float(offsetX), float(offsetY));
                        vec2 gridId = floor(sampleGrid);
                        vec2 gridUv = fract(sampleGrid) - 0.5;
                        
                        // Hexagonal offset for better packing
                        float rowOffset = mod(gridId.y, 2.0) * 0.5;
                        gridId.x += rowOffset;
                        gridUv.x = fract(gridUv.x + rowOffset) - 0.5;
                        
                        // Scale properties
                        vec2 scaleHash = hash22(gridId);
                        float scaleRadius = 0.65 + scaleHash.x * 0.15; // Larger radius for full coverage
                        
                        // Small rotation for natural look
                        float rotation = (scaleHash.y - 0.5) * 0.3;
                        float c = cos(rotation);
                        float s = sin(rotation);
                        vec2 rotUv = vec2(gridUv.x * c - gridUv.y * s, gridUv.x * s + gridUv.y * c);
                        
                        // Semi-circle distance with imperfections
                        float angle = atan(rotUv.y, rotUv.x);
                        float dist = length(rotUv);
                        
                        // Semi-circle constraint (front half only)
                        float angleMask = smoothstep(-1.8, -1.4, angle) * smoothstep(1.8, 1.4, angle);
                        
                        // Add subtle imperfections
                        float imperfectionNoise = noise(rotUv * 15.0) * u_imperfection;
                        float adjustedRadius = scaleRadius + imperfectionNoise;
                        
                        // Scale weight (distance from edge)
                        float scaleWeight = 1.0 - smoothstep(adjustedRadius * 0.7, adjustedRadius, dist);
                        scaleWeight *= angleMask;
                        
                        if (scaleWeight > 0.01) {
                            // Memory sampling
                            vec2 scaleWorldPos = (gridId + 0.5) / u_scales;
                            vec4 memoryData = texture(u_memory, scaleWorldPos);
                            float memoryValue = memoryData.x;
                            
                            // Viewing angle calculation
                            vec2 viewDir = normalize(u_mouse - scaleWorldPos);
                            float viewAngle = atan(viewDir.y, viewDir.x);
                            
                            // Surface ridging
                            float ridgeAngle = atan(rotUv.y, rotUv.x);
                            float ridgeDistance = length(rotUv);
                            float ridges = sin(ridgeDistance * u_ridgeDetail * 6.0 + ridgeAngle * 4.0 + u_time * u_phaseSpeed * 4.0) * 0.1;
                            
                            // Memory-modulated phase
                            float memoryPhase = memoryValue * scaleHash.x * 6.28318;
                            float timePhase = u_time * u_phaseSpeed;
                            float totalPhase = timePhase + memoryPhase;
                            
                            // Optical calculations
                            float filmThickness = 0.6 + 0.2 * ridges + 0.3 * sin(totalPhase);
                            filmThickness += memoryValue * 0.4;
                            
                            float pathDiff = filmThickness * (1.5 + 0.5 * abs(dot(normalize(rotUv), viewDir)));
                            
                            // Wavelength interference
                            float phase_r = 6.28318 * pathDiff / 0.65 + viewAngle;
                            float phase_g = 6.28318 * pathDiff / 0.55 + viewAngle;
                            float phase_b = 6.28318 * pathDiff / 0.45 + viewAngle;
                            
                            // Base color gradient
                            float colorGrad = (scaleWorldPos.x * 0.7 + scaleWorldPos.y * 0.5) * 1.8;
                            vec3 baseColor = vec3(
                                0.2 + 0.8 * smoothstep(0.1, 0.9, colorGrad),
                                0.5 + 0.5 * sin(colorGrad * 2.5),
                                0.9 - 0.7 * smoothstep(0.1, 0.9, colorGrad)
                            );
                            
                            // Iridescent colors
                            vec3 iridescent = vec3(
                                0.3 + 0.7 * abs(sin(phase_r + memoryPhase * 0.3)) * u_interference,
                                0.3 + 0.7 * abs(sin(phase_g + memoryPhase * 0.5)) * u_interference,
                                0.3 + 0.7 * abs(sin(phase_b + memoryPhase * 0.7)) * u_interference
                            );
                            
                            // Memory coherence effects
                            vec3 memoryMod = vec3(
                                0.25 * sin(totalPhase + 0.0),
                                0.25 * sin(totalPhase + 2.094),
                                0.25 * sin(totalPhase + 4.188)
                            ) * memoryValue;
                            
                            // Combine colors
                            vec3 scaleColor = baseColor * 0.4 + iridescent * 0.6 + memoryMod;
                            
                            // Lighting
                            float lighting = 0.7 + 0.3 * max(0.0, dot(normalize(vec3(rotUv, 0.5)), normalize(vec3(viewDir, 0.3))));
                            
                            // Accumulate weighted colors
                            finalColor += scaleColor * lighting * scaleWeight;
                            totalWeight += scaleWeight;
                        }
                    }
                }
                
                // Ensure we always have some coverage
                if (totalWeight < 0.1) {
                    // Fallback base color to prevent black gaps
                    vec3 fallbackColor = vec3(0.1, 0.15, 0.3);
                    finalColor = mix(fallbackColor, finalColor, totalWeight * 10.0);
                    totalWeight = max(totalWeight, 0.1);
                }
                
                return finalColor / max(totalWeight, 0.1);
            }
            
            void main() {
                vec2 coord = v_texCoord;
                
                // Calculate seamless scale coverage
                vec3 scaleColor = calculateSeamlessScales(coord);
                
                fragColor = vec4(scaleColor, 1.0);
            }
        `;
        
        // Update shader
        const updateShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 fragColor;
            
            uniform sampler2D u_texture;
            uniform sampler2D u_memory;
            uniform float u_lambda;
            uniform float u_beta;
            uniform float u_feed;
            uniform float u_kill;
            uniform vec2 u_mouse;
            uniform float u_ruptureThreshold;
            uniform bool u_disturb;
            
            const float Du = 0.16;
            const float Dv = 0.08;
            const float dt = 0.75;
            const float texelSize = 1.0 / 512.0;
            
            vec4 laplacian(sampler2D tex, vec2 coord) {
                vec4 sum = vec4(0.0);
                sum += texture(tex, coord + vec2(-texelSize, 0.0));
                sum += texture(tex, coord + vec2(texelSize, 0.0));
                sum += texture(tex, coord + vec2(0.0, -texelSize));
                sum += texture(tex, coord + vec2(0.0, texelSize));
                sum -= 4.0 * texture(tex, coord);
                return sum;
            }
            
            void main() {
                vec2 coord = v_texCoord;
                vec4 current = texture(u_texture, coord);
                vec4 memory = texture(u_memory, coord);
                
                float u = current.x;
                float v = current.y;
                float m = memory.x;
                
                // Rupture on mouse interaction
                if (u_disturb && length(u_mouse - coord) < 0.07) {
                    v = 1.0;
                    u = 0.15;
                    m *= 0.3;
                }
                
                // Gray-Scott reaction-diffusion
                vec4 lapU = laplacian(u_texture, coord);
                float uvv = u * v * v;
                
                float dU = Du * lapU.x - uvv + u_feed * (1.0 - u);
                float dV = Dv * lapU.y + uvv - (u_feed + u_kill) * v;
                
                // Memory integration
                float newMemory = m + u_lambda * (u - m);
                
                // Non-Markovian feedback
                dU += u_beta * (newMemory - u);
                
                // Update
                float newU = clamp(u + dU * dt, 0.0, 1.0);
                float newV = clamp(v + dV * dt, 0.0, 1.0);
                
                fragColor = vec4(newU, newV, 0.0, newMemory);
            }
        `;
        
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function createProgram(vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }
        
        // Create programs
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const renderProgram = createProgram(vertexShader, createShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
        const updateProgram = createProgram(vertexShader, createShader(gl.FRAGMENT_SHADER, updateShaderSource));
        
        // Create geometry
        const positions = new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1,
        ]);
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        // Create textures
        function createTexture() {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return texture;
        }
        
        const texture1 = createTexture();
        const texture2 = createTexture();
        const memoryTexture1 = createTexture();
        const memoryTexture2 = createTexture();
        
        function initializeTextures() {
            const size = 512;
            const data = new Float32Array(size * size * 4);
            const memoryData = new Float32Array(size * size * 4);
            
            for (let i = 0; i < size * size * 4; i += 4) {
                data[i] = 1.0;
                data[i + 1] = Math.random() < 0.005 ? 1.0 : 0.0;
                data[i + 2] = 0.0;
                data[i + 3] = 1.0;
                
                memoryData[i] = 1.0;
                memoryData[i + 1] = 0.0;
                memoryData[i + 2] = 0.0;
                memoryData[i + 3] = 1.0;
            }
            
            [texture1, texture2].forEach(tex => {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, size, size, 0, gl.RGBA, gl.FLOAT, data);
            });
            
            [memoryTexture1, memoryTexture2].forEach(tex => {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, size, size, 0, gl.RGBA, gl.FLOAT, memoryData);
            });
        }
        
        // Framebuffers
        const framebuffer1 = gl.createFramebuffer();
        const framebuffer2 = gl.createFramebuffer();
        
        initializeTextures();
        
        // State
        let currentTexture = texture1;
        let nextTexture = texture2;
        let currentMemory = memoryTexture1;
        let nextMemory = memoryTexture2;
        let currentFramebuffer = framebuffer1;
        let nextFramebuffer = framebuffer2;
        
        let time = 0;
        let mouseX = 0.5;
        let mouseY = 0.5;
        let mousePressed = false;
        
        // Parameters
        let lambda = 0.028;
        let beta = 0.20;
        let interference = 1.8;
        let scales = 12;
        let phaseSpeed = 0.07;
        let ridgeDetail = 8;
        let imperfection = 0.025;
        let feed = 0.040;
        let kill = 0.064;
        let ruptureThreshold = 0.8;
        
        // Events
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) / rect.width;
            mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
            updateStatus();
        });
        
        canvas.addEventListener('mousedown', () => { mousePressed = true; });
        canvas.addEventListener('mouseup', () => { mousePressed = false; });
        
        // Sliders
        function setupSlider(id, callback) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + '-value');
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                valueDisplay.textContent = value.toString();
                callback(value);
            });
        }
        
        setupSlider('lambda', (v) => { lambda = v; });
        setupSlider('beta', (v) => { beta = v; });
        setupSlider('interference', (v) => { interference = v; });
        setupSlider('scales', (v) => { scales = v; });
        setupSlider('phase-speed', (v) => { phaseSpeed = v; });
        setupSlider('ridge-detail', (v) => { ridgeDetail = v; });
        setupSlider('imperfection', (v) => { imperfection = v; });
        setupSlider('feed', (v) => { feed = v; });
        setupSlider('kill', (v) => { kill = v; });
        setupSlider('rupture', (v) => { ruptureThreshold = v; });
        
        function reset() {
            initializeTextures();
            time = 0;
        }
        
        function updateStatus() {
            const angle = Math.atan2(mouseY - 0.5, mouseX - 0.5) * 180 / Math.PI;
            document.getElementById('status').textContent = 
                `Memory System: ACTIVE | Coverage: SEAMLESS | View: ${angle.toFixed(0)}°`;
        }
        
        function render() {
            time += 0.016;
            
            // Update simulation
            gl.bindFramebuffer(gl.FRAMEBUFFER, nextFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, nextTexture, 0);
            
            gl.useProgram(updateProgram);
            gl.viewport(0, 0, 512, 512);
            
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_lambda'), lambda);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_beta'), beta);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_feed'), feed);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_kill'), kill);
            gl.uniform2f(gl.getUniformLocation(updateProgram, 'u_mouse'), mouseX, mouseY);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_ruptureThreshold'), ruptureThreshold);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_disturb'), mousePressed);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentTexture);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_texture'), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, currentMemory);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_memory'), 1);
            
            const posLoc = gl.getAttribLocation(updateProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Update memory
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, nextMemory, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Render to screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.useProgram(renderProgram);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_time'), time);
            gl.uniform2f(gl.getUniformLocation(renderProgram, 'u_mouse'), mouseX, mouseY);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_interference'), interference);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_scales'), scales);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_phaseSpeed'), phaseSpeed);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_ridgeDetail'), ridgeDetail);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_imperfection'), imperfection);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, nextTexture);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_texture'), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, nextMemory);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_memory'), 1);
            
            const renderPosLoc = gl.getAttribLocation(renderProgram, 'a_position');
            gl.enableVertexAttribArray(renderPosLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(renderPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Swap buffers
            [currentTexture, nextTexture] = [nextTexture, currentTexture];
            [currentMemory, nextMemory] = [nextMemory, currentMemory];
            [currentFramebuffer, nextFramebuffer] = [nextFramebuffer, currentFramebuffer];
            
            requestAnimationFrame(render);
        }
        
        // Global functions
        window.reset = reset;
        
        // Start
        updateStatus();
        render();
    </script>
</body>
</html>