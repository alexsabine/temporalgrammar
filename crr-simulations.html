<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Simulations - Cohere.org.uk</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-svg.min.js" async></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
            font-family: Georgia, serif;
            line-height: 1.6;
            color: #2c2c2c;
            overflow-x: hidden;
        }

        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 60px;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .title-group {
            display: flex;
            flex-direction: column;
        }

        .site-title {
            font-family: Georgia, serif;
            font-size: 48px;
            font-weight: normal;
            color: #1a1a1a;
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .strapline {
            font-family: Georgia, serif;
            font-size: 18px;
            font-style: italic;
            color: #6c757d;
            letter-spacing: 0.5px;
        }

        .main-nav {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #495057;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #1a1a1a;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: #4a90e2;
            color: white;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .nav-item:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 8px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 1000;
            overflow: hidden;
        }

        .nav-item:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-menu:hover {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-link {
            display: block;
            padding: 12px 20px;
            color: #495057;
            text-decoration: none;
            font-size: 16px;
            font-family: Georgia, serif;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #4a90e2;
            border-left-color: #4a90e2;
        }

        .hero-section {
            padding: 100px 0 80px;
            text-align: center;
            position: relative;
        }

        .hero-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(74, 144, 226, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(108, 117, 125, 0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 1;
        }

        .hero-title {
            font-family: Georgia, serif;
            font-size: 56px;
            font-weight: normal;
            line-height: 1.1;
            margin-bottom: 30px;
            color: #1a1a1a;
            letter-spacing: -1px;
        }

        .hero-subtitle {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            color: #495057;
            margin-bottom: 40px;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .content-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
        }

        .section-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(248, 249, 250, 0.5) 0%, transparent 100%);
            pointer-events: none;
        }

        .section-content {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
        }

        .section-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .section-content p {
            font-family: Georgia, serif;
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 25px;
            text-align: justify;
        }

        .section-content h3 {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin: 35px 0 20px;
            color: #1a1a1a;
        }

        .intro-text {
            font-size: 20px;
            line-height: 1.9;
            color: #2c2c2c;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(74, 144, 226, 0.03);
        }

        /* FAQ Styles */
        .faq-container {
            margin: 40px 0;
        }

        .faq-item {
            margin-bottom: 20px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 0.9);
            overflow: hidden;
        }

        .faq-question {
            padding: 25px 30px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
        }

        .faq-question:hover {
            background: rgba(74, 144, 226, 0.05);
        }

        .faq-question h4 {
            font-family: Georgia, serif;
            font-size: 20px;
            font-weight: normal;
            color: #1a1a1a;
            margin: 0;
        }

        .faq-toggle {
            font-size: 24px;
            color: #4a90e2;
            transition: transform 0.3s ease;
            font-weight: 300;
        }

        .faq-item.active .faq-toggle {
            transform: rotate(45deg);
        }

        .faq-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, padding 0.4s ease;
            padding: 0 30px;
        }

        .faq-item.active .faq-answer {
            max-height: 800px;
            padding: 0 30px 30px;
        }

        .faq-answer p {
            font-size: 17px;
            line-height: 1.8;
            color: #495057;
            margin-bottom: 15px;
        }

        .faq-answer p:last-child {
            margin-bottom: 0;
        }

        .equation-highlight {
            background: rgba(74, 144, 226, 0.08);
            padding: 20px 25px;
            margin: 20px 0;
            text-align: center;
        }

        /* Simulation Styles */
        .simulation-container {
            margin: 50px 0;
            padding: 40px;
            background: #fafbfc;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .simulation-title {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
            text-align: center;
        }

        .simulation-description {
            font-size: 16px;
            color: #6c757d;
            text-align: center;
            margin-bottom: 30px;
            font-style: italic;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        #crrCanvas {
            border: 1px solid #dee2e6;
            background: white;
        }

        .controls-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 180px;
        }

        .control-label {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #495057;
            margin-bottom: 8px;
            text-align: center;
        }

        .control-value {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }

        input[type="range"] {
            width: 160px;
            height: 6px;
            -webkit-appearance: none;
            background: #dee2e6;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #4a90e2;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #357abd;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .sim-button {
            font-family: Georgia, serif;
            font-size: 16px;
            padding: 12px 30px;
            border: 1px solid #4a90e2;
            background: white;
            color: #4a90e2;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sim-button:hover {
            background: #4a90e2;
            color: white;
        }

        .sim-button.active {
            background: #4a90e2;
            color: white;
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 25px;
            background: white;
            border: 1px solid #dee2e6;
        }

        .metric {
            text-align: center;
            padding: 15px;
        }

        .metric-label {
            font-family: Georgia, serif;
            font-size: 13px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            color: #1a1a1a;
        }

        .metric-sublabel {
            font-size: 12px;
            color: #adb5bd;
            margin-top: 5px;
        }

        .state-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }

        .state-coherence { background: #4a90e2; }
        .state-rupture { background: #dc3545; }
        .state-regeneration { background: #28a745; }

        .footer {
            background: rgba(245, 246, 248, 0.9);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            padding: 50px 0 40px;
            text-align: center;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1000px;
            margin: 0 auto;
        }

        .github-link {
            font-family: Georgia, serif;
            font-size: 18px;
            color: #4a90e2;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
            border: 1px solid #4a90e2;
            transition: all 0.3s ease;
        }

        .github-link:hover {
            background: #4a90e2;
            color: white;
        }

        .github-icon {
            width: 24px;
            height: 24px;
        }

        @media (max-width: 1024px) {
            .controls-panel {
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .page-container {
                padding: 0 30px;
            }

            .header {
                flex-direction: column;
                gap: 30px;
                text-align: center;
                padding: 30px 0;
            }

            .logo-section {
                flex-direction: column;
                gap: 15px;
            }

            .logo {
                margin-right: 0;
            }

            .site-title {
                font-size: 36px;
            }

            .main-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            .dropdown-menu {
                position: static;
                opacity: 1;
                visibility: visible;
                transform: none;
                box-shadow: none;
                border: none;
                background: rgba(74, 144, 226, 0.05);
                margin-top: 10px;
                display: none;
            }

            .nav-item:hover .dropdown-menu {
                display: block;
            }

            .hero-section {
                padding: 60px 0 40px;
            }

            .hero-title {
                font-size: 42px;
            }

            .hero-subtitle {
                font-size: 20px;
            }

            .content-section {
                padding: 40px 25px;
                margin: 60px 0;
            }

            .section-title {
                font-size: 28px;
            }

            .simulation-container {
                padding: 25px 15px;
            }

            #crrCanvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header class="header">
            <div class="logo-section">                
                <div class="title-group">
                    <h1 class="site-title">Cohere.org.uk</h1>
                    <p class="strapline">A Temporal Grammar</p>
                </div>
            </div>

            <nav class="main-nav">
                <div class="nav-item">
                    <a href="index.html" class="nav-link">Home</a>
                </div>
                <div class="nav-item">
                    <a href="crr-simulations.html" class="nav-link active">
                        CRR Simulations
                        <span class="dropdown-arrow">â–¼</span>
                    </a>
                    <div class="dropdown-menu">
                        <a href="biological-systems.html" class="dropdown-link">Biological Systems</a>
                        <a href="physical-systems.html" class="dropdown-link">Physical Systems</a>
                        <a href="mathematical-life.html" class="dropdown-link">Mathematical Life</a>
                    </div>
                </div>
                <div class="nav-item">
                    <a href="crr-benchmarks.html" class="nav-link">CRR Benchmarks</a>
                </div>
                <div class="nav-item">
                    <a href="crr-explained.html" class="nav-link">CRR Explained</a>
                </div>
                <div class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </div>
            </nav>
        </header>

        <main>
            <section class="hero-section">
                <div class="hero-background"></div>
                <div class="hero-content">
                    <h2 class="hero-title">CRR Simulations</h2>
                    <p class="hero-subtitle">A Coarse Grain Temporal Grammar</p>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <div class="section-content">
                    <div class="intro-text">
                        <p>These simulations exist because academia is full of noise. Too much coherence accumulates too fast, creating an overabundance of knowledge and an inability to find signal in noise. This presents real psychological risks to individual humans navigating the density of modern information environments.</p>
                        <p style="margin-bottom: 0;">These are playful simulations, running the CRR, for people to reflect on as a temporal grammar: a way of thinking about how systems integrate their pasts, reach critical thresholds, and regenerate toward new futures.</p>
                    </div>

                    <h3>The CRR as Temporal Grammar</h3>
                    <p>The Coherence-Rupture-Regeneration framework provides a coarse grain grammar for describing temporal dynamics across scales. It is not a theory of everything, but a lens: a minimal formal structure for thinking about how any system, whether a neuron, a mind, an ecosystem, or a market, accumulates history, reaches saturation, and reconstitutes itself.</p>
                    
                    <p>The grammar has three movements: Coherence integrates the past non-Markovianly (the present state depends on all prior states, not just the most recent). Rupture marks the moment of phase transition, when accumulated history saturates the system's capacity. Regeneration reconstructs future states, weighted by the historical field.</p>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Frequently Asked Questions</h2>
                <div class="section-content">
                    <div class="faq-container">
                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>What is Coherence?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Coherence is the temporal integral of all past states. It represents the accumulated history of a system, a non-Markovian memory that weights the present with everything that came before.</p>
                                <div class="equation-highlight">
                                    $$C(x) = \int L(x,\tau) \, d\tau$$
                                </div>
                                <p>Here, $L(x,\tau)$ is the memory density at position $x$ and time $\tau$. The integral runs over all past time, meaning coherence carries the full temporal signature of the system. This is fundamentally different from Markovian dynamics, where only the immediately preceding state matters.</p>
                            </div>
                        </div>

                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>What is Omega and what happens when C equals Omega?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Omega ($\Omega$) is the system temperature parameter, a normalisation constant that sets the scale of the Markov blanket. It determines how much coherence a system can hold before reaching saturation.</p>
                                <p>When $C = \Omega$, the system reaches Markov blanket saturation. At this critical point, the exponential term $e^{C/\Omega}$ in the Regeneration operator equals Euler's number $e \approx 2.718$:</p>
                                <div class="equation-highlight">
                                    $$e^{C/\Omega} = e^1 = e$$
                                </div>
                                <p>This is the inflection point where the accumulated past has filled the system's capacity to integrate more history. The Markov blanket, the statistical boundary separating system from environment, becomes saturated. The system can no longer absorb new information without structural change.</p>
                            </div>
                        </div>

                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>What does Omega tell us about system porosity?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Omega controls the porosity of the Markov blanket, determining how easily information flows between system and environment:</p>
                                <p><strong>Higher Omega</strong> means a more porous, liquid system. The blanket is permeable. The system can integrate more history before reaching saturation, and the exponential weighting in Regeneration remains moderate even at high coherence. Such systems are adaptable, responsive, perhaps unstable.</p>
                                <p><strong>Lower Omega</strong> means a more rigid, crystalline system. The blanket is impermeable. Even small amounts of accumulated coherence push the exponential term toward large values, meaning recent priors dominate heavily. Such systems are stable, perhaps brittle, locked into their recent histories.</p>
                                <p>In the simulation below, adjusting Omega lets you see this directly: low Omega systems rupture quickly and regenerate with heavy weighting on recent states. High Omega systems can accumulate vast coherence before transition.</p>
                            </div>
                        </div>

                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>What is Rupture?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Rupture is the phase transition, the discrete moment when coherence saturates and the system reorganises. Formally, it is represented by a Dirac delta function at the rupture time:</p>
                                <div class="equation-highlight">
                                    $$\delta(t - t_0)$$
                                </div>
                                <p>The Dirac delta is infinitely concentrated at a single instant: infinite intensity, zero duration, unit integral. This captures the scale-invariant nature of rupture. Whether the system is a synapse or a civilisation, the rupture event is singular, a point of discontinuity in the otherwise continuous accumulation of coherence.</p>
                                <p>Rupture can be endogenous (arising from internal dynamics reaching threshold) or exogenous (imposed by external perturbation). At any spatial or temporal scale, rupture marks the moment when the past is metabolised, when accumulated history is processed and the system prepares for reconstitution.</p>
                            </div>
                        </div>

                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>What is Regeneration?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Regeneration is the reconstruction of future states from the historical field, weighted by the coherence accumulated before rupture:</p>
                                <div class="equation-highlight">
                                    $$R[\chi](x,t) = \int \phi(x,\tau) \cdot e^{C(x)/\Omega} \cdot \Theta(t-\tau) \, d\tau$$
                                </div>
                                <p>Here, $\phi(x,\tau)$ is the historical field signal, the record of past states. The exponential term $e^{C/\Omega}$ weights this history by the coherence at rupture. The Heaviside function $\Theta(t-\tau)$ enforces causality, ensuring only past states contribute to the reconstruction.</p>
                                <p>Regeneration is not mere recovery. The system does not return to its prior state. Instead, it reconstitutes itself through the lens of its accumulated history, weighted by how saturated its Markov blanket was at the moment of rupture. High coherence at rupture means the historical field is amplified exponentially in shaping what comes next.</p>
                            </div>
                        </div>

                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>Why is this called a "coarse grain" grammar?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Coarse graining refers to the deliberate loss of fine detail to reveal essential structure. The CRR does not attempt to model every microscopic interaction within a system. Instead, it tracks three macro-level quantities, coherence, rupture threshold, and regeneration dynamics, that apply regardless of the underlying substrate.</p>
                                <p>This is a grammar in the linguistic sense: a formal structure that generates valid descriptions without specifying content. Just as grammar tells you how to combine words without telling you what to say, the CRR tells you how temporal dynamics unfold without specifying what the system is. A neuron, a forest, a financial market, a human life: all can be parsed through this grammar.</p>
                                <p>The coarseness is the point. By abstracting away particulars, the grammar becomes applicable across scales and domains. The price of this generality is that specific predictions require additional domain knowledge. The CRR provides the temporal skeleton; flesh must be added by understanding the particular system in question.</p>
                            </div>
                        </div>

                        <div class="faq-item">
                            <div class="faq-question">
                                <h4>Why does the role of Euler's number matter here?</h4>
                                <span class="faq-toggle">+</span>
                            </div>
                            <div class="faq-answer">
                                <p>Euler's number $e$ emerges naturally in processes involving continuous growth and decay. It is the base of the natural logarithm, the eigenvalue of differentiation, the limit of compound interest as compounding becomes continuous.</p>
                                <p>In the CRR, $e$ appears in the Regeneration operator as the weighting factor when $C = \Omega$. This is not arbitrary. The exponential function $e^x$ is the unique function equal to its own derivative: it describes processes where the rate of change is proportional to the current value. This is precisely the behaviour of coherence accumulation and its influence on regeneration.</p>
                                <p>When $C/\Omega = 1$, the weighting factor $e^1 = e$ represents a precise balance point. Below this, the historical field is underweighted. Above this, it becomes increasingly dominant. The appearance of $e$ at the saturation threshold is not coincidental; it reflects the deep mathematical structure of continuous integration and exponential dynamics.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Fundamental CRR Dynamics</h2>
                <div class="section-content">
                    <div class="simulation-container">
                        <h3 class="simulation-title">Interactive CRR Simulation</h3>
                        <p class="simulation-description">Observe how coherence accumulates, saturates at the Markov blanket threshold, ruptures, and regenerates</p>
                        
                        <div class="canvas-wrapper">
                            <canvas id="crrCanvas" width="800" height="400"></canvas>
                        </div>

                        <div class="controls-panel">
                            <div class="control-group">
                                <label class="control-label">Omega (System Temperature)</label>
                                <input type="range" id="omegaSlider" min="0.3" max="2.0" step="0.1" value="1.0">
                                <span class="control-value" id="omegaValue">1.0</span>
                            </div>
                            <div class="control-group">
                                <label class="control-label">Memory Density Rate</label>
                                <input type="range" id="densitySlider" min="0.01" max="0.1" step="0.01" value="0.04">
                                <span class="control-value" id="densityValue">0.04</span>
                            </div>
                            <div class="control-group">
                                <label class="control-label">Decay Constant (Lambda)</label>
                                <input type="range" id="lambdaSlider" min="0.01" max="0.2" step="0.01" value="0.05">
                                <span class="control-value" id="lambdaValue">0.05</span>
                            </div>
                        </div>

                        <div class="button-group">
                            <button class="sim-button active" id="playPause">Pause</button>
                            <button class="sim-button" id="reset">Reset</button>
                            <button class="sim-button" id="triggerRupture">Trigger Rupture</button>
                        </div>

                        <div class="metrics-panel">
                            <div class="metric">
                                <div class="metric-label">Coherence (C)</div>
                                <div class="metric-value" id="coherenceMetric">0.000</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">C / Omega</div>
                                <div class="metric-value" id="ratioMetric">0.000</div>
                                <div class="metric-sublabel">Blanket saturation</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">exp(C/Omega)</div>
                                <div class="metric-value" id="expMetric">1.000</div>
                                <div class="metric-sublabel">Regeneration weight</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">System State</div>
                                <div class="metric-value" id="stateMetric">
                                    <span class="state-indicator state-coherence"></span>Coherence
                                </div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Rupture Count</div>
                                <div class="metric-value" id="ruptureCount">0</div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <footer class="footer">
        <div class="page-container">
            <div class="footer-content">
                <a href="https://github.com/alexsabine/CRR/" class="github-link" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
                    </svg>
                    View on GitHub
                </a>
            </div>
        </div>
    </footer>

    <script>
        'use strict';

        // FAQ Accordion
        document.querySelectorAll('.faq-question').forEach(question => {
            question.addEventListener('click', () => {
                const item = question.parentElement;
                const wasActive = item.classList.contains('active');
                
                document.querySelectorAll('.faq-item').forEach(i => i.classList.remove('active'));
                
                if (!wasActive) {
                    item.classList.add('active');
                }
            });
        });

        // CRR Simulation
        class CRRSimulation {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                // Parameters
                this.omega = 1.0;
                this.lambda = 0.05;
                this.densityRate = 0.04;
                
                // State
                this.C = 0;
                this.L = 0;
                this.state = 'coherence';
                this.ruptureCount = 0;
                this.regenerationTimer = 0;
                this.time = 0;
                
                // History for visualization
                this.history = [];
                this.maxHistory = 400;
                
                // Animation
                this.isRunning = true;
                this.lastTime = performance.now();
                
                this.setupControls();
                this.animate();
            }
            
            setupControls() {
                const omegaSlider = document.getElementById('omegaSlider');
                const densitySlider = document.getElementById('densitySlider');
                const lambdaSlider = document.getElementById('lambdaSlider');
                
                omegaSlider.addEventListener('input', (e) => {
                    this.omega = parseFloat(e.target.value);
                    document.getElementById('omegaValue').textContent = this.omega.toFixed(1);
                });
                
                densitySlider.addEventListener('input', (e) => {
                    this.densityRate = parseFloat(e.target.value);
                    document.getElementById('densityValue').textContent = this.densityRate.toFixed(2);
                });
                
                lambdaSlider.addEventListener('input', (e) => {
                    this.lambda = parseFloat(e.target.value);
                    document.getElementById('lambdaValue').textContent = this.lambda.toFixed(2);
                });
                
                document.getElementById('playPause').addEventListener('click', (e) => {
                    this.isRunning = !this.isRunning;
                    e.target.textContent = this.isRunning ? 'Pause' : 'Play';
                    e.target.classList.toggle('active', this.isRunning);
                    if (this.isRunning) {
                        this.lastTime = performance.now();
                        this.animate();
                    }
                });
                
                document.getElementById('reset').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('triggerRupture').addEventListener('click', () => {
                    if (this.state === 'coherence' && this.C > 0.1) {
                        this.triggerRupture();
                    }
                });
            }
            
            reset() {
                this.C = 0;
                this.L = 0;
                this.state = 'coherence';
                this.ruptureCount = 0;
                this.regenerationTimer = 0;
                this.time = 0;
                this.history = [];
                this.updateMetrics();
            }
            
            triggerRupture() {
                this.state = 'rupture';
                this.ruptureCount++;
                this.regenerationTimer = 0;
                
                // Store coherence at rupture for regeneration weighting
                this.coherenceAtRupture = this.C;
            }
            
            update(dt) {
                this.time += dt;
                
                if (this.state === 'coherence') {
                    // Accumulate memory density
                    const noise = (Math.random() - 0.5) * 0.01;
                    this.L += (this.densityRate + noise) * dt;
                    this.L = Math.max(0, Math.min(1, this.L));
                    
                    // Coherence integration with decay
                    const dC = this.L * dt - this.lambda * this.C * dt;
                    this.C += dC;
                    this.C = Math.max(0, this.C);
                    
                    // Check for saturation (C approaches Omega)
                    if (this.C >= this.omega * 0.95) {
                        this.triggerRupture();
                    }
                }
                else if (this.state === 'rupture') {
                    // Rapid coherence drop (Dirac-like transition)
                    this.C *= 0.85;
                    this.L *= 0.9;
                    
                    if (this.C < 0.05) {
                        this.state = 'regeneration';
                        this.regenerationTimer = 0;
                    }
                }
                else if (this.state === 'regeneration') {
                    this.regenerationTimer += dt;
                    
                    // Regeneration with exponential weighting from historical field
                    const expWeight = Math.exp(this.coherenceAtRupture / this.omega);
                    const regenerationRate = 0.02 * Math.min(expWeight, 3);
                    
                    this.L += regenerationRate * dt * 0.5;
                    this.C += this.L * regenerationRate * dt;
                    
                    // Transition back to coherence after regeneration period
                    if (this.regenerationTimer > 2.0) {
                        this.state = 'coherence';
                    }
                }
                
                // Record history
                this.history.push({
                    C: this.C,
                    L: this.L,
                    state: this.state,
                    ratio: this.C / this.omega
                });
                
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
                
                this.updateMetrics();
            }
            
            updateMetrics() {
                const ratio = this.C / this.omega;
                const expTerm = Math.exp(ratio);
                
                document.getElementById('coherenceMetric').textContent = this.C.toFixed(3);
                document.getElementById('ratioMetric').textContent = ratio.toFixed(3);
                document.getElementById('expMetric').textContent = expTerm.toFixed(3);
                document.getElementById('ruptureCount').textContent = this.ruptureCount;
                
                const stateEl = document.getElementById('stateMetric');
                const indicator = stateEl.querySelector('.state-indicator');
                
                indicator.className = 'state-indicator';
                if (this.state === 'coherence') {
                    indicator.classList.add('state-coherence');
                    stateEl.innerHTML = '<span class="state-indicator state-coherence"></span>Coherence';
                } else if (this.state === 'rupture') {
                    indicator.classList.add('state-rupture');
                    stateEl.innerHTML = '<span class="state-indicator state-rupture"></span>Rupture';
                } else {
                    indicator.classList.add('state-regeneration');
                    stateEl.innerHTML = '<span class="state-indicator state-regeneration"></span>Regeneration';
                }
            }
            
            render() {
                const ctx = this.ctx;
                const w = this.width;
                const h = this.height;
                
                // Clear
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                // Grid
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const y = (h - 60) * (1 - i / 10) + 30;
                    ctx.beginPath();
                    ctx.moveTo(60, y);
                    ctx.lineTo(w - 20, y);
                    ctx.stroke();
                }
                
                // Omega threshold line
                const omegaY = 30 + (h - 60) * (1 - this.omega / 2);
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(60, omegaY);
                ctx.lineTo(w - 20, omegaY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Label
                ctx.fillStyle = '#dc3545';
                ctx.font = '12px Georgia';
                ctx.fillText('Omega = ' + this.omega.toFixed(1), w - 100, omegaY - 8);
                
                // e threshold (C/Omega = 1)
                if (this.omega <= 2) {
                    const eY = 30 + (h - 60) * (1 - this.omega / 2);
                    ctx.fillStyle = '#6c757d';
                    ctx.font = '11px Georgia';
                    ctx.fillText('C = Omega (e^1 threshold)', 65, eY - 8);
                }
                
                // Draw history
                if (this.history.length > 1) {
                    const xStep = (w - 80) / this.maxHistory;
                    
                    // Coherence line
                    ctx.beginPath();
                    ctx.strokeStyle = '#4a90e2';
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < this.history.length; i++) {
                        const x = 60 + i * xStep;
                        const y = 30 + (h - 60) * (1 - this.history[i].C / 2);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Memory density (lighter)
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(74, 144, 226, 0.3)';
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i < this.history.length; i++) {
                        const x = 60 + i * xStep;
                        const y = 30 + (h - 60) * (1 - this.history[i].L / 2);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // State indicator background
                    for (let i = 0; i < this.history.length; i++) {
                        const x = 60 + i * xStep;
                        const state = this.history[i].state;
                        
                        if (state === 'rupture') {
                            ctx.fillStyle = 'rgba(220, 53, 69, 0.1)';
                            ctx.fillRect(x, 30, xStep, h - 60);
                        } else if (state === 'regeneration') {
                            ctx.fillStyle = 'rgba(40, 167, 69, 0.05)';
                            ctx.fillRect(x, 30, xStep, h - 60);
                        }
                    }
                }
                
                // Y-axis labels
                ctx.fillStyle = '#6c757d';
                ctx.font = '11px Georgia';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const val = (i * 0.5).toFixed(1);
                    const y = 30 + (h - 60) * (1 - i / 4);
                    ctx.fillText(val, 55, y + 4);
                }
                
                // Axis labels
                ctx.textAlign = 'center';
                ctx.fillText('Time', w / 2, h - 10);
                
                ctx.save();
                ctx.translate(15, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Coherence (C) / Memory Density (L)', 0, 0);
                ctx.restore();
                
                // Legend
                ctx.textAlign = 'left';
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(70, h - 45, 15, 3);
                ctx.fillStyle = '#495057';
                ctx.fillText('Coherence', 90, h - 40);
                
                ctx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                ctx.fillRect(180, h - 45, 15, 3);
                ctx.fillStyle = '#495057';
                ctx.fillText('Memory Density', 200, h - 40);
            }
            
            animate() {
                if (!this.isRunning) return;
                
                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;
                
                this.update(dt);
                this.render();
                
                requestAnimationFrame(() => this.animate());
            }
        }

        // Logo Animation
        class LogoAnimation {
            constructor() {
                this.animationTime = 0;
                this.isAnimating = true;
                this.rafId = null;
                this.elements = {
                    logo: document.querySelector('.logo'),
                    logoHive: document.querySelector('.logo-hive'),
                    bees: document.querySelectorAll('.logo-bee'),
                    interiorBees: document.querySelectorAll('[class*="interior-bee"]')
                };
                
                if (!this.respectsReducedMotion()) {
                    this.startAnimation();
                }
                
                this.setupVisibilityChange();
            }
            
            startAnimation() {
                const animate = () => {
                    if (!this.isAnimating) return;
                    
                    this.animationTime += 0.02;
                    this.animateBees();
                    
                    this.rafId = requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            animateBees() {
                this.elements.bees.forEach((bee, index) => {
                    const baseAngle = (index * Math.PI * 0.5) + this.animationTime * (0.3 + index * 0.1);
                    const radius = 15 + Math.sin(this.animationTime * 0.5 + index) * 4;
                    const figure8 = Math.sin(this.animationTime * 0.4 + index * 0.6) * 6;
                    
                    const x = 50 + Math.cos(baseAngle) * radius + figure8 * Math.cos(baseAngle * 1.5);
                    const y = 50 + Math.sin(baseAngle) * radius * 0.7 + figure8 * 0.2 * Math.sin(baseAngle * 2);
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    
                    const wingBeat = 0.7 + 0.3 * Math.sin(this.animationTime * 10 + index * 2);
                    bee.style.opacity = wingBeat;
                });
            }
            
            setupVisibilityChange() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.isAnimating = false;
                        if (this.rafId) cancelAnimationFrame(this.rafId);
                    } else if (!this.respectsReducedMotion()) {
                        this.isAnimating = true;
                        this.startAnimation();
                    }
                });
            }
            
            respectsReducedMotion() {
                return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            new CRRSimulation(document.getElementById('crrCanvas'));
            new LogoAnimation();
        });
    </script>
</body>
</html>
