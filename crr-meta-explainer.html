<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Meta-Explainer | A World Made of Coherence</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Crimson+Text:ital@0;1&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a1a;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'EB Garamond', Georgia, serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }

    /* Narrative Overlay */
    .narrative-overlay {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 30px 50px;
      background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.6) 60%, transparent 100%);
      color: rgba(255, 255, 255, 0.95);
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in;
      max-height: 45vh;
      overflow: hidden;
    }
    .narrative-overlay.visible { opacity: 1; }

    .dialogue-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 900px;
      margin: 0 auto;
    }

    .speaker {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      opacity: 0.6;
      margin-bottom: 2px;
    }
    .speaker.professor { color: #7dd3fc; }
    .speaker.student { color: #fcd34d; }

    .dialogue {
      font-size: 1.25rem;
      line-height: 1.7;
      font-family: 'Crimson Text', Georgia, serif;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    .explanation-box {
      background: rgba(255,255,255,0.08);
      border-left: 3px solid rgba(125, 211, 252, 0.6);
      padding: 12px 18px;
      margin-top: 10px;
      border-radius: 0 8px 8px 0;
    }

    .explanation-box .layperson {
      font-size: 1rem;
      color: rgba(255,255,255,0.85);
      margin-bottom: 8px;
    }

    .explanation-box .fep {
      font-size: 0.9rem;
      color: rgba(167, 139, 250, 0.9);
      font-family: 'SF Mono', Monaco, monospace;
      padding: 8px 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
    }

    /* Controls */
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 15px 20px;
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.85rem;
      z-index: 100;
      min-width: 200px;
    }
    .controls h4 {
      margin-bottom: 10px;
      font-weight: 500;
      color: #7dd3fc;
    }
    .controls button {
      display: block;
      width: 100%;
      padding: 8px 12px;
      margin: 5px 0;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 6px;
      color: white;
      font-family: inherit;
      cursor: pointer;
      transition: background 0.2s;
    }
    .controls button:hover { background: rgba(255,255,255,0.2); }
    .controls button.active { background: rgba(125, 211, 252, 0.3); border: 1px solid rgba(125, 211, 252, 0.5); }

    .scene-indicator {
      font-size: 0.75rem;
      opacity: 0.6;
      margin-top: 10px;
      text-align: center;
    }

    /* CRR Debug Panel */
    .crr-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 15px 20px;
      color: rgba(255, 255, 255, 0.8);
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      line-height: 1.6;
      z-index: 100;
      min-width: 280px;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .crr-panel.visible { opacity: 1; }
    .crr-panel .title {
      font-weight: 600;
      color: #7dd3fc;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .crr-panel .section {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .crr-panel .section:last-child { border-bottom: none; }
    .crr-panel .section-title {
      color: rgba(255,255,255,0.5);
      font-size: 10px;
      margin-bottom: 4px;
    }
    .crr-panel .row { display: flex; justify-content: space-between; gap: 15px; }
    .crr-panel .label { color: rgba(255,255,255,0.5); }
    .crr-panel .value { color: #fcd34d; font-weight: 500; }
    .crr-panel .coherence { color: #34d399; }
    .crr-panel .rupture { color: #f87171; }
    .crr-panel .regeneration { color: #a78bfa; }

    /* Calendar display */
    .calendar-display {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      border-radius: 8px;
      padding: 12px 18px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
      text-align: right;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .calendar-display.visible { opacity: 1; }
    .calendar-display .time { font-size: 2rem; font-weight: 400; }
    .calendar-display .date { opacity: 0.7; font-style: italic; }
    .calendar-display .crr-note { font-size: 0.75rem; color: #7dd3fc; margin-top: 5px; }

    /* Process Philosophy Quote */
    .philosophy-quote {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: rgba(255, 255, 255, 0.9);
      max-width: 700px;
      opacity: 0;
      transition: opacity 2s ease-in-out;
      pointer-events: none;
      z-index: 200;
    }
    .philosophy-quote.visible { opacity: 1; }
    .philosophy-quote blockquote {
      font-size: 1.8rem;
      font-style: italic;
      line-height: 1.6;
      text-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    .philosophy-quote cite {
      display: block;
      margin-top: 15px;
      font-size: 1rem;
      opacity: 0.7;
    }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="crr-panel" id="crrPanel">
  <div class="title">CRR Systems Monitor</div>
  <div class="section">
    <div class="section-title">DAY-NIGHT CYCLE</div>
    <div class="row"><span class="label">Phase:</span><span class="value" id="dayPhase">coherence</span></div>
    <div class="row"><span class="label">C:</span><span class="value coherence" id="dayC">0.00</span></div>
    <div class="row"><span class="label">exp(C/Ω):</span><span class="value" id="dayMemory">1.00</span></div>
  </div>
  <div class="section">
    <div class="section-title">HEARTBEAT</div>
    <div class="row"><span class="label">Phase:</span><span class="value" id="heartPhase">systole</span></div>
    <div class="row"><span class="label">C:</span><span class="value coherence" id="heartC">0.00</span></div>
    <div class="row"><span class="label">BPM:</span><span class="value" id="heartBPM">72</span></div>
  </div>
  <div class="section">
    <div class="section-title">MURMURATION</div>
    <div class="row"><span class="label">Flock C:</span><span class="value coherence" id="flockC">0.00</span></div>
    <div class="row"><span class="label">State:</span><span class="value" id="flockState">coherence</span></div>
  </div>
  <div class="section">
    <div class="section-title">FIRE (House 1)</div>
    <div class="row"><span class="label">C:</span><span class="value coherence" id="fireC">0.00</span></div>
    <div class="row"><span class="label">Intensity:</span><span class="value" id="fireIntensity">0.00</span></div>
  </div>
</div>

<div class="controls" id="controls">
  <h4>Narrative Control</h4>
  <button id="btnPrev">Previous Scene</button>
  <button id="btnNext">Next Scene</button>
  <button id="btnAuto" class="active">Auto-Advance</button>
  <button id="btnToggleCRR">Show CRR Panel</button>
  <div class="scene-indicator">Scene <span id="sceneNum">1</span> of <span id="totalScenes">12</span></div>
</div>

<div class="narrative-overlay" id="narrativeOverlay">
  <div class="dialogue-container" id="dialogueContainer">
    <!-- Populated by JavaScript -->
  </div>
</div>

<div class="calendar-display" id="calendarDisplay">
  <div class="time" id="timeDisplay">00:00</div>
  <div class="date" id="dateDisplay">Loading...</div>
  <div class="crr-note">Annual cycle: CRR Ω = 1/2π</div>
</div>

<div class="philosophy-quote" id="philosophyQuote">
  <blockquote id="quoteText"></blockquote>
  <cite id="quoteCite"></cite>
</div>

<script>
// ============================================================================
// CRR META-EXPLAINER
// A World Made of Coherence-Rupture-Regeneration
// ============================================================================

const { sin, cos, sqrt, abs, floor, max, min, random, PI, atan2, exp } = Math;
const PI2 = PI * 2;
const lerp = (a, b, t) => a + (b - a) * t;
const lerpColor = (c1, c2, t) => ({ r: lerp(c1.r, c2.r, t), g: lerp(c1.g, c2.g, t), b: lerp(c1.b, c2.b, t) });
const rgba = (c, a) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;

// ============================================================================
// CRR CONSTANTS - The Mathematical Foundation
// ============================================================================
const CRR = {
  // Primary threshold - SO(2) symmetry for cyclic phenomena
  OMEGA_SO2: 1 / (2 * PI),  // ≈ 0.159

  // Biological rhythms
  OMEGA_HEART: 0.25,        // Cardiac cycle threshold
  OMEGA_BREATH: 0.35,       // Respiratory cycle
  OMEGA_EI: 0.18,           // Excitatory-Inhibitory balance

  // Environmental
  OMEGA_FIRE: 0.22,         // Combustion dynamics
  OMEGA_FLOCK: 0.30,        // Collective behavior
  OMEGA_LAMP: 0.15,         // Flickering threshold

  // Cosmic
  OMEGA_BLACKHOLE: 0.08,    // Event horizon dynamics

  /**
   * The fundamental CRR equations:
   *
   * COHERENCE: C(x,t) = ∫₀ᵗ L(x,τ) dτ
   *   - Accumulates integration over time
   *   - L(x,τ) is the memory density (learning rate)
   *
   * RUPTURE: δ(t-t₀) when C ≥ Ω
   *   - Instantaneous discontinuity
   *   - The "choice moment" - scale-invariant
   *
   * REGENERATION: R[χ](x,t) = ∫₀ᵗ φ(x,τ)·exp(C(x,τ)/Ω)·Θ(t-τ) dτ
   *   - exp(C/Ω) creates differential memory weighting
   *   - High-coherence moments weighted more heavily
   *
   * FEP CORRESPONDENCE:
   *   - Precision Π = (1/Ω)·exp(C/Ω)
   *   - C = F₀ - F(t) (coherence = free energy reduction)
   *   - Rupture occurs at Bayes factor threshold
   */
};

// ============================================================================
// CRR SYSTEM CLASS - Universal Implementation
// ============================================================================
class CRRSystem {
  constructor(omega, learningRate = 0.1, name = 'unnamed') {
    this.omega = omega;
    this.learningRate = learningRate;
    this.name = name;

    // State
    this.coherence = 0;
    this.state = 'coherence'; // coherence | rupture | regeneration
    this.amplitude = 0;
    this.phi = 1; // Reconstruction resources

    // History for regeneration
    this.coherenceHistory = [];
    this.maxHistoryLength = 100;
    this.lastRuptureTime = 0;
    this.ruptureCount = 0;
  }

  /**
   * Update the CRR system
   * @param {number} dt - Time delta
   * @param {number} attention - Learning signal (precision proxy)
   * @param {number} globalTime - For history tracking
   */
  update(dt, attention = 1, globalTime = 0) {
    if (this.state === 'coherence') {
      // COHERENCE: C(x,t) = ∫L(x,τ)dτ
      const dC = this.learningRate * attention * dt;
      this.coherence += dC;

      // Track history for memory-weighted regeneration
      this.coherenceHistory.push({ t: globalTime, C: this.coherence });
      if (this.coherenceHistory.length > this.maxHistoryLength) {
        this.coherenceHistory.shift();
      }

      this.amplitude = min(1, this.coherence / this.omega);

      // RUPTURE threshold: C ≥ Ω
      if (this.coherence >= this.omega) {
        this.state = 'rupture';
        this.lastRuptureTime = globalTime;
        this.ruptureCount++;
      }

    } else if (this.state === 'rupture') {
      // RUPTURE: δ(now) - instantaneous
      this.amplitude = 1.0;
      this.state = 'regeneration';

    } else {
      // REGENERATION: R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ
      const memoryWeight = this.getMemoryWeight();
      this.phi = min(1, this.phi + dt * 0.5);

      // Decay modulated by memory weight
      const decayRate = 2 * exp(-memoryWeight * 0.5);
      this.coherence *= exp(-decayRate * dt);
      this.amplitude = this.coherence / this.omega;

      if (this.coherence < 0.01 * this.omega) {
        this.coherence = 0;
        this.state = 'coherence';
        this.coherenceHistory = [];
      }
    }

    return this.amplitude;
  }

  /**
   * Calculate exp(C/Ω) - the key CRR memory weighting
   */
  getMemoryWeight() {
    const exponent = min(this.coherence / this.omega, 5);
    return exp(exponent);
  }

  /**
   * Get precision (FEP correspondence)
   * Π = (1/Ω)·exp(C/Ω)
   */
  getPrecision() {
    return (1 / this.omega) * this.getMemoryWeight();
  }

  /**
   * Get coefficient of variation
   */
  getCV() {
    return this.omega / 2;
  }

  /**
   * Reset to initial state
   */
  reset() {
    this.coherence = 0;
    this.state = 'coherence';
    this.amplitude = 0;
    this.coherenceHistory = [];
  }
}

// ============================================================================
// CANVAS & GLOBALS
// ============================================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W, H, horizonY, forestY, time = 0, dayTime = 12;

function initCanvas() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);
  horizonY = H * 0.52;
  forestY = H * 0.62;
}

// ============================================================================
// CRR SYSTEMS - All Environmental Components
// ============================================================================

// Day-Night Cycle
const dayNightCRR = new CRRSystem(CRR.OMEGA_SO2, 0.08, 'DayNight');

// Houses with fires
const houses = [];
const NUM_HOUSES = 3;

// Street lamps
const lamps = [];
const NUM_LAMPS = 4;

// Characters (professor and student)
const characters = {
  professor: {
    x: 0, y: 0,
    heart: new CRRSystem(CRR.OMEGA_HEART, 0.8, 'ProfHeart'),
    lungs: new CRRSystem(CRR.OMEGA_BREATH, 0.4, 'ProfLungs'),
    brain: new CRRSystem(CRR.OMEGA_EI, 0.3, 'ProfBrain'),
    walking: false,
    targetX: 0
  },
  student: {
    x: 0, y: 0,
    heart: new CRRSystem(CRR.OMEGA_HEART, 0.9, 'StudentHeart'),
    lungs: new CRRSystem(CRR.OMEGA_BREATH, 0.45, 'StudentLungs'),
    brain: new CRRSystem(CRR.OMEGA_EI, 0.35, 'StudentBrain'),
    walking: false,
    targetX: 0
  }
};

// Starling murmuration (CRR-driven, not boid)
const murmurationCRR = new CRRSystem(CRR.OMEGA_FLOCK, 0.15, 'Murmuration');
let starlings = [];
const STARLING_COUNT = 300;

// Black hole
const blackHoleCRR = new CRRSystem(CRR.OMEGA_BLACKHOLE, 0.05, 'BlackHole');
let blackHoleActive = false;
let blackHoleIntensity = 0;

// Rainbow
let rainbowActive = false;
let rainbowIntensity = 0;

// Stars
let stars = [];

// ============================================================================
// NARRATIVE SYSTEM
// ============================================================================
const NARRATIVE = [
  // Scene 0: Introduction
  {
    speaker: null,
    dialogue: null,
    setup: (scene) => {
      // Evening setting
      dayTime = 18.5;
      characters.professor.x = W * 0.3;
      characters.professor.y = H * 0.78;
      characters.student.x = W * 0.25;
      characters.student.y = H * 0.78;
    },
    explanation: null,
    duration: 4000,
    showCRR: false
  },

  // Scene 1: Meeting
  {
    speaker: 'student',
    dialogue: "Professor, I've been watching this world all day. The light changes, the birds move in waves, the fires flicker... it all feels so alive. What makes it work?",
    setup: null,
    explanation: null,
    duration: 8000,
    showCRR: false
  },

  // Scene 2: The Revelation
  {
    speaker: 'professor',
    dialogue: "Ah, you've sensed it. This entire world - every rhythm, every transition, every living pulse - runs on a single temporal grammar. We call it CRR: Coherence-Rupture-Regeneration.",
    setup: (scene) => {
      document.getElementById('crrPanel').classList.add('visible');
    },
    explanation: {
      layperson: "CRR is a three-phase cycle that governs how systems accumulate, release, and rebuild over time.",
      fep: "C(x,t) = ∫L(x,τ)dτ | δ(t-t₀) when C≥Ω | R = ∫φ·exp(C/Ω)·Θ dτ"
    },
    duration: 12000,
    showCRR: true
  },

  // Scene 3: Day-Night
  {
    speaker: 'professor',
    dialogue: "Watch the sky. The day-night cycle isn't a simple gradient - it's a CRR system. Coherence builds through the hours, ruptures at dawn and dusk, then regenerates into the new phase.",
    setup: (scene) => {
      // Accelerate day-night for demonstration
    },
    explanation: {
      layperson: "Dawn and dusk are rupture events - moments when the accumulated 'dayness' or 'nightness' crosses a threshold and the system reorganizes.",
      fep: "Ω = 1/2π (SO(2) symmetry) | Rupture at C = Ω marks phase transition | exp(C/Ω) weights how 'committed' the sky is to its current state"
    },
    duration: 10000,
    showCRR: true,
    highlight: 'daynight'
  },

  // Scene 4: Houses and Fire
  {
    speaker: 'student',
    dialogue: "The chimneys... I see smoke rising. Are the fires inside running on CRR too?",
    setup: null,
    explanation: null,
    duration: 5000,
    showCRR: true
  },

  // Scene 5: Fire Explanation
  {
    speaker: 'professor',
    dialogue: "Precisely. Each flame is a CRR cycle - fuel coherence builds, then ruptures in combustion, regenerating as the reaction seeks new fuel. The flickering you see is many tiny rupture events cascading.",
    setup: null,
    explanation: {
      layperson: "Fire doesn't burn smoothly - it's a series of micro-explosions. Each flicker is a rupture event where accumulated chemical energy releases suddenly.",
      fep: "Ω_fire ≈ 0.22 | Precision Π = (1/Ω)·exp(C/Ω) governs flame stability | Low Ω = more ruptures = more flicker"
    },
    duration: 11000,
    showCRR: true,
    highlight: 'fire'
  },

  // Scene 6: The Circulatory System
  {
    speaker: 'professor',
    dialogue: "But CRR isn't just in the environment. It's inside us. Feel your heartbeat - that's the most fundamental CRR rhythm in your body.",
    setup: null,
    explanation: {
      layperson: "Your heart accumulates electrical potential (coherence), ruptures in contraction (the beat), then regenerates as it relaxes and refills.",
      fep: "Cardiac Ω ≈ 0.25 | Coherence = diastolic filling | Rupture = systolic contraction | Regeneration = repolarization"
    },
    duration: 10000,
    showCRR: true,
    highlight: 'heart'
  },

  // Scene 7: Brain E-I Networks
  {
    speaker: 'student',
    dialogue: "And our thoughts? Our brains?",
    setup: null,
    explanation: null,
    duration: 4000,
    showCRR: true
  },

  // Scene 8: E-I Balance
  {
    speaker: 'professor',
    dialogue: "The brain runs on excitation-inhibition balance - another CRR system. Excitatory signals build coherence until inhibition ruptures the pattern, allowing regeneration into new thoughts. Consciousness itself may be a CRR phenomenon.",
    setup: null,
    explanation: {
      layperson: "Your thoughts form as neural coherence builds, then 'break' (rupture) to allow new thoughts. The spacing of these ruptures creates your stream of consciousness.",
      fep: "E-I balance: Ω_brain ≈ 0.18 | Gamma oscillations (~40Hz) = rapid CRR cycling | exp(C/Ω) = attention/precision"
    },
    duration: 12000,
    showCRR: true,
    highlight: 'brain'
  },

  // Scene 9: Murmuration
  {
    speaker: 'professor',
    dialogue: "Now watch the starlings. Traditional science would say they follow 'boid rules' - separation, alignment, cohesion. But look deeper: the flock is a single CRR organism.",
    setup: (scene) => {
      // Trigger murmuration display
    },
    explanation: {
      layperson: "The flock builds collective coherence until a rupture event - a predator, a wind shift, or just reaching threshold - causes the dramatic shape-shifting we see as a murmuration.",
      fep: "Flock Ω ≈ 0.30 | Each bird's position = sample from shared generative model | Rupture = collective belief update | Regeneration = new formation"
    },
    duration: 12000,
    showCRR: true,
    highlight: 'flock'
  },

  // Scene 10: Street Lamps
  {
    speaker: 'student',
    dialogue: "Even the street lamps seem to breathe...",
    setup: null,
    explanation: null,
    duration: 4000,
    showCRR: true
  },

  // Scene 11: Lamp Explanation
  {
    speaker: 'professor',
    dialogue: "Gas lamps, candles, even LEDs with their thermal fluctuations - all CRR. The glow builds, micro-ruptures in the excitation cascade, regenerates. The apparent steadiness is many tiny cycles averaging out.",
    setup: null,
    explanation: {
      layperson: "What looks like steady light is actually rapid coherence-rupture-regeneration cycles happening faster than your eye can see.",
      fep: "Lamp Ω ≈ 0.15 | High-frequency ruptures → apparent stability | Variance in timing = visible flicker"
    },
    duration: 10000,
    showCRR: true,
    highlight: 'lamp'
  },

  // Scene 12: Black Hole Appears
  {
    speaker: 'professor',
    dialogue: "But CRR extends beyond Earth. Look up - I'll show you something cosmic.",
    setup: (scene) => {
      blackHoleActive = true;
      dayTime = 22; // Make it night
    },
    explanation: null,
    duration: 6000,
    showCRR: true
  },

  // Scene 13: Black Hole Explanation
  {
    speaker: 'professor',
    dialogue: "A black hole. The ultimate rupture - where coherence accumulates to such density that spacetime itself ruptures. The event horizon is the Ω threshold made manifest in geometry.",
    setup: null,
    explanation: {
      layperson: "Black holes are where gravity's coherence crosses a threshold so extreme that not even light can escape the rupture zone.",
      fep: "Ω_horizon ≈ 0.08 | Hawking radiation = regeneration from quantum fluctuations | Information paradox = what happens to coherence history?"
    },
    duration: 12000,
    showCRR: true,
    highlight: 'blackhole'
  },

  // Scene 14: Calendar/Time
  {
    speaker: 'student',
    dialogue: "This is extraordinary. Does it mean... time itself is CRR?",
    setup: (scene) => {
      document.getElementById('calendarDisplay').classList.add('visible');
    },
    explanation: null,
    duration: 5000,
    showCRR: true
  },

  // Scene 15: Calendar Explanation
  {
    speaker: 'professor',
    dialogue: "The calendar - days, months, seasons, years - all CRR cycles nested within each other. Each scale has its own Ω. The solstices and equinoxes are rupture events in the annual cycle.",
    setup: null,
    explanation: {
      layperson: "The year doesn't flow smoothly - it accumulates toward seasonal transitions (ruptures) then regenerates into the new season. Your birthday, holidays, anniversaries - all mark rupture points in personal time.",
      fep: "Annual Ω = 1/2π (SO(2) rotation) | Seasonal transitions = rupture events | Cultural calendars = shared coherence markers"
    },
    duration: 12000,
    showCRR: true
  },

  // Scene 16: Process Philosophy
  {
    speaker: 'professor',
    dialogue: "This connects to something ancient. The process philosophers understood it - Whitehead, Bergson, Heraclitus. Reality isn't made of things, but of events. CRR is the grammar of becoming.",
    setup: (scene) => {
      showPhilosophyQuote(
        "The world is made of events, not things. What endures is not substance but rhythm.",
        "Alfred North Whitehead"
      );
    },
    explanation: {
      layperson: "Process philosophy says the universe is fundamentally about change, not static objects. CRR formalizes this: everything is a process of coherence building toward rupture, then regenerating.",
      fep: "Whitehead's 'actual occasions' = CRR events | Prehension = coherence accumulation | Concrescence = rupture | Transition = regeneration"
    },
    duration: 14000,
    showCRR: true
  },

  // Scene 17: The Spiritual Resonance (slightly embarrassing)
  {
    speaker: 'student',
    dialogue: "Professor... this might sound strange, but it feels almost spiritual. Like there's a rhythm to existence itself.",
    setup: null,
    explanation: null,
    duration: 6000,
    showCRR: true
  },

  // Scene 18: Spiritual Acknowledgment
  {
    speaker: 'professor',
    dialogue: "I... yes. I admit there's something slightly embarrassing about this. CRR does seem to echo ancient wisdom - the breath of Brahman, the pulse of the Tao, the Christian rhythm of death and resurrection. Perhaps mathematics and mysticism are two languages for the same truth.",
    setup: (scene) => {
      showPhilosophyQuote(
        "The Tao that can be told is not the eternal Tao... Yet mystery and manifestations arise from the same source.",
        "Lao Tzu"
      );
    },
    explanation: {
      layperson: "Many spiritual traditions describe reality as rhythmic - breath, heartbeat, cycles of creation and dissolution. CRR might be the mathematical structure they intuited.",
      fep: "The 'embarrassment' is that rigorous math and mystical insight converge on the same structure. Either reality has this shape, or human minds project it everywhere."
    },
    duration: 14000,
    showCRR: true
  },

  // Scene 19: Rainbow Appears
  {
    speaker: 'professor',
    dialogue: "And sometimes, when conditions align just so - when light coherence meets rain, rupturing into its spectrum, regenerating as unified perception - we see...",
    setup: (scene) => {
      rainbowActive = true;
      dayTime = 17; // Late afternoon
    },
    explanation: null,
    duration: 8000,
    showCRR: true
  },

  // Scene 20: Rainbow Finale
  {
    speaker: 'professor',
    dialogue: "A rainbow. The visible proof that rupture creates beauty. That from coherence breaking comes something more than the sum of parts. This is CRR's gift: discontinuity is not failure - it is creation.",
    setup: null,
    explanation: {
      layperson: "A rainbow is white light rupturing into its component wavelengths, each color a different coherence state made visible.",
      fep: "Light coherence C(λ) = ∫L(λ,τ)dτ | Refraction = wavelength-dependent rupture | Your perception = regeneration into unified experience"
    },
    duration: 12000,
    showCRR: true
  },

  // Scene 21: Closing
  {
    speaker: 'student',
    dialogue: "So everything - the sky, the fire, my heart, my thoughts, the birds, even time itself - it's all CRR?",
    setup: null,
    explanation: null,
    duration: 5000,
    showCRR: true
  },

  // Scene 22: Final Word
  {
    speaker: 'professor',
    dialogue: "A coarse-grain temporal grammar, yes. Not the only truth, but perhaps a useful one. The universe seems to like this pattern: gather, release, rebuild. Coherence, rupture, regeneration. Now you see it everywhere - because it is everywhere.",
    setup: (scene) => {
      showPhilosophyQuote(
        "The eye with which I see God is the same eye with which God sees me.",
        "Meister Eckhart"
      );
    },
    explanation: {
      layperson: "CRR isn't a metaphor - it's a mathematical framework that appears across scales from quantum to cosmic. Once you see it, you can't unsee it.",
      fep: "Universal structure: C = ∫L dτ → δ when C≥Ω → R = ∫φ·exp(C/Ω)·Θ dτ | The simplest grammar that captures discontinuous change."
    },
    duration: 15000,
    showCRR: true
  }
];

let currentScene = 0;
let sceneTimer = 0;
let autoAdvance = true;

function showPhilosophyQuote(text, author) {
  const quote = document.getElementById('philosophyQuote');
  document.getElementById('quoteText').textContent = `"${text}"`;
  document.getElementById('quoteCite').textContent = `— ${author}`;
  quote.classList.add('visible');
  setTimeout(() => quote.classList.remove('visible'), 10000);
}

function updateNarrative() {
  const scene = NARRATIVE[currentScene];
  const container = document.getElementById('dialogueContainer');
  const overlay = document.getElementById('narrativeOverlay');

  container.innerHTML = '';

  if (scene.speaker && scene.dialogue) {
    const speakerDiv = document.createElement('div');
    speakerDiv.className = `speaker ${scene.speaker}`;
    speakerDiv.textContent = scene.speaker === 'professor' ? 'Professor' : 'Student';
    container.appendChild(speakerDiv);

    const dialogueDiv = document.createElement('div');
    dialogueDiv.className = 'dialogue';
    dialogueDiv.textContent = scene.dialogue;
    container.appendChild(dialogueDiv);

    if (scene.explanation) {
      const expBox = document.createElement('div');
      expBox.className = 'explanation-box';
      expBox.innerHTML = `
        <div class="layperson">${scene.explanation.layperson}</div>
        <div class="fep">${scene.explanation.fep}</div>
      `;
      container.appendChild(expBox);
    }

    overlay.classList.add('visible');
  } else {
    overlay.classList.remove('visible');
  }

  if (scene.setup) {
    scene.setup(scene);
  }

  document.getElementById('sceneNum').textContent = currentScene + 1;
}

function nextScene() {
  if (currentScene < NARRATIVE.length - 1) {
    currentScene++;
    sceneTimer = 0;
    updateNarrative();
  }
}

function prevScene() {
  if (currentScene > 0) {
    currentScene--;
    sceneTimer = 0;
    updateNarrative();
  }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

function initHouses() {
  houses.length = 0;
  const positions = [0.2, 0.5, 0.8];

  for (let i = 0; i < NUM_HOUSES; i++) {
    houses.push({
      x: W * positions[i],
      y: H * 0.72,
      width: W * 0.08,
      height: H * 0.12,
      fire: new CRRSystem(CRR.OMEGA_FIRE, 0.4 + random() * 0.2, `Fire${i}`),
      smokeParticles: []
    });
  }
}

function initLamps() {
  lamps.length = 0;
  const positions = [0.15, 0.38, 0.62, 0.85];

  for (let i = 0; i < NUM_LAMPS; i++) {
    lamps.push({
      x: W * positions[i],
      y: H * 0.75,
      crr: new CRRSystem(CRR.OMEGA_LAMP, 0.3 + random() * 0.15, `Lamp${i}`),
      phase: random() * PI2
    });
  }
}

function initStarlings() {
  starlings = [];
  const cx = W * 0.5, cy = horizonY - H * 0.15;

  for (let i = 0; i < STARLING_COUNT; i++) {
    const angle = random() * PI2;
    const dist = random() * W * 0.12;
    starlings.push({
      x: cx + cos(angle) * dist,
      y: cy + sin(angle) * dist * 0.5,
      vx: (random() - 0.5) * 30,
      vy: (random() - 0.5) * 20,
      phase: random() * PI2,
      coherenceOffset: random(),
      size: 1.5 + random() * 0.8
    });
  }
}

function initStars() {
  stars = [];
  const count = floor((W * horizonY) / 3000);
  for (let i = 0; i < count; i++) {
    stars.push({
      x: random() * W,
      y: random() * horizonY * 0.9,
      size: 0.5 + random() * 1.5,
      brightness: 0.3 + random() * 0.7,
      twinkleSpeed: 1 + random() * 2,
      twinklePhase: random() * PI2
    });
  }
}

// ============================================================================
// SKY & ENVIRONMENT RENDERING
// ============================================================================

function getSkyColors(dayTime) {
  // CRR-driven color transitions
  const dayNightAmplitude = dayNightCRR.amplitude;
  const memoryWeight = dayNightCRR.getMemoryWeight();

  let ambient, skyTop, skyMid, skyBot;

  if (dayTime >= 6 && dayTime < 12) {
    // Morning
    const t = (dayTime - 6) / 6;
    ambient = 0.3 + t * 0.7;
    skyTop = lerpColor({r:30,g:40,b:80}, {r:100,g:150,b:220}, t * memoryWeight);
    skyMid = lerpColor({r:80,g:100,b:140}, {r:150,g:190,b:230}, t * memoryWeight);
    skyBot = lerpColor({r:200,g:150,b:120}, {r:200,g:210,b:220}, t);
  } else if (dayTime >= 12 && dayTime < 17) {
    // Afternoon
    ambient = 1.0;
    skyTop = {r:100,g:150,b:220};
    skyMid = {r:150,g:190,b:230};
    skyBot = {r:200,g:210,b:220};
  } else if (dayTime >= 17 && dayTime < 20) {
    // Evening
    const t = (dayTime - 17) / 3;
    ambient = 1.0 - t * 0.6;
    skyTop = lerpColor({r:100,g:150,b:220}, {r:40,g:50,b:100}, t);
    skyMid = lerpColor({r:150,g:190,b:230}, {r:180,g:100,b:80}, t * 0.7);
    skyBot = lerpColor({r:200,g:210,b:220}, {r:220,g:120,b:80}, t);
  } else if (dayTime >= 20 || dayTime < 5) {
    // Night
    ambient = 0.15;
    skyTop = {r:15,g:20,b:40};
    skyMid = {r:25,g:30,b:55};
    skyBot = {r:35,g:40,b:60};
  } else {
    // Dawn
    const t = (dayTime - 5) / 1;
    ambient = 0.15 + t * 0.15;
    skyTop = lerpColor({r:15,g:20,b:40}, {r:30,g:40,b:80}, t);
    skyMid = lerpColor({r:25,g:30,b:55}, {r:80,g:100,b:140}, t);
    skyBot = lerpColor({r:35,g:40,b:60}, {r:200,g:150,b:120}, t);
  }

  return { ambient, skyTop, skyMid, skyBot };
}

function drawSky(colors) {
  const grad = ctx.createLinearGradient(0, 0, 0, horizonY);
  grad.addColorStop(0, rgba(colors.skyTop, 1));
  grad.addColorStop(0.5, rgba(colors.skyMid, 1));
  grad.addColorStop(1, rgba(colors.skyBot, 1));
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, horizonY);
}

function drawStars(ambient) {
  if (ambient > 0.4) return;
  const visibility = 1 - ambient * 2.5;

  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const twinkle = 0.7 + sin(time * s.twinkleSpeed + s.twinklePhase) * 0.3;
    const alpha = s.brightness * visibility * twinkle;
    if (alpha < 0.05) continue;

    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, PI2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawGround(colors) {
  const groundColor = lerpColor({r:80,g:100,b:70}, {r:40,g:50,b:35}, 1 - colors.ambient);

  const grad = ctx.createLinearGradient(0, horizonY, 0, H);
  grad.addColorStop(0, rgba(groundColor, 1));
  grad.addColorStop(1, rgba(lerpColor(groundColor, {r:30,g:35,b:25}, 0.3), 1));
  ctx.fillStyle = grad;
  ctx.fillRect(0, horizonY, W, H - horizonY);

  // Path
  ctx.fillStyle = `rgba(60, 55, 45, ${0.4 + colors.ambient * 0.3})`;
  ctx.beginPath();
  ctx.moveTo(0, H * 0.82);
  ctx.quadraticCurveTo(W * 0.3, H * 0.78, W * 0.5, H * 0.80);
  ctx.quadraticCurveTo(W * 0.7, H * 0.82, W, H * 0.79);
  ctx.lineTo(W, H * 0.85);
  ctx.quadraticCurveTo(W * 0.7, H * 0.87, W * 0.5, H * 0.85);
  ctx.quadraticCurveTo(W * 0.3, H * 0.83, 0, H * 0.87);
  ctx.closePath();
  ctx.fill();
}

// ============================================================================
// TREES (Preserved from forest-seasonal aesthetic)
// ============================================================================

function drawTree(x, y, height, colors) {
  const trunkWidth = height * 0.08;
  const trunkColor = lerpColor({r:60,g:50,b:40}, {r:40,g:35,b:25}, 1 - colors.ambient);

  // Trunk
  ctx.fillStyle = rgba(trunkColor, 1);
  ctx.beginPath();
  ctx.moveTo(x - trunkWidth/2, y);
  ctx.lineTo(x - trunkWidth/3, y - height * 0.4);
  ctx.lineTo(x + trunkWidth/3, y - height * 0.4);
  ctx.lineTo(x + trunkWidth/2, y);
  ctx.closePath();
  ctx.fill();

  // Branches
  const branchColor = lerpColor({r:50,g:45,b:35}, {r:35,g:30,b:22}, 1 - colors.ambient);
  ctx.strokeStyle = rgba(branchColor, 1);
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';

  function drawBranch(bx, by, length, angle, depth) {
    if (depth > 5) return;

    const endX = bx + cos(angle) * length;
    const endY = by + sin(angle) * length;

    ctx.beginPath();
    ctx.moveTo(bx, by);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    if (depth < 5) {
      const newLen = length * (0.6 + random() * 0.2);
      drawBranch(endX, endY, newLen, angle - 0.4 - random() * 0.3, depth + 1);
      drawBranch(endX, endY, newLen, angle + 0.4 + random() * 0.3, depth + 1);
    }
  }

  const baseY = y - height * 0.35;
  ctx.lineWidth = 3;
  drawBranch(x, baseY, height * 0.25, -PI/2 - 0.3, 0);
  drawBranch(x, baseY, height * 0.25, -PI/2 + 0.3, 0);
  drawBranch(x, baseY - height * 0.1, height * 0.2, -PI/2, 0);
}

function drawForest(colors) {
  // Background trees
  for (let i = 0; i < 12; i++) {
    const x = W * (0.05 + i * 0.08 + (random() - 0.5) * 0.03);
    const h = H * (0.15 + random() * 0.08);
    drawTree(x, forestY + random() * 10, h, colors);
  }
}

// ============================================================================
// HOUSES WITH CRR FIRES
// ============================================================================

function updateHouses(dt) {
  for (const house of houses) {
    // Update fire CRR
    house.fire.update(dt, 1 + sin(time * 2) * 0.3, time);

    // Generate smoke based on fire state
    if (random() < 0.3 + house.fire.amplitude * 0.5) {
      house.smokeParticles.push({
        x: house.x + house.width * 0.7,
        y: house.y - house.height * 0.9,
        vx: (random() - 0.5) * 10,
        vy: -15 - random() * 20,
        size: 3 + random() * 5,
        life: 1,
        intensity: house.fire.amplitude
      });
    }

    // Update smoke
    for (let i = house.smokeParticles.length - 1; i >= 0; i--) {
      const p = house.smokeParticles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy *= 0.98;
      p.vx += (random() - 0.5) * 5 * dt;
      p.size += 3 * dt;
      p.life -= 0.4 * dt;

      if (p.life <= 0) {
        house.smokeParticles.splice(i, 1);
      }
    }
  }
}

function drawHouses(colors) {
  for (const house of houses) {
    const x = house.x;
    const y = house.y;
    const w = house.width;
    const h = house.height;

    // House body
    const wallColor = lerpColor({r:120,g:100,b:80}, {r:60,g:50,b:40}, 1 - colors.ambient);
    ctx.fillStyle = rgba(wallColor, 1);
    ctx.fillRect(x - w/2, y - h, w, h);

    // Roof
    const roofColor = lerpColor({r:80,g:60,b:50}, {r:40,g:30,b:25}, 1 - colors.ambient);
    ctx.fillStyle = rgba(roofColor, 1);
    ctx.beginPath();
    ctx.moveTo(x - w/2 - w*0.1, y - h);
    ctx.lineTo(x, y - h - h*0.5);
    ctx.lineTo(x + w/2 + w*0.1, y - h);
    ctx.closePath();
    ctx.fill();

    // Chimney
    ctx.fillStyle = rgba(lerpColor(roofColor, {r:100,g:80,b:70}, 0.3), 1);
    const chimneyX = x + w * 0.25;
    const chimneyW = w * 0.15;
    const chimneyH = h * 0.3;
    ctx.fillRect(chimneyX - chimneyW/2, y - h - h*0.3 - chimneyH, chimneyW, chimneyH + h*0.1);

    // Window with fire glow
    const fireIntensity = house.fire.amplitude;
    const windowGlow = fireIntensity * colors.ambient;

    ctx.fillStyle = `rgba(${180 + fireIntensity * 75}, ${120 + fireIntensity * 60}, ${50}, ${0.3 + windowGlow * 0.5})`;
    ctx.fillRect(x - w*0.15, y - h*0.7, w*0.3, w*0.25);

    // Fire glow effect from window
    if (fireIntensity > 0.3) {
      const glowGrad = ctx.createRadialGradient(x, y - h*0.5, 0, x, y - h*0.5, w);
      glowGrad.addColorStop(0, `rgba(255, 150, 50, ${fireIntensity * 0.15})`);
      glowGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = glowGrad;
      ctx.fillRect(x - w, y - h, w*2, h);
    }

    // Draw smoke
    for (const p of house.smokeParticles) {
      const alpha = p.life * 0.4 * p.intensity;
      ctx.fillStyle = `rgba(180, 180, 180, ${alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, PI2);
      ctx.fill();
    }
  }
}

// ============================================================================
// CRR STREET LAMPS
// ============================================================================

function updateLamps(dt) {
  for (const lamp of lamps) {
    lamp.crr.update(dt, 1 + sin(time * 3 + lamp.phase) * 0.2, time);
  }
}

function drawLamps(colors) {
  for (const lamp of lamps) {
    const x = lamp.x;
    const y = lamp.y;
    const intensity = 0.5 + lamp.crr.amplitude * 0.5;
    const scale = H * 0.0015;

    // Post
    ctx.fillStyle = `rgba(40, 35, 30, ${0.8 + colors.ambient * 0.2})`;
    ctx.fillRect(x - 3*scale, y - 80*scale, 6*scale, 80*scale);

    // Lamp housing
    ctx.fillStyle = `rgba(50, 45, 40, 1)`;
    ctx.beginPath();
    ctx.moveTo(x - 12*scale, y - 80*scale);
    ctx.lineTo(x - 15*scale, y - 95*scale);
    ctx.lineTo(x + 15*scale, y - 95*scale);
    ctx.lineTo(x + 12*scale, y - 80*scale);
    ctx.closePath();
    ctx.fill();

    // Light glow
    const isNight = colors.ambient < 0.5;
    if (isNight) {
      const glowSize = 60 * scale * intensity;
      const glowGrad = ctx.createRadialGradient(x, y - 87*scale, 0, x, y - 87*scale, glowSize);
      glowGrad.addColorStop(0, `rgba(255, 220, 150, ${intensity * 0.8})`);
      glowGrad.addColorStop(0.3, `rgba(255, 200, 100, ${intensity * 0.4})`);
      glowGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(x, y - 87*scale, glowSize, 0, PI2);
      ctx.fill();

      // Ground light pool
      const poolGrad = ctx.createRadialGradient(x, y, 0, x, y, 50*scale);
      poolGrad.addColorStop(0, `rgba(255, 220, 150, ${intensity * 0.2})`);
      poolGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = poolGrad;
      ctx.fillRect(x - 50*scale, y - 20*scale, 100*scale, 40*scale);
    }

    // Lamp glass
    ctx.fillStyle = isNight
      ? `rgba(255, 240, 200, ${0.3 + intensity * 0.5})`
      : `rgba(200, 200, 200, 0.3)`;
    ctx.beginPath();
    ctx.ellipse(x, y - 87*scale, 8*scale, 6*scale, 0, 0, PI2);
    ctx.fill();
  }
}

// ============================================================================
// CRR MURMURATION (Not Boids!)
// ============================================================================

function updateMurmuration(dt) {
  // Update global flock CRR
  murmurationCRR.update(dt, 1 + sin(time * 0.15) * 0.4, time);

  const flockC = murmurationCRR.coherence;
  const flockState = murmurationCRR.state;
  const isRupture = flockState === 'rupture';

  // Flock attractor - CRR-modulated movement
  const attractorSpeed = 0.1 + murmurationCRR.amplitude * 0.08;
  const ax = W * 0.5 + sin(time * attractorSpeed) * W * 0.25;
  const ay = horizonY - H * 0.18 + cos(time * attractorSpeed * 0.7) * H * 0.08;

  // Secondary attractor for shape complexity
  const memoryWeight = murmurationCRR.getMemoryWeight();
  const ax2 = ax + sin(time * 0.3) * W * 0.15 * min(memoryWeight, 3);
  const ay2 = ay + cos(time * 0.25) * H * 0.1 * min(memoryWeight, 3);

  for (let i = 0; i < starlings.length; i++) {
    const b = starlings[i];

    // Each bird has its own coherence offset for wave-like behavior
    const birdCoherence = (flockC + b.coherenceOffset * 0.2) % murmurationCRR.omega;
    const birdPhase = birdCoherence / murmurationCRR.omega;

    // CRR-driven velocity modulation
    // During coherence: smooth, aligned movement
    // During rupture: explosive shape change
    // During regeneration: settling into new formation

    let targetX, targetY;

    if (isRupture) {
      // Rupture: explosive expansion
      const explosionAngle = atan2(b.y - ay, b.x - ax) + (random() - 0.5) * PI;
      targetX = b.x + cos(explosionAngle) * 50;
      targetY = b.y + sin(explosionAngle) * 30;
    } else {
      // Coherence/Regeneration: flow toward attractor with wave modulation
      const waveOffset = sin(birdPhase * PI2 + time * 2) * 30;
      const chooseSecondary = sin(b.phase + time * 0.5) > 0;

      if (chooseSecondary) {
        targetX = ax2 + waveOffset;
        targetY = ay2 + cos(birdPhase * PI2 + time * 2) * 20;
      } else {
        targetX = ax + waveOffset;
        targetY = ay + cos(birdPhase * PI2 + time * 2) * 20;
      }
    }

    // Apply velocity toward target (strength modulated by CRR state)
    const coherenceStrength = flockState === 'coherence' ? 0.03 :
                              flockState === 'regeneration' ? 0.05 : 0.01;

    b.vx += (targetX - b.x) * coherenceStrength;
    b.vy += (targetY - b.y) * coherenceStrength;

    // Local separation (avoid collisions)
    for (let j = i + 1; j < min(i + 20, starlings.length); j++) {
      const other = starlings[j];
      const dx = b.x - other.x;
      const dy = b.y - other.y;
      const distSq = dx * dx + dy * dy;

      if (distSq < 400 && distSq > 0) {
        const dist = sqrt(distSq);
        const force = (20 - dist) / 20;
        b.vx += (dx / dist) * force * 0.8;
        b.vy += (dy / dist) * force * 0.8;
      }
    }

    // Boundary constraints
    if (b.x < W * 0.05) b.vx += 2;
    if (b.x > W * 0.95) b.vx -= 2;
    if (b.y < H * 0.08) b.vy += 1.5;
    if (b.y > forestY - H * 0.05) b.vy -= 1.5;

    // Damping
    b.vx *= 0.95;
    b.vy *= 0.95;

    // Speed limits
    const speed = sqrt(b.vx * b.vx + b.vy * b.vy);
    const maxSpeed = isRupture ? 80 : 50;
    if (speed > maxSpeed) {
      b.vx = (b.vx / speed) * maxSpeed;
      b.vy = (b.vy / speed) * maxSpeed;
    }

    // Update position
    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // Update wing phase
    b.phase += (8 + speed * 0.1) * dt;
  }
}

function drawMurmuration(colors) {
  const ambient = colors.ambient;

  for (const b of starlings) {
    const speed = sqrt(b.vx * b.vx + b.vy * b.vy);
    const angle = atan2(b.vy, b.vx);
    const wingFlap = sin(b.phase) * 0.5;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(angle);

    // Body
    ctx.fillStyle = `rgba(30, 35, 45, ${0.6 + ambient * 0.3})`;
    ctx.beginPath();
    ctx.ellipse(0, 0, b.size * 1.5, b.size * 0.5, 0, 0, PI2);
    ctx.fill();

    // Wings
    const wingSpan = b.size * 2.5;
    ctx.beginPath();
    ctx.moveTo(-b.size * 0.3, 0);
    ctx.quadraticCurveTo(0, -wingSpan * (0.7 + wingFlap * 0.3), b.size * 0.3, -wingSpan * 0.3 * (1 + wingFlap));
    ctx.quadraticCurveTo(0, -wingSpan * 0.2, -b.size * 0.3, 0);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-b.size * 0.3, 0);
    ctx.quadraticCurveTo(0, wingSpan * (0.7 + wingFlap * 0.3), b.size * 0.3, wingSpan * 0.3 * (1 + wingFlap));
    ctx.quadraticCurveTo(0, wingSpan * 0.2, -b.size * 0.3, 0);
    ctx.fill();

    ctx.restore();
  }
}

// ============================================================================
// CRR BLACK HOLE
// ============================================================================

function updateBlackHole(dt) {
  if (!blackHoleActive) {
    blackHoleIntensity = max(0, blackHoleIntensity - dt * 0.3);
    return;
  }

  blackHoleCRR.update(dt, 1, time);
  blackHoleIntensity = min(1, blackHoleIntensity + dt * 0.2);
}

function drawBlackHole(colors) {
  if (blackHoleIntensity < 0.01) return;

  const cx = W * 0.75;
  const cy = H * 0.2;
  const radius = H * 0.08 * blackHoleIntensity;

  // Event horizon (pure black)
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, PI2);
  ctx.fill();

  // Accretion disk
  const diskIntensity = blackHoleCRR.amplitude;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(time * 0.5);

  for (let i = 0; i < 3; i++) {
    const diskRadius = radius * (1.5 + i * 0.4);
    const grad = ctx.createRadialGradient(0, 0, radius, 0, 0, diskRadius);
    grad.addColorStop(0, `rgba(255, 150, 50, ${0.3 * diskIntensity * blackHoleIntensity})`);
    grad.addColorStop(0.5, `rgba(255, 100, 30, ${0.2 * diskIntensity * blackHoleIntensity})`);
    grad.addColorStop(1, 'transparent');

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, diskRadius, diskRadius * 0.3, 0, 0, PI2);
    ctx.fill();
  }

  ctx.restore();

  // Gravitational lensing effect (stars bent around)
  const lensRadius = radius * 2.5;
  const lensGrad = ctx.createRadialGradient(cx, cy, radius, cx, cy, lensRadius);
  lensGrad.addColorStop(0, 'rgba(0,0,0,0)');
  lensGrad.addColorStop(0.7, `rgba(100, 120, 180, ${0.1 * blackHoleIntensity})`);
  lensGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = lensGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, lensRadius, 0, PI2);
  ctx.fill();
}

// ============================================================================
// CRR RAINBOW
// ============================================================================

function drawRainbow(colors) {
  if (!rainbowActive) {
    rainbowIntensity = max(0, rainbowIntensity - 0.01);
    if (rainbowIntensity < 0.01) return;
  } else {
    rainbowIntensity = min(1, rainbowIntensity + 0.015);
  }

  const cx = W * 0.5;
  const cy = H * 0.7;
  const radius = H * 0.5;
  const bandWidth = H * 0.05;
  const numBands = 50;

  ctx.save();

  for (let i = 0; i < numBands; i++) {
    const t = i / (numBands - 1);
    const wavelength = 700 - t * (700 - 380);

    // CRR coherence at this wavelength
    const normalizedWL = t;
    const coherence = exp(-pow(normalizedWL - 0.5, 2) / 0.32) * 0.8 + 0.2;
    const memoryWeight = exp(min(coherence / CRR.OMEGA_SO2, 4));

    // Wavelength to RGB
    let r, g, b;
    if (wavelength >= 380 && wavelength < 440) {
      r = -(wavelength - 440) / 60; g = 0; b = 1;
    } else if (wavelength >= 440 && wavelength < 490) {
      r = 0; g = (wavelength - 440) / 50; b = 1;
    } else if (wavelength >= 490 && wavelength < 510) {
      r = 0; g = 1; b = -(wavelength - 510) / 20;
    } else if (wavelength >= 510 && wavelength < 580) {
      r = (wavelength - 510) / 70; g = 1; b = 0;
    } else if (wavelength >= 580 && wavelength < 645) {
      r = 1; g = -(wavelength - 645) / 65; b = 0;
    } else {
      r = 1; g = 0; b = 0;
    }

    // Edge falloff
    let factor = 1;
    if (wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / 40;
    else if (wavelength > 645) factor = 0.3 + 0.7 * (700 - wavelength) / 55;

    // Apply CRR memory weighting
    const crrFactor = (memoryWeight - 1) / (exp(4) - 1);
    const intensity = rainbowIntensity * factor * (0.6 + 0.4 * crrFactor) * colors.ambient;

    const bandRadius = radius - t * bandWidth;

    ctx.strokeStyle = `rgba(${r*255|0}, ${g*255|0}, ${b*255|0}, ${intensity * 0.5})`;
    ctx.lineWidth = bandWidth / numBands * 1.5;
    ctx.beginPath();
    ctx.arc(cx, cy, bandRadius, PI * 1.1, PI * 1.9);
    ctx.stroke();
  }

  ctx.restore();
}

// ============================================================================
// CHARACTERS (Professor and Student)
// ============================================================================

function drawCharacter(char, name, colors) {
  const x = char.x;
  const y = char.y;
  const scale = H * 0.001;
  const isProfessor = name === 'professor';

  // Update biological CRR systems
  char.heart.update(0.016, 1, time);
  char.lungs.update(0.016, 1, time);
  char.brain.update(0.016, 1, time);

  // Body color
  const bodyColor = isProfessor
    ? lerpColor({r:60,g:50,b:70}, {r:30,g:25,b:35}, 1 - colors.ambient)
    : lerpColor({r:70,g:60,b:50}, {r:35,g:30,b:25}, 1 - colors.ambient);

  // Body
  ctx.fillStyle = rgba(bodyColor, 1);
  ctx.beginPath();
  ctx.ellipse(x, y - 40*scale, 15*scale, 25*scale, 0, 0, PI2);
  ctx.fill();

  // Head
  ctx.fillStyle = `rgba(200, 170, 150, ${0.8 + colors.ambient * 0.2})`;
  ctx.beginPath();
  ctx.arc(x, y - 75*scale, 12*scale, 0, PI2);
  ctx.fill();

  // Heart glow (subtle, internal)
  const heartIntensity = char.heart.amplitude;
  if (heartIntensity > 0.5) {
    const heartGlow = ctx.createRadialGradient(x - 5*scale, y - 45*scale, 0, x - 5*scale, y - 45*scale, 20*scale);
    heartGlow.addColorStop(0, `rgba(200, 50, 50, ${(heartIntensity - 0.5) * 0.15})`);
    heartGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = heartGlow;
    ctx.fillRect(x - 25*scale, y - 65*scale, 50*scale, 50*scale);
  }

  // Brain activity indicator (subtle aura around head)
  const brainIntensity = char.brain.amplitude;
  if (brainIntensity > 0.3) {
    const brainGlow = ctx.createRadialGradient(x, y - 75*scale, 10*scale, x, y - 75*scale, 25*scale);
    brainGlow.addColorStop(0, `rgba(150, 180, 255, ${brainIntensity * 0.1})`);
    brainGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = brainGlow;
    ctx.beginPath();
    ctx.arc(x, y - 75*scale, 25*scale, 0, PI2);
    ctx.fill();
  }

  // Professor's hat
  if (isProfessor) {
    ctx.fillStyle = rgba(lerpColor({r:40,g:35,b:50}, {r:20,g:18,b:25}, 1 - colors.ambient), 1);
    ctx.fillRect(x - 15*scale, y - 90*scale, 30*scale, 5*scale);
    ctx.fillRect(x - 8*scale, y - 100*scale, 16*scale, 10*scale);
  }
}

// ============================================================================
// UI UPDATES
// ============================================================================

function updateCRRPanel() {
  // Day-Night
  document.getElementById('dayPhase').textContent = dayNightCRR.state;
  document.getElementById('dayC').textContent = dayNightCRR.coherence.toFixed(3);
  document.getElementById('dayMemory').textContent = dayNightCRR.getMemoryWeight().toFixed(2);

  // Heart (professor's)
  document.getElementById('heartPhase').textContent = characters.professor.heart.state;
  document.getElementById('heartC').textContent = characters.professor.heart.coherence.toFixed(3);
  const bpm = 60 + characters.professor.heart.ruptureCount * 2;
  document.getElementById('heartBPM').textContent = min(bpm, 90);

  // Murmuration
  document.getElementById('flockC').textContent = murmurationCRR.coherence.toFixed(3);
  document.getElementById('flockState').textContent = murmurationCRR.state;

  // Fire
  if (houses.length > 0) {
    document.getElementById('fireC').textContent = houses[0].fire.coherence.toFixed(3);
    document.getElementById('fireIntensity').textContent = houses[0].fire.amplitude.toFixed(2);
  }
}

function updateCalendar() {
  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  document.getElementById('timeDisplay').textContent =
    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

  const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  document.getElementById('dateDisplay').textContent = now.toLocaleDateString('en-US', options);
}

// ============================================================================
// MAIN LOOP
// ============================================================================

function update(dt) {
  time += dt;

  // Update day-night CRR
  dayNightCRR.update(dt * 0.1, 1, time);

  // Slowly cycle dayTime for demonstration
  dayTime += dt * 0.05; // ~20 seconds per hour
  if (dayTime >= 24) dayTime -= 24;

  // Update all systems
  updateHouses(dt);
  updateLamps(dt);
  updateMurmuration(dt);
  updateBlackHole(dt);

  // Auto-advance narrative
  if (autoAdvance) {
    sceneTimer += dt * 1000;
    const scene = NARRATIVE[currentScene];
    if (sceneTimer >= scene.duration) {
      nextScene();
    }
  }

  // Update UI
  updateCRRPanel();
}

function render() {
  const colors = getSkyColors(dayTime);

  // Sky
  drawSky(colors);
  drawStars(colors.ambient);

  // Black hole (if active)
  drawBlackHole(colors);

  // Rainbow (if active)
  drawRainbow(colors);

  // Ground
  drawGround(colors);

  // Forest
  drawForest(colors);

  // Houses
  drawHouses(colors);

  // Lamps
  drawLamps(colors);

  // Murmuration
  drawMurmuration(colors);

  // Characters
  drawCharacter(characters.professor, 'professor', colors);
  drawCharacter(characters.student, 'student', colors);
}

let lastTime = 0;
function animate(timestamp) {
  const dt = min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  update(dt);
  render();

  requestAnimationFrame(animate);
}

// ============================================================================
// INITIALIZATION & EVENT HANDLERS
// ============================================================================

function init() {
  initCanvas();
  initHouses();
  initLamps();
  initStarlings();
  initStars();

  // Position characters
  characters.professor.x = W * 0.35;
  characters.professor.y = H * 0.78;
  characters.student.x = W * 0.28;
  characters.student.y = H * 0.78;

  // Update totals
  document.getElementById('totalScenes').textContent = NARRATIVE.length;

  // Start narrative
  updateNarrative();
  updateCalendar();
  setInterval(updateCalendar, 1000);

  // Show narrative overlay after short delay
  setTimeout(() => {
    document.getElementById('narrativeOverlay').classList.add('visible');
  }, 2000);

  requestAnimationFrame(animate);
}

// Event listeners
document.getElementById('btnNext').addEventListener('click', nextScene);
document.getElementById('btnPrev').addEventListener('click', prevScene);
document.getElementById('btnAuto').addEventListener('click', function() {
  autoAdvance = !autoAdvance;
  this.classList.toggle('active', autoAdvance);
  this.textContent = autoAdvance ? 'Auto-Advance' : 'Manual Mode';
});
document.getElementById('btnToggleCRR').addEventListener('click', function() {
  const panel = document.getElementById('crrPanel');
  panel.classList.toggle('visible');
  this.textContent = panel.classList.contains('visible') ? 'Hide CRR Panel' : 'Show CRR Panel';
});

// Keyboard controls
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') nextScene();
  if (e.key === 'ArrowLeft') prevScene();
  if (e.key === 'c') document.getElementById('crrPanel').classList.toggle('visible');
  if (e.key === 'r') rainbowActive = !rainbowActive;
  if (e.key === 'b') blackHoleActive = !blackHoleActive;
});

window.addEventListener('resize', () => {
  initCanvas();
  initHouses();
  initLamps();
  initStarlings();
  initStars();
});

// Start
init();
</script>

</body>
</html>
