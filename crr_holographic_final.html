<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Holographic Certificate Generator</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fafafa;
            colour: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
        }
        
        .demo-area {
            background: white;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .controls-area {
            background: white;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        /* Mathematical Principles Section */
        .principles-section {
            background: white;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            grid-column: 1 / -1;
        }
        
        .principles-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 2px solid #6C5CE7;
            margin-bottom: 15px;
        }
        
        .principles-header h2 {
            margin: 0;
            colour: #2c3e50;
            font-size: 20px;
        }
        
        .toggle-arrow {
            font-size: 18px;
            transition: transform 0.3s ease;
            colour: #6C5CE7;
        }
        
        .toggle-arrow.expanded {
            transform: rotate(180deg);
        }
        
        .principles-content {
            display: none;
            animation: slideDown 0.3s ease;
        }
        
        .principles-content.expanded {
            display: block;
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .math-section {
            background: #f8f9fa;
            padding: 15px;
            margin: 15px 0;
        }
        
        .math-section h3 {
            margin-top: 0;
            colour: #6C5CE7;
            font-size: 16px;
        }
        
        .equation-block {
            background: white;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            font-size: 14px;
            text-align: center;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .code-example {
            background: white;
            colour: #333;
            padding: 15px;
            border: 1px solid #ddd;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 10px 0;
            overflow-x: auto;
        }
        
        .code-comment {
            colour: #008000;
        }
        
        .math-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .parameter-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .parameter-table th,
        .parameter-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .parameter-table th {
            background: #e5e5e5;
            colour: #333;
        }
        
        h1 {
            margin-top: 0;
            colour: #2c3e50;
            font-size: 24px;
        }
        
        h2 {
            colour: #34495e;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .crr-explanation {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .equation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: white;
        }
        
        #canvas {
            width: 500px;
            height: 500px;
            border: 2px solid #ddd;
            cursor: crosshair;
            display: block;
            margin: 20px auto;
        }
        
        .upload-area {
            background: #f8f9fa;
            border: 2px dashed #6C5CE7;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            background: #e8f4f8;
            border-colour: #5A4FCF;
        }
        
        .upload-area.dragover {
            background: #e8f4f8;
            border-colour: #5A4FCF;
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 24px;
            colour: #6C5CE7;
            margin-bottom: 10px;
        }
        
        .upload-text {
            colour: #666;
            font-size: 14px;
        }
        
        .file-input {
            display: none;
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 100px;
            margin-top: 10px;
        }
        
        .slider-group {
            margin-bottom: 20px;
            position: relative;
        }
        
        .slider-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            colour: #2c3e50;
        }
        
        .slider {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .slider-value {
            font-family: monospace;
            colour: #666;
            font-size: 12px;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        
        .btn {
            padding: 10px 18px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .btn-primary {
            background: #90EE90;
            colour: #333;
        }
        
        .btn-primary:hover {
            background: #7FDD7F;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: #95a5a6;
            colour: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .status {
            padding: 12px;
            background: #e8f4f8;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 15px;
        }
        
        .parameter-section {
            border-top: 1px solid #eee;
            padding-top: 15px;
            margin-top: 15px;
        }
        
        .mouse-info {
            font-size: 12px;
            colour: #666;
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
        }
        
        .memory-indicator {
            colour: #6C5CE7;
            font-weight: bold;
        }
        
        .image-controls {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Mathematical Principles Section -->
        <div class="principles-section">
            <div class="principles-header" onclick="togglePrinciples()">
                <h2>Mathematical Principles</h2>
                <span class="toggle-arrow" id="toggleArrow">‚ñº</span>
            </div>
            <div class="principles-content" id="principlesContent">
                
                <div class="math-section">
                    <h3>Core CRR Framework Implementation</h3>
                    <p>This holographic certificate generator explores the Coherence-Rupture-Renewal (CRR) mathematical framework through three computational components:</p>
                    
                    <div class="equation-block">
                        <strong>Coherence Integration:</strong><br>
                        C(x,t) = ‚à´‚ÇÄ·µó L(x,œÑ) dœÑ<br>
                        <em>where L(x,œÑ) represents the memory density function</em>
                    </div>
                    
                    <div class="equation-block">
                        <strong>Rupture Detection:</strong><br>
                        Œ¥(t-t‚ÇÄ) = Dirac delta at rupture time t‚ÇÄ<br>
                        <em>Computationally triggered via mouse interaction thresholds</em>
                    </div>
                    
                    <div class="equation-block">
                        <strong>Regeneration Operator:</strong><br>
                        R[œá](x,t) = ‚à´‚ÇÄ·µó œÜ(x,œÑ)¬∑e^(C(x)/Œ©)¬∑Œò(t-œÑ) dœÑ<br>
                        <em>Memory-weighted integration of historical field states</em>
                    </div>
                    
                    <div class="code-example">
<span class="code-comment">// CRR Implementation in Fragment Shader</span>
vec4 memory = texture(u_memory, coord);
float coherence = memory.x;  <span class="code-comment">// C(x,t)</span>
float regeneration = memory.z;  <span class="code-comment">// R[œá](x,t)</span>

<span class="code-comment">// Memory integration: ‚àÇm/‚àÇt = Œª(u - m)</span>
float newMemory = coherence + u_lambda * (u - coherence);

<span class="code-comment">// Rupture via mouse interaction</span>
if (u_disturb && length(u_mouse - coord) < 0.08) {
    float distStrength = exp(-length(u_mouse - coord) / 0.03);
    coherence *= 0.5;  <span class="code-comment">// Rupture event</span>
    regeneration += 0.4 * distStrength;  <span class="code-comment">// Regeneration</span>
}
                    </div>
                </div>
                
                <div class="math-grid">
                    <div class="math-section">
                        <h3>Reaction-Diffusion with Memory</h3>
                        <p>The pattern dynamics derive from modified Gray-Scott equations enhanced with CRR memory integration:</p>
                        
                        <div class="equation-block">
                            ‚àÇu/‚àÇt = D·µ§‚àá¬≤u - uv¬≤ + f(1-u) + Œº(m-u)<br>
                            ‚àÇv/‚àÇt = D·µ•‚àá¬≤v + uv¬≤ - (f+k)v<br>
                            ‚àÇm/‚àÇt = Œª(u - m)
                        </div>
                        
                        <table class="parameter-table">
                            <tr><th>Parameter</th><th>Value</th><th>Role</th></tr>
                            <tr><td>D·µ§</td><td>0.18</td><td>Activator diffusion</td></tr>
                            <tr><td>D·µ•</td><td>0.09</td><td>Inhibitor diffusion</td></tr>
                            <tr><td>f</td><td>0.042</td><td>Feed rate</td></tr>
                            <tr><td>k</td><td>0.066</td><td>Kill rate</td></tr>
                            <tr><td>Œª</td><td>0.035</td><td>Memory rate</td></tr>
                        </table>
                        
                        <div class="code-example">
<span class="code-comment">// Reaction-diffusion update in shader</span>
vec4 lapU = laplacian(u_texture, coord);
float uvv = u * v * v;

float dU = Du * lapU.x - uvv + u_feed * (1.0 - u);
float dV = Dv * lapU.y + uvv - (u_feed + u_kill) * v;

<span class="code-comment">// Memory-driven feedback (CRR enhancement)</span>
dU += 0.15 * (newMemory - u) * sin(coord.x * 18.0);
                        </div>
                    </div>
                    
                    <div class="math-section">
                        <h3>Holographic Interference Mathematics</h3>
                        <p>Multi-layer optical interference calculations simulate holographic visual effects:</p>
                        
                        <div class="equation-block">
                            Œ¥ = 2nd cos(Œ∏)<br>
                            <em>Optical path difference</em>
                        </div>
                        
                        <div class="equation-block">
                            I(Œª) = 0.5 + 0.5 cos(2œÄŒ¥/Œª)<br>
                            <em>Wavelength-specific intensity</em>
                        </div>
                        
                        <table class="parameter-table">
                            <tr><th>Wavelength</th><th>Value (Œºm)</th><th>Colour</th></tr>
                            <tr><td>Œª·µ£</td><td>0.65</td><td>Red</td></tr>
                            <tr><td>Œª_g</td><td>0.53</td><td>Green</td></tr>
                            <tr><td>Œª·µ¶</td><td>0.45</td><td>Blue</td></tr>
                        </table>
                        
                        <div class="code-example">
<span class="code-comment">// Multi-layer interference calculation</span>
for(int layer = 0; layer < u_depthLayers; layer++) {
    float layerThickness = 0.3 + float(layer) * 0.15;
    float layerDensity = 1.45 + float(layer) * 0.05;
    
    float pathDiff = 2.0 * layerThickness * layerDensity * cos(viewAngle);
    
    <span class="code-comment">// RGB phase calculations</span>
    float redPhase = 6.28318 * pathDiff / 0.65;
    float greenPhase = 6.28318 * pathDiff / 0.53;
    float bluePhase = 6.28318 * pathDiff / 0.45;
    
    <span class="code-comment">// Interference intensities</span>
    vec3 layerColour = vec3(
        0.5 + 0.5 * cos(redPhase),
        0.5 + 0.5 * cos(greenPhase),
        0.5 + 0.5 * cos(bluePhase)
    );
}
                        </div>
                    </div>
                </div>
                
                <div class="math-section">
                    <h3>Image Integration via CRR</h3>
                    <p>Uploaded images modulate the holographic dynamics through computational integration with the coherence field:</p>
                    
                    <div class="equation-block">
                        <strong>Image-Depth Integration:</strong><br>
                        h(x,t) = I(x) ¬∑ ‚à´‚ÇÄ·µó L(x,œÑ)¬∑‚àáœÜ(x,œÑ) dœÑ<br>
                        <em>Image brightness I(x) scales accumulated memory gradients</em>
                    </div>
                    
                    <div class="equation-block">
                        <strong>Parallax Displacement:</strong><br>
                        p(Œ∏) = [h(x) + I_depth(x)] ¬∑ tan(Œ∏) ¬∑ k_scale<br>
                        <em>Viewing-angle dependent offset based on computed depth</em>
                    </div>
                    
                    <div class="equation-block">
                        <strong>Phase Modulation:</strong><br>
                        Œ¥_total = Œ¥_base + I(x) ¬∑ Œ¥_modulation<br>
                        <em>Image data modulates optical interference phase</em>
                    </div>
                    
                    <div class="code-example">
<span class="code-comment">// Image depth calculation</span>
float calculateImageDepth(vec2 coord) {
    vec4 imageData = texture(u_image, coord);
    float brightness = dot(imageData.rgb, vec3(0.299, 0.587, 0.114));
    
    <span class="code-comment">// Edge detection for enhanced relief</span>
    vec2 epsilon = vec2(1.0 / 512.0);
    float edge = 0.0;
    edge += length(texture(u_image, coord + vec2(epsilon.x, 0.0)).rgb - imageData.rgb);
    edge += length(texture(u_image, coord - vec2(epsilon.x, 0.0)).rgb - imageData.rgb);
    
    <span class="code-comment">// Combine brightness and edge for depth</span>
    float depthValue = brightness * 0.7 + edge * 0.3;
    return depthValue * imageData.a * u_imageDepthInfluence;
}
                    </div>
                </div>
                
                <div class="math-section">
                    <h3>Dynamic Memory Signatures</h3>
                    <p>The system exhibits characteristic CRR signature types based on parameter regimes:</p>
                    
                    <div class="math-grid">
                        <div>
                            <strong>Resilient Signature:</strong><br>
                            ‚Ä¢ Œª = 0.035 (moderate memory rate)<br>
                            ‚Ä¢ Balanced rupture thresholds<br>
                            ‚Ä¢ Stable coherence oscillations<br>
                            ‚Ä¢ Self-repairing holographic patterns
                        </div>
                        <div>
                            <strong>Oscillatory Signature:</strong><br>
                            ‚Ä¢ High shimmer values (1.6+)<br>
                            ‚Ä¢ Rhythmic depth layer cycling<br>
                            ‚Ä¢ Periodic interference patterns<br>
                            ‚Ä¢ Phase-locked colour evolution
                        </div>
                    </div>
                    
                    <div class="equation-block">
                        Signature Detection: œÉ = var(C(x,t)) / mean(C(x,t))<br>
                        <em>Coherence variance-to-mean ratio</em><br>
                        œÉ < 0.3 ‚Üí Resilient | 0.3 < œÉ < 0.8 ‚Üí Oscillatory | œÉ > 0.8 ‚Üí Chaotic
                    </div>
                </div>
                
                <div class="math-section">
                    <h3>Implementation Verification</h3>
                    <p>Mathematical analysis of the CRR holographic implementation suggests consistency with expected behaviour:</p>
                    
                    <div class="code-example">
<span class="code-comment">// Stability analysis indicates:</span>
<span class="code-comment">// Eigenvalues at equilibrium (1,0): Œª‚ÇÅ = 0.892, Œª‚ÇÇ = -0.042</span>
<span class="code-comment">// System exhibits limit cycle behaviour (typical for pattern-forming systems)</span>

<span class="code-comment">// Computed values from test runs:</span>
<span class="code-comment">// Coherence accumulation over 5 time units: 2.246</span>
<span class="code-comment">// Optical path difference at 30¬∞ viewing: 0.753 Œºm</span>
<span class="code-comment">// RGB interference intensities: R=0.77, G=0.06, B=0.27</span>
<span class="code-comment">// Regeneration operator value: 13.89</span>

<span class="code-comment">// These values suggest the simulation produces plausible holographic behaviour</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="demo-area">
            <h1>CRR Holographic Certificate Generator</h1>
            
            <div class="crr-explanation">
                <strong>Transform Images into Holographic Certificates</strong><br>
                Upload logos, text, or images to create holographic security features through computational simulation:
                
                <div class="equation">
                    <strong>Image-Depth Integration:</strong> h(x,t) = I(x) ¬∑ ‚à´ L(x,œÑ)¬∑‚àáœÜ(x,œÑ) dœÑ
                </div>
                <div class="equation">
                    <strong>Parallax Displacement:</strong> p(Œ∏) = [h(x) + I_depth(x)] ¬∑ tan(Œ∏) ¬∑ k_scale
                </div>
                <div class="equation">
                    <strong>Phase Modulation:</strong> Œ¥_total = Œ¥_base + I(x) ¬∑ Œ¥_modulation
                </div>
                
                <span class="memory-indicator">Computational hologram</span> simulating certificate-grade optical effects.
            </div>
            
            <canvas id="canvas" width="512" height="512"></canvas>
            
            <div class="mouse-info">
                Move mouse to see logo parallax and depth effects.
                Click and drag to create authentication ruptures that interact with your image.
            </div>
        </div>
        
        <div class="controls-area">
            <h2>Image Upload</h2>
            
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">
                    <strong>Drop image here or click to upload</strong><br>
                    PNG, JPEG supported
                </div>
                <input type="file" class="file-input" id="fileInput" accept="image/*">
                <img id="imagePreview" class="image-preview" style="display: none;">
            </div>
            
            <div class="image-controls" id="imageControls" style="display: none;">
                <h3 style="margin-top: 0; colour: #6C5CE7;">Image Hologram Settings</h3>
                
                <div class="slider-group">
                    <label class="slider-label">Image Depth Influence</label>
                    <input type="range" class="slider" id="image-depth" min="0.0" max="2.0" step="0.1" value="1.2">
                    <div class="slider-value" id="image-depth-value">1.2</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Logo Parallax Strength</label>
                    <input type="range" class="slider" id="logo-parallax" min="0.5" max="3.0" step="0.1" value="1.8">
                    <div class="slider-value" id="logo-parallax-value">1.8</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Image Colour Influence</label>
                    <input type="range" class="slider" id="colour-influence" min="0.0" max="1.0" step="0.05" value="0.6">
                    <div class="slider-value" id="colour-influence-value">0.6</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Edge Enhancement</label>
                    <input type="range" class="slider" id="edge-enhancement" min="0.0" max="2.0" step="0.1" value="0.8">
                    <div class="slider-value" id="edge-enhancement-value">0.8</div>
                </div>
            </div>
            
            <div class="status" id="status">
                Hologram: READY | Image: NONE | Depth: 3D
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="reset()">Reset Hologram</button>
                <button class="btn btn-secondary" onclick="clearImage()">Clear Image</button>
            </div>
            
            <div class="slider-group">
                <label class="slider-label">Memory Rate (Œª)</label>
                <input type="range" class="slider" id="lambda" min="0.01" max="0.08" step="0.005" value="0.035">
                <div class="slider-value" id="lambda-value">0.035</div>
            </div>
            
            <div class="slider-group">
                <label class="slider-label">Depth Accumulation</label>
                <input type="range" class="slider" id="depth-rate" min="0.1" max="0.8" step="0.05" value="0.4">
                <div class="slider-value" id="depth-rate-value">0.4</div>
            </div>
            
            <div class="parameter-section">
                <h2>Holographic Effects</h2>
                
                <div class="slider-group">
                    <label class="slider-label">Parallax Strength</label>
                    <input type="range" class="slider" id="parallax" min="0.5" max="3.0" step="0.1" value="1.8">
                    <div class="slider-value" id="parallax-value">1.8</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Relief Height</label>
                    <input type="range" class="slider" id="relief-height" min="0.2" max="1.5" step="0.05" value="0.8">
                    <div class="slider-value" id="relief-height-value">0.8</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Depth Layers</label>
                    <input type="range" class="slider" id="depth-layers" min="2" max="6" step="1" value="4">
                    <div class="slider-value" id="depth-layers-value">4</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Holographic Shimmer</label>
                    <input type="range" class="slider" id="shimmer" min="0.8" max="2.5" step="0.1" value="1.6">
                    <div class="slider-value" id="shimmer-value">1.6</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Iridescent Intensity</label>
                    <input type="range" class="slider" id="iridescence" min="0.5" max="2.0" step="0.1" value="1.3">
                    <div class="slider-value" id="iridescence-value">1.3</div>
                </div>
            </div>
            
            <div class="parameter-section">
                <h2>Animation & Detail</h2>
                
                <div class="slider-group">
                    <label class="slider-label">Evolution Speed</label>
                    <input type="range" class="slider" id="evolution-speed" min="0.02" max="0.15" step="0.01" value="0.06">
                    <div class="slider-value" id="evolution-speed-value">0.06</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Surface Detail</label>
                    <input type="range" class="slider" id="surface-detail" min="5" max="25" step="1" value="15">
                    <div class="slider-value" id="surface-detail-value">15</div>
                </div>
                
                <div class="slider-group">
                    <label class="slider-label">Pattern Scale</label>
                    <input type="range" class="slider" id="pattern-scale" min="0.3" max="2.0" step="0.1" value="0.8">
                    <div class="slider-value" id="pattern-scale-value">0.8</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Toggle function for mathematical principles
        function togglePrinciples() {
            const content = document.getElementById('principlesContent');
            const arrow = document.getElementById('toggleArrow');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                arrow.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                arrow.classList.add('expanded');
            }
        }
        
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL2 not supported');
        }
        
        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = (a_position + 1.0) * 0.5;
            }
        `;
        
        // Enhanced holographic rendering shader with image integration
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 fragColor;
            
            uniform sampler2D u_texture;
            uniform sampler2D u_memory;
            uniform sampler2D u_image;
            uniform float u_time;
            uniform vec2 u_mouse;
            uniform float u_parallaxStrength;
            uniform float u_reliefHeight;
            uniform int u_depthLayers;
            uniform float u_layerSeparation;
            uniform float u_shimmer;
            uniform float u_iridescence;
            uniform float u_surfaceDetail;
            uniform float u_evolutionSpeed;
            uniform float u_patternScale;
            
            // Image-specific uniforms
            uniform bool u_hasImage;
            uniform float u_imageDepthInfluence;
            uniform float u_logoParallaxStrength;
            uniform float u_colourInfluence;
            uniform float u_edgeEnhancement;
            
            // Enhanced hash for holographic patterns
            float hash21(vec2 p) {
                p = fract(p * vec2(443.97, 751.73));
                p += dot(p, p + 41.45);
                return fract(p.x * p.y);
            }
            
            // Improved noise for depth fields
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = hash21(i);
                float b = hash21(i + vec2(1.0, 0.0));
                float c = hash21(i + vec2(0.0, 1.0));
                float d = hash21(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            // Multi-octave noise for complex relief
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                for(int i = 0; i < 6; i++) {
                    value += amplitude * noise(p * frequency);
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }
            
            // Calculate image-influenced depth
            float calculateImageDepth(vec2 coord) {
                if (!u_hasImage) return 0.0;
                
                vec4 imageData = texture(u_image, coord);
                float imageBrightness = dot(imageData.rgb, vec3(0.299, 0.587, 0.114));
                float imageAlpha = imageData.a;
                
                // Calculate edge detection for enhanced relief
                vec2 epsilon = vec2(1.0 / 512.0);
                float edge = 0.0;
                edge += length(texture(u_image, coord + vec2(epsilon.x, 0.0)).rgb - imageData.rgb);
                edge += length(texture(u_image, coord - vec2(epsilon.x, 0.0)).rgb - imageData.rgb);
                edge += length(texture(u_image, coord + vec2(0.0, epsilon.y)).rgb - imageData.rgb);
                edge += length(texture(u_image, coord - vec2(0.0, epsilon.y)).rgb - imageData.rgb);
                edge = clamp(edge * u_edgeEnhancement, 0.0, 1.0);
                
                // Combine brightness and edge information for depth
                float depthValue = imageBrightness * 0.7 + edge * 0.3;
                return depthValue * imageAlpha * u_imageDepthInfluence;
            }
            
            // Calculate holographic depth with image integration
            float calculateHolographicDepth(vec2 coord) {
                vec4 texData = texture(u_texture, coord);
                vec4 memData = texture(u_memory, coord);
                
                float u = texData.x;
                float v = texData.y;
                float memory = memData.x;
                float storedDepth = memData.z;
                
                vec2 scaledCoord = coord * u_patternScale;
                float time = u_time * u_evolutionSpeed;
                
                // Base relief from reaction-diffusion patterns
                float rdRelief = (u - v * 0.5) * 0.4;
                
                // Memory-driven depth accumulation
                float memoryDepth = memory * 0.6 + storedDepth * 0.8;
                
                // Multi-scale surface features
                float largeFeat = fbm(scaledCoord * 3.0 + time * 0.3) * 0.3;
                float mediumFeat = fbm(scaledCoord * 8.0 + time * 0.5) * 0.2;
                float fineFeat = fbm(scaledCoord * 20.0 + time * 0.8) * 0.1;
                
                // Holographic interference patterns
                float holoPattern1 = sin(scaledCoord.x * 12.0 + scaledCoord.y * 8.0 + time * 2.0) * 0.15;
                float holoPattern2 = sin(scaledCoord.x * 18.0 - scaledCoord.y * 14.0 + time * 1.5) * 0.1;
                
                // Add image depth influence
                float imageDepth = calculateImageDepth(coord);
                
                return (rdRelief + memoryDepth + largeFeat + mediumFeat + fineFeat + holoPattern1 + holoPattern2 + imageDepth) * u_reliefHeight;
            }
            
            // Calculate surface normal from depth
            vec3 calculateNormal(vec2 coord, float epsilon) {
                float h1 = calculateHolographicDepth(coord + vec2(epsilon, 0.0));
                float h2 = calculateHolographicDepth(coord - vec2(epsilon, 0.0));
                float h3 = calculateHolographicDepth(coord + vec2(0.0, epsilon));
                float h4 = calculateHolographicDepth(coord - vec2(0.0, epsilon));
                
                float dx = (h1 - h2) / (2.0 * epsilon);
                float dy = (h3 - h4) / (2.0 * epsilon);
                
                return normalize(vec3(dx * 20.0, dy * 20.0, 1.0));
            }
            
            // Enhanced parallax calculation with image influence
            vec2 calculateParallaxOffset(vec2 coord, vec3 viewDir) {
                float depth = calculateHolographicDepth(coord);
                float baseParallax = depth * u_parallaxStrength * 0.05;
                
                // Additional parallax for image areas
                if (u_hasImage) {
                    float imageDepth = calculateImageDepth(coord);
                    baseParallax += imageDepth * u_logoParallaxStrength * 0.03;
                }
                
                return viewDir.xy * baseParallax;
            }
            
            // Multi-layer holographic interference with image colour influence
            vec3 calculateMultiLayerInterference(vec2 coord, vec3 viewDir, vec3 normal) {
                vec3 totalColour = vec3(0.0);
                float totalWeight = 0.0;
                
                // Get image colour for influence
                vec3 imageColour = vec3(1.0);
                float imageInfluence = 0.0;
                if (u_hasImage) {
                    vec4 imageData = texture(u_image, coord);
                    imageColour = imageData.rgb;
                    imageInfluence = imageData.a * u_colourInfluence;
                }
                
                for(int layer = 0; layer < 6; layer++) {
                    if(layer >= u_depthLayers) break;
                    
                    float layerDepth = float(layer) * u_layerSeparation;
                    vec2 layerOffset = viewDir.xy * layerDepth * u_parallaxStrength * 0.02;
                    vec2 layerCoord = coord + layerOffset;
                    
                    if(layerCoord.x < 0.0 || layerCoord.x > 1.0 || layerCoord.y < 0.0 || layerCoord.y > 1.0) {
                        continue;
                    }
                    
                    // Layer-specific properties
                    float layerThickness = 0.3 + float(layer) * 0.15 + noise(layerCoord * 30.0) * 0.1;
                    float layerDensity = 1.45 + float(layer) * 0.05;
                    
                    // Optical path calculation
                    float viewAngle = acos(max(0.0, min(1.0, dot(normal, viewDir))));
                    float pathDiff = 2.0 * layerThickness * layerDensity * cos(viewAngle);
                    
                    // Wavelength-specific interference with holographic enhancement
                    float redPhase = 6.28318 * pathDiff / 0.65 + u_time * u_evolutionSpeed * (1.0 + float(layer) * 0.2);
                    float greenPhase = 6.28318 * pathDiff / 0.53 + u_time * u_evolutionSpeed * (0.8 + float(layer) * 0.15);
                    float bluePhase = 6.28318 * pathDiff / 0.45 + u_time * u_evolutionSpeed * (0.6 + float(layer) * 0.1);
                    
                    // Enhanced interference with memory modulation
                    vec4 memData = texture(u_memory, layerCoord);
                    float memoryMod = memData.x * 3.14159;
                    
                    float redInt = 0.5 + 0.5 * cos(redPhase + memoryMod);
                    float greenInt = 0.5 + 0.5 * cos(greenPhase + memoryMod * 0.7);
                    float blueInt = 0.5 + 0.5 * cos(bluePhase + memoryMod * 0.4);
                    
                    // Layer colour with holographic characteristics
                    vec3 layerColour = vec3(redInt, greenInt, blueInt) * u_iridescence;
                    
                    // Blend with image colours where present
                    if (u_hasImage) {
                        layerColour = mix(layerColour, layerColour * imageColour, imageInfluence);
                    }
                    
                    // Add holographic shimmer
                    float shimmerPhase = u_time * u_evolutionSpeed * 3.0 + layerCoord.x * 20.0 + layerCoord.y * 15.0;
                    vec3 shimmer = vec3(
                        0.3 + 0.7 * abs(sin(shimmerPhase)),
                        0.3 + 0.7 * abs(sin(shimmerPhase + 2.094)),
                        0.3 + 0.7 * abs(sin(shimmerPhase + 4.188))
                    ) * u_shimmer * 0.4;
                    
                    layerColour += shimmer;
                    
                    // Layer weight based on depth and viewing angle
                    float layerWeight = exp(-float(layer) * 0.3) * (1.0 - viewAngle / 3.14159);
                    
                    totalColour += layerColour * layerWeight;
                    totalWeight += layerWeight;
                }
                
                return totalColour / max(totalWeight, 0.1);
            }
            
            void main() {
                vec2 coord = v_texCoord;
                
                // Calculate viewing direction from mouse position
                vec2 mouseOffset = u_mouse - coord;
                float mouseDistance = length(mouseOffset);
                vec3 viewDir = normalize(vec3(mouseOffset * (2.0 - mouseDistance), 0.4 + 0.6 * (1.0 - mouseDistance)));
                
                // Calculate holographic depth
                float depth = calculateHolographicDepth(coord);
                
                // Apply parallax offset
                vec2 parallaxOffset = calculateParallaxOffset(coord, viewDir);
                vec2 offsetCoord = coord + parallaxOffset;
                
                // Ensure coordinates stay within bounds
                offsetCoord = clamp(offsetCoord, 0.0, 1.0);
                
                // Calculate surface normal
                vec3 normal = calculateNormal(offsetCoord, 0.01);
                
                // Multi-layer holographic interference
                vec3 holoColour = calculateMultiLayerInterference(offsetCoord, viewDir, normal);
                
                // Enhanced surface detail from depth
                float detailNoise = fbm(offsetCoord * u_surfaceDetail + u_time * u_evolutionSpeed * 0.5) * 0.2;
                vec3 detailColour = vec3(detailNoise) * vec3(0.4, 0.6, 0.8);
                
                // Depth-based self-shadowing
                float shadow = 1.0;
                if(depth > 0.1) {
                    vec2 shadowCoord = offsetCoord + viewDir.xy * 0.02;
                    float shadowDepth = calculateHolographicDepth(shadowCoord);
                    if(shadowDepth > depth + 0.05) {
                        shadow = 0.7;
                    }
                }
                
                // Combine all effects
                vec3 finalColour = holoColour + detailColour * 0.3;
                
                // Apply lighting with depth consideration
                float lighting = 0.6 + 0.4 * max(0.0, dot(normal, viewDir));
                finalColour *= lighting * shadow;
                
                // Holographic enhancement based on viewing angle
                float holoIntensity = 1.0 + 0.5 * abs(dot(normal, viewDir));
                finalColour *= holoIntensity;
                
                // Gamma correction and clamping
                finalColour = pow(finalColour, vec3(0.85));
                finalColour = clamp(finalColour, 0.0, 1.0);
                
                fragColor = vec4(finalColour, 1.0);
            }
        `;
        
        // Reaction-diffusion update shader
        const updateShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 fragColor;
            
            uniform sampler2D u_texture;
            uniform sampler2D u_memory;
            uniform sampler2D u_image;
            uniform float u_lambda;
            uniform float u_depthRate;
            uniform float u_feed;
            uniform float u_kill;
            uniform vec2 u_mouse;
            uniform bool u_disturb;
            uniform bool u_hasImage;
            
            const float Du = 0.18;
            const float Dv = 0.09;
            const float dt = 0.8;
            const float texelSize = 1.0 / 512.0;
            
            vec4 laplacian(sampler2D tex, vec2 coord) {
                vec4 sum = vec4(0.0);
                sum += texture(tex, coord + vec2(-texelSize, 0.0));
                sum += texture(tex, coord + vec2(texelSize, 0.0));
                sum += texture(tex, coord + vec2(0.0, -texelSize));
                sum += texture(tex, coord + vec2(0.0, texelSize));
                sum -= 4.0 * texture(tex, coord);
                return sum;
            }
            
            void main() {
                vec2 coord = v_texCoord;
                vec4 current = texture(u_texture, coord);
                vec4 memory = texture(u_memory, coord);
                
                float u = current.x;
                float v = current.y;
                float m = memory.x;
                
                // Mouse interaction for depth ruptures
                if (u_disturb && length(u_mouse - coord) < 0.08) {
                    float distStrength = exp(-length(u_mouse - coord) / 0.03);
                    v += 0.6 * distStrength;
                    u *= 0.7;
                    m *= 0.5;
                }
                
                // Image influence on reaction-diffusion
                if (u_hasImage) {
                    vec4 imageData = texture(u_image, coord);
                    float imageInfluence = imageData.a * 0.2;
                    v += imageInfluence * 0.1 * sin(coord.x * 20.0 + coord.y * 15.0);
                }
                
                // Reaction-diffusion with enhanced parameters
                vec4 lapU = laplacian(u_texture, coord);
                float uvv = u * v * v;
                
                float dU = Du * lapU.x - uvv + u_feed * (1.0 - u);
                float dV = Dv * lapU.y + uvv - (u_feed + u_kill) * v;
                
                // Memory integration
                float newMemory = m + u_lambda * (u - m);
                
                // Memory-driven feedback for holographic patterns
                dU += 0.15 * (newMemory - u) * sin(coord.x * 18.0 + coord.y * 12.0);
                
                // Update values
                float newU = clamp(u + dU * dt, 0.0, 1.0);
                float newV = clamp(v + dV * dt, 0.0, 1.0);
                
                fragColor = vec4(newU, newV, 0.0, 1.0);
            }
        `;
        
        // Memory update shader
        const memoryUpdateShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 fragColor;
            
            uniform sampler2D u_texture;
            uniform sampler2D u_memory;
            uniform sampler2D u_image;
            uniform float u_lambda;
            uniform float u_depthRate;
            uniform vec2 u_mouse;
            uniform bool u_disturb;
            uniform bool u_hasImage;
            uniform float u_imageDepthInfluence;
            
            void main() {
                vec2 coord = v_texCoord;
                vec4 current = texture(u_texture, coord);
                vec4 memory = texture(u_memory, coord);
                
                float u = current.x;
                float v = current.y;
                float m = memory.x;
                float depth = memory.z;
                
                // Mouse interaction for depth ruptures
                if (u_disturb && length(u_mouse - coord) < 0.08) {
                    float distStrength = exp(-length(u_mouse - coord) / 0.03);
                    m *= 0.5;
                    depth += 0.4 * distStrength;
                }
                
                // Memory integration
                float newMemory = m + u_lambda * (u - m);
                
                // Depth accumulation based on CRR dynamics
                float depthGradient = abs(u - 0.5) + abs(v - 0.1);
                float newDepth = depth + u_depthRate * 0.1 * (depthGradient - 0.1);
                
                // Image influence on depth accumulation
                if (u_hasImage) {
                    vec4 imageData = texture(u_image, coord);
                    float imageBrightness = dot(imageData.rgb, vec3(0.299, 0.587, 0.114));
                    newDepth += imageBrightness * imageData.a * u_imageDepthInfluence * 0.1;
                }
                
                // Depth decay to prevent runaway accumulation
                newDepth = clamp(newDepth * 0.995, 0.0, 2.0);
                
                fragColor = vec4(newMemory, 0.0, newDepth, 1.0);
            }
        `;
        
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function createProgram(vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }
        
        // Create programs
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const renderProgram = createProgram(vertexShader, createShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
        const updateProgram = createProgram(vertexShader, createShader(gl.FRAGMENT_SHADER, updateShaderSource));
        const memoryUpdateProgram = createProgram(vertexShader, createShader(gl.FRAGMENT_SHADER, memoryUpdateShaderSource));
        
        // Create geometry
        const positions = new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1,
        ]);
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        // Create textures
        function createTexture() {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return texture;
        }
        
        const texture1 = createTexture();
        const texture2 = createTexture();
        const memoryTexture1 = createTexture();
        const memoryTexture2 = createTexture();
        const imageTexture = createTexture();
        
        function initialiseTextures() {
            const size = 512;
            const data = new Float32Array(size * size * 4);
            const memoryData = new Float32Array(size * size * 4);
            
            for (let i = 0; i < size * size * 4; i += 4) {
                data[i] = 1.0;
                data[i + 1] = Math.random() < 0.006 ? 1.0 : 0.0;
                data[i + 2] = 0.0;
                data[i + 3] = 1.0;
                
                memoryData[i] = Math.random() * 0.2;
                memoryData[i + 1] = 0.0;
                memoryData[i + 2] = Math.random() * 0.1;
                memoryData[i + 3] = 1.0;
            }
            
            [texture1, texture2].forEach(tex => {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, size, size, 0, gl.RGBA, gl.FLOAT, data);
            });
            
            [memoryTexture1, memoryTexture2].forEach(tex => {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, size, size, 0, gl.RGBA, gl.FLOAT, memoryData);
            });
        }
        
        // Framebuffers
        const framebuffer1 = gl.createFramebuffer();
        const framebuffer2 = gl.createFramebuffer();
        
        initialiseTextures();
        
        // State
        let currentTexture = texture1;
        let nextTexture = texture2;
        let currentMemory = memoryTexture1;
        let nextMemory = memoryTexture2;
        let currentFramebuffer = framebuffer1;
        let nextFramebuffer = framebuffer2;
        
        let time = 0;
        let mouseX = 0.5;
        let mouseY = 0.5;
        let mousePressed = false;
        let hasImage = false;
        
        // Parameters
        let lambda = 0.035;
        let depthRate = 0.4;
        let parallaxStrength = 1.8;
        let reliefHeight = 0.8;
        let depthLayers = 4;
        let layerSeparation = 0.12;
        let shimmer = 1.6;
        let iridescence = 1.3;
        let surfaceDetail = 15;
        let evolutionSpeed = 0.06;
        let patternScale = 0.8;
        let feed = 0.042;
        let kill = 0.066;
        
        // Image parameters
        let imageDepthInfluence = 1.2;
        let logoParallaxStrength = 1.8;
        let colourInfluence = 0.6;
        let edgeEnhancement = 0.8;
        
        // Image upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const imageControls = document.getElementById('imageControls');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFileUpload(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileUpload(e.target.files[0]);
            }
        });
        
        function handleFileUpload(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file (PNG, JPEG)');
                return;
            }
            
            if (file.size > 5 * 1024 * 1024) {
                alert('Image file too large. Please use an image smaller than 5MB.');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = () => {
                    imagePreview.src = img.src;
                    imagePreview.style.display = 'block';
                    imageControls.style.display = 'block';
                    
                    loadImageToTexture(img);
                    hasImage = true;
                    updateStatus();
                };
                
                img.onerror = () => {
                    console.error('Error loading image');
                    alert('Error loading image. Please try another file.');
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = () => {
                console.error('Error reading file');
                alert('Error reading file. Please try another file.');
            };
            
            reader.readAsDataURL(file);
        }
        
        function loadImageToTexture(img) {
            gl.bindTexture(gl.TEXTURE_2D, imageTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        
        function clearImage() {
            hasImage = false;
            imagePreview.style.display = 'none';
            imageControls.style.display = 'none';
            updateStatus();
        }
        
        // Events
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) / rect.width;
            mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
            updateStatus();
        });
        
        canvas.addEventListener('mousedown', () => { mousePressed = true; });
        canvas.addEventListener('mouseup', () => { mousePressed = false; });
        
        // Sliders
        function setupSlider(id, callback) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + '-value');
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                valueDisplay.textContent = value.toString();
                callback(value);
            });
        }
        
        setupSlider('lambda', (v) => { lambda = v; });
        setupSlider('depth-rate', (v) => { depthRate = v; });
        setupSlider('parallax', (v) => { parallaxStrength = v; });
        setupSlider('relief-height', (v) => { reliefHeight = v; });
        setupSlider('depth-layers', (v) => { depthLayers = v; });
        setupSlider('shimmer', (v) => { shimmer = v; });
        setupSlider('iridescence', (v) => { iridescence = v; });
        setupSlider('surface-detail', (v) => { surfaceDetail = v; });
        setupSlider('evolution-speed', (v) => { evolutionSpeed = v; });
        setupSlider('pattern-scale', (v) => { patternScale = v; });
        
        // Image-specific sliders
        setupSlider('image-depth', (v) => { imageDepthInfluence = v; });
        setupSlider('logo-parallax', (v) => { logoParallaxStrength = v; });
        setupSlider('colour-influence', (v) => { colourInfluence = v; });
        setupSlider('edge-enhancement', (v) => { edgeEnhancement = v; });
        
        function reset() {
            initialiseTextures();
            time = 0;
        }
        
        function updateStatus() {
            const angle = Math.atan2(mouseY - 0.5, mouseX - 0.5) * 180 / Math.PI;
            const imageStatus = hasImage ? 'LOADED' : 'NONE';
            document.getElementById('status').textContent = 
                `Hologram: ACTIVE | Image: ${imageStatus} | View: ${angle.toFixed(0)}¬∞`;
        }
        
        function render() {
            time += 0.016;
            
            // Update reaction-diffusion
            gl.bindFramebuffer(gl.FRAMEBUFFER, nextFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, nextTexture, 0);
            
            gl.useProgram(updateProgram);
            gl.viewport(0, 0, 512, 512);
            
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_lambda'), lambda);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_depthRate'), depthRate);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_feed'), feed);
            gl.uniform1f(gl.getUniformLocation(updateProgram, 'u_kill'), kill);
            gl.uniform2f(gl.getUniformLocation(updateProgram, 'u_mouse'), mouseX, mouseY);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_disturb'), mousePressed);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_hasImage'), hasImage);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentTexture);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_texture'), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, currentMemory);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_memory'), 1);
            
            if (hasImage) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);
                gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_image'), 2);
            }
            
            const posLoc = gl.getAttribLocation(updateProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Update memory with depth
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, nextMemory, 0);
            
            gl.useProgram(memoryUpdateProgram);
            
            gl.uniform1f(gl.getUniformLocation(memoryUpdateProgram, 'u_lambda'), lambda);
            gl.uniform1f(gl.getUniformLocation(memoryUpdateProgram, 'u_depthRate'), depthRate);
            gl.uniform2f(gl.getUniformLocation(memoryUpdateProgram, 'u_mouse'), mouseX, mouseY);
            gl.uniform1i(gl.getUniformLocation(memoryUpdateProgram, 'u_disturb'), mousePressed);
            gl.uniform1i(gl.getUniformLocation(memoryUpdateProgram, 'u_hasImage'), hasImage);
            gl.uniform1f(gl.getUniformLocation(memoryUpdateProgram, 'u_imageDepthInfluence'), imageDepthInfluence);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, nextTexture);
            gl.uniform1i(gl.getUniformLocation(memoryUpdateProgram, 'u_texture'), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, currentMemory);
            gl.uniform1i(gl.getUniformLocation(memoryUpdateProgram, 'u_memory'), 1);
            
            if (hasImage) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);
                gl.uniform1i(gl.getUniformLocation(memoryUpdateProgram, 'u_image'), 2);
            }
            
            const memPosLoc = gl.getAttribLocation(memoryUpdateProgram, 'a_position');
            gl.enableVertexAttribArray(memPosLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(memPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Render to screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.useProgram(renderProgram);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_time'), time);
            gl.uniform2f(gl.getUniformLocation(renderProgram, 'u_mouse'), mouseX, mouseY);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_parallaxStrength'), parallaxStrength);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_reliefHeight'), reliefHeight);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_depthLayers'), depthLayers);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_layerSeparation'), layerSeparation);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_shimmer'), shimmer);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_iridescence'), iridescence);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_surfaceDetail'), surfaceDetail);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_evolutionSpeed'), evolutionSpeed);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_patternScale'), patternScale);
            
            // Image-specific uniforms
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_hasImage'), hasImage);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_imageDepthInfluence'), imageDepthInfluence);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_logoParallaxStrength'), logoParallaxStrength);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_colourInfluence'), colourInfluence);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_edgeEnhancement'), edgeEnhancement);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, nextTexture);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_texture'), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, nextMemory);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_memory'), 1);
            
            if (hasImage) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);
                gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_image'), 2);
            }
            
            const renderPosLoc = gl.getAttribLocation(renderProgram, 'a_position');
            gl.enableVertexAttribArray(renderPosLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(renderPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Swap buffers
            [currentTexture, nextTexture] = [nextTexture, currentTexture];
            [currentMemory, nextMemory] = [nextMemory, currentMemory];
            [currentFramebuffer, nextFramebuffer] = [nextFramebuffer, currentFramebuffer];
            
            requestAnimationFrame(render);
        }
        
        // Global functions
        window.reset = reset;
        window.clearImage = clearImage;
        
        // Start
        updateStatus();
        render();
    </script>
</body>
</html>