<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Mycelium Network Growth - Process Visualisation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', 'Times', serif;
            background: 
                radial-gradient(circle at 20% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(34, 53, 34, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #f5f3ec 0%, #ede8d8 30%, #e5e0d0 60%, #d8d0c0 100%);
            color: #3a342e;
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        /* UCF Explanation Section */
        .ucf-explanation {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(245, 243, 236, 0.95) 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(139, 115, 85, 0.2);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.08);
        }
        
        .ucf-explanation h1 {
            font-size: 2.2rem;
            color: #4a4136;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .ucf-formula {
            text-align: center;
            font-family: 'Times', serif;
            font-size: 1.3rem;
            color: #6b5b4d;
            font-style: italic;
            margin: 25px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(139, 115, 85, 0.15);
        }
        
        .ucf-explanation p {
            font-size: 1.05rem;
            color: #5a4a3d;
            margin-bottom: 15px;
            text-align: justify;
        }
        
        /* Details/Summary Styling */
        details {
            margin: 20px 0;
            cursor: pointer;
        }
        
        details summary {
            font-weight: bold;
            color: #4a4136;
            padding: 12px 0;
            font-size: 1.1rem;
            border-top: 2px solid #8b7355;
            border-bottom: 1px solid #ccc;
            list-style: none;
            position: relative;
        }
        
        details summary::-webkit-details-marker {
            display: none;
        }
        
        details summary::after {
            content: "▼";
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s;
        }
        
        details[open] summary::after {
            transform: translateY(-50%) rotate(180deg);
        }
        
        details details summary {
            font-size: 1rem;
            border-top: 1px solid #8b7355;
            border-bottom: none;
            padding: 8px 0;
        }
        
        /* Visualisation Controls */
        .visualization-controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(139, 115, 85, 0.2);
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
        }
        
        .visualization-controls h3 {
            color: #4a4136;
            margin-bottom: 15px;
            font-size: 1.2rem;
            text-align: center;
            border-bottom: 2px solid rgba(139, 115, 85, 0.2);
            padding-bottom: 8px;
        }
        
        .viz-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .viz-option {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 8px;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(139, 115, 85, 0.3);
        }
        
        .viz-option:hover {
            background: rgba(139, 115, 85, 0.1);
        }
        
        .viz-option input[type="radio"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .viz-legend {
            text-align: center;
            font-size: 0.85rem;
            color: #6b5b4d;
            font-style: italic;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 6px;
        }
        
        /* Simulation Container */
        .simulation-container {
            background: 
                radial-gradient(circle at 40% 30%, rgba(139,69,19,0.3) 0%, transparent 60%),
                linear-gradient(45deg, #2d1b0e 0%, #1a1a0f 50%, #0f1a0f 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 6px solid rgba(68, 68, 68, 0.8);
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.3),
                inset 0 0 60px rgba(0, 0, 0, 0.2);
            position: relative;
            min-height: 750px;
        }
        
        .substrate-container {
            position: relative;
            width: 700px;
            height: 700px;
            margin: 0 auto;
            border-radius: 15px;
            background: 
                radial-gradient(circle at 40% 30%, rgba(139,69,19,0.3) 0%, transparent 60%),
                linear-gradient(45deg, #2d1b0e 0%, #1a1a0f 50%, #0f1a0f 100%);
            border: 4px solid #444;
            box-shadow: 
                0 0 30px rgba(0,0,0,0.6),
                inset 0 0 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px;
            cursor: crosshair;
        }
        
        .sim-instructions {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
            font-size: 0.85rem;
            text-align: center;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
        }
        
        .sim-reset {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .reset-btn {
            background: rgba(139, 115, 85, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 0.9rem;
            transition: all 0.2s;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .reset-btn:hover {
            background: rgba(122, 99, 69, 0.9);
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }
        
        /* Controls Section */
        .controls-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(139, 115, 85, 0.2);
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
        }
        
        .control-panel h3 {
            color: #4a4136;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-bottom: 2px solid rgba(139, 115, 85, 0.2);
            padding-bottom: 8px;
        }
        
        .param-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 12px 0;
            font-size: 0.9rem;
        }
        
        .param-slider {
            width: 100px;
            height: 4px;
            background: #ddd;
            outline: none;
            border-radius: 2px;
            -webkit-appearance: none;
        }
        
        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #8b7355;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .substrate-btn {
            background: #f5f3ec;
            border: 1px solid #8b7355;
            color: #5a4a3d;
            padding: 6px 10px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            font-family: 'Georgia', serif;
        }
        
        .substrate-btn.active {
            background: #8b7355;
            color: white;
        }
        
        .substrate-btn:hover {
            background: #e5e0d0;
        }
        
        .substrate-btn.active:hover {
            background: #7a6345;
        }
        
        /* Metrics Display */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 0.85rem;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(139, 115, 85, 0.1);
        }
        
        .metric-value {
            font-weight: bold;
            color: #8b7355;
        }
        
        /* Status Indicators */
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }
        
        .status-optimal { background: #4CAF50; }
        .status-good { background: #2196F3; }
        .status-poor { background: #FF9800; }
        .status-critical { background: #F44336; }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .substrate-container {
                width: 100%;
                max-width: 500px;
                height: 500px;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .viz-options {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- UCF Explanation -->
        <section class="ucf-explanation">
            <h1>CRR Mathematical Framework: Mycelium Network Growth</h1>
            
            <div class="ucf-formula">
                Complete CRR Dynamics: d/dt(∂L/∂ẋ) - ∂L/∂x = ∫ K(t-τ)φ(x,τ)e^(C(x,τ)/Ω) dτ + Σ ρᵢ(x)δ(t-tᵢ)
            </div>
            
            <p><strong>Real-Time CRR Dynamics:</strong> This simulation implements the complete CRR mathematical framework with rigorous temporal integration. Hyphal tips exhibit <em>coherence</em> through nutrient-seeking behaviour and coordinated branching patterns, with accumulated history C(x,t) = ∫₀ᵗ L(x,τ)dτ tracked explicitly in each grid cell. <em>Rupture</em> occurs when environmental stress exceeds biological thresholds, triggering discrete δ(t-tᵢ) events that fragment the network. <em>Regeneration</em> manifests through exponentially weighted Regeneration: growth rates scale as exp(C(x)/Ω), creating history-dependent amplification where high-coherence regions grow exponentially faster than low-coherence regions.</p>
            
            <details>
                <summary><strong>Mathematical Implementation: CRR Equations → Live Simulation</strong></summary>
                <div style="background: rgba(255,255,255,0.9); padding: 20px; border-radius: 12px; margin: 15px 0; font-family: 'Courier New', monospace; font-size: 0.85rem; line-height: 1.4;">
                    
                    <div style="border-bottom: 1px solid #ccc; margin-bottom: 12px; padding-bottom: 8px;"><strong>1. COHERENCE INTEGRATION: C(x,t) = ∫₀ᵗ L(x,τ) dτ</strong></div>
                    <div style="margin-left: 15px; color: #666;">
                        <div>Mathematical: Temporal integration of memory density field L(x,τ)</div>
                        <div>Memory Density: <code>L[idx] = growthActivity[idx]×0.1 + branchingActivity[idx]×0.2 + hyphalDensity[idx]×0.05</code></div>
                        <div>Integration: <code>coherence[idx] += L[idx] × dt</code> (each frame)</div>
                        <div>Decay: <code>coherence[idx] ×= 0.9998</code> (slow coherence dissipation)</div>
                        <div>Result: Each grid cell accumulates coherence C(x,t) representing integrated history of mycelial activity</div>
                    </div>
                    
                    <div style="border-bottom: 1px solid #ccc; margin: 12px 0 12px 0; padding-bottom: 8px;"><strong>2. RUPTURE DETECTION: δ(t-tᵢ) at threshold crossing</strong></div>
                    <div style="margin-left: 15px; color: #666;">
                        <div>Mathematical: Dirac delta impulse at critical stress σ(t) > σ_crit</div>
                        <div>Stress Calculation: <code>σ_combined = weighted_avg(σ_temp, σ_pH, σ_moisture, σ_O₂, σ_CO₂)</code></div>
                        <div>Rupture Threshold: <code>if(σ > 0.75) { probabilistic_death(); ruptureCounter++ }</code></div>
                        <div>Immediate Lethal: <code>if(σ > 0.9) { immediate_death(); ruptureCounter++ }</code></div>
                        <div>Result: Biologically accurate rupture events at discrete times tᵢ when stress exceeds tolerance</div>
                    </div>
                    
                    <div style="border-bottom: 1px solid #ccc; margin: 12px 0 12px 0; padding-bottom: 8px;"><strong>3. EXPONENTIAL Regeneration: R[χ](x,t) = ∫ φ(x,τ)·exp(C(x,τ)/Ω)·Θ(t-τ) dτ</strong></div>
                    <div style="margin-left: 15px; color: #666;">
                        <div><strong>φ(x,τ)</strong> Historical field: <code>signal = nutrients[idx]×2 + moisture[idx]×0.5 - density[idx]×0.3</code></div>
                        <div><strong>exp(C(x)/Ω)</strong> Coherence amplification: <code>RegenerationWeight = exp(coherence[idx] / OMEGA)</code></div>
                        <div><strong>Implementation</strong>: <code>effectiveSpeed = baseSpeed × RegenerationWeight × (1-stress)</code></div>
                        <div><strong>Memory Kernel K(t-τ)</strong>: 10-frame exponentially weighted sensor history</div>
                        <div>Result: Hyphal growth rates exponentially amplified by accumulated coherence - high C regions grow much faster</div>
                    </div>
                    
                    <div style="border-bottom: 1px solid #ccc; margin: 12px 0 12px 0; padding-bottom: 8px;"><strong>4. MEMORY KERNEL: K(t-τ) = exp(-|t-τ|/τ_memory)</strong></div>
                    <div style="margin-left: 15px; color: #666;">
                        <div>Sensor History: <code>sensorMemory[10]</code> array stores last 10 nutrient/moisture readings</div>
                        <div>Exponential Weighting: <code>weight[i] = exp(-i × 0.15)</code> (older memories weighted less)</div>
                        <div>Convolution: <code>memSignal = Σᵢ sensorMemory[i] × weight[i]</code></div>
                        <div>Navigation: Hyphal tips use memory-weighted signal for directional growth</div>
                        <div>Result: Non-Markovian dynamics - decisions depend on accumulated sensory history, not just current state</div>
                    </div>
                    
                    <details style="margin-top: 15px;">
                        <summary><strong>5. EULER-LAGRANGE VARIATIONAL STRUCTURE</strong></summary>
                        <div style="margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.7); border-radius: 8px; border-left: 4px solid #8b7355;">
                            <div style="font-size: 0.9rem; text-align: center; font-style: italic; margin-bottom: 15px; color: #6b5b4d;">
                                <strong>d/dt(∂L/∂ẋ) - ∂L/∂x = ∫ K(t-τ)φ(x,τ)exp(C(x,τ)/Ω) dτ + Σ ρᵢ(x)δ(t-tᵢ)</strong>
                            </div>
                            
                            <div style="margin-bottom: 10px;"><strong>LEFT SIDE: Classical Variational Dynamics</strong></div>
                            <div style="margin-left: 10px; color: #666; margin-bottom: 12px;">
                                <div>• <strong>d/dt(∂L/∂ẋ)</strong>: Momentum evolution → <code>velocity updates via chemotactic gradients</code></div>
                                <div>• <strong>∂L/∂x</strong>: Force from coherence field → <code>∇nutrients, ∇moisture guide growth</code></div>
                                <div>• <strong>Coherence Lagrangian L(x,ẋ,t)</strong>: Environmental signal strength integrated over time</div>
                            </div>
                            
                            <div style="margin-bottom: 10px;"><strong>RIGHT SIDE TERM 1: Memory Integral (Regeneration)</strong></div>
                            <div style="margin-left: 10px; color: #666; margin-bottom: 12px;">
                                <div>• <strong>φ(x,τ)</strong>: Historical field → <code>nutrient×2 + moisture×0.5 - density×0.3</code></div>
                                <div>• <strong>exp(C(x,τ)/Ω)</strong>: Exponential coherence weighting → <code>OMEGA = 0.3 (temperature scale)</code></div>
                                <div>• <strong>K(t-τ)</strong>: Memory kernel → <code>exp(-Δt/τ_memory)</code> with τ = 10 frames</div>
                                <div>• <strong>∫ ... dτ</strong>: Temporal convolution → weighted history influences present dynamics</div>
                                <div>• <strong>Observable Effect</strong>: High-coherence regions exhibit 2-10× faster growth than low-coherence regions</div>
                            </div>
                            
                            <div style="margin-bottom: 10px;"><strong>RIGHT SIDE TERM 2: Impulsive Terms (Rupture)</strong></div>
                            <div style="margin-left: 10px; color: #666; margin-bottom: 12px;">
                                <div>• <strong>δ(t-tᵢ)</strong>: Dirac delta at rupture → <code>discrete stress-threshold events</code></div>
                                <div>• <strong>ρᵢ(x)</strong>: Rupture amplitude → <code>energy loss proportional to stress severity</code></div>
                                <div>• <strong>Σ</strong>: Multiple rupture events → <code>ruptureCounter tracks cumulative damage</code></div>
                                <div>• <strong>Biological Correspondence</strong>: Hyphal death, network fragmentation, resource loss</div>
                            </div>
                            
                            <div style="margin-bottom: 10px;"><strong>KEY SIGNATURES YOU CAN OBSERVE:</strong></div>
                            <div style="margin-left: 10px; color: #666;">
                                <div>1. <strong>Exponential Divergence</strong>: Dense mycelial regions grow exponentially faster than sparse regions (exp(C/Ω) term)</div>
                                <div>2. <strong>Non-Markovian Navigation</strong>: Hyphae "remember" past 10 nutrient readings, creating smooth adaptive trajectories</div>
                                <div>3. <strong>Threshold Ruptures</strong>: Network suddenly fragments when stress crosses σ = 0.75 (discrete δ-function events)</div>
                                <div>4. <strong>History-Weighted Recovery</strong>: After stress relief, high-coherence regions recover first and fastest</div>
                            </div>
                        </div>
                    </details>
                    
                    <div style="margin-top: 12px;"><strong>6. PERFORMANCE OPTIMIZATION</strong></div>
                    <div style="margin-left: 15px; color: #666;">
                        <div>Float32Array fields: <code>coherence[], hyphalDensity[], nutrients[], moisture[]</code></div>
                        <div>Coherence integration: O(N) per frame where N = 700×700 grid cells</div>
                        <div>Exponential caching: <code>RegenerationWeight</code> computed per hyphal tip, not per grid cell</div>
                        <div>Memory kernel: Fixed 10-frame window (not full history) for O(1) access</div>
                        <div>Result: Maintains 60fps with full CRR mathematical rigour</div>
                    </div>
                </div>
            </details>
        </section>

        <!-- Visualisation Controls -->
        <section class="visualization-controls">
            <h3>Network Process Visualisation</h3>
            <div class="viz-options">
                <label class="viz-option">
                    <input type="radio" name="vizMode" value="hyphal" checked>
                    Standard View
                </label>
                <label class="viz-option">
                    <input type="radio" name="vizMode" value="coherence">
                    Coherence Field C(x,t)
                </label>
                <label class="viz-option">
                    <input type="radio" name="vizMode" value="growth">
                    Growth Activity
                </label>
                <label class="viz-option">
                    <input type="radio" name="vizMode" value="network">
                    Network Formation
                </label>
            </div>
            <div class="viz-legend" id="vizLegend">
                Showing hyphal network density - bright areas indicate mature mycelium
            </div>
        </section>

        <!-- Simulation -->
        <section class="simulation-container">
            <div class="substrate-container">
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="sim-instructions">
                <em>Left Click: Add inoculation • Right Click: Add nutrients • Shift+Click: Add moisture • R: Reset • F: Trigger fruiting • Space: Play/Pause</em>
            </div>
            
            <div class="sim-reset">
                <button class="reset-btn" onclick="resetSimulation()">Reset Network</button>
            </div>
        </section>

        <!-- Controls and Metrics -->
        <div class="controls-section">
            <!-- Environmental Controls -->
            <div class="control-panel">
                <h3>Environmental Parameters</h3>
                <div class="param-row">
                    <span>Temperature:</span>
                    <input type="range" class="param-slider" id="temperature" min="5" max="35" value="22">
                    <span id="tempVal">22°C</span>
                </div>
                <div class="param-row">
                    <span>Moisture:</span>
                    <input type="range" class="param-slider" id="moisture" min="20" max="95" value="70">
                    <span id="moistureVal">70%</span>
                </div>
                <div class="param-row">
                    <span>pH Level:</span>
                    <input type="range" class="param-slider" id="ph" min="4" max="9" step="0.1" value="6.5">
                    <span id="phVal">6.5</span>
                </div>
                <div class="param-row">
                    <span>Oxygen:</span>
                    <input type="range" class="param-slider" id="oxygen" min="10" max="25" value="21">
                    <span id="oxygenVal">21%</span>
                </div>
                <div class="param-row">
                    <span>CO₂ Level:</span>
                    <input type="range" class="param-slider" id="co2" min="300" max="5000" value="400">
                    <span id="co2Val">400ppm</span>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4>Substrate Type:</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px;">
                        <button class="substrate-btn active" data-substrate="compost">Compost</button>
                        <button class="substrate-btn" data-substrate="wood">Wood Chips</button>
                        <button class="substrate-btn" data-substrate="straw">Straw</button>
                        <button class="substrate-btn" data-substrate="soil">Garden Soil</button>
                        <button class="substrate-btn" data-substrate="sawdust">Sawdust</button>
                    </div>
                </div>
            </div>

            <!-- Network Metrics -->
            <div class="control-panel">
                <h3>Network Status & CRR Metrics</h3>
                <div class="metrics-grid">
                    <div class="metric-item">
                        <span>Hyphal Mass:</span>
                        <span class="metric-value" id="hyphalMass">0.00g</span>
                    </div>
                    <div class="metric-item">
                        <span>Avg Coherence C̄:</span>
                        <span class="metric-value" id="avgCoherence">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span>Network Length:</span>
                        <span class="metric-value" id="networkLength">0.0cm</span>
                    </div>
                    <div class="metric-item">
                        <span>Regeneration Amp:</span>
                        <span class="metric-value" id="RegenerationAmp">1.00×</span>
                    </div>
                    <div class="metric-item">
                        <span>Branch Points:</span>
                        <span class="metric-value" id="branchPoints">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Rupture Events:</span>
                        <span class="metric-value" id="ruptureEvents">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Decomposition:</span>
                        <span class="metric-value" id="decomposition">0.0%</span>
                    </div>
                    <div class="metric-item">
                        <span>Fruiting Bodies:</span>
                        <span class="metric-value" id="fruitingBodies">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Growth Rate:</span>
                        <span class="metric-value" id="growthRate">0.0mm/day</span>
                    </div>
                </div>
            </div>

            <!-- Health Status -->
            <div class="control-panel">
                <h3>Health Status</h3>
                <div style="font-size: 0.9rem;">
                    <div style="margin: 8px 0;"><span class="status-indicator" id="tempStatus"></span>Temperature</div>
                    <div style="margin: 8px 0;"><span class="status-indicator" id="moistStatus"></span>Moisture</div>
                    <div style="margin: 8px 0;"><span class="status-indicator" id="phStatus"></span>pH Level</div>
                    <div style="margin: 8px 0;"><span class="status-indicator" id="oxyStatus"></span>Oxygen</div>
                    <div style="margin: 8px 0;"><span class="status-indicator" id="co2Status"></span>CO₂</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        'use strict';
        
        // CRR Constants
        const OMEGA = 0.3; // Temperature scale for coherence weighting
        const COHERENCE_DECAY = 0.9998; // Slow coherence dissipation
        const MEMORY_KERNEL_SIZE = 10; // Number of frames for memory integration
        const MEMORY_DECAY_RATE = 0.15; // Exponential decay rate for memory kernel
        const DT = 1/60; // 60fps timestep
        
        let globalSimulation = null;
        
        const STRESS_THRESHOLDS = {
            MILD: 0.3,
            DAMAGE: 0.6,
            RUPTURE: 0.75,
            LETHAL: 0.9
        };
        
        class EnvironmentalParameters {
            constructor() {
                this.temperature = 22;
                this.moisture = 70;
                this.phLevel = 6.5;
                this.oxygenLevel = 21;
                this.co2Level = 400;
                this.substrateType = 'compost';
            }
            
            getBiologicalLimits() {
                return {
                    temperature: { optimal: [15, 25], lethal: [5, 35] },
                    ph: { optimal: [6.0, 7.5], lethal: [4.0, 9.0] },
                    moisture: { optimal: [65, 85], lethal: [20, 95] },
                    oxygen: { optimal: [18, 23], lethal: [5, 30] },
                    co2: { optimal: [300, 800], lethal: [0, 5000] }
                };
            }
            
            calculateBiologicalStress(value, optimalRange, lethalRange) {
                const [optMin, optMax] = optimalRange;
                const [letMin, letMax] = lethalRange;
                
                if (value >= optMin && value <= optMax) return 0.0;
                
                let stressDistance;
                if (value < optMin) {
                    stressDistance = Math.min(1.0, (optMin - value) / (optMin - letMin));
                } else {
                    stressDistance = Math.min(1.0, (value - optMax) / (letMax - optMax));
                }
                
                return Math.pow(stressDistance, 1.5);
            }
            
            calculateOverallStress() {
                const limits = this.getBiologicalLimits();
                
                const tempStress = this.calculateBiologicalStress(this.temperature, limits.temperature.optimal, limits.temperature.lethal);
                const phStress = this.calculateBiologicalStress(this.phLevel, limits.ph.optimal, limits.ph.lethal);
                const moistureStress = this.calculateBiologicalStress(this.moisture, limits.moisture.optimal, limits.moisture.lethal);
                const oxygenStress = this.calculateBiologicalStress(this.oxygenLevel, limits.oxygen.optimal, limits.oxygen.lethal);
                const co2Stress = this.calculateBiologicalStress(this.co2Level, limits.co2.optimal, limits.co2.lethal);
                
                const weights = { temp: 1.5, ph: 1.3, moisture: 1.2, oxygen: 1.0, co2: 0.8 };
                
                const weightedStresses = [
                    tempStress * weights.temp,
                    phStress * weights.ph,
                    moistureStress * weights.moisture,
                    oxygenStress * weights.oxygen,
                    co2Stress * weights.co2
                ];
                
                const maxStress = Math.max(...weightedStresses);
                const avgStress = weightedStresses.reduce((a, b) => a + b, 0) / weightedStresses.length;
                
                return {
                    individual: { tempStress, phStress, moistureStress, oxygenStress, co2Stress },
                    combined: Math.min(1.0, avgStress + (maxStress - avgStress) * 0.4),
                    maxFactor: maxStress
                };
            }
            
            getEnvironmentalHealth() {
                const stressData = this.calculateOverallStress();
                return Math.max(0, 1.0 - stressData.combined);
            }
        }
        
        class SubstrateManager {
            static getProperties(type) {
                const properties = {
                    compost: { nutrients: 0.8, colour: [45, 35, 20] },
                    wood: { nutrients: 0.6, colour: [60, 45, 30] },
                    straw: { nutrients: 0.7, colour: [70, 60, 40] },
                    soil: { nutrients: 0.4, colour: [35, 25, 15] },
                    sawdust: { nutrients: 0.5, colour: [50, 40, 25] }
                };
                return properties[type] || properties.compost;
            }
        }
        
        class FieldArrays {
            constructor(totalCells) {
                this.totalCells = totalCells;
                this.initializeFields();
            }
            
            initializeFields() {
                // Core CRR fields
                this.coherence = new Float32Array(this.totalCells); // C(x,t) = ∫L(x,τ)dτ
                this.memoryDensity = new Float32Array(this.totalCells); // L(x,t)
                
                // Biological fields
                this.hyphalDensity = new Float32Array(this.totalCells);
                this.nutrients = new Float32Array(this.totalCells);
                this.moistureField = new Float32Array(this.totalCells);
                this.decomposition = new Float32Array(this.totalCells);
                this.substrateField = new Float32Array(this.totalCells);
                this.growthActivity = new Float32Array(this.totalCells);
                this.environmentalStress = new Float32Array(this.totalCells);
                this.branchingActivity = new Float32Array(this.totalCells);
                this.fruitingReadiness = new Float32Array(this.totalCells);
                
                this.temp = new Float32Array(this.totalCells);
            }
            
            resetFields(baseNutrients, moisture) {
                for (let i = 0; i < this.totalCells; i++) {
                    this.coherence[i] = 0;
                    this.memoryDensity[i] = 0;
                    this.hyphalDensity[i] = 0;
                    this.nutrients[i] = baseNutrients * (0.8 + Math.random() * 0.4);
                    this.moistureField[i] = (moisture / 100) * (0.9 + Math.random() * 0.2);
                    this.decomposition[i] = 0;
                    this.substrateField[i] = 1;
                    this.growthActivity[i] = 0;
                    this.environmentalStress[i] = 0;
                    this.branchingActivity[i] = 0;
                    this.fruitingReadiness[i] = 0;
                }
            }
            
            updateCoherence() {
                // CRR: C(x,t+dt) = C(x,t) + L(x,t)×dt - decay
                for (let i = 0; i < this.totalCells; i++) {
                    // L(x,t) = weighted combination of activities
                    this.memoryDensity[i] = 
                        this.growthActivity[i] * 0.1 +
                        this.branchingActivity[i] * 0.2 +
                        this.hyphalDensity[i] * 0.05;
                    
                    // Temporal integration: C(t+dt) = C(t) + L(t)×dt
                    this.coherence[i] += this.memoryDensity[i] * DT;
                    
                    // Slow coherence decay
                    this.coherence[i] *= COHERENCE_DECAY;
                }
            }
            
            decayActivityFields() {
                for (let i = 0; i < this.totalCells; i++) {
                    this.growthActivity[i] *= 0.95;
                    this.branchingActivity[i] *= 0.9;
                }
            }
            
            updateEnvironmentalStress(stressLevel) {
                for (let i = 0; i < this.totalCells; i++) {
                    this.environmentalStress[i] = stressLevel;
                }
            }
            
            diffuse(field, rate, gridSize) {
                this.temp.fill(0);
                
                for (let y = 1; y < gridSize - 1; y++) {
                    for (let x = 1; x < gridSize - 1; x++) {
                        const idx = x + y * gridSize;
                        const neighbors = field[idx - 1] + field[idx + 1] + 
                                        field[idx - gridSize] + field[idx + gridSize];
                        this.temp[idx] = field[idx] + rate * (neighbors - 4 * field[idx]);
                    }
                }
                
                for (let i = 0; i < this.totalCells; i++) {
                    field[i] = Math.max(0, this.temp[i]);
                }
            }
            
            getAverageCoherence() {
                let sum = 0;
                let count = 0;
                for (let i = 0; i < this.totalCells; i++) {
                    if (this.hyphalDensity[i] > 0.05) {
                        sum += this.coherence[i];
                        count++;
                    }
                }
                return count > 0 ? sum / count : 0;
            }
        }
        
        class HyphalTip {
            constructor(x, y, simulation, parent = null) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.age = 0;
                this.energy = 1.0;
                this.diameter = 0.5 + Math.random() * 0.5;
                this.branchCooldown = 0;
                this.parent = parent;
                this.generation = parent ? parent.generation + 1 : 0;
                this.species = 'oyster';
                this.anastomosisRadius = 8;
                this.simulation = simulation;
                
                // CRR: Memory kernel for non-Markovian dynamics
                this.sensorMemory = new Array(MEMORY_KERNEL_SIZE).fill(0);
                this.memoryWeights = new Array(MEMORY_KERNEL_SIZE);
                for (let i = 0; i < MEMORY_KERNEL_SIZE; i++) {
                    this.memoryWeights[i] = Math.exp(-i * MEMORY_DECAY_RATE);
                }
            }
            
            update(allHyphae) {
                this.age++;
                const stressData = this.simulation.environment.calculateOverallStress();
                const overallStress = stressData.combined;
                const maxStressFactor = stressData.maxFactor;
                
                // CRR RUPTURE: δ(t-tᵢ) events at stress thresholds
                if (maxStressFactor > STRESS_THRESHOLDS.LETHAL) {
                    this.simulation.ruptureCounter++;
                    return [];
                }
                
                if (overallStress > STRESS_THRESHOLDS.RUPTURE) {
                    const ruptureProb = (overallStress - STRESS_THRESHOLDS.RUPTURE) / (1.0 - STRESS_THRESHOLDS.RUPTURE);
                    if (Math.random() < ruptureProb * 0.8) {
                        this.energy *= 0.7;
                        this.simulation.ruptureCounter++;
                        return [];
                    }
                }
                
                if (overallStress > STRESS_THRESHOLDS.DAMAGE) {
                    const damageRate = (overallStress - STRESS_THRESHOLDS.DAMAGE) / (STRESS_THRESHOLDS.RUPTURE - STRESS_THRESHOLDS.DAMAGE);
                    this.energy *= (0.98 - damageRate * 0.03);
                }
                
                if (overallStress > STRESS_THRESHOLDS.MILD) {
                    const stressRate = (overallStress - STRESS_THRESHOLDS.MILD) / (STRESS_THRESHOLDS.DAMAGE - STRESS_THRESHOLDS.MILD);
                    this.energy *= (0.999 - stressRate * 0.001);
                }
                
                // CRR: Multi-directional sensing with memory kernel K(t-τ)
                const sensorDistance = 15;
                const numSensors = 8;
                let bestSignal = -1;
                let bestDirection = Math.atan2(this.vy, this.vx);
                
                for (let i = 0; i < numSensors; i++) {
                    const angle = (i * Math.PI * 2) / numSensors;
                    const sx = this.x + Math.cos(angle) * sensorDistance;
                    const sy = this.y + Math.sin(angle) * sensorDistance;
                    
                    if (sx >= 0 && sx < this.simulation.gridSize && sy >= 0 && sy < this.simulation.gridSize) {
                        const idx = Math.floor(sx) + Math.floor(sy) * this.simulation.gridSize;
                        
                        // φ(x,τ): Historical field
                        let currentSignal = this.simulation.fields.nutrients[idx] * 2 + 
                                          this.simulation.fields.moistureField[idx] * 0.5 - 
                                          this.simulation.fields.hyphalDensity[idx] * 0.3;
                        
                        currentSignal += (1 - this.simulation.fields.decomposition[idx]) * 0.8;
                        
                        // Update sensor memory (for this direction)
                        if (i === 0) {
                            this.sensorMemory.unshift(currentSignal);
                            this.sensorMemory.pop();
                        }
                        
                        // K(t-τ): Apply memory kernel (exponentially weighted history)
                        let memoryWeightedSignal = 0;
                        for (let m = 0; m < MEMORY_KERNEL_SIZE; m++) {
                            memoryWeightedSignal += this.sensorMemory[m] * this.memoryWeights[m];
                        }
                        
                        const signal = currentSignal * 0.7 + memoryWeightedSignal * 0.3;
                        
                        if (signal > bestSignal) {
                            bestSignal = signal;
                            bestDirection = angle;
                        }
                    }
                }
                
                // CRR Regeneration: exp(C(x)/Ω) exponential coherence weighting
                const idx = Math.floor(this.x) + Math.floor(this.y) * this.simulation.gridSize;
                const localCoherence = this.simulation.fields.coherence[idx];
                
                // exp(C/Ω): Exponential amplification by accumulated coherence
                const RegenerationWeight = Math.exp(localCoherence / OMEGA);
                
                // Growth speed with CRR weighting
                const stressMultiplier = Math.pow(1.0 - overallStress, 2);
                const baseSpeed = 0.8 * 1.2; // Oyster mushroom base speed
                const effectiveSpeed = baseSpeed * RegenerationWeight * stressMultiplier;
                
                // Store Regeneration amplification for metrics
                this.RegenerationAmplification = RegenerationWeight;
                
                // Update velocity (with memory-weighted navigation)
                const currentAngle = Math.atan2(this.vy, this.vx);
                const targetAngle = bestDirection;
                const turnRate = 0.3 * stressMultiplier;
                
                const newAngle = currentAngle + this.normalizeAngle(targetAngle - currentAngle) * turnRate;
                this.vx = Math.cos(newAngle) * effectiveSpeed;
                this.vy = Math.sin(newAngle) * effectiveSpeed;
                
                // Move
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary conditions
                this.x = Math.max(5, Math.min(this.simulation.gridSize - 5, this.x));
                this.y = Math.max(5, Math.min(this.simulation.gridSize - 5, this.y));
                
                // Deposit hyphal material and update coherence
                this.depositHyphalMaterial(effectiveSpeed);
                
                // Check for anastomosis
                this.checkAnastomosis(allHyphae);
                
                // Branching with coherence-weighted probability
                const branches = this.performBranching(RegenerationWeight, stressMultiplier);
                
                // Natural energy decay
                const baseDecay = 0.9995;
                const stressDecay = overallStress * 0.002;
                this.energy *= (baseDecay - stressDecay);
                
                return branches;
            }
            
            depositHyphalMaterial(efficiency) {
                const depositRadius = this.diameter + 1;
                
                for (let dy = -depositRadius; dy <= depositRadius; dy++) {
                    for (let dx = -depositRadius; dx <= depositRadius; dx++) {
                        const px = Math.floor(this.x + dx);
                        const py = Math.floor(this.y + dy);
                        
                        if (px >= 0 && px < this.simulation.gridSize && py >= 0 && py < this.simulation.gridSize) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= depositRadius) {
                                const idx = px + py * this.simulation.gridSize;
                                const strength = Math.exp(-dist * dist / (depositRadius * depositRadius));
                                
                                this.simulation.fields.hyphalDensity[idx] = Math.min(1, this.simulation.fields.hyphalDensity[idx] + 0.04 * strength * efficiency);
                                this.simulation.fields.growthActivity[idx] = Math.min(1, this.simulation.fields.growthActivity[idx] + Math.abs(this.vx * this.vy) * strength * 0.5);
                                this.simulation.fields.fruitingReadiness[idx] = Math.min(1, this.simulation.fields.fruitingReadiness[idx] + (this.simulation.fields.hyphalDensity[idx] > 0.5 ? 0.01 * efficiency : 0));
                                
                                const consumption = 0.001 * strength * efficiency;
                                this.simulation.fields.nutrients[idx] = Math.max(0, this.simulation.fields.nutrients[idx] - consumption);
                                this.simulation.fields.decomposition[idx] = Math.min(1, this.simulation.fields.decomposition[idx] + consumption * 0.5);
                            }
                        }
                    }
                }
            }
            
            checkAnastomosis(allHyphae) {
                for (let other of allHyphae) {
                    if (other === this || other.species !== this.species) continue;
                    
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < this.anastomosisRadius && Math.random() < 0.01) {
                        this.energy = Math.min(1.2, this.energy + 0.1);
                        other.energy = Math.min(1.2, other.energy + 0.1);
                    }
                }
            }
            
            performBranching(RegenerationWeight, stressMultiplier) {
                const branches = [];
                this.branchCooldown = Math.max(0, this.branchCooldown - 1);
                
                const branchThreshold = 0.8 - (1.0 - stressMultiplier) * 0.3;
                const baseBranchRate = 0.8;
                
                // CRR: Branching probability amplified by coherence
                const coherenceBoost = Math.min(2.0, RegenerationWeight);
                
                if (this.energy > branchThreshold && this.branchCooldown <= 0 && 
                    Math.random() < baseBranchRate * 0.002 * stressMultiplier * coherenceBoost && this.generation < 6) {
                    
                    const numBranches = Math.random() < (0.3 * stressMultiplier) ? 2 : 1;
                    for (let i = 0; i < numBranches; i++) {
                        const branchAngle = Math.atan2(this.vy, this.vx) + (Math.random() - 0.5) * Math.PI * 0.6;
                        const branch = new HyphalTip(this.x, this.y, this.simulation, this);
                        branch.vx = Math.cos(branchAngle);
                        branch.vy = Math.sin(branchAngle);
                        branch.diameter = this.diameter * 0.8;
                        branches.push(branch);
                        
                        const idx = Math.floor(this.x) + Math.floor(this.y) * this.simulation.gridSize;
                        if (idx >= 0 && idx < this.simulation.totalCells) {
                            this.simulation.fields.branchingActivity[idx] = Math.min(1, this.simulation.fields.branchingActivity[idx] + 0.3 * stressMultiplier);
                        }
                    }
                    
                    this.branchCooldown = (100 + Math.random() * 200) / stressMultiplier;
                    this.energy *= 0.8;
                }
                
                return branches;
            }
            
            normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }
        }
        
        class FruitingBody {
            constructor(x, y, species, environmentalHealth) {
                this.x = x;
                this.y = y;
                this.size = 1;
                this.maxSize = 8 + Math.random() * 12 * environmentalHealth;
                this.growth = 0.1 * environmentalHealth;
                this.species = species;
                this.age = 0;
            }
            
            update(environmentalHealth) {
                this.age++;
                if (this.size < this.maxSize) {
                    this.size += this.growth * environmentalHealth;
                    this.growth *= 0.99;
                }
            }
        }
        
        class MyceliumSimulation {
            constructor() {
                this.gridSize = 700;
                this.totalCells = this.gridSize * this.gridSize;
                this.visualizationMode = 'hyphal';
                
                this.environment = new EnvironmentalParameters();
                this.fields = new FieldArrays(this.totalCells);
                
                this.simulationDay = 0;
                this.isPlaying = true;
                this.ruptureCounter = 0;
                
                this.hyphae = [];
                this.fruitingBodies = [];
                this.inoculationPoints = [];
                
                this.initializeCanvas();
                this.initializeSimulation();
                this.setupEventHandlers();
                this.setupControls();
                this.startAnimationLoop();
            }
            
            initializeCanvas() {
                this.canvas = document.getElementById('canvas');
                this.context = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.height = this.gridSize;
            }
            
            initializeSimulation() {
                this.hyphae = [];
                this.fruitingBodies = [];
                this.inoculationPoints = [];
                this.simulationDay = 0;
                this.ruptureCounter = 0;
                
                const substrateProps = SubstrateManager.getProperties(this.environment.substrateType);
                this.fields.resetFields(substrateProps.nutrients, this.environment.moisture);
                
                // Initial inoculations
                this.addInoculation(this.gridSize * 0.3, this.gridSize * 0.5);
                this.addInoculation(this.gridSize * 0.7, this.gridSize * 0.5);
            }
            
            addInoculation(x, y) {
                for (let i = 0; i < 20; i++) {
                    this.hyphae.push(new HyphalTip(
                        x + (Math.random() - 0.5) * 10,
                        y + (Math.random() - 0.5) * 10,
                        this
                    ));
                }
                this.inoculationPoints.push({x, y, age: 0});
            }
            
            addNutrients(x, y) {
                const radius = 25;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const px = Math.floor(x + dx);
                        const py = Math.floor(y + dy);
                        
                        if (px >= 0 && px < this.gridSize && py >= 0 && py < this.gridSize) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= radius) {
                                const idx = px + py * this.gridSize;
                                const strength = Math.exp(-dist * dist / (radius * radius * 0.3));
                                this.fields.nutrients[idx] = Math.min(1, this.fields.nutrients[idx] + 0.3 * strength);
                            }
                        }
                    }
                }
            }
            
            addMoisture(x, y) {
                const radius = 30;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const px = Math.floor(x + dx);
                        const py = Math.floor(y + dy);
                        
                        if (px >= 0 && px < this.gridSize && py >= 0 && py < this.gridSize) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= radius) {
                                const idx = px + py * this.gridSize;
                                const strength = Math.exp(-dist * dist / (radius * radius * 0.3));
                                this.fields.moistureField[idx] = Math.min(1, this.fields.moistureField[idx] + 0.2 * strength);
                            }
                        }
                    }
                }
            }
            
            triggerFruiting() {
                const environmentalHealth = this.environment.getEnvironmentalHealth();
                
                for (let y = 20; y < this.gridSize - 20; y += 30) {
                    for (let x = 20; x < this.gridSize - 20; x += 30) {
                        let totalDensity = 0;
                        let totalCoherence = 0;
                        const checkRadius = 15;
                        
                        for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                            for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                                const px = x + dx;
                                const py = y + dy;
                                if (px >= 0 && px < this.gridSize && py >= 0 && py < this.gridSize) {
                                    const idx = px + py * this.gridSize;
                                    totalDensity += this.fields.hyphalDensity[idx];
                                    totalCoherence += this.fields.coherence[idx];
                                }
                            }
                        }
                        
                        const avgDensity = totalDensity / ((checkRadius * 2 + 1) ** 2);
                        const avgCoherence = totalCoherence / ((checkRadius * 2 + 1) ** 2);
                        
                        // CRR: Fruiting probability increases with coherence
                        const coherenceBoost = Math.min(2.0, 1.0 + avgCoherence * 2);
                        
                        if (avgDensity > (0.7 * 0.6) && Math.random() < (0.6 * environmentalHealth * coherenceBoost)) {
                            this.fruitingBodies.push(new FruitingBody(
                                x + (Math.random() - 0.5) * 20,
                                y + (Math.random() - 0.5) * 20,
                                'oyster',
                                environmentalHealth
                            ));
                        }
                    }
                }
            }
            
            simulationStep() {
                if (!this.isPlaying) return;
                
                const environmentalHealth = this.environment.getEnvironmentalHealth();
                const stressData = this.environment.calculateOverallStress();
                
                // CRR: Update coherence field C(x,t) = ∫L(x,τ)dτ
                this.fields.updateCoherence();
                
                // Update activity fields
                this.fields.decayActivityFields();
                this.fields.updateEnvironmentalStress(stressData.combined);
                
                // Update hyphae
                const newHyphae = [];
                for (let hyphal of this.hyphae) {
                    const branches = hyphal.update(this.hyphae);
                    newHyphae.push(...branches);
                }
                this.hyphae.push(...newHyphae);
                
                // Remove dead hyphae (rupture events)
                const initialCount = this.hyphae.length;
                this.hyphae = this.hyphae.filter(h => h.energy > 0.1);
                const finalCount = this.hyphae.length;
                this.ruptureCounter += (initialCount - finalCount);
                
                // Update fruiting bodies
                for (let fruit of this.fruitingBodies) {
                    fruit.update(environmentalHealth);
                }
                
                // Environmental processes
                this.fields.diffuse(this.fields.nutrients, 0.01 * environmentalHealth, this.gridSize);
                this.fields.diffuse(this.fields.moistureField, 0.005, this.gridSize);
                
                // Natural moisture evaporation
                for (let i = 0; i < this.totalCells; i++) {
                    this.fields.moistureField[i] *= (0.9999 + environmentalHealth * 0.0001);
                }
                
                // Spontaneous fruiting (coherence-weighted)
                if (this.simulationDay > 7 && this.simulationDay % 5 === 0 && Math.random() < (0.3 * environmentalHealth)) {
                    this.triggerFruiting();
                }
                
                this.simulationDay += 0.1;
                this.updateUI();
            }
            
            updateVisualizationLegend() {
                const legends = {
                    hyphal: "Showing hyphal network density - bright areas indicate mature mycelium",
                    coherence: "CRR Coherence Field C(x,t) = ∫L(x,τ)dτ - shows accumulated temporal history",
                    growth: "Growth activity - bright areas show active hyphal extension",
                    network: "Network formation - lines show connections between hyphal nodes and branching patterns"
                };
                
                document.getElementById('vizLegend').textContent = legends[this.visualizationMode];
            }
            
            updateUI() {
                const environmentalHealth = this.environment.getEnvironmentalHealth();
                
                // Calculate metrics
                let totalMass = 0, totalDecomp = 0;
                const avgCoherence = this.fields.getAverageCoherence();
                
                // Calculate average Regeneration amplification
                let totalRegenerationAmp = 0;
                for (let h of this.hyphae) {
                    if (h.RegenerationAmplification) totalRegenerationAmp += h.RegenerationAmplification;
                }
                const avgRegenerationAmp = this.hyphae.length > 0 ? totalRegenerationAmp / this.hyphae.length : 1.0;
                
                for (let i = 0; i < this.totalCells; i++) {
                    totalMass += this.fields.hyphalDensity[i];
                    totalDecomp += this.fields.decomposition[i];
                }
                
                const totalLength = totalMass * 0.1 * (0.5 + environmentalHealth * 0.5);
                const branchCount = this.hyphae.length;
                const effectiveGrowthRate = branchCount * 0.1 * environmentalHealth * avgRegenerationAmp;
                
                document.getElementById('hyphalMass').textContent = (totalMass * 0.001 * (0.7 + environmentalHealth * 0.3)).toFixed(2) + 'g';
                document.getElementById('avgCoherence').textContent = avgCoherence.toFixed(2);
                document.getElementById('RegenerationAmp').textContent = avgRegenerationAmp.toFixed(2) + '×';
                document.getElementById('networkLength').textContent = totalLength.toFixed(1) + 'cm';
                document.getElementById('branchPoints').textContent = Math.floor(branchCount * (0.8 + environmentalHealth * 0.2));
                document.getElementById('ruptureEvents').textContent = this.ruptureCounter;
                document.getElementById('decomposition').textContent = ((totalDecomp / this.totalCells) * 100 * (0.6 + environmentalHealth * 0.4)).toFixed(1) + '%';
                document.getElementById('fruitingBodies').textContent = this.fruitingBodies.length;
                document.getElementById('growthRate').textContent = effectiveGrowthRate.toFixed(1) + 'mm/day';
                
                // Update status indicators
                const limits = this.environment.getBiologicalLimits();
                this.updateStatusIndicator('tempStatus', this.environment.temperature, limits.temperature.optimal);
                this.updateStatusIndicator('moistStatus', this.environment.moisture, limits.moisture.optimal);
                this.updateStatusIndicator('phStatus', this.environment.phLevel, limits.ph.optimal);
                this.updateStatusIndicator('oxyStatus', this.environment.oxygenLevel, limits.oxygen.optimal);
                this.updateStatusIndicator('co2Status', this.environment.co2Level, limits.co2.optimal);
            }
            
            updateStatusIndicator(elementId, value, optimalRange) {
                const element = document.getElementById(elementId);
                if (!element) return;
                
                if (value >= optimalRange[0] && value <= optimalRange[1]) {
                    element.className = 'status-indicator status-optimal';
                } else if (value >= optimalRange[0] * 0.8 && value <= optimalRange[1] * 1.2) {
                    element.className = 'status-indicator status-good';
                } else if (value >= optimalRange[0] * 0.6 && value <= optimalRange[1] * 1.4) {
                    element.className = 'status-indicator status-poor';
                } else {
                    element.className = 'status-indicator status-critical';
                }
            }
            
            render() {
                const imageData = this.context.createImageData(this.gridSize, this.gridSize);
                const pixels = imageData.data;
                const substrateColour = SubstrateManager.getProperties(this.environment.substrateType).colour;
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const idx = x + y * this.gridSize;
                        const pixelIdx = idx * 4;
                        
                        let r, g, b;
                        
                        switch (this.visualizationMode) {
                            case 'hyphal':
                                const density = this.fields.hyphalDensity[idx];
                                const speciesColour = [220, 210, 190];
                                if (density > 0.02) {
                                    const intensity = Math.min(1, density * 2);
                                    r = Math.floor(speciesColour[0] * intensity + substrateColour[0] * (1 - intensity));
                                    g = Math.floor(speciesColour[1] * intensity + substrateColour[1] * (1 - intensity));
                                    b = Math.floor(speciesColour[2] * intensity + substrateColour[2] * (1 - intensity));
                                } else {
                                    r = substrateColour[0];
                                    g = substrateColour[1];
                                    b = substrateColour[2];
                                }
                                break;
                            
                            case 'coherence':
                                // CRR: Visualize coherence field C(x,t)
                                const coherence = this.fields.coherence[idx];
                                const coherenceIntensity = Math.min(1, coherence * 5); // Scale for visibility
                                r = Math.floor(substrateColour[0] + coherenceIntensity * 100);
                                g = Math.floor(substrateColour[1] + coherenceIntensity * 150);
                                b = Math.floor(substrateColour[2] + coherenceIntensity * 200);
                                break;
                                
                            case 'growth':
                                const growth = this.fields.growthActivity[idx];
                                r = Math.floor(substrateColour[0] + growth * 150);
                                g = Math.floor(substrateColour[1] + growth * 200);
                                b = Math.floor(substrateColour[2] + growth * 100);
                                break;
                                
                            case 'network':
                                r = 20;
                                g = 25;
                                b = 30;
                                const networkDensity = this.fields.hyphalDensity[idx];
                                if (networkDensity > 0.1) {
                                    r += networkDensity * 40;
                                    g += networkDensity * 50;
                                    b += networkDensity * 60;
                                }
                                break;
                                
                            default:
                                r = substrateColour[0];
                                g = substrateColour[1];
                                b = substrateColour[2];
                        }
                        
                        pixels[pixelIdx] = Math.max(0, Math.min(255, r));
                        pixels[pixelIdx + 1] = Math.max(0, Math.min(255, g));
                        pixels[pixelIdx + 2] = Math.max(0, Math.min(255, b));
                        pixels[pixelIdx + 3] = 255;
                    }
                }
                
                this.context.putImageData(imageData, 0, 0);
                
                // Network formation visualization
                if (this.visualizationMode === 'network') {
                    this.drawNetworkConnections();
                }
                
                // Draw fruiting bodies
                this.drawFruitingBodies();
            }
            
            drawNetworkConnections() {
                // Draw anastomosis connections
                this.context.strokeStyle = 'rgba(150, 200, 255, 0.6)';
                this.context.lineWidth = 1;
                
                for (let i = 0; i < this.hyphae.length; i++) {
                    const hyphal1 = this.hyphae[i];
                    for (let j = i + 1; j < this.hyphae.length; j++) {
                        const hyphal2 = this.hyphae[j];
                        
                        if (hyphal1.species !== hyphal2.species) continue;
                        
                        const dx = hyphal1.x - hyphal2.x;
                        const dy = hyphal1.y - hyphal2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < hyphal1.anastomosisRadius && dist > 2) {
                            const opacity = 1 - (dist / hyphal1.anastomosisRadius);
                            this.context.strokeStyle = `rgba(150, 200, 255, ${opacity * 0.4})`;
                            this.context.beginPath();
                            this.context.moveTo(hyphal1.x, hyphal1.y);
                            this.context.lineTo(hyphal2.x, hyphal2.y);
                            this.context.stroke();
                        }
                    }
                }
                
                // Draw parent-child branching relationships
                this.context.strokeStyle = 'rgba(255, 200, 100, 0.7)';
                this.context.lineWidth = 1.5;
                for (let hyphal of this.hyphae) {
                    if (hyphal.parent && hyphal.age < 50) {
                        const fadeRatio = 1 - (hyphal.age / 50);
                        this.context.strokeStyle = `rgba(255, 200, 100, ${fadeRatio * 0.7})`;
                        this.context.beginPath();
                        this.context.moveTo(hyphal.parent.x, hyphal.parent.y);
                        this.context.lineTo(hyphal.x, hyphal.y);
                        this.context.stroke();
                    }
                }
                
                // Draw hyphal tips as nodes (color-coded by Regeneration amplification)
                for (let hyphal of this.hyphae) {
                    const energy = hyphal.energy;
                    const RegenerationAmp = hyphal.RegenerationAmplification || 1.0;
                    const size = hyphal.diameter + energy;
                    
                    // Color by Regeneration amplification
                    if (RegenerationAmp > 2.0) {
                        this.context.fillStyle = 'rgba(255, 100, 255, 0.9)'; // Magenta for very high
                    } else if (RegenerationAmp > 1.5) {
                        this.context.fillStyle = 'rgba(100, 255, 150, 0.8)'; // Green for high
                    } else if (RegenerationAmp > 1.0) {
                        this.context.fillStyle = 'rgba(255, 255, 100, 0.8)'; // Yellow for moderate
                    } else {
                        this.context.fillStyle = 'rgba(255, 150, 100, 0.8)'; // Orange for low
                    }
                    
                    this.context.beginPath();
                    this.context.arc(hyphal.x, hyphal.y, size * 0.8, 0, Math.PI * 2);
                    this.context.fill();
                    
                    this.context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.context.beginPath();
                    this.context.arc(hyphal.x, hyphal.y, 1, 0, Math.PI * 2);
                    this.context.fill();
                }
            }
            
            drawFruitingBodies() {
                for (let fruit of this.fruitingBodies) {
                    const capGradient = this.context.createRadialGradient(
                        fruit.x, fruit.y - fruit.size, 0,
                        fruit.x, fruit.y - fruit.size, fruit.size * 0.8
                    );
                    
                    capGradient.addColorStop(0, 'rgba(200, 180, 160, 0.9)');
                    capGradient.addColorStop(1, 'rgba(120, 100, 80, 0.7)');
                    
                    this.context.fillStyle = capGradient;
                    this.context.beginPath();
                    this.context.ellipse(fruit.x, fruit.y - fruit.size, fruit.size * 0.8, fruit.size * 0.4, 0, 0, Math.PI * 2);
                    this.context.fill();
                    
                    this.context.fillStyle = 'rgba(230, 220, 210, 0.8)';
                    this.context.fillRect(fruit.x - fruit.size * 0.1, fruit.y - fruit.size * 0.2, fruit.size * 0.2, fruit.size * 0.6);
                }
            }
            
            setupEventHandlers() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * this.gridSize / rect.width;
                    const y = (e.clientY - rect.top) * this.gridSize / rect.height;
                    
                    if (e.shiftKey) {
                        this.addMoisture(x, y);
                    } else {
                        this.addInoculation(x, y);
                    }
                });
                
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * this.gridSize / rect.width;
                    const y = (e.clientY - rect.top) * this.gridSize / rect.height;
                    
                    this.addNutrients(x, y);
                });
                
                window.addEventListener('keydown', (e) => {
                    switch (e.key.toLowerCase()) {
                        case 'r':
                            this.initializeSimulation();
                            break;
                        case 'f':
                            this.triggerFruiting();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.isPlaying = !this.isPlaying;
                            break;
                    }
                });
            }
            
            setupControls() {
                // Visualisation mode controls
                document.querySelectorAll('input[name="vizMode"]').forEach(radio => {
                    radio.addEventListener('change', () => {
                        if (radio.checked) {
                            this.visualizationMode = radio.value;
                            this.updateVisualizationLegend();
                        }
                    });
                });
                
                // Parameter controls
                const paramMap = {
                    'temperature': { prop: 'temperature', suffix: '°C', display: 'tempVal' },
                    'moisture': { prop: 'moisture', suffix: '%', display: 'moistureVal' },
                    'ph': { prop: 'phLevel', suffix: '', display: 'phVal', decimals: 1 },
                    'oxygen': { prop: 'oxygenLevel', suffix: '%', display: 'oxygenVal' },
                    'co2': { prop: 'co2Level', suffix: 'ppm', display: 'co2Val' }
                };
                
                Object.keys(paramMap).forEach(param => {
                    const slider = document.getElementById(param);
                    const config = paramMap[param];
                    const display = document.getElementById(config.display);
                    
                    if (slider && display) {
                        slider.oninput = () => {
                            const value = parseFloat(slider.value);
                            this.environment[config.prop] = value;
                            const displayValue = config.decimals ? value.toFixed(config.decimals) : value;
                            display.textContent = displayValue + config.suffix;
                        };
                    }
                });
                
                // Substrate controls
                document.querySelectorAll('.substrate-btn').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.substrate-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.environment.substrateType = btn.dataset.substrate;
                        this.initializeSimulation();
                    };
                });
                
                this.updateVisualizationLegend();
            }
            
            startAnimationLoop() {
                const animate = () => {
                    this.simulationStep();
                    this.render();
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }
        
        function resetSimulation() {
            if (globalSimulation) {
                globalSimulation.initializeSimulation();
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            globalSimulation = new MyceliumSimulation();
        });
    </script>
</body>
</html>