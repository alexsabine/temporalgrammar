<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coherence Simulation: Bee Ecosystem</title>
    <style>
        body {
            margin: 0;
            padding: 15px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 40%, #90EE90 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: auto;
        }

        .header {
            text-align: center;
            color: #2d5016;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.8em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            max-width: 900px;
            margin: 10px auto;
            line-height: 1.6;
            background: rgba(255,255,255,0.8);
            padding: 15px;
            border-radius: 10px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            background: rgba(255,255,255,0.9);
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: white;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .primary { background: #22c55e; }
        .primary:hover { background: #16a34a; transform: translateY(-1px); }
        .secondary { background: #3b82f6; }
        .secondary:hover { background: #2563eb; transform: translateY(-1px); }
        .danger { background: #ef4444; }
        .danger:hover { background: #dc2626; transform: translateY(-1px); }
        .webcam { background: #f59e0b; }
        .webcam:hover { background: #d97706; transform: translateY(-1px); }
        .audio { background: #8b5cf6; }
        .audio:hover { background: #7c3aed; transform: translateY(-1px); }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider {
            width: 100px;
            accent-color: #22c55e;
        }

        .value-display {
            min-width: 40px;
            font-weight: bold;
            color: #2d5016;
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .stat-card {
            background: rgba(255,255,255,0.9);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value.coherence { color: #8b5cf6; }
        .stat-value.population { color: #22c55e; }
        .stat-value.hive { color: #f59e0b; }
        .stat-value.resources { color: #06b6d4; }
        .stat-value.honey { color: #fbbf24; }
        .stat-value.interior { color: #84cc16; }
        .stat-value.intelligence { color: #ec4899; }
        .stat-value.adaptation { color: #f97316; }
        .stat-value.rupture { color: #ef4444; }
        .stat-value.rebirth { color: #10b981; }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        canvas {
            border: 3px solid #2d5016;
            border-radius: 12px;
            background: #87CEEB;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        #hiveInterior {
            display: none;
            background: #8B4513;
        }

        .webcam-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(220, 38, 38, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.8em;
            display: none;
        }

        .audio-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(139, 92, 246, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.8em;
            display: none;
        }

        .info-panel {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .info-panel h3 {
            color: #2d5016;
            margin-bottom: 15px;
            text-align: center;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .feature-card {
            background: rgba(34, 197, 94, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(34, 197, 94, 0.2);
        }

        .feature-card.new-feature {
            background: rgba(251, 191, 36, 0.05);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .feature-card.sound-feature {
            background: rgba(139, 92, 246, 0.05);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .feature-card h4 {
            margin: 0 0 8px 0;
            color: #16a34a;
            font-size: 1.1em;
        }

        .new-feature h4 {
            color: #d97706;
        }

        .sound-feature h4 {
            color: #8b5cf6;
        }

        .feature-card p {
            margin: 0;
            font-size: 0.9em;
            line-height: 1.4;
            color: #2d5016;
        }

        .visualization-controls {
            max-width: 1200px;
            margin: 20px auto 0;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .visualization-controls h3 {
            color: #1f3a0f;
            margin-top: 0;
            text-align: center;
            border-bottom: 2px solid #22c55e;
            padding-bottom: 10px;
        }

        .control-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-section {
            background: rgba(34, 197, 94, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(34, 197, 94, 0.2);
        }

        .control-section h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: #16a34a;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(34, 197, 94, 0.3);
            padding-bottom: 5px;
        }

        .control-section label {
            display: block;
            margin-bottom: 8px;
            color: #2d5016;
            font-size: 0.9em;
            cursor: pointer;
            padding: 3px 0;
            transition: background-color 0.2s ease;
        }

        .control-section label:hover {
            background-color: rgba(34, 197, 94, 0.1);
            border-radius: 4px;
            padding-left: 5px;
        }

        .control-section input[type="checkbox"] {
            margin-right: 8px;
            width: 14px;
            height: 14px;
            accent-color: #22c55e;
        }

        .honey-section {
            background: rgba(251, 191, 36, 0.05);
            border: 1px solid rgba(251, 191, 36, 0.2);
        }

        .honey-section h4 {
            color: #d97706;
            border-bottom: 1px solid rgba(251, 191, 36, 0.3);
        }

        .audio-section {
            background: rgba(139, 92, 246, 0.05);
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .audio-section h4 {
            color: #8b5cf6;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üêù Coherence Simulation: Bee Ecosystem</h1>
        <p>
            <strong>Advanced Simulation with Hive Interior:</strong> Watch as bees with RNA-encoded behaviors and visual cortexes 
            spontaneously build their hive, develop foraging pathways, enter the hive to construct internal structures, 
            produce emergent honey, and adapt to environmental changes. 
            Everything emerges from coherence principles - no hardcoded behaviors. <strong>Webcam:</strong> View inside the hive!
            <strong>Sound:</strong> Experience realistic bee buzzing audio!
        </p>
    </div>

    <div class="controls">
        <div class="control-group">
            <button id="playPause" class="primary">‚è∏Ô∏è Pause</button>
            <button id="reset" class="secondary">üîÑ Reset Colony</button>
            <button id="addBees" class="primary">üêù Add Bees</button>
        </div>
        
        <div class="control-group">
            <button id="weather" class="secondary">üå§Ô∏è Change Weather</button>
            <button id="predator" class="danger">ü¶Ö Add Predator</button>
            <button id="bloom" class="primary">üå∏ Flower Bloom</button>
            <button id="mutation" class="secondary">üß¨ Trigger Mutation</button>
        </div>

        <div class="control-group">
            <button id="webcamToggle" class="webcam">üìπ Hive Webcam</button>
            <button id="honeyHarvest" class="primary">üçØ Harvest Honey</button>
            <button id="soundToggle" class="audio">üîä Enable Sound</button>
        </div>

        <div class="control-group">
            <label>Environment Speed:</label>
            <div class="slider-container">
                <input type="range" id="speedSlider" class="slider" min="0.1" max="3" step="0.1" value="1">
                <span id="speedValue" class="value-display">1.0x</span>
            </div>
        </div>

        <div class="control-group">
            <label>CRR Sensitivity:</label>
            <div class="slider-container">
                <input type="range" id="ucfSlider" class="slider" min="0.5" max="2" step="0.1" value="1">
                <span id="ucfValue" class="value-display">1.0x</span>
            </div>
        </div>

        <div class="control-group">
            <label>Audio Volume:</label>
            <div class="slider-container">
                <input type="range" id="volumeSlider" class="slider" min="0" max="100" step="5" value="50">
                <span id="volumeValue" class="value-display">50%</span>
            </div>
        </div>
    </div>

    <div class="stats-display">
        <div class="stat-card">
            <div class="stat-value coherence" id="avgCoherence">0.000</div>
            <div class="stat-label">Avg Coherence</div>
        </div>
        <div class="stat-card">
            <div class="stat-value population" id="population">0</div>
            <div class="stat-label">Population</div>
        </div>
        <div class="stat-card">
            <div class="stat-value hive" id="hiveProgress">0%</div>
            <div class="stat-label">Hive Progress</div>
        </div>
        <div class="stat-card">
            <div class="stat-value resources" id="totalResources">0.00</div>
            <div class="stat-label">Resources</div>
        </div>
        <div class="stat-card">
            <div class="stat-value honey" id="honeyProduction">0.00</div>
            <div class="stat-label">Honey Stores</div>
        </div>
        <div class="stat-card">
            <div class="stat-value interior" id="interiorBees">0</div>
            <div class="stat-label">Bees Inside</div>
        </div>
        <div class="stat-card">
            <div class="stat-value intelligence" id="avgIntelligence">0.00</div>
            <div class="stat-label">Swarm IQ</div>
        </div>
        <div class="stat-card">
            <div class="stat-value adaptation" id="adaptationRate">0.00</div>
            <div class="stat-label">Adaptation Rate</div>
        </div>
        <div class="stat-card">
            <div class="stat-value rupture" id="ruptureCount">0</div>
            <div class="stat-label">Active Ruptures</div>
        </div>
        <div class="stat-card">
            <div class="stat-value rebirth" id="rebirthCount">0</div>
            <div class="stat-label">Rebirth Events</div>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="ecosystem" width="1200" height="800"></canvas>
        <canvas id="hiveInterior" width="1200" height="800"></canvas>
        <div class="webcam-overlay" id="webcamOverlay">üî¥ LIVE HIVE CAM</div>
        <div class="audio-overlay" id="audioOverlay">üîä AUDIO ENABLED</div>
    </div>

    <div class="info-panel">
        <h3>üß¨ Enhanced Features</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>üß† Visual Cortex</h4>
                <p>Each bee processes visual information through coherence fields, enabling pattern recognition, depth perception, and emergent navigation strategies.</p>
            </div>
            <div class="feature-card">
                <h4>üß¨ RNA Behavioral Encoding</h4>
                <p>Genetic sequences determine personality traits, foraging preferences, and construction abilities. Mutations occur through rupture/rebirth cycles.</p>
            </div>
            <div class="feature-card">
                <h4>üèóÔ∏è Emergent Architecture</h4>
                <p>Hive structure emerges from collective decisions. No blueprints - just pure swarm intelligence guided by coherence optimisation.</p>
            </div>
            <div class="feature-card new-feature">
                <h4>üö™ Hive Interior Access</h4>
                <p>Bees can now enter and exit the hive to construct interior honeycomb structures, process nectar, and create specialised chambers based on emergent needs.</p>
            </div>
            <div class="feature-card new-feature">
                <h4>üçØ Emergent Honey</h4>
                <p>Honey production emerges through collective dynamics. Bees collaboratively process nectar using temporal coherence patterns to optimise honey quality and storage.</p>
            </div>
            <div class="feature-card new-feature">
                <h4>üìπ Live Hive Webcam</h4>
                <p>Advanced webcam mode provides real-time view inside the hive, showing internal construction, honey production, bee activities, and field dynamics in 3D interior space.</p>
            </div>
            <div class="feature-card sound-feature">
                <h4>üîä Immersive Bee Audio</h4>
                <p>Realistic bee buzzing sounds that dynamically respond to population, behavior, and location. Experience the authentic soundscape of a living hive with spatial audio effects.</p>
            </div>
            <div class="feature-card">
                <h4>üåø Dynamic Ecosystem</h4>
                <p>Weather patterns, seasonal changes, and resource availability all influence field dynamics, creating adaptive selection pressures.</p>
            </div>
            <div class="feature-card">
                <h4>üí≠ Collective Intelligence</h4>
                <p>Individual coherence states combine to form emergent swarm 'consciousness'. Colony-level decisions arise from distributed coherence computations. Markovian Bees in a Non-Markovian field of Memory</p>
            </div>
            <div class="feature-card">
                <h4>üîÑ Adaptive Evolution</h4>
                <p>Successful behaviors strengthen through memory entanglement. Failed strategies trigger ruptures, enabling rapid evolutionary adaptation.</p>
            </div>
        </div>
        <p><strong>Current Simulation:</strong> <span id="simInfo">Environment loading... Initialising field dynamics...</span></p>
    </div>

    <!-- Enhanced Visualization Controls -->
    <div class="visualization-controls">
        <h3>üî¨ Mathematical Layer Visualisation</h3>
        
        <div class="control-sections">
            <div class="control-section">
                <h4>üåä Coherence Field Dynamics</h4>
                <label><input type="checkbox" id="showCoherenceField" checked> Coherence Field</label>
                <label><input type="checkbox" id="showRuptureZones"> Rupture Zones</label>
                <label><input type="checkbox" id="showRebirthFields"> Rebirth Fields</label>
                <label><input type="checkbox" id="showMemoryEntanglement"> Memory Entanglement</label>
                <label><input type="checkbox" id="showTemporalDecay"> Temporal Decay</label>
            </div>

            <div class="control-section">
                <h4>üß¨ Genetic & Evolution</h4>
                <label><input type="checkbox" id="showGeneticSequences"> Genetic Sequences</label>
                <label><input type="checkbox" id="showMutationEvents"> Mutation Events</label>
                <label><input type="checkbox" id="showInheritanceLines"> Inheritance Lines</label>
                <label><input type="checkbox" id="showTraitExpressions"> Trait Expressions</label>
                <label><input type="checkbox" id="showEvolutionPressure"> Evolution Pressure</label>
            </div>

            <div class="control-section">
                <h4>üì° Communication Networks</h4>
                <label><input type="checkbox" id="showPheromoneTrails"> Pheromone Trails</label>
                <label><input type="checkbox" id="showWaggleDances"> Waggle Dances</label>
                <label><input type="checkbox" id="showInformationFlow"> Information Flow</label>
                <label><input type="checkbox" id="showSocialNetworks"> Social Networks</label>
                <label><input type="checkbox" id="showDecisionTrees"> Decision Trees</label>
            </div>

            <div class="control-section">
                <h4>üå°Ô∏è Environmental Physics</h4>
                <label><input type="checkbox" id="showWindVectors"> Wind Vectors</label>
                <label><input type="checkbox" id="showTemperatureGradient"> Temperature Gradient</label>
                <label><input type="checkbox" id="showHumidityZones"> Humidity Zones</label>
                <label><input type="checkbox" id="showAirPressure"> Air Pressure</label>
                <label><input type="checkbox" id="showLightIntensity"> Light Intensity</label>
            </div>

            <div class="control-section">
                <h4>‚ö° Energy & Metabolism</h4>
                <label><input type="checkbox" id="showEnergyFlows"> Energy Flows</label>
                <label><input type="checkbox" id="showResourceDistribution"> Resource Distribution</label>
                <label><input type="checkbox" id="showMetabolicRates"> Metabolic Rates</label>
                <label><input type="checkbox" id="showEnergyGradients"> Energy Gradients</label>
                <label><input type="checkbox" id="showNutrientNetworks"> Nutrient Networks</label>
            </div>

            <div class="control-section">
                <h4>üèóÔ∏è Construction Dynamics</h4>
                <label><input type="checkbox" id="showConstructionPaths"> Construction Paths</label>
                <label><input type="checkbox" id="showStructuralIntegrity"> Structural Integrity</label>
                <label><input type="checkbox" id="showBuildingAlgorithms"> Building Algorithms</label>
                <label><input type="checkbox" id="showMaterialFlow"> Material Flow</label>
                <label><input type="checkbox" id="showArchitecturalPlanning"> Architectural Planning</label>
            </div>

            <div class="control-section honey-section">
                <h4>üçØ Honey & Hive Interior</h4>
                <label><input type="checkbox" id="showHoneyFlows"> Honey Production Flows</label>
                <label><input type="checkbox" id="showNectarProcessing"> Nectar Processing</label>
                <label><input type="checkbox" id="showHoneyCombConstruction"> Honeycomb Construction</label>
                <label><input type="checkbox" id="showInteriorActivities"> Interior Activities</label>
                <label><input type="checkbox" id="showHoneyStorage"> Honey Storage</label>
            </div>

            <div class="control-section">
                <h4>ü¶Ö Predator & Threat Dynamics</h4>
                <label><input type="checkbox" id="showThreatZones"> Threat Zones</label>
                <label><input type="checkbox" id="showEscapeVectors"> Escape Vectors</label>
                <label><input type="checkbox" id="showPredatorPatterns"> Predator Patterns</label>
                <label><input type="checkbox" id="showDefenseFormations"> Defense Formations</label>
                <label><input type="checkbox" id="showRiskAssessment"> Risk Assessment</label>
            </div>

            <div class="control-section">
                <h4>üß† Intelligence & Learning</h4>
                <label><input type="checkbox" id="showLearningPaths"> Learning Paths</label>
                <label><input type="checkbox" id="showKnowledgeDistribution"> Knowledge Distribution</label>
                <label><input type="checkbox" id="showAdaptationRates"> Adaptation Rates</label>
                <label><input type="checkbox" id="showIntelligenceNetworks"> Intelligence Networks</label>
                <label><input type="checkbox" id="showEmergentBehaviors"> Emergent Behaviors</label>
            </div>

            <div class="control-section audio-section">
                <h4>üîä Audio & Sound</h4>
                <label><input type="checkbox" id="enableBeeSound" checked> Bee Buzzing</label>
                <label><input type="checkbox" id="enableHiveSound" checked> Hive Ambience</label>
                <label><input type="checkbox" id="enableSpatialAudio" checked> Spatial Audio</label>
                <label><input type="checkbox" id="enableConstructionSound"> Construction Sounds</label>
                <label><input type="checkbox" id="enableWeatherSound"> Weather Audio</label>
            </div>
        </div>
    </div>

    <script>
        // Enhanced UCF Configuration with Hive Interior and Honey Production
        const UCF = {
            COHERENCE_BASE: 0.8,
            RUPTURE_THRESHOLD: 0.25,
            REBIRTH_TEMPERATURE: 2.5,
            MEMORY_DEPTH: 100,
            FIELD_RESOLUTION: 15,
            EMERGENCE_FACTOR: 1.0,
            INTELLIGENCE_FACTOR: 1.0,
            
            // Advanced UCF Parameters
            VISUAL_COHERENCE_RANGE: 150,
            CHEMICAL_COHERENCE_RANGE: 200,
            TEMPORAL_COHERENCE_DECAY: 0.02,
            SPATIAL_COHERENCE_AMPLIFIER: 4.0,
            COLLECTIVE_INTELLIGENCE_THRESHOLD: 0.7,
            
            // NEW: Hive Interior and Honey Parameters
            HIVE_ENTRANCE_RADIUS: 25,
            HONEY_COHERENCE_THRESHOLD: 0.6,
            INTERIOR_COHERENCE_BONUS: 0.2,
            HONEY_PRODUCTION_RATE: 0.001
        };

        // NEW: Advanced Audio System for Bee Simulation
        class BeeAudioSystem {
            constructor() {
                this.audioContext = null;
                this.enabled = false;
                this.volume = 0.5;
                this.sounds = {
                    bees: new Map(),
                    hive: null,
                    ambient: null,
                    construction: null,
                    weather: null
                };
                this.audioSettings = {
                    enableBeeSound: true,
                    enableHiveSound: true,
                    enableSpatialAudio: true,
                    enableConstructionSound: false,
                    enableWeatherSound: false
                };
            }

            async initialize() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create master gain node
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = this.volume;
                    
                    // Initialize audio nodes
                    this.initializeHiveAmbience();
                    this.initializeWeatherSounds();
                    this.initializeConstructionSounds();
                    
                    this.enabled = true;
                    console.log("Bee Audio System initialized");
                    return true;
                } catch (error) {
                    console.warn("Audio initialization failed:", error);
                    return false;
                }
            }

            initializeHiveAmbience() {
                // Create subtle hive ambience
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                
                oscillator.type = 'brown';
                oscillator.frequency.value = 60;
                
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 200;
                filterNode.Q.value = 0.5;
                
                gainNode.gain.value = 0.05;
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.start();
                this.sounds.hive = { oscillator, gainNode, filterNode };
            }

            initializeWeatherSounds() {
                // Weather ambience (wind, etc.)
                const noiseBuffer = this.createNoiseBuffer(2, this.audioContext.sampleRate * 4);
                this.sounds.weather = {
                    buffer: noiseBuffer,
                    source: null,
                    gainNode: this.audioContext.createGain()
                };
                this.sounds.weather.gainNode.gain.value = 0.02;
                this.sounds.weather.gainNode.connect(this.masterGain);
            }

            initializeConstructionSounds() {
                // Construction sound effects
                this.sounds.construction = {
                    gainNode: this.audioContext.createGain(),
                    oscillators: []
                };
                this.sounds.construction.gainNode.gain.value = 0.1;
                this.sounds.construction.gainNode.connect(this.masterGain);
            }

            createNoiseBuffer(channels, length) {
                const buffer = this.audioContext.createBuffer(channels, length, this.audioContext.sampleRate);
                for (let channel = 0; channel < channels; channel++) {
                    const data = buffer.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                }
                return buffer;
            }

            createBeeBuzzSound(bee) {
                if (!this.enabled || !this.audioSettings.enableBeeSound) return null;

                try {
                    // Create bee buzz with multiple oscillators for realistic sound
                    const fundamentalFreq = 200 + bee.id * 5; // Slight frequency variation per bee
                    const activityMultiplier = this.getBeeActivityMultiplier(bee);
                    
                    // Main buzz oscillator
                    const buzzOsc = this.audioContext.createOscillator();
                    buzzOsc.type = 'sawtooth';
                    buzzOsc.frequency.value = fundamentalFreq * activityMultiplier;
                    
                    // Wing beat modulation
                    const wingBeatOsc = this.audioContext.createOscillator();
                    wingBeatOsc.type = 'sine';
                    wingBeatOsc.frequency.value = 230; // Wing beat frequency
                    
                    const wingBeatGain = this.audioContext.createGain();
                    wingBeatGain.gain.value = 0.3;
                    
                    // Gain control
                    const beeGain = this.audioContext.createGain();
                    const baseVolume = this.getBeeBaseVolume(bee);
                    beeGain.gain.value = baseVolume;
                    
                    // Filter for more realistic buzz
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = fundamentalFreq;
                    filter.Q.value = 2;
                    
                    // Spatial audio if enabled
                    let spatialNode = null;
                    if (this.audioSettings.enableSpatialAudio) {
                        spatialNode = this.createSpatialAudioNode(bee);
                    }
                    
                    // Connect audio graph
                    wingBeatOsc.connect(wingBeatGain);
                    wingBeatGain.connect(buzzOsc.frequency);
                    
                    buzzOsc.connect(filter);
                    filter.connect(beeGain);
                    
                    if (spatialNode) {
                        beeGain.connect(spatialNode);
                        spatialNode.connect(this.masterGain);
                    } else {
                        beeGain.connect(this.masterGain);
                    }
                    
                    // Start oscillators
                    buzzOsc.start();
                    wingBeatOsc.start();
                    
                    return {
                        buzzOsc,
                        wingBeatOsc,
                        beeGain,
                        filter,
                        spatialNode,
                        fundamentalFreq
                    };
                } catch (error) {
                    console.warn("Failed to create bee sound:", error);
                    return null;
                }
            }

            createSpatialAudioNode(bee) {
                if (!this.audioContext.createPanner) return null;
                
                const panner = this.audioContext.createPanner();
                panner.panningModel = 'HRTF';
                panner.distanceModel = 'inverse';
                panner.refDistance = 100;
                panner.maxDistance = 1000;
                panner.rolloffFactor = 1;
                
                // Convert bee position to 3D space
                const x = (bee.x - 600) / 600; // Normalize to -1 to 1
                const y = (bee.y - 400) / 400;
                const z = bee.isInside ? -0.5 : 0; // Interior bees slightly behind
                
                panner.setPosition(x, y, z);
                
                return panner;
            }

            getBeeActivityMultiplier(bee) {
                switch (bee.currentBehavior) {
                    case 'foraging': return 1.2;
                    case 'returning_home': return 1.3;
                    case 'construction': return 0.9;
                    case 'exploring': return 1.1;
                    case 'honey_processing': return 0.8;
                    case 'resting': return 0.6;
                    case 'ruptured': return 1.5;
                    default: return 1.0;
                }
            }

            getBeeBaseVolume(bee) {
                let volume = 0.05; // Base volume
                
                // Energy affects volume
                volume *= (0.3 + bee.energy * 0.7);
                
                // Coherence affects volume
                volume *= (0.5 + bee.coherenceState * 0.5);
                
                // Activity affects volume
                volume *= this.getBeeActivityMultiplier(bee);
                
                return Math.min(0.15, volume); // Cap maximum volume
            }

            updateBeeSound(bee, soundData) {
                if (!soundData || !this.enabled) return;

                try {
                    // Update frequency based on activity
                    const activityMultiplier = this.getBeeActivityMultiplier(bee);
                    const newFreq = soundData.fundamentalFreq * activityMultiplier;
                    soundData.buzzOsc.frequency.exponentialRampToValueAtTime(
                        newFreq, 
                        this.audioContext.currentTime + 0.1
                    );
                    
                    // Update volume
                    const newVolume = this.getBeeBaseVolume(bee);
                    soundData.beeGain.gain.exponentialRampToValueAtTime(
                        Math.max(0.001, newVolume), 
                        this.audioContext.currentTime + 0.1
                    );
                    
                    // Update spatial position
                    if (soundData.spatialNode && this.audioSettings.enableSpatialAudio) {
                        const x = (bee.x - 600) / 600;
                        const y = (bee.y - 400) / 400;
                        const z = bee.isInside ? -0.5 : 0;
                        soundData.spatialNode.setPosition(x, y, z);
                    }
                } catch (error) {
                    console.warn("Failed to update bee sound:", error);
                }
            }

            stopBeeSound(soundData) {
                if (!soundData) return;
                
                try {
                    // Fade out before stopping
                    soundData.beeGain.gain.exponentialRampToValueAtTime(
                        0.001, 
                        this.audioContext.currentTime + 0.1
                    );
                    
                    setTimeout(() => {
                        try {
                            soundData.buzzOsc.stop();
                            soundData.wingBeatOsc.stop();
                        } catch (e) {
                            // Oscillator may already be stopped
                        }
                    }, 100);
                } catch (error) {
                    console.warn("Failed to stop bee sound:", error);
                }
            }

            updateHiveAmbience(beeCount, interiorBeeCount, hiveActivity) {
                if (!this.enabled || !this.audioSettings.enableHiveSound || !this.sounds.hive) return;
                
                try {
                    // Adjust hive ambience based on activity
                    const targetVolume = Math.min(0.1, 0.02 + (beeCount * 0.003) + (interiorBeeCount * 0.005));
                    this.sounds.hive.gainNode.gain.exponentialRampToValueAtTime(
                        Math.max(0.001, targetVolume), 
                        this.audioContext.currentTime + 0.5
                    );
                    
                    // Adjust frequency based on hive activity
                    const targetFreq = 60 + (hiveActivity * 20);
                    this.sounds.hive.oscillator.frequency.exponentialRampToValueAtTime(
                        targetFreq, 
                        this.audioContext.currentTime + 0.5
                    );
                } catch (error) {
                    console.warn("Failed to update hive ambience:", error);
                }
            }

            playConstructionSound(duration = 0.2) {
                if (!this.enabled || !this.audioSettings.enableConstructionSound) return;
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = 'square';
                    osc.frequency.value = 150 + Math.random() * 100;
                    
                    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(0.05, this.audioContext.currentTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.sounds.construction.gainNode);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.warn("Failed to play construction sound:", error);
                }
            }

            setVolume(volume) {
                this.volume = volume / 100;
                if (this.masterGain) {
                    this.masterGain.gain.exponentialRampToValueAtTime(
                        Math.max(0.001, this.volume), 
                        this.audioContext.currentTime + 0.1
                    );
                }
            }

            setAudioSetting(setting, value) {
                this.audioSettings[setting] = value;
                
                // Apply setting changes immediately
                if (setting === 'enableHiveSound' && this.sounds.hive) {
                    this.sounds.hive.gainNode.gain.exponentialRampToValueAtTime(
                        value ? 0.05 : 0.001, 
                        this.audioContext.currentTime + 0.1
                    );
                }
            }

            suspend() {
                if (this.audioContext && this.audioContext.state === 'running') {
                    this.audioContext.suspend();
                }
            }

            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }

            destroy() {
                if (this.audioContext) {
                    this.audioContext.close();
                }
                this.enabled = false;
            }
        }

        // Crash Protection & Error Handling System
        class CrashProtection {
            static safeExecute(operation, fallback = null, context = 'unknown') {
                try {
                    return operation();
                } catch (error) {
                    console.warn(`Safe execution failed in ${context}:`, error);
                    return fallback;
                }
            }

            static validateBee(bee) {
                return bee && 
                       typeof bee.x === 'number' && !isNaN(bee.x) && isFinite(bee.x) &&
                       typeof bee.y === 'number' && !isNaN(bee.y) && isFinite(bee.y) &&
                       typeof bee.coherenceState === 'number' && !isNaN(bee.coherenceState) &&
                       bee.genetics && bee.genetics.sequences &&
                       typeof bee.id !== 'undefined' &&
                       typeof bee.currentBehavior === 'string' &&
                       bee.x >= 0 && bee.x <= 1200 &&
                       bee.y >= 0 && bee.y <= 800;
            }

            static validateArray(arr, name = 'array') {
                if (!Array.isArray(arr)) {
                    console.warn(`Expected array for ${name}, got:`, typeof arr);
                    return [];
                }
                return arr.filter(item => item !== null && item !== undefined);
            }

            static safeCanvasOperation(ctx, operation, operationName = 'canvas operation') {
                try {
                    ctx.save();
                    operation();
                    ctx.restore();
                } catch (error) {
                    console.warn(`Canvas operation failed (${operationName}):`, error);
                    try { ctx.restore(); } catch (restoreError) { /* ignore */ }
                }
            }
        }

        // Hive Interior Management System
        class HiveInterior {
            constructor() {
                this.honeyCells = [];
                this.airFlow = [];
                this.honeyStores = 0;
                this.interiorBees = new Set();
                this.constructionQueue = [];
                this.temperatureZones = new Map();
                
                this.initializeInterior();
            }

            initializeInterior() {
                // Create initial honeycomb pattern
                const centerX = 600;
                const centerY = 400;
                const hexSize = 20;
                
                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 20; col++) {
                        const x = centerX + (col - 10) * hexSize * 1.5;
                        const y = centerY + (row - 7.5) * hexSize * Math.sqrt(3) + (col % 2) * hexSize * Math.sqrt(3) / 2;
                        
                        this.honeyCells.push({
                            x: x,
                            y: y,
                            type: Math.random() < 0.7 ? 'storage' : 'brood',
                            honeyLevel: 0,
                            constructionProgress: Math.random() * 0.3,
                            quality: 0,
                            lastAccessed: 0
                        });
                    }
                }

                // Initialize air flow patterns
                for (let i = 0; i < 30; i++) {
                    this.airFlow.push({
                        x: Math.random() * 1200,
                        y: Math.random() * 800,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        temperature: 34 + Math.random() * 2,
                        humidity: 0.6 + Math.random() * 0.2
                    });
                }
            }

            update(bees) {
                this.updateAirFlow();
                this.updateHoneyProduction(bees);
                this.updateStructuralIntegrity(bees);
                this.manageInteriorBees(bees);
            }

            updateAirFlow() {
                this.airFlow.forEach(flow => {
                    // Natural convection patterns
                    flow.temperature += (Math.random() - 0.5) * 0.1;
                    flow.humidity += (Math.random() - 0.5) * 0.02;
                    
                    // Adjust flow based on temperature gradients
                    if (flow.temperature > 35) {
                        flow.vy -= 0.01; // Hot air rises
                    } else if (flow.temperature < 33) {
                        flow.vy += 0.01; // Cool air sinks
                    }
                });
            }

            // Additional comprehensive visualization functions
            renderMutationEvents() {
                this.bees.forEach(bee => {
                    if (bee.genetics.mutations > 0) {
                        const mutationIntensity = Math.min(1, bee.genetics.mutations / 10);
                        this.ctx.strokeStyle = `rgba(255, 0, 255, ${mutationIntensity})`;
                        this.ctx.lineWidth = 2;
                        
                        // DNA helix pattern around bee
                        for (let t = 0; t < Math.PI * 4; t += 0.2) {
                            const r = 15;
                            const x = bee.x + Math.cos(t) * r;
                            const y = bee.y + Math.sin(t * 2) * r * 0.5;
                            
                            if (t === 0) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.stroke();
                    }
                });
            }

            renderTraitExpressions() {
                this.bees.forEach(bee => {
                    // Show dominant traits as colored auras
                    const traits = ['foraging', 'construction', 'social', 'intelligence'];
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                    
                    traits.forEach((trait, index) => {
                        const strength = bee.genetics.getTraitStrength(trait);
                        if (strength > 0.6) {
                            this.ctx.fillStyle = `${colors[index]}33`; // Semi-transparent
                            this.ctx.beginPath();
                            this.ctx.arc(bee.x, bee.y, 15 + strength * 10, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                    });
                });
            }

            renderEvolutionPressure() {
                // Visualize environmental evolution pressure as field overlay
                const pressure = this.geneticEvolution.evolutionPressure;
                
                for (let x = 0; x < 1200; x += 100) {
                    for (let y = 0; y < 800; y += 100) {
                        const totalPressure = pressure.environmental + pressure.predation + pressure.resource + pressure.social;
                        if (totalPressure > 0.1) {
                            this.ctx.fillStyle = `rgba(255, 100, 0, ${totalPressure * 0.3})`;
                            this.ctx.fillRect(x, y, 90, 90);
                            
                            // Pressure indicator text
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = '12px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText(totalPressure.toFixed(2), x + 45, y + 50);
                        }
                    }
                }
            }

            renderDecisionTrees() {
                this.bees.forEach(bee => {
                    // Show decision branches for high-intelligence bees
                    if (bee.intelligence > 0.7) {
                        const decisions = ['forage', 'build', 'explore', 'rest'];
                        
                        decisions.forEach((decision, index) => {
                            const angle = (index / decisions.length) * Math.PI * 2;
                            const probability = Math.random(); // Simplified - would be based on actual decision logic
                            
                            if (probability > 0.3) {
                                this.ctx.strokeStyle = `rgba(100, 255, 100, ${probability})`;
                                this.ctx.lineWidth = Math.max(1, probability * 3);
                                this.ctx.beginPath();
                                this.ctx.moveTo(bee.x, bee.y);
                                this.ctx.lineTo(
                                    bee.x + Math.cos(angle) * 30,
                                    bee.y + Math.sin(angle) * 30
                                );
                                this.ctx.stroke();
                            }
                        });
                    }
                });
            }

            renderMetabolicRates() {
                this.bees.forEach(bee => {
                    // Metabolic rate visualization as heat signature
                    const metabolicRate = 1 - bee.energy; // Higher metabolism when energy is lower
                    const hue = (1 - metabolicRate) * 120; // Red = high metabolism, Green = low
                    
                    this.ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.4)`;
                    this.ctx.beginPath();
                    this.ctx.arc(bee.x, bee.y, 8 + metabolicRate * 12, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            renderEnergyGradients() {
                // Show energy flow between bees and resources
                this.bees.forEach(bee => {
                    if (bee.targetFlower && bee.currentBehavior === 'foraging') {
                        const gradient = this.ctx.createLinearGradient(
                            bee.x, bee.y, 
                            bee.targetFlower.x, bee.targetFlower.y
                        );
                        gradient.addColorStop(0, `rgba(255, 100, 100, ${bee.energy})`);
                        gradient.addColorStop(1, `rgba(100, 255, 100, ${bee.targetFlower.nectar})`);
                        
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(bee.x, bee.y);
                        this.ctx.lineTo(bee.targetFlower.x, bee.targetFlower.y);
                        this.ctx.stroke();
                    }
                });
            }

            renderNutrientNetworks() {
                // Network of resource sharing between flowers
                this.environment.flowers.forEach((flower1, i) => {
                    this.environment.flowers.forEach((flower2, j) => {
                        if (i < j) {
                            const distance = Math.sqrt(
                                (flower1.x - flower2.x) ** 2 + (flower1.y - flower2.y) ** 2
                            );
                            
                            if (distance < 150 && flower1.nectar > 0.5 && flower2.nectar > 0.5) {
                                const networkStrength = (flower1.nectar + flower2.nectar) / 2;
                                this.ctx.strokeStyle = `rgba(0, 255, 0, ${networkStrength * 0.3})`;
                                this.ctx.lineWidth = 1;
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.beginPath();
                                this.ctx.moveTo(flower1.x, flower1.y);
                                this.ctx.lineTo(flower2.x, flower2.y);
                                this.ctx.stroke();
                                this.ctx.setLineDash([]);
                            }
                        }
                    });
                });
            }

            renderBuildingAlgorithms() {
                this.bees.forEach(bee => {
                    if (bee.currentBehavior === 'construction') {
                        // Show construction algorithm as geometric pattern
                        const algorithm = bee.genetics.getTraitStrength('construction');
                        
                        this.ctx.strokeStyle = `rgba(139, 69, 19, ${algorithm})`;
                        this.ctx.lineWidth = 2;
                        
                        // Hexagonal construction pattern
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const radius = 20 * algorithm;
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(bee.x, bee.y);
                            this.ctx.lineTo(
                                bee.x + Math.cos(angle) * radius,
                                bee.y + Math.sin(angle) * radius
                            );
                            this.ctx.stroke();
                        }
                    }
                });
            }

            renderMaterialFlow() {
                this.bees.forEach(bee => {
                    if (bee.constructionMaterial > 0) {
                        // Show material as flowing particles
                        const particleCount = Math.floor(bee.constructionMaterial * 10);
                        
                        for (let i = 0; i < particleCount; i++) {
                            const angle = (i / particleCount) * Math.PI * 2 + this.time * 0.1;
                            const radius = 5 + i;
                            const x = bee.x + Math.cos(angle) * radius;
                            const y = bee.y + Math.sin(angle) * radius;
                            
                            this.ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                    }
                });
            }

            renderArchitecturalPlanning() {
                // Show planned hive expansion
                const hiveCenter = this.environment.hiveCenter;
                const expansionRadius = 100;
                
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const x = hiveCenter.x + Math.cos(angle) * expansionRadius;
                    const y = hiveCenter.y + Math.sin(angle) * expansionRadius;
                    
                    this.ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([10, 20]);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 15, 0, 2 * Math.PI);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            renderPredatorPatterns() {
                this.predatorDynamics.predators.forEach(predator => {
                    // Show predator movement pattern
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 10]);
                    
                    // Predicted movement path
                    for (let t = 0; t < 5; t++) {
                        const futureX = predator.x + predator.vx * t * 10;
                        const futureY = predator.y + predator.vy * t * 10;
                        
                        if (t === 0) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(futureX, futureY);
                        } else {
                            this.ctx.lineTo(futureX, futureY);
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });
            }

            renderDefenseFormations() {
                // Group nearby bees for defense visualization
                const defenseGroups = [];
                
                this.bees.forEach(bee => {
                    let inGroup = false;
                    defenseGroups.forEach(group => {
                        const avgX = group.reduce((sum, b) => sum + b.x, 0) / group.length;
                        const avgY = group.reduce((sum, b) => sum + b.y, 0) / group.length;
                        const distance = Math.sqrt((bee.x - avgX) ** 2 + (bee.y - avgY) ** 2);
                        
                        if (distance < 50) {
                            group.push(bee);
                            inGroup = true;
                        }
                    });
                    
                    if (!inGroup) {
                        defenseGroups.push([bee]);
                    }
                });
                
                // Draw defense formations for groups of 3 or more
                defenseGroups.forEach(group => {
                    if (group.length >= 3) {
                        this.ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
                        this.ctx.lineWidth = 2;
                        
                        // Draw formation polygon
                        this.ctx.beginPath();
                        group.forEach((bee, index) => {
                            if (index === 0) {
                                this.ctx.moveTo(bee.x, bee.y);
                            } else {
                                this.ctx.lineTo(bee.x, bee.y);
                            }
                        });
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                });
            }

            renderRiskAssessment() {
                this.bees.forEach(bee => {
                    // Calculate risk level based on proximity to predators
                    let riskLevel = 0;
                    
                    this.predatorDynamics.predators.forEach(predator => {
                        const distance = Math.sqrt((bee.x - predator.x) ** 2 + (bee.y - predator.y) ** 2);
                        if (distance < 150) {
                            riskLevel += (150 - distance) / 150;
                        }
                    });
                    
                    if (riskLevel > 0.1) {
                        // Risk visualization as warning indicator
                        this.ctx.fillStyle = `rgba(255, 0, 0, ${Math.min(1, riskLevel) * 0.4})`;
                        this.ctx.beginPath();
                        this.ctx.arc(bee.x, bee.y, 10 + riskLevel * 15, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        // Warning symbol
                        this.ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('‚ö†', bee.x, bee.y + 4);
                    }
                });
            }

            renderKnowledgeDistribution() {
                // Show how knowledge spreads through the colony
                this.bees.forEach(bee1 => {
                    if (bee1.experiencePoints > 100) {
                        this.bees.forEach(bee2 => {
                            if (bee1 !== bee2) {
                                const distance = Math.sqrt((bee1.x - bee2.x) ** 2 + (bee1.y - bee2.y) ** 2);
                                if (distance < 80) {
                                    const knowledgeTransfer = Math.exp(-distance / 40) * bee1.experiencePoints / 200;
                                    this.ctx.strokeStyle = `rgba(0, 100, 255, ${knowledgeTransfer})`;
                                    this.ctx.lineWidth = 1;
                                    this.ctx.setLineDash([3, 6]);
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(bee1.x, bee1.y);
                                    this.ctx.lineTo(bee2.x, bee2.y);
                                    this.ctx.stroke();
                                    this.ctx.setLineDash([]);
                                }
                            }
                        });
                    }
                });
            }

            renderEmergentBehaviors() {
                // Identify and highlight emergent swarm behaviors
                const behaviorClusters = {};
                
                this.bees.forEach(bee => {
                    const key = bee.currentBehavior;
                    if (!behaviorClusters[key]) {
                        behaviorClusters[key] = [];
                    }
                    behaviorClusters[key].push(bee);
                });
                
                // Highlight synchronized behaviors
                Object.entries(behaviorClusters).forEach(([behavior, bees], index) => {
                    if (bees.length >= 4) { // Emergent behavior requires coordination
                        const colors = ['rgba(255,100,255,0.2)', 'rgba(100,255,255,0.2)', 'rgba(255,255,100,0.2)', 'rgba(100,255,100,0.2)'];
                        this.ctx.fillStyle = colors[index % colors.length];
                        
                        // Find bounding area of coordinated behavior
                        const minX = Math.min(...bees.map(b => b.x)) - 20;
                        const maxX = Math.max(...bees.map(b => b.x)) + 20;
                        const minY = Math.min(...bees.map(b => b.y)) - 20;
                        const maxY = Math.max(...bees.map(b => b.y)) + 20;
                        
                        this.ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
                        
                        // Label the emergent behavior
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '14px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(behavior.toUpperCase(), (minX + maxX) / 2, minY - 5);
                    }
                });
            }

            renderLearningPaths() {
                this.bees.forEach(bee => {
                    if (bee.experiencePoints > 50) {
                        // Show learning trajectory
                        this.ctx.strokeStyle = `rgba(100, 200, 255, ${Math.min(1, bee.experiencePoints / 200)})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 10]);
                        
                        // Create a spiral learning path
                        this.ctx.beginPath();
                        for (let t = 0; t < Math.PI * 2; t += 0.1) {
                            const r = (bee.experiencePoints / 100) * t;
                            const x = bee.x + Math.cos(t) * r;
                            const y = bee.y + Math.sin(t) * r;
                            if (t === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                });
            }

            renderAdaptationRates() {
                this.bees.forEach(bee => {
                    // Adaptation rate as pulsing circle
                    const pulseIntensity = 0.5 + 0.5 * Math.sin(this.time * 0.1 + bee.id);
                    const radius = 15 + bee.adaptationRate * 20;
                    this.ctx.strokeStyle = `rgba(255, 150, 0, ${bee.adaptationRate * pulseIntensity})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(bee.x, bee.y, radius, 0, 2 * Math.PI);
                    this.ctx.stroke();
                });
            }

            updateHoneyProduction(bees) {
                const interiorBeeArray = Array.from(this.interiorBees).map(id => 
                    bees.find(bee => bee.id === id)).filter(bee => bee);

                this.honeyCells.forEach(cell => {
                    if (cell.type === 'storage') {
                        let honeyProduction = 0;
                        let qualityBonus = 0;

                        interiorBeeArray.forEach(bee => {
                            const distance = Math.sqrt((bee.x - cell.x) ** 2 + (bee.y - cell.y) ** 2);
                            if (distance < 30 && bee.nectar > 0) {
                                const contribution = bee.nectar * UCF.HONEY_PRODUCTION_RATE * bee.coherenceState;
                                honeyProduction += contribution;
                                qualityBonus += bee.genetics.getTraitStrength('honeyProduction') * 0.1;
                                bee.nectar -= contribution * 0.5; // Convert nectar to honey
                            }
                        });

                        cell.honeyLevel = Math.min(1.0, cell.honeyLevel + honeyProduction);
                        cell.quality = Math.min(1.0, cell.quality + qualityBonus * 0.01);
                        this.honeyStores += honeyProduction;
                    }
                });
            }

            updateStructuralIntegrity(bees) {
                const interiorBeeArray = Array.from(this.interiorBees).map(id => 
                    bees.find(bee => bee.id === id)).filter(bee => bee);

                this.honeyCells.forEach(cell => {
                    let coherenceInfluence = 0;
                    let constructionActivity = 0;

                    interiorBeeArray.forEach(bee => {
                        const distance = Math.sqrt((bee.x - cell.x) ** 2 + (bee.y - cell.y) ** 2);
                        if (distance < 50) {
                            coherenceInfluence += bee.coherenceState * Math.exp(-distance / 30);
                            if (bee.currentBehavior === 'construction') {
                                constructionActivity += 0.02;
                            }
                        }
                    });

                    // UCF-based construction progress
                    if (coherenceInfluence > UCF.HONEY_COHERENCE_THRESHOLD) {
                        cell.constructionProgress += constructionActivity * 0.1;
                        cell.constructionProgress = Math.min(1.0, cell.constructionProgress);
                    }
                });
            }

            manageInteriorBees(bees) {
                bees.forEach(bee => {
                    const distanceToHive = Math.sqrt(
                        (bee.x - 600) ** 2 + (bee.y - 400) ** 2
                    );

                    // Check if bee should enter hive - restored more balanced conditions
                    if (!bee.isInside && distanceToHive < UCF.HIVE_ENTRANCE_RADIUS) {
                        // Enter if carrying nectar OR doing construction OR randomly for activity
                        if (bee.nectar > 0.3 || bee.constructionMaterial > 0.1 || 
                            (bee.currentBehavior === 'returning_home' && Math.random() < 0.4) ||
                            (Math.random() < 0.15)) { // 15% random chance for interior activity
                            bee.isInside = true;
                            this.interiorBees.add(bee.id);
                            
                            // Position bee properly inside hive
                            const enterAngle = Math.random() * Math.PI * 2;
                            bee.x = 600 + Math.cos(enterAngle) * 40;
                            bee.y = 400 + Math.sin(enterAngle) * 40;
                        }
                    }

                    // Check if bee should exit hive - less frequent exits to maintain interior population
                    if (bee.isInside && (bee.nectar < 0.05 || bee.energy < 0.2)) {
                        if (Math.random() < 0.2) { // Reduced exit probability to 20%
                            bee.isInside = false;
                            this.interiorBees.delete(bee.id);
                            // Position bee outside hive entrance when exiting
                            const exitAngle = Math.random() * Math.PI * 2;
                            bee.x = 600 + Math.cos(exitAngle) * (UCF.HIVE_ENTRANCE_RADIUS + 10);
                            bee.y = 400 + Math.sin(exitAngle) * (UCF.HIVE_ENTRANCE_RADIUS + 10);
                        }
                    }
                    
                    // Keep interior bees within hive bounds
                    if (bee.isInside) {
                        const maxInteriorRadius = 280;
                        const distanceFromCenter = Math.sqrt((bee.x - 600) ** 2 + (bee.y - 400) ** 2);
                        if (distanceFromCenter > maxInteriorRadius) {
                            const angle = Math.atan2(bee.y - 400, bee.x - 600);
                            bee.x = 600 + Math.cos(angle) * maxInteriorRadius;
                            bee.y = 400 + Math.sin(angle) * maxInteriorRadius;
                        }
                    }
                });
            }

            harvestHoney() {
                let harvestedAmount = 0;
                
                this.honeyCells.forEach(cell => {
                    if (cell.honeyLevel > 0.8 && cell.quality > 0.7) {
                        const harvestable = cell.honeyLevel * 0.8; // Leave some honey
                        harvestedAmount += harvestable;
                        cell.honeyLevel -= harvestable;
                        this.honeyStores -= harvestable;
                    }
                });

                return harvestedAmount;
            }
        }

        // RNA-like Genetic System (Enhanced)
        class BeeGenetics {
            constructor() {
                this.sequences = {
                    foraging: this.generateSequence(8),
                    construction: this.generateSequence(6),
                    social: this.generateSequence(4),
                    intelligence: this.generateSequence(10),
                    vision: this.generateSequence(12),
                    energy: this.generateSequence(6),
                    // NEW: Honey production genetics
                    honeyProduction: this.generateSequence(8),
                    interiorNavigation: this.generateSequence(6)
                };
                this.mutations = 0;
                this.adaptationHistory = [];
            }

            generateSequence(length) {
                const bases = ['A', 'T', 'G', 'C'];
                return Array.from({length}, () => bases[Math.floor(Math.random() * 4)]).join('');
            }

            mutate(intensity = 0.1) {
                Object.keys(this.sequences).forEach(trait => {
                    if (Math.random() < intensity) {
                        const seq = this.sequences[trait].split('');
                        const pos = Math.floor(Math.random() * seq.length);
                        const bases = ['A', 'T', 'G', 'C'];
                        seq[pos] = bases[Math.floor(Math.random() * 4)];
                        this.sequences[trait] = seq.join('');
                        this.mutations++;
                    }
                });
            }

            getTraitStrength(trait) {
                const sequence = this.sequences[trait] || '';
                const gcContent = (sequence.match(/[GC]/g) || []).length / sequence.length;
                const repetition = this.calculateRepetition(sequence);
                return Math.max(0.1, Math.min(1.0, gcContent + repetition * 0.3));
            }

            calculateRepetition(sequence) {
                const patterns = {};
                for (let i = 0; i < sequence.length - 1; i++) {
                    const pair = sequence.substring(i, i + 2);
                    patterns[pair] = (patterns[pair] || 0) + 1;
                }
                return Math.max(...Object.values(patterns)) / sequence.length;
            }

            crossover(partner) {
                const child = new BeeGenetics();
                Object.keys(this.sequences).forEach(trait => {
                    const crossPoint = Math.floor(this.sequences[trait].length / 2);
                    const parent1 = Math.random() < 0.5 ? this : partner;
                    const parent2 = parent1 === this ? partner : this;
                    
                    child.sequences[trait] = 
                        parent1.sequences[trait].substring(0, crossPoint) + 
                        parent2.sequences[trait].substring(crossPoint);
                });
                return child;
            }
        }

        // Enhanced UCF Visual Cortex (Updated for Interior)
        class UCFVisualCortex {
            constructor(bee) {
                this.bee = bee;
                this.visualField = new Map();
                this.patternMemory = [];
                this.depthPerception = 0;
                this.motionDetection = new Map();
                this.colorSensitivity = {
                    UV: bee.genetics.getTraitStrength('vision') * 0.3,
                    blue: bee.genetics.getTraitStrength('vision') * 0.8,
                    green: bee.genetics.getTraitStrength('vision') * 0.6,
                    yellow: bee.genetics.getTraitStrength('vision') * 0.9
                };
                // NEW: Interior-specific vision
                this.interiorVision = bee.genetics.getTraitStrength('interiorNavigation');
            }

            processVisualInput(environment, otherBees, hiveInterior = null) {
                this.visualField.clear();
                const visionRange = UCF.VISUAL_COHERENCE_RANGE * this.bee.genetics.getTraitStrength('vision');
                
                // If bee is inside hive, process interior visual input
                if (this.bee.isInside && hiveInterior) {
                    return this.processInteriorVisualInput(hiveInterior, otherBees);
                }
                
                // Original exterior vision processing
                return this.processExteriorVisualInput(environment, otherBees, visionRange);
            }

            processInteriorVisualInput(hiveInterior, otherBees) {
                const interiorRange = UCF.VISUAL_COHERENCE_RANGE * this.interiorVision;
                
                // Process honey cells
                hiveInterior.honeyCells.forEach((cell, index) => {
                    const distance = Math.sqrt((this.bee.x - cell.x) ** 2 + (this.bee.y - cell.y) ** 2);
                    if (distance <= interiorRange) {
                        this.visualField.set(`cell_${index}`, {
                            type: 'honey_cell',
                            distance: distance,
                            angle: Math.atan2(cell.y - this.bee.y, cell.x - this.bee.x),
                            honeyLevel: cell.honeyLevel,
                            constructionProgress: cell.constructionProgress,
                            coherenceWeight: Math.exp(-distance / (interiorRange * 0.3))
                        });
                    }
                });

                // Process other interior bees
                const interiorBeeArray = Array.from(hiveInterior.interiorBees).map(id => 
                    otherBees.find(bee => bee.id === id)).filter(bee => bee && bee !== this.bee);

                interiorBeeArray.forEach(otherBee => {
                    const distance = Math.sqrt((this.bee.x - otherBee.x) ** 2 + (this.bee.y - otherBee.y) ** 2);
                    if (distance <= interiorRange) {
                        this.visualField.set(`interior_bee_${otherBee.id}`, {
                            type: 'interior_bee',
                            distance: distance,
                            angle: Math.atan2(otherBee.y - this.bee.y, otherBee.x - this.bee.x),
                            behavior: otherBee.currentBehavior,
                            coherenceState: otherBee.coherenceState,
                            coherenceWeight: this.calculateSocialCoherence(otherBee, distance)
                        });
                    }
                });

                return this.calculateInteriorCoherence();
            }

            processExteriorVisualInput(environment, otherBees, visionRange) {
                // Process flowers
                environment.flowers.forEach((flower, index) => {
                    const distance = Math.sqrt((this.bee.x - flower.x) ** 2 + (this.bee.y - flower.y) ** 2);
                    if (distance <= visionRange && flower.nectar > 0) {
                        this.visualField.set(`flower_${index}`, {
                            type: 'flower',
                            distance: distance,
                            angle: Math.atan2(flower.y - this.bee.y, flower.x - this.bee.x),
                            nectar: flower.nectar,
                            attractiveness: flower.nectar * this.colorSensitivity[flower.color] || this.colorSensitivity.yellow,
                            coherenceWeight: this.calculateFloralCoherence(flower, distance)
                        });
                    }
                });

                // Process other bees
                otherBees.forEach(otherBee => {
                    if (otherBee === this.bee || otherBee.isInside) return;
                    
                    const distance = Math.sqrt((this.bee.x - otherBee.x) ** 2 + (this.bee.y - otherBee.y) ** 2);
                    if (distance <= visionRange) {
                        this.visualField.set(`bee_${otherBee.id}`, {
                            type: 'bee',
                            distance: distance,
                            angle: Math.atan2(otherBee.y - this.bee.y, otherBee.x - this.bee.x),
                            behavior: otherBee.currentBehavior,
                            coherenceState: otherBee.coherenceState,
                            coherenceWeight: this.calculateSocialCoherence(otherBee, distance)
                        });
                    }
                });

                // Process hive structure
                const hiveDistance = Math.sqrt((this.bee.x - environment.hiveCenter.x) ** 2 + 
                                             (this.bee.y - environment.hiveCenter.y) ** 2);
                if (hiveDistance <= visionRange) {
                    this.visualField.set('hive', {
                        type: 'hive',
                        distance: hiveDistance,
                        angle: Math.atan2(environment.hiveCenter.y - this.bee.y, environment.hiveCenter.x - this.bee.x),
                        constructionProgress: environment.hiveConstructionProgress / 20,
                        coherenceWeight: Math.exp(-hiveDistance / 100)
                    });
                }

                return this.calculateExteriorCoherence();
            }

            calculateFloralCoherence(flower, distance) {
                const base = flower.nectar * 0.5;
                const distanceFactor = Math.exp(-distance / UCF.VISUAL_COHERENCE_RANGE);
                const novelty = this.hasSeenFlowerRecently(flower) ? 0.8 : 1.2;
                return base * distanceFactor * novelty;
            }

            calculateSocialCoherence(other, distance) {
                const baseSocial = this.bee.genetics.getTraitStrength('social');
                const distanceFactor = Math.exp(-distance / 50);
                const behaviorAlignment = this.bee.currentBehavior === other.currentBehavior ? 1.2 : 0.8;
                return baseSocial * distanceFactor * behaviorAlignment;
            }

            calculateInteriorCoherence() {
                let totalCoherence = UCF.INTERIOR_COHERENCE_BONUS;
                
                this.visualField.forEach(obj => {
                    totalCoherence += obj.coherenceWeight;
                });

                return Math.min(1.0, totalCoherence / this.visualField.size);
            }

            calculateExteriorCoherence() {
                let totalCoherence = 0;
                
                this.visualField.forEach(obj => {
                    totalCoherence += obj.coherenceWeight;
                });

                return Math.min(1.0, totalCoherence / Math.max(1, this.visualField.size));
            }

            hasSeenFlowerRecently(flower) {
                return this.patternMemory.some(pattern => 
                    pattern.type === 'flower' && 
                    Math.abs(pattern.x - flower.x) < 20 && 
                    Math.abs(pattern.y - flower.y) < 20 &&
                    Date.now() - pattern.timestamp < 30000
                );
            }
        }

        // Enhanced UCF Bee with Hive Interior Capabilities
        class EmergentBee {
            constructor(x, y, id, parentGenetics = null) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                
                // UCF Core States
                this.coherenceState = UCF.COHERENCE_BASE + (Math.random() - 0.5) * 0.2;
                this.coherenceHistory = Array(UCF.MEMORY_DEPTH).fill(this.coherenceState);
                this.ruptureState = false;
                this.rebirthField = 0;
                this.memoryEntanglement = new Map();
                
                // Genetic System
                this.genetics = parentGenetics || new BeeGenetics();
                if (parentGenetics && Math.random() < 0.1) {
                    this.genetics.mutate(0.05);
                }
                
                // Enhanced Attributes with better flight dynamics
                this.visualCortex = new UCFVisualCortex(this);
                this.age = 0;
                this.experiencePoints = 0;
                this.adaptationRate = 0;
                this.intelligence = this.genetics.getTraitStrength('intelligence');
                this.energy = 1.0;
                this.nectar = 0;
                this.constructionMaterial = 0;
                
                // Behavioral States
                this.currentBehavior = 'exploring';
                this.targetFlower = null;
                this.role = this.determineRole();
                this.pheromoneSignature = Math.random();
                this.waggleDanceData = null;
                
                // NEW: Interior capabilities
                this.isInside = false;
                this.interiorTarget = null;
                this.honeyProcessingEfficiency = this.genetics.getTraitStrength('honeyProduction');
                
                // Enhanced flight dynamics - much faster and more bee-like
                this.size = 4 + Math.random() * 2;
                this.bodyTilt = Math.random() * Math.PI * 2;
                this.wingBeat = 0;
                this.speed = 1.5 + this.genetics.getTraitStrength('foraging') * 2.0; // Increased base speed significantly
                this.maxSpeed = 4.0; // Higher maximum speed
                this.acceleration = 0.2; // How quickly they can change direction
                this.angularVelocity = 0; // For more realistic turning

                // NEW: Audio properties
                this.soundData = null;
            }

            determineRole() {
                const intelligence = this.intelligence;
                const construction = this.genetics.getTraitStrength('construction');
                const foraging = this.genetics.getTraitStrength('foraging');
                
                if (intelligence > 0.8) return 'scout';
                if (construction > 0.7) return 'builder';
                if (foraging > 0.7) return 'forager';
                return 'worker';
            }

            update(otherBees, environment, time, hiveInterior) {
                this.age++;
                this.wingBeat += 0.6; // Faster wing beating for more realistic bee movement
                
                try {
                    // Process visual input and update coherence
                    const visualCoherence = this.visualCortex.processVisualInput(environment, otherBees, hiveInterior);
                    this.updateCoherence(visualCoherence, otherBees, environment);
                    
                    // Update behavioral state
                    this.updateBehavior(otherBees, environment, hiveInterior);
                    
                    // Execute behavior
                    this.executeBehavior(otherBees, environment, hiveInterior);
                    
                    // Update energy metabolism
                    this.updateEnergyMetabolism();
                    
                    // Update movement with enhanced flight dynamics
                    this.updateMovement();
                    
                    // Handle rupture/rebirth
                    this.handleRuptureRebirth();
                    
                } catch (error) {
                    console.warn(`Bee ${this.id} update error:`, error);
                }
            }

            updateCoherence(visualCoherence, otherBees, environment) {
                let newCoherence = this.coherenceState;
                
                // Visual influence
                newCoherence += visualCoherence * 0.1;
                
                // Social coherence
                const nearbyBees = otherBees.filter(bee => 
                    bee !== this && 
                    Math.sqrt((bee.x - this.x) ** 2 + (bee.y - this.y) ** 2) < 80
                );
                
                if (nearbyBees.length > 0) {
                    const avgNearbyCoherence = nearbyBees.reduce((sum, bee) => sum + bee.coherenceState, 0) / nearbyBees.length;
                    newCoherence += (avgNearbyCoherence - this.coherenceState) * 0.05;
                }
                
                // Environmental influence
                const environmentalFactor = environment.environmentalPressure * -0.1;
                newCoherence += environmentalFactor;
                
                // Interior bonus
                if (this.isInside) {
                    newCoherence += UCF.INTERIOR_COHERENCE_BONUS;
                }
                
                // Temporal decay
                newCoherence -= UCF.TEMPORAL_COHERENCE_DECAY;
                
                // Update coherence state
                this.coherenceState = Math.max(0, Math.min(1, newCoherence));
                
                // Update coherence history
                this.coherenceHistory.shift();
                this.coherenceHistory.push(this.coherenceState);
            }

            updateBehavior(otherBees, environment, hiveInterior) {
                // Behavior decision tree based on coherence and genetics
                if (this.energy < 0.3) {
                    this.currentBehavior = 'resting';
                } else if (this.isInside) {
                    this.updateInteriorBehavior(hiveInterior);
                } else if (this.nectar > 0.7) {
                    this.currentBehavior = 'returning_home';
                } else if (this.coherenceState < UCF.RUPTURE_THRESHOLD) {
                    this.currentBehavior = 'ruptured';
                } else {
                    this.updateExteriorBehavior(otherBees, environment);
                }
            }

            updateInteriorBehavior(hiveInterior) {
                if (this.nectar > 0.3) {
                    this.currentBehavior = 'honey_processing';
                } else if (this.constructionMaterial > 0.1) {
                    this.currentBehavior = 'construction';
                } else if (this.genetics.getTraitStrength('construction') > 0.5 && Math.random() < 0.3) {
                    this.currentBehavior = 'construction';
                } else {
                    this.currentBehavior = 'interior_exploration';
                }
            }

            updateExteriorBehavior(otherBees, environment) {
                const nearestFlower = this.findNearestFlower(environment);
                
                if (nearestFlower && nearestFlower.nectar > 0.1) {
                    this.currentBehavior = 'foraging';
                    this.targetFlower = nearestFlower;
                } else if (this.genetics.getTraitStrength('construction') > 0.7) {
                    this.currentBehavior = 'construction';
                } else {
                    this.currentBehavior = 'exploring';
                }
            }

            executeBehavior(otherBees, environment, hiveInterior) {
                switch (this.currentBehavior) {
                    case 'foraging':
                        this.forage(environment);
                        break;
                    case 'construction':
                        this.performConstruction(environment, null);
                        break;
                    case 'honey_processing':
                        this.processHoney(hiveInterior);
                        break;
                    case 'interior_exploration':
                        this.exploreInterior(hiveInterior);
                        break;
                    case 'returning_home':
                        this.returnToHive(environment);
                        break;
                    case 'exploring':
                        this.exploreTerritory(environment);
                        break;
                    case 'resting':
                        this.rest();
                        break;
                    case 'ruptured':
                        this.handleRupture();
                        break;
                }

                // Update pheromone trail
                this.updatePheromoneTrail(environment);
            }

            forage(environment) {
                if (this.targetFlower && this.targetFlower.nectar > 0) {
                    const dx = this.targetFlower.x - this.x;
                    const dy = this.targetFlower.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 15) {
                        // Collect nectar
                        const collected = Math.min(0.1, this.targetFlower.nectar, 1 - this.nectar);
                        this.nectar += collected;
                        this.targetFlower.nectar -= collected;
                        this.energy -= 0.005;
                        this.experiencePoints += collected * 10;
                        
                        if (this.nectar > 0.9 || this.targetFlower.nectar <= 0) {
                            this.targetFlower = null;
                            this.currentBehavior = 'returning_home';
                        }
                    } else {
                        // Move toward flower
                        this.vx += (dx / distance) * 0.03 * this.speed;
                        this.vy += (dy / distance) * 0.03 * this.speed;
                    }
                } else {
                    this.searchForFlowers(environment);
                }
            }

            processHoney(hiveInterior) {
                if (this.nectar > 0) {
                    // Find nearest storage cell
                    const nearestCell = this.findNearestHoneyCell(hiveInterior);
                    if (nearestCell) {
                        const dx = nearestCell.x - this.x;
                        const dy = nearestCell.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 15) {
                            // Process nectar into honey
                            const processed = Math.min(0.05, this.nectar) * this.honeyProcessingEfficiency;
                            this.nectar -= processed * 2; // Takes more nectar to make honey
                            nearestCell.honeyLevel += processed;
                            this.energy -= 0.003;
                        } else {
                            // Move toward cell
                            this.vx += (dx / distance) * 0.02;
                            this.vy += (dy / distance) * 0.02;
                        }
                    }
                }
            }

            exploreInterior(hiveInterior) {
                // Move randomly within hive bounds
                this.vx += (Math.random() - 0.5) * 0.02;
                this.vy += (Math.random() - 0.5) * 0.02;
                
                // Keep within interior bounds
                const centerX = 600;
                const centerY = 400;
                const maxRadius = 300;
                
                const distanceFromCenter = Math.sqrt((this.x - centerX) ** 2 + (this.y - centerY) ** 2);
                if (distanceFromCenter > maxRadius) {
                    const angle = Math.atan2(this.y - centerY, this.x - centerX);
                    this.vx -= Math.cos(angle) * 0.01;
                    this.vy -= Math.sin(angle) * 0.01;
                }
            }

            returnToHive(environment) {
                const dx = environment.hiveCenter.x - this.x;
                const dy = environment.hiveCenter.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < UCF.HIVE_ENTRANCE_RADIUS) {
                    // Deposit nectar and materials
                    environment.totalResources += this.nectar;
                    this.constructionMaterial += this.nectar * 0.3;
                    this.nectar = 0;
                    
                    if (Math.random() < 0.7) {
                        this.currentBehavior = 'construction';
                    } else {
                        this.currentBehavior = 'exploring';
                    }
                } else {
                    // Move toward hive
                    this.vx += (dx / distance) * 0.04 * this.speed;
                    this.vy += (dy / distance) * 0.04 * this.speed;
                }
            }

            performConstruction(environment, target) {
                if (this.constructionMaterial > 0) {
                    const efficiency = this.genetics.getTraitStrength('construction') * this.coherenceState;
                    const materialUsed = Math.min(0.1 * efficiency, this.constructionMaterial);
                    
                    this.constructionMaterial -= materialUsed;
                    this.addToHiveStructure(environment, materialUsed);
                    this.experiencePoints += materialUsed * 20;
                }
            }

            addToHiveStructure(environment, material) {
                let nearestSite = environment.hiveStructures.find(site => 
                    this.distanceTo(site) < 30 && site.constructionNeeded);
                
                if (!nearestSite) {
                    nearestSite = {
                        x: this.x + (Math.random() - 0.5) * 40,
                        y: this.y + (Math.random() - 0.5) * 40,
                        integrity: 0,
                        constructionNeeded: true,
                        type: 'cell'
                    };
                    environment.hiveStructures.push(nearestSite);
                }
                
                nearestSite.integrity += material;
                if (nearestSite.integrity >= 1.0) {
                    nearestSite.constructionNeeded = false;
                    environment.hiveConstructionProgress++;
                }
            }

            updateEnergyMetabolism() {
                const baseMetabolism = 0.0003;
                const activityMultiplier = this.currentBehavior === 'foraging' ? 1.2 : 
                                         this.currentBehavior === 'construction' ? 1.1 : 
                                         this.currentBehavior === 'honey_processing' ? 0.9 :
                                         this.currentBehavior === 'ruptured' ? 1.5 : 1.0;
                
                this.energy -= baseMetabolism * activityMultiplier;
                
                // Energy regeneration when resting
                if (this.currentBehavior === 'resting' || this.isInside) {
                    this.energy += 0.001;
                }
                
                this.energy = Math.max(0, Math.min(1, this.energy));
                
                // Calculate adaptation rate
                this.adaptationRate = this.experiencePoints / (this.age + 1) * this.coherenceState;
            }

            updateMovement() {
                // Enhanced bee flight dynamics - much more realistic
                
                // Update wing beat (faster for more realistic bee movement)
                this.wingBeat += 0.8; // Increased wing beat frequency
                
                // Apply less aggressive damping for more lively movement
                this.vx *= 0.98; // Reduced damping from 0.95
                this.vy *= 0.98;
                
                // Calculate current velocity
                const currentVel = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                // Bee-like flight characteristics: irregular, buzzing movement
                if (this.currentBehavior !== 'resting') {
                    // Add small random flight variations (bee "buzzing")
                    this.vx += (Math.random() - 0.5) * 0.1;
                    this.vy += (Math.random() - 0.5) * 0.1;
                    
                    // Energy-based speed modulation
                    const energySpeedMultiplier = 0.6 + (this.energy * 0.8);
                    const targetSpeed = this.speed * energySpeedMultiplier;
                    
                    // If moving too slowly, add some base movement
                    if (currentVel < targetSpeed * 0.3) {
                        const randomAngle = Math.random() * Math.PI * 2;
                        this.vx += Math.cos(randomAngle) * 0.3;
                        this.vy += Math.sin(randomAngle) * 0.3;
                    }
                }
                
                // Dynamic speed limiting based on bee state
                let maxVel = this.maxSpeed;
                
                switch (this.currentBehavior) {
                    case 'foraging':
                        maxVel = this.maxSpeed * 1.2; // Foraging bees move faster
                        break;
                    case 'returning_home':
                        maxVel = this.maxSpeed * 1.4; // Fastest when returning with nectar
                        break;
                    case 'exploring':
                        maxVel = this.maxSpeed * 0.9; // Moderate speed for exploration
                        break;
                    case 'construction':
                        maxVel = this.maxSpeed * 0.7; // Slower when focused on building
                        break;
                    case 'resting':
                        maxVel = this.maxSpeed * 0.2; // Very slow when resting
                        break;
                    case 'ruptured':
                        maxVel = this.maxSpeed * 1.6; // Erratic, fast movement when ruptured
                        break;
                }
                
                // Apply intelligent speed limiting
                if (currentVel > maxVel) {
                    const scale = maxVel / currentVel;
                    this.vx *= scale;
                    this.vy *= scale;
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // More realistic body orientation with smooth turning
                if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    const targetAngle = Math.atan2(this.vy, this.vx);
                    const angleDiff = targetAngle - this.bodyTilt;
                    
                    // Normalize angle difference
                    let normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                    
                    // Smooth turning based on bee's agility
                    const turnSpeed = 0.15 + this.genetics.getTraitStrength('intelligence') * 0.1;
                    this.bodyTilt += normalizedDiff * turnSpeed;
                }
                
                // Boundary conditions with more natural edge behavior
                if (!this.isInside) {
                    const margin = 20;
                    
                    // Soft boundary repulsion instead of hard limits
                    if (this.x < margin) {
                        this.vx += (margin - this.x) * 0.01;
                        this.x = Math.max(5, this.x);
                    } else if (this.x > 1200 - margin) {
                        this.vx -= (this.x - (1200 - margin)) * 0.01;
                        this.x = Math.min(1195, this.x);
                    }
                    
                    if (this.y < margin) {
                        this.vy += (margin - this.y) * 0.01;
                        this.y = Math.max(5, this.y);
                    } else if (this.y > 800 - margin) {
                        this.vy -= (this.y - (800 - margin)) * 0.01;
                        this.y = Math.min(795, this.y);
                    }
                }
            }

            handleRuptureRebirth() {
                // Rupture detection
                if (this.coherenceState < UCF.RUPTURE_THRESHOLD && !this.ruptureState) {
                    this.ruptureState = true;
                    this.rebirthField = 0;
                }
                
                // Rebirth process
                if (this.ruptureState) {
                    this.rebirthField += UCF.REBIRTH_TEMPERATURE * 0.1;
                    
                    if (this.rebirthField > 1.0) {
                        this.coherenceState = UCF.COHERENCE_BASE + Math.random() * 0.2;
                        this.ruptureState = false;
                        this.rebirthField = 0;
                        this.experiencePoints += 50; // Growth through adversity
                    }
                }
            }

            findNearestFlower(environment) {
                let nearest = null;
                let minDistance = Infinity;
                
                environment.flowers.forEach(flower => {
                    if (flower.nectar > 0.1) {
                        const distance = Math.sqrt((flower.x - this.x) ** 2 + (flower.y - this.y) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearest = flower;
                        }
                    }
                });
                
                return nearest;
            }

            findNearestHoneyCell(hiveInterior) {
                let nearest = null;
                let minDistance = Infinity;
                
                hiveInterior.honeyCells.forEach(cell => {
                    if (cell.type === 'storage' && cell.honeyLevel < 0.9) {
                        const distance = Math.sqrt((cell.x - this.x) ** 2 + (cell.y - this.y) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearest = cell;
                        }
                    }
                });
                
                return nearest;
            }

            searchForFlowers(environment) {
                const searchAngle = this.bodyTilt + (Math.random() - 0.5) * Math.PI * 0.5;
                this.vx += Math.cos(searchAngle) * 0.02 * this.intelligence;
                this.vy += Math.sin(searchAngle) * 0.02 * this.intelligence;
            }

            exploreTerritory(environment) {
                const explorationRadius = 200;
                const centerX = environment.hiveCenter.x;
                const centerY = environment.hiveCenter.y;
                
                const targetX = centerX + Math.cos(this.age * 0.01) * explorationRadius;
                const targetY = centerY + Math.sin(this.age * 0.01) * explorationRadius;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    this.vx += (dx / distance) * 0.02;
                    this.vy += (dy / distance) * 0.02;
                }
            }

            rest() {
                this.vx *= 0.8;
                this.vy *= 0.8;
                this.energy += 0.002;
            }

            handleRupture() {
                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;
            }

            updatePheromoneTrail(environment) {
                if (Math.random() < 0.1) {
                    environment.pheromoneTrails.push({
                        x: this.x,
                        y: this.y,
                        intensity: this.coherenceState,
                        signature: this.pheromoneSignature,
                        type: this.currentBehavior,
                        timestamp: Date.now()
                    });
                }
            }

            distanceTo(target) {
                return Math.sqrt((this.x - target.x) ** 2 + (this.y - target.y) ** 2);
            }
        }

        // Enhanced Environment System
        class EmergentEnvironment {
            constructor() {
                this.flowers = this.generateFlowers();
                this.hiveCenter = { x: 600, y: 400 };
                this.hiveStructures = [];
                this.pheromoneTrails = [];
                this.totalResources = 0;
                this.hiveConstructionProgress = 0;
                this.weather = 'sunny';
                this.season = 'spring';
                this.dayTime = 0;
                this.environmentalPressure = 0;
                
                this.initializeHive();
            }

            generateFlowers() {
                const flowers = [];
                const flowerTypes = ['sunflower', 'clover', 'lavender', 'wildflower'];
                const colors = ['yellow', 'purple', 'blue', 'white'];
                
                for (let i = 0; i < 40; i++) {
                    flowers.push({
                        x: 50 + Math.random() * 1100,
                        y: 50 + Math.random() * 700,
                        nectar: 0.5 + Math.random() * 0.5,
                        type: flowerTypes[Math.floor(Math.random() * flowerTypes.length)],
                        color: colors[Math.floor(Math.random() * colors.length)],
                        bloomStage: Math.random(),
                        lastVisited: 0
                    });
                }
                return flowers;
            }

            initializeHive() {
                // Create basic hive structure
                const hiveRadius = 60;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.hiveStructures.push({
                        x: this.hiveCenter.x + Math.cos(angle) * hiveRadius,
                        y: this.hiveCenter.y + Math.sin(angle) * hiveRadius,
                        integrity: 0.3 + Math.random() * 0.4,
                        constructionNeeded: Math.random() < 0.6,
                        type: 'wall'
                    });
                }
            }

            update() {
                this.updateFlowers();
                this.updateWeatherPatterns();
                this.updatePheromoneTrails();
                this.dayTime += 0.001;
            }

            updateFlowers() {
                this.flowers.forEach(flower => {
                    // Natural nectar regeneration
                    if (flower.nectar < 1.0) {
                        flower.nectar += 0.001 * this.getSeasonalModifier();
                        flower.nectar = Math.min(1.0, flower.nectar);
                    }
                    
                    // Bloom cycle
                    flower.bloomStage = (flower.bloomStage + 0.001) % 1.0;
                });
            }

            updateWeatherPatterns() {
                // Simple weather simulation
                if (Math.random() < 0.001) {
                    const weathers = ['sunny', 'cloudy', 'rainy', 'windy'];
                    this.weather = weathers[Math.floor(Math.random() * weathers.length)];
                    
                    // Weather affects environmental pressure
                    switch (this.weather) {
                        case 'rainy':
                            this.environmentalPressure += 0.2;
                            break;
                        case 'windy':
                            this.environmentalPressure += 0.1;
                            break;
                        default:
                            this.environmentalPressure = Math.max(0, this.environmentalPressure - 0.05);
                    }
                    
                    this.environmentalPressure = Math.min(1.0, this.environmentalPressure);
                }
            }

            updatePheromoneTrails() {
                // Remove old pheromone trails
                this.pheromoneTrails = this.pheromoneTrails.filter(trail => 
                    Date.now() - trail.timestamp < 60000
                );
                
                // Decay pheromone intensity
                this.pheromoneTrails.forEach(trail => {
                    trail.intensity *= 0.995;
                });
            }

            addFlowerBloom() {
                // Add new flowers in bloom
                for (let i = 0; i < 5; i++) {
                    this.flowers.push({
                        x: 50 + Math.random() * 1100,
                        y: 50 + Math.random() * 700,
                        nectar: 0.8 + Math.random() * 0.2,
                        type: 'wildflower',
                        color: ['yellow', 'purple', 'blue'][Math.floor(Math.random() * 3)],
                        bloomStage: 0,
                        lastVisited: 0
                    });
                }
            }

            updateWeather() {
                const weathers = ['sunny', 'cloudy', 'rainy', 'windy'];
                this.weather = weathers[Math.floor(Math.random() * weathers.length)];
            }

            getSeasonalModifier() {
                switch (this.season) {
                    case 'spring': return 1.2;
                    case 'summer': return 1.0;
                    case 'autumn': return 0.8;
                    case 'winter': return 0.4;
                    default: return 1.0;
                }
            }
        }

        // Environmental Physics System
        class EnvironmentalPhysics {
            constructor() {
                this.windField = [];
                this.temperatureField = [];
                this.humidityField = [];
                this.pressureField = [];
                this.lightField = [];
                this.initializeFields();
            }

            initializeFields() {
                // Initialize environmental fields with realistic patterns
                for (let x = 0; x < 120; x++) {
                    for (let y = 0; y < 80; y++) {
                        this.windField.push({
                            x: x * 10,
                            y: y * 10,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            intensity: Math.random()
                        });
                    }
                }
            }

            update() {
                // Update environmental fields
                this.updateWindField();
                // Other field updates would go here
            }

            updateWindField() {
                this.windField.forEach(cell => {
                    cell.vx += (Math.random() - 0.5) * 0.1;
                    cell.vy += (Math.random() - 0.5) * 0.1;
                    cell.vx *= 0.95;
                    cell.vy *= 0.95;
                });
            }
        }

        // Communication Networks System
        class CommunicationNetworks {
            constructor() {
                this.pheromoneNetwork = new Map();
                this.waggleDances = [];
                this.informationNodes = [];
                this.socialConnections = new Map();
            }

            update() {
                this.updatePheromoneNetwork();
                this.updateWaggleDances();
            }

            updatePheromoneNetwork() {
                // Decay pheromone network
                for (let [key, value] of this.pheromoneNetwork) {
                    value.intensity *= 0.99;
                    if (value.intensity < 0.1) {
                        this.pheromoneNetwork.delete(key);
                    }
                }
            }

            updateWaggleDances() {
                this.waggleDances = this.waggleDances.filter(dance => 
                    Date.now() - dance.timestamp < 30000
                );
            }

            addPheromoneTrail(x, y, type, intensity, signature, bee) {
                const key = `${Math.floor(x/10)}_${Math.floor(y/10)}`;
                this.pheromoneNetwork.set(key, {
                    x, y, type, intensity, signature, 
                    timestamp: Date.now(),
                    beeId: bee.id
                });
            }
        }

        // Predator Dynamics System
        class PredatorDynamics {
            constructor() {
                this.predators = [];
                this.threatZones = [];
                this.escapeRoutes = new Map();
            }

            update() {
                this.updatePredators();
                this.updateThreatZones();
            }

            updatePredators() {
                this.predators.forEach(predator => {
                    predator.x += predator.vx;
                    predator.y += predator.vy;
                    
                    // Boundary conditions
                    if (predator.x < 0 || predator.x > 1200 || predator.y < 0 || predator.y > 800) {
                        predator.vx *= -1;
                        predator.vy *= -1;
                        predator.x = Math.max(0, Math.min(1200, predator.x));
                        predator.y = Math.max(0, Math.min(800, predator.y));
                    }
                });
            }

            addPredator(type, x, y) {
                this.predators.push({
                    type: type,
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    dangerLevel: 0.8 + Math.random() * 0.2,
                    huntingRange: 100 + Math.random() * 50,
                    timestamp: Date.now()
                });
            }

            updateThreatZones() {
                this.threatZones = this.predators.map(predator => ({
                    x: predator.x,
                    y: predator.y,
                    radius: predator.huntingRange,
                    intensity: predator.dangerLevel
                }));
            }
        }

        // Genetic Evolution System
        class GeneticEvolution {
            constructor() {
                this.mutationEvents = [];
                this.inheritanceLines = new Map();
                this.traitExpressions = new Map();
                this.evolutionPressure = {
                    environmental: 0,
                    predation: 0,
                    resource: 0,
                    social: 0
                };
            }

            updateEvolutionPressure(environment, bees, predators) {
                this.evolutionPressure.environmental = environment.environmentalPressure;
                this.evolutionPressure.predation = Math.min(1.0, predators.length * 0.3);

                const avgNectar = environment.flowers.reduce((sum, f) => sum + f.nectar, 0) / environment.flowers.length;
                this.evolutionPressure.resource = 1 - avgNectar;

                const avgCoherence = bees.reduce((sum, bee) => sum + bee.coherenceState, 0) / (bees.length || 1);
                this.evolutionPressure.social = avgCoherence < 0.5 ? 1 - avgCoherence : 0;
            }

            update() {
                this.mutationEvents = this.mutationEvents.filter(event => 
                    Date.now() - event.timestamp < 300000
                );
            }
        }

        // Main Enhanced Simulation System
        class UCFEcosystemSimulation {
            constructor() {
                this.canvas = document.getElementById('ecosystem');
                this.ctx = this.canvas.getContext('2d');
                this.hiveCanvas = document.getElementById('hiveInterior');
                this.hiveCtx = this.hiveCanvas.getContext('2d');
                
                this.bees = [];
                this.environment = new EmergentEnvironment();
                this.hiveInterior = new HiveInterior();
                this.time = 0;
                this.isRunning = true;
                this.simulationSpeed = 1.0;
                this.ucfSensitivity = 1.0;
                this.webcamMode = false;
                
                // NEW: Audio system
                this.audioSystem = new BeeAudioSystem();
                this.soundEnabled = false;
                
                // Advanced Reality Layers
                this.environmentalPhysics = new EnvironmentalPhysics();
                this.communicationNetworks = new CommunicationNetworks();
                this.predatorDynamics = new PredatorDynamics();
                this.geneticEvolution = new GeneticEvolution();
                
                this.visualizations = {
                    // UCF Field Dynamics
                    showCoherenceField: true,
                    showRuptureZones: false,
                    showRebirthFields: false,
                    showMemoryEntanglement: false,
                    showTemporalDecay: false,
                    
                    // Genetic & Evolution
                    showGeneticSequences: false,
                    showMutationEvents: false,
                    showInheritanceLines: false,
                    showTraitExpressions: false,
                    showEvolutionPressure: false,
                    
                    // Communication Networks
                    showPheromoneTrails: false,
                    showWaggleDances: false,
                    showInformationFlow: false,
                    showSocialNetworks: false,
                    showDecisionTrees: false,
                    
                    // Environmental Physics
                    showWindVectors: false,
                    showTemperatureGradient: false,
                    showHumidityZones: false,
                    showAirPressure: false,
                    showLightIntensity: false,
                    
                    // Energy & Metabolism
                    showEnergyFlows: false,
                    showResourceDistribution: false,
                    showMetabolicRates: false,
                    showEnergyGradients: false,
                    showNutrientNetworks: false,
                    
                    // Construction Dynamics
                    showConstructionPaths: false,
                    showStructuralIntegrity: false,
                    showBuildingAlgorithms: false,
                    showMaterialFlow: false,
                    showArchitecturalPlanning: false,
                    
                    // NEW: Honey & Hive Interior
                    showHoneyFlows: false,
                    showNectarProcessing: false,
                    showHoneyCombConstruction: false,
                    showInteriorActivities: false,
                    showHoneyStorage: false,
                    
                    // Predator & Threat Dynamics
                    showThreatZones: false,
                    showEscapeVectors: false,
                    showPredatorPatterns: false,
                    showDefenseFormations: false,
                    showRiskAssessment: false,
                    
                    // Intelligence & Learning
                    showLearningPaths: false,
                    showKnowledgeDistribution: false,
                    showAdaptationRates: false,
                    showIntelligenceNetworks: false,
                    showEmergentBehaviors: false
                };
                
                this.initializeBees();
                this.setupEventListeners();
                this.animate();
            }

            initializeBees() {
                const initialBeeCount = 12;
                for (let i = 0; i < initialBeeCount; i++) {
                    const angle = (i / initialBeeCount) * 2 * Math.PI;
                    // Start bees further from hive to ensure they're clearly outside
                    const radius = 80 + Math.random() * 120; // Increased from 40-100 to 80-200
                    const x = this.environment.hiveCenter.x + Math.cos(angle) * radius;
                    const y = this.environment.hiveCenter.y + Math.sin(angle) * radius;
                    
                    const newBee = new EmergentBee(x, y, i);
                    
                    // Explicitly ensure bee starts outside
                    newBee.isInside = false;
                    
                    // Give initial random behavior variety
                    const behaviors = ['exploring', 'foraging', 'exploring', 'foraging', 'exploring'];
                    newBee.currentBehavior = behaviors[i % behaviors.length];
                    
                    this.bees.push(newBee);
                }
            }

            async setupEventListeners() {
                document.getElementById('playPause').addEventListener('click', () => {
                    this.isRunning = !this.isRunning;
                    document.getElementById('playPause').textContent = this.isRunning ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                    
                    // Handle audio when pausing/playing
                    if (this.soundEnabled) {
                        if (this.isRunning) {
                            this.audioSystem.resume();
                        } else {
                            this.audioSystem.suspend();
                        }
                    }
                });

                document.getElementById('reset').addEventListener('click', () => {
                    this.resetSimulation();
                });

                document.getElementById('addBees').addEventListener('click', () => {
                    this.addBees(5);
                });

                document.getElementById('weather').addEventListener('click', () => {
                    this.environment.updateWeather();
                });

                document.getElementById('predator').addEventListener('click', () => {
                    const x = Math.random() * 1200;
                    const y = Math.random() * 400;
                    this.predatorDynamics.addPredator('bird', x, y);
                    this.environment.environmentalPressure += 0.5;
                });

                document.getElementById('bloom').addEventListener('click', () => {
                    this.environment.addFlowerBloom();
                });

                document.getElementById('mutation').addEventListener('click', () => {
                    if (this.bees.length > 0) {
                        const randomBee = this.bees[Math.floor(Math.random() * this.bees.length)];
                        randomBee.genetics.mutate(0.2);
                    }
                });

                document.getElementById('webcamToggle').addEventListener('click', () => {
                    this.toggleWebcamMode();
                });

                document.getElementById('honeyHarvest').addEventListener('click', () => {
                    this.harvestHoney();
                });

                // NEW: Sound toggle button
                document.getElementById('soundToggle').addEventListener('click', async () => {
                    await this.toggleSound();
                });

                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.simulationSpeed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = this.simulationSpeed.toFixed(1) + 'x';
                });

                document.getElementById('ucfSlider').addEventListener('input', (e) => {
                    this.ucfSensitivity = parseFloat(e.target.value);
                    UCF.EMERGENCE_FACTOR = this.ucfSensitivity;
                    document.getElementById('ucfValue').textContent = this.ucfSensitivity.toFixed(1) + 'x';
                });

                // NEW: Volume control
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value);
                    document.getElementById('volumeValue').textContent = volume + '%';
                    if (this.audioSystem) {
                        this.audioSystem.setVolume(volume);
                    }
                });

                // Setup visualization toggle listeners
                Object.keys(this.visualizations).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.addEventListener('change', (e) => {
                            this.visualizations[key] = e.target.checked;
                        });
                    }
                });

                // NEW: Setup audio setting listeners
                ['enableBeeSound', 'enableHiveSound', 'enableSpatialAudio', 'enableConstructionSound', 'enableWeatherSound'].forEach(setting => {
                    const element = document.getElementById(setting);
                    if (element) {
                        element.addEventListener('change', (e) => {
                            if (this.audioSystem) {
                                this.audioSystem.setAudioSetting(setting, e.target.checked);
                            }
                        });
                    }
                });
            }

            async toggleSound() {
                if (!this.soundEnabled) {
                    // Enable sound
                    const success = await this.audioSystem.initialize();
                    if (success) {
                        this.soundEnabled = true;
                        document.getElementById('soundToggle').textContent = 'üîá Disable Sound';
                        document.getElementById('soundToggle').className = 'audio';
                        document.getElementById('audioOverlay').style.display = 'block';
                        
                        // Create initial bee sounds
                        this.bees.forEach(bee => {
                            if (!bee.soundData) {
                                bee.soundData = this.audioSystem.createBeeBuzzSound(bee);
                            }
                        });
                        
                        console.log("Audio enabled - bee sounds activated");
                    } else {
                        console.warn("Failed to initialize audio system");
                    }
                } else {
                    // Disable sound
                    this.soundEnabled = false;
                    document.getElementById('soundToggle').textContent = 'üîä Enable Sound';
                    document.getElementById('soundToggle').className = 'audio';
                    document.getElementById('audioOverlay').style.display = 'none';
                    
                    // Stop all bee sounds
                    this.bees.forEach(bee => {
                        if (bee.soundData) {
                            this.audioSystem.stopBeeSound(bee.soundData);
                            bee.soundData = null;
                        }
                    });
                    
                    this.audioSystem.suspend();
                    console.log("Audio disabled");
                }
            }

            toggleWebcamMode() {
                this.webcamMode = !this.webcamMode;
                
                console.log(`Switching to ${this.webcamMode ? 'INTERIOR' : 'EXTERIOR'} view`);
                
                if (this.webcamMode) {
                    this.canvas.style.display = 'none';
                    this.hiveCanvas.style.display = 'block';
                    document.getElementById('webcamOverlay').style.display = 'block';
                    
                    // Encourage more bees to enter hive for interior viewing
                    let beesMovedInside = 0;
                    this.bees.forEach(bee => {
                        if (!bee.isInside && Math.random() < 0.3) { // 30% chance to move inside
                            const distanceToHive = Math.sqrt((bee.x - 600) ** 2 + (bee.y - 400) ** 2);
                            if (distanceToHive < 150) { // Within reasonable distance
                                bee.isInside = true;
                                this.hiveInterior.interiorBees.add(bee.id);
                                
                                // Position inside hive
                                const enterAngle = Math.random() * Math.PI * 2;
                                bee.x = 600 + Math.cos(enterAngle) * (50 + Math.random() * 150);
                                bee.y = 400 + Math.sin(enterAngle) * (50 + Math.random() * 150);
                                beesMovedInside++;
                            }
                        }
                    });
                    console.log(`Moved ${beesMovedInside} bees inside for interior view`);
                    
                } else {
                    this.canvas.style.display = 'block';
                    this.hiveCanvas.style.display = 'none';
                    document.getElementById('webcamOverlay').style.display = 'none';
                }
            }

            harvestHoney() {
                const harvested = this.hiveInterior.harvestHoney();
                console.log(`Harvested ${harvested.toFixed(3)} units of honey`);
            }

            addBees(count) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    // Ensure new bees spawn clearly outside the hive
                    const radius = 100 + Math.random() * 150; // Far from hive center
                    const x = this.environment.hiveCenter.x + Math.cos(angle) * radius;
                    const y = this.environment.hiveCenter.y + Math.sin(angle) * radius;
                    
                    const newBee = new EmergentBee(x, y, this.bees.length);
                    
                    // Explicitly set as outside
                    newBee.isInside = false;
                    
                    // NEW: Create sound for new bee if audio is enabled
                    if (this.soundEnabled && this.audioSystem.enabled) {
                        newBee.soundData = this.audioSystem.createBeeBuzzSound(newBee);
                    }
                    
                    this.bees.push(newBee);
                }
            }

            resetSimulation() {
                // Stop all bee sounds before reset
                if (this.soundEnabled) {
                    this.bees.forEach(bee => {
                        if (bee.soundData) {
                            this.audioSystem.stopBeeSound(bee.soundData);
                            bee.soundData = null;
                        }
                    });
                }
                
                this.bees = [];
                this.environment = new EmergentEnvironment();
                this.hiveInterior = new HiveInterior();
                this.predatorDynamics.predators = [];
                this.time = 0;
                this.initializeBees();
            }

            render() {
                CrashProtection.safeExecute(() => {
                    if (this.webcamMode) {
                        this.renderInterior();
                    } else {
                        this.renderExterior();
                    }
                    this.updateStats();
                }, null, 'render loop');
            }

            renderExterior() {
                // Clear canvas with dynamic background
                this.renderBackground();
                
                // Render environment physics layers with protection
                if (this.visualizations.showWindVectors) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderWindVectors(), 'windVectors');
                }
                if (this.visualizations.showTemperatureGradient) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderTemperatureGradient(), 'temperature');
                }
                if (this.visualizations.showHumidityZones) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderHumidityZones(), 'humidity');
                }
                if (this.visualizations.showAirPressure) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderAirPressure(), 'airPressure');
                }
                if (this.visualizations.showLightIntensity) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderLightIntensity(), 'lightIntensity');
                }
                
                // Render UCF field layers with protection
                if (this.visualizations.showCoherenceField) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderUCFField(), 'coherenceField');
                }
                if (this.visualizations.showRuptureZones) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderRuptureZones(), 'ruptureZones');
                }
                if (this.visualizations.showRebirthFields) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderRebirthFields(), 'rebirthFields');
                }
                if (this.visualizations.showTemporalDecay) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderTemporalDecay(), 'temporalDecay');
                }
                if (this.visualizations.showMemoryEntanglement) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderMemoryEntanglement(), 'memoryEntanglement');
                }
                
                // Render communication layers with protection
                if (this.visualizations.showPheromoneTrails) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderPheromoneTrails(), 'pheromoneTrails');
                }
                if (this.visualizations.showWaggleDances) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderWaggleDances(), 'waggleDances');
                }
                if (this.visualizations.showInformationFlow) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderInformationFlow(), 'informationFlow');
                }
                if (this.visualizations.showSocialNetworks) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderSocialNetworks(), 'socialNetworks');
                }
                
                // Render flowers with resource visualization
                if (this.visualizations.showResourceDistribution) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderResourceDistribution(), 'resourceDistribution');
                }
                this.renderFlowers();

                // Render hive and structures
                this.renderHive();
                
                // Render construction visualization
                if (this.visualizations.showConstructionPaths) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderConstructionPaths(), 'constructionPaths');
                }
                if (this.visualizations.showStructuralIntegrity) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderStructuralIntegrity(), 'structuralIntegrity');
                }
                
                // Render predators and threat zones
                this.renderPredators();
                if (this.visualizations.showThreatZones) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderThreatZones(), 'threatZones');
                }
                if (this.visualizations.showEscapeVectors) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderEscapeVectors(), 'escapeVectors');
                }

                // Render bees with enhanced visibility and consistent rendering
                let exteriorBeeCount = 0;
                this.bees.forEach(bee => {
                    // Ensure bee has valid position and state
                    if (!CrashProtection.validateBee(bee)) return;
                    
                    // Force exterior rendering for debugging - ensure we can see bees
                    const shouldRenderExterior = !bee.isInside || this.webcamMode === false;
                    
                    if (shouldRenderExterior) {
                        exteriorBeeCount++;
                        
                        // Render the bee with error protection - SAME as interior
                        CrashProtection.safeCanvasOperation(this.ctx, () => {
                            // Save canvas state before rendering
                            this.ctx.save();
                            this.renderBee(bee, this.ctx);
                            this.ctx.restore();
                        }, `bee-${bee.id}-rendering`);
                        
                        // Render bee overlays ONLY if specifically enabled and don't interfere with bee appearance
                        if (this.visualizations.showGeneticSequences) {
                            CrashProtection.safeCanvasOperation(this.ctx, () => {
                                this.ctx.save();
                                this.renderBeeGenetics(bee, this.ctx);
                                this.ctx.restore();
                            }, 'bee-genetics');
                        }
                        if (this.visualizations.showEnergyFlows) {
                            CrashProtection.safeCanvasOperation(this.ctx, () => {
                                this.ctx.save();
                                this.renderBeeEnergy(bee, this.ctx);
                                this.ctx.restore();
                            }, 'bee-energy');
                        }
                        if (this.visualizations.showIntelligenceNetworks) {
                            CrashProtection.safeCanvasOperation(this.ctx, () => {
                                this.ctx.save();
                                this.renderBeeIntelligence(bee, this.ctx);
                                this.ctx.restore();
                            }, 'bee-intelligence');
                        }
                        
                        // Debug info: show bee ID and status (only when needed for troubleshooting)
                        if (exteriorBeeCount <= 3 && this.time % 120 === 0) { // Only every 2 seconds, first 3 bees
                            this.ctx.save();
                            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            this.ctx.font = '10px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText(
                                `${bee.id}:${bee.currentBehavior.substring(0,3)}`, 
                                bee.x, 
                                bee.y - 15
                            );
                            this.ctx.restore();
                        }
                    }
                });
                
                // Debug: Log if no exterior bees are being rendered (less frequent)
                if (exteriorBeeCount === 0 && this.bees.length > 0 && this.time % 300 === 0) {
                    console.log(`Warning: ${this.bees.length} bees exist but none rendered externally. Interior bees: ${this.hiveInterior.interiorBees.size}`);
                }
                
                // Render learning and adaptation overlays
                if (this.visualizations.showLearningPaths) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderLearningPaths(), 'learningPaths');
                }
                if (this.visualizations.showAdaptationRates) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderAdaptationRates(), 'adaptationRates');
                }

                // Add missing visualization functions for completeness
                if (this.visualizations.showMutationEvents) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderMutationEvents(), 'mutationEvents');
                }
                if (this.visualizations.showTraitExpressions) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderTraitExpressions(), 'traitExpressions');
                }
                if (this.visualizations.showEvolutionPressure) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderEvolutionPressure(), 'evolutionPressure');
                }
                if (this.visualizations.showDecisionTrees) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderDecisionTrees(), 'decisionTrees');
                }
                if (this.visualizations.showMetabolicRates) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderMetabolicRates(), 'metabolicRates');
                }
                if (this.visualizations.showEnergyGradients) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderEnergyGradients(), 'energyGradients');
                }
                if (this.visualizations.showNutrientNetworks) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderNutrientNetworks(), 'nutrientNetworks');
                }
                if (this.visualizations.showBuildingAlgorithms) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderBuildingAlgorithms(), 'buildingAlgorithms');
                }
                if (this.visualizations.showMaterialFlow) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderMaterialFlow(), 'materialFlow');
                }
                if (this.visualizations.showArchitecturalPlanning) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderArchitecturalPlanning(), 'architecturalPlanning');
                }
                if (this.visualizations.showPredatorPatterns) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderPredatorPatterns(), 'predatorPatterns');
                }
                if (this.visualizations.showDefenseFormations) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderDefenseFormations(), 'defenseFormations');
                }
                if (this.visualizations.showRiskAssessment) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderRiskAssessment(), 'riskAssessment');
                }
                if (this.visualizations.showKnowledgeDistribution) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderKnowledgeDistribution(), 'knowledgeDistribution');
                }
                if (this.visualizations.showEmergentBehaviors) {
                    CrashProtection.safeCanvasOperation(this.ctx, () => this.renderEmergentBehaviors(), 'emergentBehaviors');
                }
            }

            renderInterior() {
                // Clear hive canvas
                this.hiveCtx.fillStyle = '#8B4513';
                this.hiveCtx.fillRect(0, 0, 1200, 800);

                // Render honey flows if enabled
                if (this.visualizations.showHoneyFlows) {
                    this.renderHoneyFlows();
                }

                // Render honeycomb construction visualization
                if (this.visualizations.showHoneyCombConstruction) {
                    this.renderHoneyCombConstruction();
                }

                // Render honeycomb cells
                this.hiveInterior.honeyCells.forEach(cell => {
                    const size = 18;
                    
                    // Cell structure
                    this.hiveCtx.strokeStyle = '#654321';
                    this.hiveCtx.lineWidth = 2;
                    this.hiveCtx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI;
                        const x = cell.x + Math.cos(angle) * size;
                        const y = cell.y + Math.sin(angle) * size;
                        if (i === 0) {
                            this.hiveCtx.moveTo(x, y);
                        } else {
                            this.hiveCtx.lineTo(x, y);
                        }
                    }
                    this.hiveCtx.closePath();
                    this.hiveCtx.stroke();

                    // Construction progress visualization
                    if (cell.constructionProgress < 1.0) {
                        const progressColor = `rgba(255, 255, 0, ${1 - cell.constructionProgress})`;
                        this.hiveCtx.strokeStyle = progressColor;
                        this.hiveCtx.lineWidth = 3;
                        this.hiveCtx.stroke();
                    }

                    // Honey level
                    if (cell.honeyLevel > 0) {
                        const honeyAlpha = cell.honeyLevel;
                        this.hiveCtx.fillStyle = `rgba(255, 215, 0, ${honeyAlpha})`;
                        this.hiveCtx.beginPath();
                        this.hiveCtx.arc(cell.x, cell.y, size * cell.honeyLevel, 0, 2 * Math.PI);
                        this.hiveCtx.fill();
                    }

                    // Quality indicator
                    if (this.visualizations.showHoneyStorage && cell.quality > 0) {
                        this.hiveCtx.fillStyle = `rgba(255, 165, 0, ${cell.quality * 0.5})`;
                        this.hiveCtx.beginPath();
                        this.hiveCtx.arc(cell.x, cell.y, 3, 0, 2 * Math.PI);
                        this.hiveCtx.fill();
                    }
                });

                // Render air flow patterns
                this.hiveInterior.airFlow.forEach(flow => {
                    this.hiveCtx.strokeStyle = `rgba(200, 200, 255, 0.3)`;
                    this.hiveCtx.lineWidth = 1;
                    this.hiveCtx.beginPath();
                    this.hiveCtx.moveTo(flow.x, flow.y);
                    this.hiveCtx.lineTo(flow.x + flow.vx * 10, flow.y + flow.vy * 10);
                    this.hiveCtx.stroke();
                });

                // Render nectar processing if enabled
                if (this.visualizations.showNectarProcessing) {
                    this.renderNectarProcessing();
                }

                // Render interior activities
                if (this.visualizations.showInteriorActivities) {
                    this.renderInteriorActivities();
                }

                // Render interior bees with enhanced visibility - SAME rendering as exterior
                let interiorBeeCount = 0;
                this.bees.forEach(bee => {
                    if (bee.isInside && CrashProtection.validateBee(bee)) {
                        interiorBeeCount++;
                        
                        // Render the bee with IDENTICAL approach as exterior
                        CrashProtection.safeCanvasOperation(this.hiveCtx, () => {
                            // Save canvas state before rendering
                            this.hiveCtx.save();
                            this.renderBee(bee, this.hiveCtx);
                            this.hiveCtx.restore();
                        }, `interior-bee-${bee.id}`);
                        
                        // Show interior-specific bee information ONLY if enabled
                        if (this.visualizations.showInteriorActivities) {
                            CrashProtection.safeCanvasOperation(this.hiveCtx, () => {
                                this.hiveCtx.save();
                                this.renderInteriorBeeActivity(bee);
                                this.hiveCtx.restore();
                            }, 'interior-bee-activity');
                        }
                        
                        // Debug info for interior bees (less frequent)
                        if (interiorBeeCount <= 3 && this.time % 120 === 0) { // Every 2 seconds, first 3 bees
                            this.hiveCtx.save();
                            this.hiveCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            this.hiveCtx.font = '10px Arial';
                            this.hiveCtx.textAlign = 'center';
                            this.hiveCtx.fillText(
                                `${bee.id}:${bee.currentBehavior.substring(0,3)}`, 
                                bee.x, 
                                bee.y - 15
                            );
                            this.hiveCtx.restore();
                        }
                    }
                });
                
                // Debug: Log interior bee count (less frequently)
                if (this.time % 300 === 0) { // Every 5 seconds
                    if (interiorBeeCount === 0 && this.bees.length > 0) {
                        console.log(`Interior view: No bees inside hive. Total bees: ${this.bees.length}, Interior set size: ${this.hiveInterior.interiorBees.size}`);
                    } else if (interiorBeeCount > 0) {
                        console.log(`Interior view: ${interiorBeeCount} bees active inside hive`);
                    }
                }
            }

            renderHoneyFlows() {
                this.bees.forEach(bee => {
                    if (bee.isInside && bee.nectar > 0 && bee.currentBehavior === 'honey_processing') {
                        // Find target honey cell
                        const targetCell = this.hiveInterior.honeyCells.find(cell => 
                            Math.sqrt((cell.x - bee.x) ** 2 + (cell.y - bee.y) ** 2) < 30 && 
                            cell.type === 'storage'
                        );
                        
                        if (targetCell) {
                            // Animate honey flow
                            const flowParticles = 8;
                            for (let i = 0; i < flowParticles; i++) {
                                const progress = (i / flowParticles) + (this.time * 0.02) % 1;
                                const x = bee.x + (targetCell.x - bee.x) * progress;
                                const y = bee.y + (targetCell.y - bee.y) * progress;
                                
                                this.hiveCtx.fillStyle = `rgba(255, 215, 0, ${bee.nectar * (1 - progress)})`;
                                this.hiveCtx.beginPath();
                                this.hiveCtx.arc(x, y, 2, 0, 2 * Math.PI);
                                this.hiveCtx.fill();
                            }
                        }
                    }
                });
            }

            renderHoneyCombConstruction() {
                this.hiveInterior.honeyCells.forEach(cell => {
                    if (cell.constructionProgress < 1.0) {
                        // Show construction progress with animated building effect
                        const progress = cell.constructionProgress;
                        const completedSides = Math.floor(progress * 6);
                        
                        this.hiveCtx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
                        this.hiveCtx.lineWidth = 3;
                        
                        // Draw completed sides
                        for (let i = 0; i < completedSides; i++) {
                            const angle1 = (i / 6) * 2 * Math.PI;
                            const angle2 = ((i + 1) / 6) * 2 * Math.PI;
                            const size = 18;
                            
                            const x1 = cell.x + Math.cos(angle1) * size;
                            const y1 = cell.y + Math.sin(angle1) * size;
                            const x2 = cell.x + Math.cos(angle2) * size;
                            const y2 = cell.y + Math.sin(angle2) * size;
                            
                            this.hiveCtx.beginPath();
                            this.hiveCtx.moveTo(x1, y1);
                            this.hiveCtx.lineTo(x2, y2);
                            this.hiveCtx.stroke();
                        }
                        
                        // Show partial construction of current side
                        if (completedSides < 6) {
                            const partialProgress = (progress * 6) % 1;
                            const angle1 = (completedSides / 6) * 2 * Math.PI;
                            const angle2 = ((completedSides + 1) / 6) * 2 * Math.PI;
                            const size = 18;
                            
                            const x1 = cell.x + Math.cos(angle1) * size;
                            const y1 = cell.y + Math.sin(angle1) * size;
                            const x2 = cell.x + Math.cos(angle2) * size;
                            const y2 = cell.y + Math.sin(angle2) * size;
                            
                            this.hiveCtx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                            this.hiveCtx.beginPath();
                            this.hiveCtx.moveTo(x1, y1);
                            this.hiveCtx.lineTo(
                                x1 + (x2 - x1) * partialProgress,
                                y1 + (y2 - y1) * partialProgress
                            );
                            this.hiveCtx.stroke();
                        }
                    }
                });
            }

            renderNectarProcessing() {
                this.bees.forEach(bee => {
                    if (bee.isInside && bee.nectar > 0) {
                        // Show nectar processing as swirling particles around bee
                        const particleCount = Math.floor(bee.nectar * 10);
                        
                        for (let i = 0; i < particleCount; i++) {
                            const angle = (i / particleCount) * Math.PI * 2 + this.time * 0.05;
                            const radius = 8 + Math.sin(this.time * 0.1 + i) * 3;
                            const x = bee.x + Math.cos(angle) * radius;
                            const y = bee.y + Math.sin(angle) * radius;
                            
                            this.hiveCtx.fillStyle = `rgba(255, 215, 0, ${bee.nectar})`;
                            this.hiveCtx.beginPath();
                            this.hiveCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
                            this.hiveCtx.fill();
                        }
                    }
                });
            }

            renderInteriorActivities() {
                // Create activity heat map
                const activityMap = new Map();
                
                this.bees.forEach(bee => {
                    if (bee.isInside) {
                        const gridX = Math.floor(bee.x / 30);
                        const gridY = Math.floor(bee.y / 30);
                        const key = `${gridX},${gridY}`;
                        
                        if (!activityMap.has(key)) {
                            activityMap.set(key, 0);
                        }
                        activityMap.set(key, activityMap.get(key) + 1);
                    }
                });
                
                // Render activity heat map
                activityMap.forEach((activity, key) => {
                    const [gridX, gridY] = key.split(',').map(Number);
                    const intensity = Math.min(1, activity / 5);
                    
                    this.hiveCtx.fillStyle = `rgba(255, 0, 0, ${intensity * 0.3})`;
                    this.hiveCtx.fillRect(gridX * 30, gridY * 30, 25, 25);
                });
            }

            renderInteriorBeeActivity(bee) {
                // Show activity-specific visualizations around interior bees
                switch (bee.currentBehavior) {
                    case 'honey_processing':
                        this.hiveCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                        this.hiveCtx.lineWidth = 2;
                        this.hiveCtx.beginPath();
                        this.hiveCtx.arc(bee.x, bee.y, 12, 0, 2 * Math.PI);
                        this.hiveCtx.stroke();
                        break;
                        
                    case 'construction':
                        // Show construction tools
                        this.hiveCtx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                        this.hiveCtx.fillRect(bee.x - 2, bee.y - 8, 4, 6);
                        this.hiveCtx.fillRect(bee.x - 6, bee.y - 2, 12, 2);
                        
                        // Play construction sound if enabled
                        if (this.soundEnabled && Math.random() < 0.05) {
                            this.audioSystem.playConstructionSound();
                        }
                        break;
                        
                    case 'interior_exploration':
                        // Show exploration path
                        this.hiveCtx.strokeStyle = 'rgba(100, 255, 100, 0.5)';
                        this.hiveCtx.lineWidth = 1;
                        this.hiveCtx.setLineDash([3, 3]);
                        this.hiveCtx.beginPath();
                        this.hiveCtx.arc(bee.x, bee.y, 20, 0, 2 * Math.PI);
                        this.hiveCtx.stroke();
                        this.hiveCtx.setLineDash([]);
                        break;
                }
            }

            renderBee(bee, ctx) {
                CrashProtection.safeCanvasOperation(ctx, () => {
                    // Always save and restore context to prevent state interference
                    ctx.save();
                    
                    // Reset any potential canvas state that could affect rendering
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.filter = 'none';
                    
                    ctx.translate(bee.x, bee.y);
                    ctx.rotate(bee.bodyTilt);
                    
                    // Realistic bee body proportions - more elongated, less fat
                    const bodyLength = bee.size * 2.0;  // Much longer body
                    const bodyWidth = bee.size * 0.7;   // Narrower width
                    
                    // Classic honey bee colors - ALWAYS consistent
                    const beeYellow = bee.ruptureState ? '#FF8C00' : '#FFD700'; // Golden yellow
                    const beeBlack = bee.ruptureState ? '#8B0000' : '#000000';   // Deep black
                    
                    // Role-based subtle yellow tinting
                    const roleTints = {
                        'scout': '#FFF700',      // Bright yellow
                        'forager': '#FFD700',    // Standard golden yellow  
                        'builder': '#FFB000',    // Amber yellow
                        'worker': '#FFED4A'      // Pale yellow
                    };
                    const bodyColor = bee.ruptureState ? '#FF6666' : (roleTints[bee.role] || beeYellow);

                    // Main bee abdomen (elongated oval) - most prominent part
                    ctx.fillStyle = bodyColor;
                    ctx.strokeStyle = 'none';
                    ctx.beginPath();
                    ctx.ellipse(bodyLength * 0.2, 0, bodyLength * 0.6, bodyWidth * 0.8, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Black stripes across the abdomen - very distinctive
                    ctx.fillStyle = beeBlack;
                    for (let i = 0; i < 4; i++) {
                        const stripeX = bodyLength * 0.1 + i * bodyLength * 0.25;
                        const stripeWidth = bodyLength * 0.12;
                        ctx.beginPath();
                        ctx.ellipse(stripeX, 0, stripeWidth, bodyWidth * 0.75, 0, 0, 2 * Math.PI);
                        ctx.fill();
                    }

                    // Thorax (middle section) - smaller, darker
                    ctx.fillStyle = '#8B4513'; // Brown thorax
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.2, 0, bodyLength * 0.3, bodyWidth * 0.6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Black thorax stripes
                    ctx.fillStyle = beeBlack;
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.25, 0, bodyLength * 0.08, bodyWidth * 0.5, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Head - black and smaller
                    ctx.fillStyle = beeBlack;
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.7, 0, bodyLength * 0.25, bodyWidth * 0.5, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Compound eyes - distinctive white dots
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.75, -bodyWidth * 0.15, bodyLength * 0.08, bodyLength * 0.08, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.75, bodyWidth * 0.15, bodyLength * 0.08, bodyLength * 0.08, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Black pupils
                    ctx.fillStyle = beeBlack;
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.75, -bodyWidth * 0.15, bodyLength * 0.04, bodyLength * 0.04, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 0.75, bodyWidth * 0.15, bodyLength * 0.04, bodyLength * 0.04, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Realistic bee wings (keep as they were - user said they're fine)
                    const wingFlap = Math.sin(bee.wingBeat) * 0.4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.strokeStyle = 'rgba(180, 180, 180, 0.9)';
                    ctx.lineWidth = 0.5;
                    
                    // Upper wings (larger)
                    ctx.save();
                    ctx.rotate(wingFlap);
                    ctx.beginPath();
                    ctx.ellipse(bodyLength * 0.1, -bodyWidth * 1.1, bodyLength * 0.4, bodyLength * 0.7, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.rotate(-wingFlap);
                    ctx.beginPath();
                    ctx.ellipse(bodyLength * 0.1, bodyWidth * 1.1, bodyLength * 0.4, bodyLength * 0.7, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    
                    // Lower wings (smaller)
                    ctx.save();
                    ctx.rotate(wingFlap * 0.7);
                    ctx.beginPath();
                    ctx.ellipse(bodyLength * 0.4, -bodyWidth * 0.8, bodyLength * 0.25, bodyLength * 0.45, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.rotate(-wingFlap * 0.7);
                    ctx.beginPath();
                    ctx.ellipse(bodyLength * 0.4, bodyWidth * 0.8, bodyLength * 0.25, bodyLength * 0.45, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    
                    // Antennae - more prominent
                    ctx.strokeStyle = beeBlack;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-bodyLength * 0.8, -bodyWidth * 0.2);
                    ctx.lineTo(-bodyLength * 1.0, -bodyWidth * 0.4);
                    ctx.moveTo(-bodyLength * 0.8, bodyWidth * 0.2);
                    ctx.lineTo(-bodyLength * 1.0, bodyWidth * 0.4);
                    ctx.stroke();
                    
                    // Antennae tips
                    ctx.fillStyle = beeBlack;
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 1.0, -bodyWidth * 0.4, bodyLength * 0.03, bodyLength * 0.03, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(-bodyLength * 1.0, bodyWidth * 0.4, bodyLength * 0.03, bodyLength * 0.03, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Legs (simple but visible)
                    ctx.strokeStyle = beeBlack;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const legX = -bodyLength * 0.4 + i * bodyLength * 0.3;
                        // Left legs
                        ctx.beginPath();
                        ctx.moveTo(legX, bodyWidth * 0.3);
                        ctx.lineTo(legX - bodyLength * 0.1, bodyWidth * 0.7);
                        ctx.stroke();
                        // Right legs  
                        ctx.beginPath();
                        ctx.moveTo(legX, -bodyWidth * 0.3);
                        ctx.lineTo(legX - bodyLength * 0.1, -bodyWidth * 0.7);
                        ctx.stroke();
                    }

                    // Always restore context state
                    ctx.restore();
                }, 'bee rendering');
                
                // Coherence glow effect - rendered OUTSIDE the main bee rendering to avoid interference
                if (bee.coherenceState > 0.7) {
                    CrashProtection.safeCanvasOperation(ctx, () => {
                        ctx.save();
                        ctx.shadowColor = `rgba(255, 215, 0, ${bee.coherenceState * 0.4})`;
                        ctx.shadowBlur = 12;
                        ctx.globalAlpha = bee.coherenceState * 0.3;
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bee.x, bee.y, bee.size * 3.0, 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.restore();
                    }, 'bee coherence glow');
                }
            }

            renderUCFField() {
                const resolution = UCF.FIELD_RESOLUTION;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                for (let x = 0; x < width; x += resolution) {
                    for (let y = 0; y < height; y += resolution) {
                        let fieldStrength = 0;
                        let beeCount = 0;
                        
                        this.bees.forEach(bee => {
                            const distance = Math.sqrt((bee.x - x) ** 2 + (bee.y - y) ** 2);
                            if (distance < UCF.VISUAL_COHERENCE_RANGE) {
                                fieldStrength += bee.coherenceState * Math.exp(-distance / 50);
                                beeCount++;
                            }
                        });
                        
                        if (beeCount > 0) {
                            const alpha = Math.min(0.3, fieldStrength / beeCount);
                            const hue = fieldStrength * 360;
                            this.ctx.fillStyle = `hsla(${hue}, 70%, 50%, ${alpha})`;
                            this.ctx.fillRect(x, y, resolution, resolution);
                        }
                    }
                }
            }

            renderPheromoneTrails() {
                this.environment.pheromoneTrails.forEach(trail => {
                    const alpha = trail.intensity;
                    this.ctx.fillStyle = `rgba(128, 0, 128, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(trail.x, trail.y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            renderBackground() {
                // Brown/earthy background like in screenshot
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(0, 0, 1200, 800);
                
                // Add subtle texture variation
                for (let x = 0; x < 1200; x += 20) {
                    for (let y = 0; y < 800; y += 20) {
                        const variation = Math.random() * 0.1 - 0.05;
                        const brightness = 0.5 + variation;
                        this.ctx.fillStyle = `rgba(139, 69, 19, ${brightness * 0.3})`;
                        this.ctx.fillRect(x, y, 15, 15);
                    }
                }
            }

            renderFlowers() {
                this.environment.flowers.forEach(flower => {
                    const baseSize = 12;
                    const size = baseSize + flower.nectar * 8;
                    const alpha = 0.7 + flower.nectar * 0.3;
                    
                    // Hexagonal flower shape (like in screenshot)
                    this.ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`; // Pink/magenta color
                    this.ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI;
                        const x = flower.x + Math.cos(angle) * size;
                        const y = flower.y + Math.sin(angle) * size;
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Yellow center
                    this.ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(flower.x, flower.y, size * 0.3, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Nectar level indicator (optional glow)
                    if (flower.nectar > 0.7) {
                        this.ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                        this.ctx.shadowBlur = 10;
                        this.ctx.beginPath();
                        this.ctx.arc(flower.x, flower.y, size * 0.2, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                });
            }

            renderHive() {
                // Main hive structure
                this.ctx.fillStyle = '#8B4513';
                this.ctx.beginPath();
                this.ctx.arc(this.environment.hiveCenter.x, this.environment.hiveCenter.y, 50, 0, 2 * Math.PI);
                this.ctx.fill();

                // Hive entrance
                this.ctx.fillStyle = '#654321';
                this.ctx.beginPath();
                this.ctx.arc(this.environment.hiveCenter.x, this.environment.hiveCenter.y + 30, 15, 0, 2 * Math.PI);
                this.ctx.fill();

                // Render hive structures
                this.environment.hiveStructures.forEach(structure => {
                    const alpha = structure.integrity;
                    this.ctx.fillStyle = `rgba(139, 69, 19, ${alpha})`;
                    this.ctx.fillRect(structure.x - 5, structure.y - 5, 10, 10);
                });
            }

            renderPredators() {
                this.predatorDynamics.predators.forEach(predator => {
                    this.ctx.save();
                    this.ctx.translate(predator.x, predator.y);
                    
                    if (predator.type === 'bird') {
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, 15, 8, 0, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        this.ctx.fillStyle = '#654321';
                        this.ctx.beginPath();
                        this.ctx.ellipse(-10, -5, 12, 4, -0.3, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.beginPath();
                        this.ctx.ellipse(-10, 5, 12, 4, 0.3, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.beginPath();
                        this.ctx.moveTo(15, 0);
                        this.ctx.lineTo(8, -3);
                        this.ctx.lineTo(8, 3);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }

            // New comprehensive visualization functions
            renderWindVectors() {
                this.environmentalPhysics.windField.forEach((cell, i) => {
                    if (i % 20 === 0) { // Sample every 20th cell for performance
                        const intensity = Math.sqrt(cell.vx * cell.vx + cell.vy * cell.vy);
                        if (intensity > 0.1) {
                            this.ctx.strokeStyle = `rgba(100, 100, 255, ${intensity})`;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(cell.x, cell.y);
                            this.ctx.lineTo(cell.x + cell.vx * 10, cell.y + cell.vy * 10);
                            this.ctx.stroke();
                        }
                    }
                });
            }

            renderTemperatureGradient() {
                for (let x = 0; x < 1200; x += 30) {
                    for (let y = 0; y < 800; y += 30) {
                        // Calculate temperature based on proximity to hive and sun position
                        const hiveDistance = Math.sqrt((x - this.environment.hiveCenter.x) ** 2 + (y - this.environment.hiveCenter.y) ** 2);
                        const temperature = 20 + (300 - hiveDistance) / 300 * 15 + Math.sin(this.time * 0.01) * 5;
                        const hue = Math.max(0, Math.min(240, 240 - temperature * 4));
                        this.ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.3)`;
                        this.ctx.fillRect(x, y, 25, 25);
                    }
                }
            }

            renderHumidityZones() {
                for (let x = 0; x < 1200; x += 40) {
                    for (let y = 0; y < 800; y += 40) {
                        const humidity = 0.4 + Math.sin(x * 0.01) * Math.cos(y * 0.01) * 0.3;
                        this.ctx.fillStyle = `rgba(0, 100, 200, ${humidity * 0.4})`;
                        this.ctx.fillRect(x, y, 35, 35);
                    }
                }
            }

            renderAirPressure() {
                for (let x = 0; x < 1200; x += 50) {
                    for (let y = 0; y < 800; y += 50) {
                        const pressure = 1013 + Math.sin(x * 0.005 + this.time * 0.02) * 10;
                        const intensity = (pressure - 1000) / 30;
                        this.ctx.fillStyle = `rgba(255, 0, 0, ${Math.abs(intensity) * 0.3})`;
                        this.ctx.fillRect(x, y, 45, 45);
                    }
                }
            }

            renderLightIntensity() {
                const sunX = 200 + Math.cos(this.time * 0.005) * 400;
                const sunY = 100 + Math.sin(this.time * 0.005) * 100;
                
                for (let x = 0; x < 1200; x += 60) {
                    for (let y = 0; y < 800; y += 60) {
                        const lightDistance = Math.sqrt((x - sunX) ** 2 + (y - sunY) ** 2);
                        const intensity = Math.max(0, 1 - lightDistance / 800);
                        this.ctx.fillStyle = `rgba(255, 255, 0, ${intensity * 0.2})`;
                        this.ctx.fillRect(x, y, 55, 55);
                    }
                }
            }

            renderRuptureZones() {
                this.bees.forEach(bee => {
                    if (bee.ruptureState) {
                        this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(bee.x, bee.y, 30, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        
                        // Lightning-like rupture effects
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(bee.x, bee.y);
                            this.ctx.lineTo(bee.x + Math.cos(angle) * 25, bee.y + Math.sin(angle) * 25);
                            this.ctx.stroke();
                        }
                    }
                });
            }

            renderRebirthFields() {
                this.bees.forEach(bee => {
                    if (bee.rebirthField > 0) {
                        const intensity = bee.rebirthField;
                        this.ctx.fillStyle = `rgba(0, 255, 100, ${intensity * 0.3})`;
                        this.ctx.beginPath();
                        this.ctx.arc(bee.x, bee.y, 40 * intensity, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        // Spiral rebirth pattern
                        this.ctx.strokeStyle = `rgba(0, 255, 150, ${intensity})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            const r = 20 * intensity * t / (Math.PI * 4);
                            const x = bee.x + Math.cos(t) * r;
                            const y = bee.y + Math.sin(t) * r;
                            if (t === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.stroke();
                    }
                });
            }

            renderTemporalDecay() {
                this.bees.forEach(bee => {
                    const historyLength = bee.coherenceHistory.length;
                    for (let i = 1; i < historyLength; i++) {
                        const alpha = i / historyLength;
                        const prevCoherence = bee.coherenceHistory[i - 1];
                        const currentCoherence = bee.coherenceHistory[i];
                        
                        this.ctx.strokeStyle = `rgba(150, 150, 255, ${alpha * 0.5})`;
                        this.ctx.lineWidth = Math.max(1, currentCoherence * 3);
                        this.ctx.beginPath();
                        this.ctx.arc(bee.x, bee.y, i * 0.5, 0, 2 * Math.PI);
                        this.ctx.stroke();
                    }
                });
            }

            renderMemoryEntanglement() {
                this.bees.forEach(bee1 => {
                    this.bees.forEach(bee2 => {
                        if (bee1 !== bee2) {
                            const distance = Math.sqrt((bee1.x - bee2.x) ** 2 + (bee1.y - bee2.y) ** 2);
                            if (distance < 100) {
                                const entanglement = Math.exp(-distance / 50) * bee1.coherenceState * bee2.coherenceState;
                                if (entanglement > 0.1) {
                                    this.ctx.strokeStyle = `rgba(255, 0, 255, ${entanglement * 0.5})`;
                                    this.ctx.lineWidth = Math.max(1, entanglement * 3);
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(bee1.x, bee1.y);
                                    this.ctx.lineTo(bee2.x, bee2.y);
                                    this.ctx.stroke();
                                }
                            }
                        }
                    });
                });
            }

            renderWaggleDances() {
                this.bees.forEach(bee => {
                    if (bee.currentBehavior === 'foraging' && bee.targetFlower) {
                        // Draw waggle dance figure-8 pattern
                        this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                        this.ctx.lineWidth = 2;
                        
                        for (let t = 0; t < Math.PI * 4; t += 0.2) {
                            const r = 15;
                            const x = bee.x + Math.cos(t) * r * Math.sin(t / 2);
                            const y = bee.y + Math.sin(t) * r;
                            
                            if (t === 0) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.stroke();
                    }
                });
            }

            renderInformationFlow() {
                this.bees.forEach(bee1 => {
                    this.bees.forEach(bee2 => {
                        if (bee1 !== bee2) {
                            const distance = Math.sqrt((bee1.x - bee2.x) ** 2 + (bee1.y - bee2.y) ** 2);
                            if (distance < 60 && bee1.currentBehavior === bee2.currentBehavior) {
                                // Information exchange visualization
                                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
                                this.ctx.lineWidth = 1;
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.beginPath();
                                this.ctx.moveTo(bee1.x, bee1.y);
                                this.ctx.lineTo(bee2.x, bee2.y);
                                this.ctx.stroke();
                                this.ctx.setLineDash([]);
                            }
                        }
                    });
                });
            }

            renderSocialNetworks() {
                // Group bees by behavior
                const behaviorGroups = {};
                this.bees.forEach(bee => {
                    if (!behaviorGroups[bee.currentBehavior]) {
                        behaviorGroups[bee.currentBehavior] = [];
                    }
                    behaviorGroups[bee.currentBehavior].push(bee);
                });

                // Draw connections within behavior groups
                Object.values(behaviorGroups).forEach((group, groupIndex) => {
                    const colors = ['rgba(255,100,100,0.3)', 'rgba(100,255,100,0.3)', 'rgba(100,100,255,0.3)', 'rgba(255,255,100,0.3)'];
                    this.ctx.strokeStyle = colors[groupIndex % colors.length];
                    this.ctx.lineWidth = 1;
                    
                    for (let i = 0; i < group.length; i++) {
                        for (let j = i + 1; j < group.length; j++) {
                            const bee1 = group[i];
                            const bee2 = group[j];
                            const distance = Math.sqrt((bee1.x - bee2.x) ** 2 + (bee1.y - bee2.y) ** 2);
                            if (distance < 80) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(bee1.x, bee1.y);
                                this.ctx.lineTo(bee2.x, bee2.y);
                                this.ctx.stroke();
                            }
                        }
                    }
                });
            }

            renderResourceDistribution() {
                this.environment.flowers.forEach(flower => {
                    // Resource field visualization
                    const radius = flower.nectar * 50;
                    this.ctx.fillStyle = `rgba(50, 255, 50, ${flower.nectar * 0.2})`;
                    this.ctx.beginPath();
                    this.ctx.arc(flower.x, flower.y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            renderConstructionPaths() {
                this.bees.forEach(bee => {
                    if (bee.currentBehavior === 'construction' && bee.constructionMaterial > 0) {
                        // Show construction path to nearest construction site
                        const nearestSite = this.environment.hiveStructures.find(s => s.constructionNeeded);
                        if (nearestSite) {
                            this.ctx.strokeStyle = 'rgba(139, 69, 19, 0.6)';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([10, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(bee.x, bee.y);
                            this.ctx.lineTo(nearestSite.x, nearestSite.y);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                        }
                    }
                });
            }

            renderStructuralIntegrity() {
                this.environment.hiveStructures.forEach(structure => {
                    // Color code by structural integrity
                    const hue = structure.integrity * 120; // Green = good, Red = poor
                    this.ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.7)`;
                    this.ctx.fillRect(structure.x - 8, structure.y - 8, 16, 16);
                    
                    // Show integrity percentage
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(Math.round(structure.integrity * 100) + '%', structure.x, structure.y + 25);
                });
            }

            renderThreatZones() {
                this.predatorDynamics.threatZones.forEach(zone => {
                    this.ctx.strokeStyle = `rgba(255, 0, 0, ${zone.intensity * 0.5})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([15, 10]);
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, 2 * Math.PI);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });
            }

            renderEscapeVectors() {
                this.bees.forEach(bee => {
                    // Calculate escape vector from nearest predator
                    let nearestPredator = null;
                    let minDistance = Infinity;
                    
                    this.predatorDynamics.predators.forEach(predator => {
                        const distance = Math.sqrt((bee.x - predator.x) ** 2 + (bee.y - predator.y) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestPredator = predator;
                        }
                    });
                    
                    if (nearestPredator && minDistance < 150) {
                        const escapeX = bee.x + (bee.x - nearestPredator.x) / minDistance * 50;
                        const escapeY = bee.y + (bee.y - nearestPredator.y) / minDistance * 50;
                        
                        this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(bee.x, bee.y);
                        this.ctx.lineTo(escapeX, escapeY);
                        this.ctx.stroke();
                        
                        // Arrow head
                        const angle = Math.atan2(escapeY - bee.y, escapeX - bee.x);
                        this.ctx.beginPath();
                        this.ctx.moveTo(escapeX, escapeY);
                        this.ctx.lineTo(escapeX - 10 * Math.cos(angle - 0.5), escapeY - 10 * Math.sin(angle - 0.5));
                        this.ctx.lineTo(escapeX - 10 * Math.cos(angle + 0.5), escapeY - 10 * Math.sin(angle + 0.5));
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                });
            }

            renderBeeGenetics(bee, ctx) {
                // Show genetic traits as colored rings around bee
                const traits = ['foraging', 'construction', 'social', 'intelligence'];
                traits.forEach((trait, index) => {
                    const strength = bee.genetics.getTraitStrength(trait);
                    const radius = 8 + index * 4;
                    const hue = index * 90;
                    ctx.strokeStyle = `hsla(${hue}, 70%, 50%, ${strength})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(bee.x, bee.y, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                });
            }

            renderBeeEnergy(bee, ctx) {
                // Energy bar above bee
                const barWidth = 20;
                const barHeight = 4;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(bee.x - barWidth/2, bee.y - 15, barWidth, barHeight);
                ctx.fillStyle = `hsl(${bee.energy * 120}, 70%, 50%)`;
                ctx.fillRect(bee.x - barWidth/2, bee.y - 15, barWidth * bee.energy, barHeight);
            }

            renderBeeIntelligence(bee, ctx) {
                // Intelligence visualization as brain-like pattern
                if (bee.intelligence > 0.7) {
                    ctx.strokeStyle = `rgba(255, 0, 255, ${bee.intelligence * 0.5})`;
                    ctx.lineWidth = 1;
                    
                    // Draw neural network pattern
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const x1 = bee.x + Math.cos(angle) * 12;
                        const y1 = bee.y + Math.sin(angle) * 12;
                        
                        for (let j = i + 1; j < 5; j++) {
                            const angle2 = (j / 5) * Math.PI * 2;
                            const x2 = bee.x + Math.cos(angle2) * 12;
                            const y2 = bee.y + Math.sin(angle2) * 12;
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }
            }

            renderLearningPaths() {
                this.bees.forEach(bee => {
                    if (bee.experiencePoints > 50) {
                        // Show learning trajectory
                        this.ctx.strokeStyle = `rgba(100, 200, 255, ${Math.min(1, bee.experiencePoints / 200)})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 10]);
                        
                        // Create a spiral learning path
                        this.ctx.beginPath();
                        for (let t = 0; t < Math.PI * 2; t += 0.1) {
                            const r = (bee.experiencePoints / 100) * t;
                            const x = bee.x + Math.cos(t) * r;
                            const y = bee.y + Math.sin(t) * r;
                            if (t === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                });
            }

            renderAdaptationRates() {
                this.bees.forEach(bee => {
                    // Adaptation rate as pulsing circle
                    const pulseIntensity = 0.5 + 0.5 * Math.sin(this.time * 0.1 + bee.id);
                    const radius = 15 + bee.adaptationRate * 20;
                    this.ctx.strokeStyle = `rgba(255, 150, 0, ${bee.adaptationRate * pulseIntensity})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(bee.x, bee.y, radius, 0, 2 * Math.PI);
                    this.ctx.stroke();
                });
            }

            renderMutationEvents() {
                this.bees.forEach(bee => {
                    if (bee.genetics.mutations > 0) {
                        const mutationIntensity = Math.min(1, bee.genetics.mutations / 10);
                        this.ctx.strokeStyle = `rgba(255, 0, 255, ${mutationIntensity})`;
                        this.ctx.lineWidth = 2;
                        
                        // DNA helix pattern around bee
                        for (let t = 0; t < Math.PI * 4; t += 0.2) {
                            const r = 15;
                            const x = bee.x + Math.cos(t) * r;
                            const y = bee.y + Math.sin(t * 2) * r * 0.5;
                            
                            if (t === 0) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.stroke();
                    }
                });
            }

            renderTraitExpressions() {
                this.bees.forEach(bee => {
                    // Show dominant traits as colored auras
                    const traits = ['foraging', 'construction', 'social', 'intelligence'];
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
                    
                    traits.forEach((trait, index) => {
                        const strength = bee.genetics.getTraitStrength(trait);
                        if (strength > 0.6) {
                            this.ctx.fillStyle = `${colors[index]}33`; // Semi-transparent
                            this.ctx.beginPath();
                            this.ctx.arc(bee.x, bee.y, 15 + strength * 10, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                    });
                });
            }

            renderEvolutionPressure() {
                // Visualize environmental evolution pressure as field overlay
                const pressure = this.geneticEvolution.evolutionPressure;
                
                for (let x = 0; x < 1200; x += 100) {
                    for (let y = 0; y < 800; y += 100) {
                        const totalPressure = pressure.environmental + pressure.predation + pressure.resource + pressure.social;
                        if (totalPressure > 0.1) {
                            this.ctx.fillStyle = `rgba(255, 100, 0, ${totalPressure * 0.3})`;
                            this.ctx.fillRect(x, y, 90, 90);
                            
                            // Pressure indicator text
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = '12px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText(totalPressure.toFixed(2), x + 45, y + 50);
                        }
                    }
                }
            }

            renderDecisionTrees() {
                this.bees.forEach(bee => {
                    // Show decision branches for high-intelligence bees
                    if (bee.intelligence > 0.7) {
                        const decisions = ['forage', 'build', 'explore', 'rest'];
                        
                        decisions.forEach((decision, index) => {
                            const angle = (index / decisions.length) * Math.PI * 2;
                            const probability = Math.random(); // Simplified - would be based on actual decision logic
                            
                            if (probability > 0.3) {
                                this.ctx.strokeStyle = `rgba(100, 255, 100, ${probability})`;
                                this.ctx.lineWidth = Math.max(1, probability * 3);
                                this.ctx.beginPath();
                                this.ctx.moveTo(bee.x, bee.y);
                                this.ctx.lineTo(
                                    bee.x + Math.cos(angle) * 30,
                                    bee.y + Math.sin(angle) * 30
                                );
                                this.ctx.stroke();
                            }
                        });
                    }
                });
            }

            renderMetabolicRates() {
                this.bees.forEach(bee => {
                    // Metabolic rate visualization as heat signature
                    const metabolicRate = 1 - bee.energy; // Higher metabolism when energy is lower
                    const hue = (1 - metabolicRate) * 120; // Red = high metabolism, Green = low
                    
                    this.ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.4)`;
                    this.ctx.beginPath();
                    this.ctx.arc(bee.x, bee.y, 8 + metabolicRate * 12, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            renderEnergyGradients() {
                // Show energy flow between bees and resources
                this.bees.forEach(bee => {
                    if (bee.targetFlower && bee.currentBehavior === 'foraging') {
                        const gradient = this.ctx.createLinearGradient(
                            bee.x, bee.y, 
                            bee.targetFlower.x, bee.targetFlower.y
                        );
                        gradient.addColorStop(0, `rgba(255, 100, 100, ${bee.energy})`);
                        gradient.addColorStop(1, `rgba(100, 255, 100, ${bee.targetFlower.nectar})`);
                        
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(bee.x, bee.y);
                        this.ctx.lineTo(bee.targetFlower.x, bee.targetFlower.y);
                        this.ctx.stroke();
                    }
                });
            }

            renderNutrientNetworks() {
                // Network of resource sharing between flowers
                this.environment.flowers.forEach((flower1, i) => {
                    this.environment.flowers.forEach((flower2, j) => {
                        if (i < j) {
                            const distance = Math.sqrt(
                                (flower1.x - flower2.x) ** 2 + (flower1.y - flower2.y) ** 2
                            );
                            
                            if (distance < 150 && flower1.nectar > 0.5 && flower2.nectar > 0.5) {
                                const networkStrength = (flower1.nectar + flower2.nectar) / 2;
                                this.ctx.strokeStyle = `rgba(0, 255, 0, ${networkStrength * 0.3})`;
                                this.ctx.lineWidth = 1;
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.beginPath();
                                this.ctx.moveTo(flower1.x, flower1.y);
                                this.ctx.lineTo(flower2.x, flower2.y);
                                this.ctx.stroke();
                                this.ctx.setLineDash([]);
                            }
                        }
                    });
                });
            }

            renderBuildingAlgorithms() {
                this.bees.forEach(bee => {
                    if (bee.currentBehavior === 'construction') {
                        // Show construction algorithm as geometric pattern
                        const algorithm = bee.genetics.getTraitStrength('construction');
                        
                        this.ctx.strokeStyle = `rgba(139, 69, 19, ${algorithm})`;
                        this.ctx.lineWidth = 2;
                        
                        // Hexagonal construction pattern
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const radius = 20 * algorithm;
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(bee.x, bee.y);
                            this.ctx.lineTo(
                                bee.x + Math.cos(angle) * radius,
                                bee.y + Math.sin(angle) * radius
                            );
                            this.ctx.stroke();
                        }
                    }
                });
            }

            renderMaterialFlow() {
                this.bees.forEach(bee => {
                    if (bee.constructionMaterial > 0) {
                        // Show material as flowing particles
                        const particleCount = Math.floor(bee.constructionMaterial * 10);
                        
                        for (let i = 0; i < particleCount; i++) {
                            const angle = (i / particleCount) * Math.PI * 2 + this.time * 0.1;
                            const radius = 5 + i;
                            const x = bee.x + Math.cos(angle) * radius;
                            const y = bee.y + Math.sin(angle) * radius;
                            
                            this.ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                    }
                });
            }

            renderArchitecturalPlanning() {
                // Show planned hive expansion
                const hiveCenter = this.environment.hiveCenter;
                const expansionRadius = 100;
                
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const x = hiveCenter.x + Math.cos(angle) * expansionRadius;
                    const y = hiveCenter.y + Math.sin(angle) * expansionRadius;
                    
                    this.ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([10, 20]);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 15, 0, 2 * Math.PI);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            renderPredatorPatterns() {
                this.predatorDynamics.predators.forEach(predator => {
                    // Show predator movement pattern
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 10]);
                    
                    // Predicted movement path
                    for (let t = 0; t < 5; t++) {
                        const futureX = predator.x + predator.vx * t * 10;
                        const futureY = predator.y + predator.vy * t * 10;
                        
                        if (t === 0) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(futureX, futureY);
                        } else {
                            this.ctx.lineTo(futureX, futureY);
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });
            }

            renderDefenseFormations() {
                // Group nearby bees for defense visualization
                const defenseGroups = [];
                
                this.bees.forEach(bee => {
                    let inGroup = false;
                    defenseGroups.forEach(group => {
                        const avgX = group.reduce((sum, b) => sum + b.x, 0) / group.length;
                        const avgY = group.reduce((sum, b) => sum + b.y, 0) / group.length;
                        const distance = Math.sqrt((bee.x - avgX) ** 2 + (bee.y - avgY) ** 2);
                        
                        if (distance < 50) {
                            group.push(bee);
                            inGroup = true;
                        }
                    });
                    
                    if (!inGroup) {
                        defenseGroups.push([bee]);
                    }
                });
                
                // Draw defense formations for groups of 3 or more
                defenseGroups.forEach(group => {
                    if (group.length >= 3) {
                        this.ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
                        this.ctx.lineWidth = 2;
                        
                        // Draw formation polygon
                        this.ctx.beginPath();
                        group.forEach((bee, index) => {
                            if (index === 0) {
                                this.ctx.moveTo(bee.x, bee.y);
                            } else {
                                this.ctx.lineTo(bee.x, bee.y);
                            }
                        });
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                });
            }

            renderRiskAssessment() {
                this.bees.forEach(bee => {
                    // Calculate risk level based on proximity to predators
                    let riskLevel = 0;
                    
                    this.predatorDynamics.predators.forEach(predator => {
                        const distance = Math.sqrt((bee.x - predator.x) ** 2 + (bee.y - predator.y) ** 2);
                        if (distance < 150) {
                            riskLevel += (150 - distance) / 150;
                        }
                    });
                    
                    if (riskLevel > 0.1) {
                        // Risk visualization as warning indicator
                        this.ctx.fillStyle = `rgba(255, 0, 0, ${Math.min(1, riskLevel) * 0.4})`;
                        this.ctx.beginPath();
                        this.ctx.arc(bee.x, bee.y, 10 + riskLevel * 15, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        // Warning symbol
                        this.ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('‚ö†', bee.x, bee.y + 4);
                    }
                });
            }

            renderKnowledgeDistribution() {
                // Show how knowledge spreads through the colony
                this.bees.forEach(bee1 => {
                    if (bee1.experiencePoints > 100) {
                        this.bees.forEach(bee2 => {
                            if (bee1 !== bee2) {
                                const distance = Math.sqrt((bee1.x - bee2.x) ** 2 + (bee1.y - bee2.y) ** 2);
                                if (distance < 80) {
                                    const knowledgeTransfer = Math.exp(-distance / 40) * bee1.experiencePoints / 200;
                                    this.ctx.strokeStyle = `rgba(0, 100, 255, ${knowledgeTransfer})`;
                                    this.ctx.lineWidth = 1;
                                    this.ctx.setLineDash([3, 6]);
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(bee1.x, bee1.y);
                                    this.ctx.lineTo(bee2.x, bee2.y);
                                    this.ctx.stroke();
                                    this.ctx.setLineDash([]);
                                }
                            }
                        });
                    }
                });
            }

            renderEmergentBehaviors() {
                // Identify and highlight emergent swarm behaviors
                const behaviorClusters = {};
                
                this.bees.forEach(bee => {
                    const key = bee.currentBehavior;
                    if (!behaviorClusters[key]) {
                        behaviorClusters[key] = [];
                    }
                    behaviorClusters[key].push(bee);
                });
                
                // Highlight synchronized behaviors
                Object.entries(behaviorClusters).forEach(([behavior, bees], index) => {
                    if (bees.length >= 4) { // Emergent behavior requires coordination
                        const colors = ['rgba(255,100,255,0.2)', 'rgba(100,255,255,0.2)', 'rgba(255,255,100,0.2)', 'rgba(100,255,100,0.2)'];
                        this.ctx.fillStyle = colors[index % colors.length];
                        
                        // Find bounding area of coordinated behavior
                        const minX = Math.min(...bees.map(b => b.x)) - 20;
                        const maxX = Math.max(...bees.map(b => b.x)) + 20;
                        const minY = Math.min(...bees.map(b => b.y)) - 20;
                        const maxY = Math.max(...bees.map(b => b.y)) + 20;
                        
                        this.ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
                        
                        // Label the emergent behavior
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '14px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(behavior.toUpperCase(), (minX + maxX) / 2, minY - 5);
                    }
                });
            }

            update() {
                if (!this.isRunning) return;

                // Environment update
                this.environment.update();
                this.hiveInterior.update(this.bees);

                // Update advanced reality layers
                this.environmentalPhysics.update();
                this.communicationNetworks.update();
                this.predatorDynamics.update();
                this.geneticEvolution.update();

                // Update evolution pressure
                this.geneticEvolution.updateEvolutionPressure(this.environment, this.bees, this.predatorDynamics.predators);

                // Update all bees
                this.bees.forEach(bee => {
                    bee.update(this.bees, this.environment, this.time, this.hiveInterior);
                    
                    // NEW: Update bee sound if audio is enabled
                    if (this.soundEnabled && bee.soundData) {
                        this.audioSystem.updateBeeSound(bee, bee.soundData);
                    }
                    
                    // Update communication networks
                    if (Math.random() < 0.1) {
                        this.communicationNetworks.addPheromoneTrail(
                            bee.x, bee.y, bee.currentBehavior, bee.coherenceState, bee.pheromoneSignature, bee
                        );
                    }
                });

                // Remove dead bees
                const deadBees = this.bees.filter(bee => bee.energy <= 0);
                deadBees.forEach(bee => {
                    if (this.soundEnabled && bee.soundData) {
                        this.audioSystem.stopBeeSound(bee.soundData);
                        bee.soundData = null;
                    }
                });
                this.bees = this.bees.filter(bee => bee.energy > 0);
                
                // Only enforce exterior population when in exterior view mode
                // This allows more bees inside when viewing hive interior
                if (!this.webcamMode) {
                    // Ensure at least 50% of bees stay outside for visibility (reduced from 60%)
                    const exteriorBees = this.bees.filter(bee => !bee.isInside);
                    const targetExteriorCount = Math.ceil(this.bees.length * 0.5);
                    
                    if (exteriorBees.length < targetExteriorCount) {
                        // Force some interior bees to come outside
                        const interiorBees = this.bees.filter(bee => bee.isInside);
                        const beesToMoveOut = Math.min(interiorBees.length, targetExteriorCount - exteriorBees.length);
                        
                        for (let i = 0; i < beesToMoveOut; i++) {
                            const bee = interiorBees[i];
                            bee.isInside = false;
                            this.hiveInterior.interiorBees.delete(bee.id);
                            
                            // Position outside hive
                            const exitAngle = Math.random() * Math.PI * 2;
                            bee.x = 600 + Math.cos(exitAngle) * (UCF.HIVE_ENTRANCE_RADIUS + 15);
                            bee.y = 400 + Math.sin(exitAngle) * (UCF.HIVE_ENTRANCE_RADIUS + 15);
                        }
                    }
                }

                // NEW: Update audio systems
                if (this.soundEnabled) {
                    const hiveActivity = this.environment.hiveConstructionProgress / 20;
                    this.audioSystem.updateHiveAmbience(
                        this.bees.length, 
                        this.hiveInterior.interiorBees.size, 
                        hiveActivity
                    );
                }

                this.time++;
            }

            updateStats() {
                const avgCoherence = this.bees.reduce((sum, bee) => sum + bee.coherenceState, 0) / (this.bees.length || 1);
                const population = this.bees.length;
                const hiveProgress = Math.min(100, (this.environment.hiveConstructionProgress / 20) * 100);
                const totalResources = this.environment.totalResources;
                const honeyProduction = this.hiveInterior.honeyStores;
                const interiorBees = this.hiveInterior.interiorBees.size;
                const avgIntelligence = this.bees.reduce((sum, bee) => sum + bee.intelligence, 0) / (this.bees.length || 1);
                const adaptationRate = this.bees.reduce((sum, bee) => sum + bee.adaptationRate, 0) / (this.bees.length || 1);
                const ruptureCount = this.bees.filter(bee => bee.ruptureState).length;
                const rebirthCount = this.bees.filter(bee => bee.rebirthField > 0.3).length;

                document.getElementById('avgCoherence').textContent = avgCoherence.toFixed(3);
                document.getElementById('population').textContent = population;
                document.getElementById('hiveProgress').textContent = hiveProgress.toFixed(0) + '%';
                document.getElementById('totalResources').textContent = totalResources.toFixed(2);
                document.getElementById('honeyProduction').textContent = honeyProduction.toFixed(2);
                document.getElementById('interiorBees').textContent = interiorBees;
                document.getElementById('avgIntelligence').textContent = avgIntelligence.toFixed(2);
                document.getElementById('adaptationRate').textContent = adaptationRate.toFixed(3);
                document.getElementById('ruptureCount').textContent = ruptureCount;
                document.getElementById('rebirthCount').textContent = rebirthCount;

                // Update simulation info
                const viewMode = this.webcamMode ? 'INTERIOR VIEW' : 'EXTERIOR VIEW';
                const audioStatus = this.soundEnabled ? 'AUDIO ON' : 'AUDIO OFF';
                const simInfo = `${viewMode} - ${audioStatus} - ${this.environment.weather} weather, ${this.environment.season} season, ` +
                              `${this.environment.flowers.length} flowers, Environmental pressure: ${this.environment.environmentalPressure.toFixed(2)}`;
                document.getElementById('simInfo').textContent = simInfo;
            }

            animate() {
                for (let i = 0; i < this.simulationSpeed; i++) {
                    this.update();
                }
                
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new UCFEcosystemSimulation();
        });
    </script>
</body>
</html>