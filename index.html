<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cohere.org.uk - Mathematical Life and Living Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        /* ════════════════════════════════════════════════════════════════════════
           ☉ THE ALCHEMICAL SUN — BLAKE'S VISION RENDERED IN CRR
           
           "What is now proved was once only imagin'd" — William Blake
           
           ════════════════════════════════════════════════════════════════════════
           
           SOLAR PHYSICS → CRR TRANSLATION
           ═══════════════════════════════════════════════════════════════════════
           
           The Sun is CRR made manifest across nested timescales.
           Below are the real physical parameters translated into CRR formalism.
           
           ┌─────────────────────────────────────────────────────────────────────┐
           │  FUNDAMENTAL SOLAR PARAMETERS                                       │
           ├─────────────────────────────────────────────────────────────────────┤
           │  Mass:              M☉ = 1.989 × 10³⁰ kg                            │
           │  Radius:            R☉ = 6.957 × 10⁸ m                              │
           │  Surface gravity:   g☉ = 274.0 m/s²                                 │
           │  Escape velocity:   v_esc = 617.7 km/s                              │
           │  Surface temp:      T_surface = 5,772 K                             │
           │  Core temp:         T_core = 1.57 × 10⁷ K                           │
           │  Luminosity:        L☉ = 3.828 × 10²⁶ W                             │
           └─────────────────────────────────────────────────────────────────────┘
           
           ┌─────────────────────────────────────────────────────────────────────┐
           │  CRR INTERPRETATION: COHERENCE AS GRAVITATIONAL BINDING            │
           ├─────────────────────────────────────────────────────────────────────┤
           │                                                                     │
           │  The Sun's gravitational binding energy represents accumulated      │
           │  coherence — the integral of gravitational work over formation:     │
           │                                                                     │
           │     C_grav = E_bind = (3/5) × GM☉²/R☉                               │
           │            = 3.8 × 10⁴¹ J                                           │
           │                                                                     │
           │  This coherence resists thermal expansion (prediction error).       │
           │  Hydrostatic equilibrium IS the C = Ω threshold maintained          │
           │  dynamically — the sun continuously approaches but never exceeds    │
           │  gravitational rupture.                                             │
           │                                                                     │
           │  Coherence gradient (how C accumulates with depth):                 │
           │     dC/dr = -ρg = -ρGM(r)/r²                                        │
           │                                                                     │
           │  At surface: g☉ = 274 m/s² defines the coherence accumulation rate  │
           │                                                                     │
           └─────────────────────────────────────────────────────────────────────┘
           
           ┌─────────────────────────────────────────────────────────────────────┐
           │  Ω-SYMMETRY ANALYSIS: SOLAR MAGNETIC CYCLE                         │
           ├─────────────────────────────────────────────────────────────────────┤
           │                                                                     │
           │  The 11-year solar cycle exhibits Z₂ symmetry (magnetic polarity   │
           │  reversal). Per CRR Ω-symmetry hypothesis:                          │
           │                                                                     │
           │     Z₂ systems: Ω = 1/π ≈ 0.3183                                    │
           │     Predicted CV = Ω/2 ≈ 0.159                                      │
           │                                                                     │
           │  Observed solar cycle variation:                                    │
           │     Mean period: μ = 11.0 years                                     │
           │     Std deviation: σ ≈ 1.5 years                                    │
           │     Observed CV = σ/μ ≈ 0.136                                       │
           │                                                                     │
           │  Agreement within ~15% — the sun's magnetic cycle follows CRR       │
           │  Z₂ dynamics with Ω_solar ≈ 1/π                                     │
           │                                                                     │
           └─────────────────────────────────────────────────────────────────────┘
           
           ┌─────────────────────────────────────────────────────────────────────┐
           │  NESTED CRR TIMESCALES                                              │
           ├─────────────────────────────────────────────────────────────────────┤
           │                                                                     │
           │  MICRO-CRR: Granulation (convection cells)                          │
           │  ───────────────────────────────────────────                        │
           │     Real timescale: τ_granule = 8-20 minutes (mean ≈ 600s)          │
           │     Size: ~1000 km diameter                                         │
           │     Process:                                                        │
           │       C: Hot plasma rises, accumulating buoyant energy              │
           │       Ω: Surface reached — cannot rise further                      │
           │       δ: Heat radiates away (rupture)                               │
           │       R: Cooled plasma sinks, regenerates convection                │
           │     Animation: 3.0-4.5s (compression factor: ~150×)                 │
           │                                                                     │
           │  MESO-CRR: Solar Flares                                             │
           │  ──────────────────────────                                         │
           │     Real timescale: τ_flare = 10-60 minutes                         │
           │     Energy release: 10²⁵ - 10³² ergs                                │
           │     Process:                                                        │
           │       C: Magnetic field lines twist/accumulate stress               │
           │       Ω: Reconnection threshold (~100 Gauss shear)                  │
           │       δ: Magnetic reconnection — sudden energy release              │
           │       R: Field reconfigures to new stable topology                  │
           │     Animation: 6s cycle (compression factor: ~100-600×)             │
           │                                                                     │
           │  MACRO-CRR: Solar Cycle (Schwabe Cycle)                             │
           │  ─────────────────────────────────────────                          │
           │     Real timescale: τ_cycle = 11 years (Z₂ symmetry)                │
           │     Process:                                                        │
           │       C: Differential rotation winds toroidal field                 │
           │       Ω: Field complexity reaches critical threshold                │
           │       δ: Solar maximum / polarity reversal                          │
           │       R: New cycle begins with reversed magnetic polarity           │
           │                                                                     │
           │     The regeneration integral exp(C/Ω) explains why solar cycles    │
           │     "remember" — strong cycles create high-C moments that weight    │
           │     future regeneration, producing multi-cycle correlations.        │
           │                                                                     │
           └─────────────────────────────────────────────────────────────────────┘
           
           ┌─────────────────────────────────────────────────────────────────────┐
           │  ANIMATION TIMING DERIVATIONS FROM PHYSICS                          │
           ├─────────────────────────────────────────────────────────────────────┤
           │                                                                     │
           │  Main CRR cycle: T = 6.0s                                           │
           │     = τ_flare/100 where τ_flare ≈ 600s                              │
           │     Rupture at 48% = 2.88s (δ moment)                               │
           │     Regeneration: 52-90% (3.12s - 5.4s)                             │
           │                                                                     │
           │  Flame periods: T = 1.0s to 1.35s                                   │
           │     Derived from Kolmogorov turbulence cascade                      │
           │     τ ∝ l^(2/3) where l = eddy scale                                │
           │     Variance creates naturalistic desynchronization                 │
           │                                                                     │
           │  Granule periods: T = 3.0s to 4.5s                                  │
           │     = τ_granule/150 where τ_granule ≈ 600s                          │
           │                                                                     │
           └─────────────────────────────────────────────────────────────────────┘
           
           ┌─────────────────────────────────────────────────────────────────────┐
           │  THE ALCHEMICAL CORRESPONDENCE                                      │
           ├─────────────────────────────────────────────────────────────────────┤
           │                                                                     │
           │  Blake's Sol and the alchemical tradition encode intuitive          │
           │  understanding that CRR now formalizes mathematically:              │
           │                                                                     │
           │     Nigredo (blackening)  → Low C, pre-coherence                    │
           │     Albedo (whitening)    → C accumulating, purification            │
           │     Citrinitas (yellowing)→ C approaching Ω, threshold              │
           │     Rubedo (reddening)    → Rupture and regeneration, gold          │
           │                                                                     │
           │  The photosphere gradient encodes this alchemical sequence:         │
           │     Center (white-gold): Peak coherence / citrinitas                │
           │     Mid (amber-orange): Accumulating / albedo                       │
           │     Edge (deep red): Transformation boundary / rubedo               │
           │                                                                     │
           │  "If the Sun and Moon should doubt, they'd immediately go out."     │
           │     — Blake, Auguries of Innocence                                  │
           │                                                                     │
           │  The sun maintains C ≈ Ω perpetually — the eternal threshold        │
           │  where coherence meets its limit and transformation is continuous.  │
           │                                                                     │
           └─────────────────────────────────────────────────────────────────────┘
           
           ════════════════════════════════════════════════════════════════════════
        */
        
        .crr-sun {
            width: 62px;
            height: 62px;
            margin-right: 18px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .crr-sun-svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }
        
        /* ═══════════════════════════════════════════
           PHOTOSPHERE — The visible surface
           Synchronized with macro CRR cycle
           ═══════════════════════════════════════════ */
        
        .photosphere {
            animation: photospherePulse 6s ease-in-out infinite;
        }
        
        @keyframes photospherePulse {
            0%, 100% { filter: brightness(1) saturate(1); }
            42% { filter: brightness(1.03) saturate(1.05); }
            48% { filter: brightness(1.08) saturate(1.12); }
            55% { filter: brightness(0.97) saturate(0.95); }
        }
        
        /* ═══════════════════════════════════════════
           GRANULATION — Convection cells
           Each granule IS a micro-CRR cycle:
           Rise (C accumulates) → Surface (C=Ω) → Cool/sink (R)
           ═══════════════════════════════════════════ */
        
        .granule {
            animation: granuleLife 4s ease-in-out infinite;
        }
        
        /* Staggered lifecycles - different periods for organic feel */
        .granule-1 { animation-delay: 0s; animation-duration: 3.2s; }
        .granule-2 { animation-delay: -1.1s; animation-duration: 4.1s; }
        .granule-3 { animation-delay: -2.3s; animation-duration: 3.6s; }
        .granule-4 { animation-delay: -0.5s; animation-duration: 4.4s; }
        .granule-5 { animation-delay: -2.8s; animation-duration: 3s; }
        .granule-6 { animation-delay: -1.7s; animation-duration: 3.9s; }
        
        @keyframes granuleLife {
            /* Birth - plasma rising from below */
            0% { 
                opacity: 0.08; 
                transform: scale(0.5) translateY(1px);
                filter: brightness(0.8);
            }
            /* Peak coherence - surface reached, brightest */
            45% { 
                opacity: 0.45; 
                transform: scale(1.15) translateY(-0.5px);
                filter: brightness(1.2);
            }
            /* Rupture - can't rise further */
            55% { 
                opacity: 0.4; 
                transform: scale(1.1) translateY(0);
                filter: brightness(1.1);
            }
            /* Regeneration - cooling, sinking */
            80% { 
                opacity: 0.15; 
                transform: scale(0.7) translateY(0.5px);
                filter: brightness(0.9);
            }
            /* Return to depths */
            100% { 
                opacity: 0.08; 
                transform: scale(0.5) translateY(1px);
                filter: brightness(0.8);
            }
        }
        
        /* ═══════════════════════════════════════════
           CORONA FLAMES — Graceful fire dance
           Real flames: stretch upward, gentle sway, 
           momentary brightening as fuel ignites
           ═══════════════════════════════════════════ */
        
        .corona-ray {
            opacity: 0.88;
            transform-origin: center;
            animation: flameDance 1.2s ease-in-out infinite;
        }
        
        /* Each flame dances to its own rhythm */
        .ray-1 { animation-duration: 1.1s; animation-delay: 0s; }
        .ray-2 { animation-duration: 1.3s; animation-delay: -0.2s; }
        .ray-3 { animation-duration: 1.0s; animation-delay: -0.5s; }
        .ray-4 { animation-duration: 1.25s; animation-delay: -0.15s; }
        .ray-5 { animation-duration: 1.15s; animation-delay: -0.4s; }
        .ray-6 { animation-duration: 1.35s; animation-delay: -0.3s; }
        .ray-7 { animation-duration: 1.05s; animation-delay: -0.55s; }
        .ray-8 { animation-duration: 1.2s; animation-delay: -0.1s; }
        
        @keyframes flameDance {
            0%, 100% { 
                opacity: 0.8;
                filter: brightness(0.95);
            }
            25% { 
                opacity: 0.92;
                filter: brightness(1.08);
            }
            50% { 
                opacity: 0.85;
                filter: brightness(1.0);
            }
            75% { 
                opacity: 0.95;
                filter: brightness(1.12);
            }
        }
        
        /* Secondary flames — gentler dance */
        .corona-ray-minor {
            opacity: 0.5;
            animation: flameDanceMinor 1.5s ease-in-out infinite;
        }
        
        .corona-ray-minor:nth-child(1) { animation-duration: 1.4s; animation-delay: 0s; }
        .corona-ray-minor:nth-child(2) { animation-duration: 1.6s; animation-delay: -0.3s; }
        .corona-ray-minor:nth-child(3) { animation-duration: 1.3s; animation-delay: -0.6s; }
        .corona-ray-minor:nth-child(4) { animation-duration: 1.55s; animation-delay: -0.2s; }
        .corona-ray-minor:nth-child(5) { animation-duration: 1.45s; animation-delay: -0.5s; }
        .corona-ray-minor:nth-child(6) { animation-duration: 1.35s; animation-delay: -0.4s; }
        .corona-ray-minor:nth-child(7) { animation-duration: 1.5s; animation-delay: -0.15s; }
        .corona-ray-minor:nth-child(8) { animation-duration: 1.4s; animation-delay: -0.45s; }
        
        @keyframes flameDanceMinor {
            0%, 100% { 
                opacity: 0.4;
                filter: brightness(0.9);
            }
            50% { 
                opacity: 0.6;
                filter: brightness(1.1);
            }
        }
        
        /* ═══════════════════════════════════════════
           CORONAL LOOP — Magnetic memory arc
           exp(C/Ω) weighting made visible
           Emerges during REGENERATION phase
           ═══════════════════════════════════════════ */
        
        .coronal-loop {
            opacity: 0;
            animation: loopMemory 6s ease-in-out infinite;
        }
        
        @keyframes loopMemory {
            0%, 48% { 
                opacity: 0;
                stroke-dashoffset: 15;
            }
            /* Post-rupture: memory structures emerge */
            55% { 
                opacity: 0.5;
                stroke-dashoffset: 8;
            }
            /* Regeneration peak */
            72% { 
                opacity: 0.75;
                stroke-dashoffset: 0;
            }
            90% { 
                opacity: 0.25;
                stroke-dashoffset: 0;
            }
            100% { 
                opacity: 0;
                stroke-dashoffset: 15;
            }
        }
        
        /* ═══════════════════════════════════════════
           CHROMOSPHERE — The burning edge
           Limb brightens as coherence saturates
           ═══════════════════════════════════════════ */
        
        .chromosphere-ring {
            animation: limbGlow 6s ease-in-out infinite;
        }
        
        @keyframes limbGlow {
            0%, 100% { opacity: 0.25; }
            42% { opacity: 0.4; }
            48% { opacity: 0.7; }
            55% { opacity: 0.35; }
        }
        
        /* ═══════════════════════════════════════════
           SOLAR FLARE — δ(now) rupture event
           The discrete moment C = Ω
           ═══════════════════════════════════════════ */
        
        .solar-flare {
            opacity: 0;
            animation: flareRupture 6s ease-out infinite;
        }
        
        @keyframes flareRupture {
            0%, 44% { 
                opacity: 0; 
                transform: scale(0.5);
            }
            48% { 
                opacity: 0.9; 
                transform: scale(1.12);
            }
            52% { 
                opacity: 0.55; 
                transform: scale(1);
            }
            62% { 
                opacity: 0.15; 
                transform: scale(0.88);
            }
            72%, 100% { 
                opacity: 0; 
                transform: scale(0.6);
            }
        }
        
        /* ═══════════════════════════════════════════
           CORE GLOW — The furnace within
           ═══════════════════════════════════════════ */
        
        .core-glow {
            animation: coreIntensity 6s ease-in-out infinite;
        }
        
        @keyframes coreIntensity {
            0%, 100% { opacity: 0.45; transform: scale(1); }
            42% { opacity: 0.7; transform: scale(1.03); }
            48% { opacity: 0.92; transform: scale(1.08); }
            55% { opacity: 0.55; transform: scale(0.97); }
        }
        
        /* ═══════════════════════════════════════════
           INTERACTIONS
           ═══════════════════════════════════════════ */
        
        .crr-sun:hover .corona-ray {
            animation-duration: 0.6s;
        }
        
        .crr-sun:hover .corona-ray-minor {
            animation-duration: 0.8s;
        }
        
        .crr-sun:hover .solar-flare,
        .crr-sun:hover .coronal-loop,
        .crr-sun:hover .photosphere,
        .crr-sun:hover .core-glow,
        .crr-sun:hover .chromosphere-ring {
            animation-duration: 3s;
        }
        
        .crr-sun:hover .granule {
            animation-duration: 1.8s !important;
        }
        
        .crr-sun:hover .crr-sun-svg {
            filter: drop-shadow(0 0 8px rgba(255, 180, 60, 0.6));
        }
        
        /* Click triggers immediate flare */
        .crr-sun.erupting .solar-flare {
            animation: cmeNow 0.6s ease-out forwards !important;
        }
        
        .crr-sun.erupting .corona-ray {
            animation: flameSurge 0.5s ease-out !important;
        }
        
        .crr-sun.erupting .corona-ray-minor {
            animation: flameSurgeMinor 0.4s ease-out !important;
        }
        
        .crr-sun.erupting .coronal-loop {
            animation: loopFlash 0.8s ease-out forwards !important;
        }
        
        @keyframes cmeNow {
            0% { opacity: 0; transform: scale(0.4); }
            20% { opacity: 1; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(0.65); }
        }
        
        @keyframes flameSurge {
            0% { 
                opacity: 0.88;
                filter: brightness(1); 
            }
            25% { 
                opacity: 1;
                filter: brightness(1.4); 
            }
            100% { 
                opacity: 0.75;
                filter: brightness(0.85); 
            }
        }
        
        @keyframes flameSurgeMinor {
            0% { opacity: 0.5; }
            25% { opacity: 0.85; }
            100% { opacity: 0.4; }
        }
        
        @keyframes loopFlash {
            0% { opacity: 0; stroke-dashoffset: 15; }
            25% { opacity: 1; stroke-dashoffset: 0; }
            100% { opacity: 0; stroke-dashoffset: -10; }
        }
        
        /* ═══════════════════════════════════════════
           REDUCED MOTION
           ═══════════════════════════════════════════ */
        
        @media (prefers-reduced-motion: reduce) {
            .photosphere, .granule, .corona-ray, .corona-ray-minor,
            .solar-flare, .core-glow, .coronal-loop, .chromosphere-ring {
                animation: none !important;
            }
            .corona-ray { opacity: 0.88; filter: brightness(1); }
            .corona-ray-minor { opacity: 0.5; }
            .granule { opacity: 0.25; }
            .coronal-loop { opacity: 0.4; stroke-dashoffset: 0; }
            .chromosphere-ring { opacity: 0.4; }
        }

        .hero-guide-link {
    margin-top: 40px;
    text-align: center;
}
.guide-summary {
    font-family: Georgia, serif;
    font-size: 15px;
    font-style: italic;
    color: #6c757d;
    margin-bottom: 15px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}
.guide-button {
    display: inline-block;
    font-family: Georgia, serif;
    font-size: 16px;
    color: #B8860B;
    text-decoration: none;
    padding: 12px 28px;
    border: 1px solid #D4A012;
    border-radius: 0;
    transition: all 0.3s ease;
}
.guide-button:hover {
    background: rgba(212, 160, 18, 0.12);
    color: #8B4513;
    transform: translateY(-2px);
}
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
            font-family: Georgia, serif;
            line-height: 1.6;
            color: #2c2c2c;
            overflow-x: hidden;
        }

        /* Main Container */
        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 60px;
        }

        /* Header Section */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .title-group {
            display: flex;
            flex-direction: column;
        }

        .site-title {
            font-family: Georgia, serif;
            font-size: 48px;
            font-weight: normal;
            color: #1a1a1a;
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .strapline {
            font-family: Georgia, serif;
            font-size: 18px;
            font-style: italic;
            color: #6c757d;
            letter-spacing: 0.5px;
        }

        /* Navigation System */
        .main-nav {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #495057;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 0;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: rgba(212, 160, 18, 0.12);
            color: #8B4513;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: linear-gradient(135deg, #D4A012 0%, #B8860B 100%);
            color: white;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .nav-item:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        /* Robust Dropdown Menu System */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(180, 120, 40, 0.2);
            border-radius: 0;
            padding: 8px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 1000;
            overflow: hidden;
        }

        /* Critical: No gap between nav item and dropdown */
        .nav-item:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Keep dropdown visible when hovering over dropdown itself */
        .dropdown-menu:hover {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Ensure dropdown stays open during mouse travel */
        .nav-item::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-link {
            display: block;
            padding: 12px 20px;
            color: #495057;
            text-decoration: none;
            font-size: 16px;
            font-family: Georgia, serif;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-link:hover {
            background: rgba(212, 160, 18, 0.1);
            color: #B8860B;
            border-left-color: #D4A012;
        }

        /* Hero Section */
        .hero-section {
            padding: 100px 0 80px;
            text-align: center;
            position: relative;
        }

        .hero-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(212, 160, 18, 0.04) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(184, 134, 11, 0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 1;
        }

        .hero-title {
            font-family: Georgia, serif;
            font-size: 56px;
            font-weight: normal;
            line-height: 1.1;
            margin-bottom: 30px;
            color: #1a1a1a;
            letter-spacing: -1px;
        }

        .hero-subtitle {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            color: #495057;
            margin-bottom: 30px;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .hero-questions {
            max-width: 800px;
            margin: 0 auto;
            text-align: left;
            padding-left: 40px;
        }

        .hero-questions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .hero-questions li {
            font-family: Georgia, serif;
            font-size: 16px;
            font-style: italic;
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 8px;
            position: relative;
            padding-left: 20px;
        }

        .hero-questions li::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #B8860B;
            font-size: 18px;
        }

        /* Content Sections */
        .content-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            position: relative;
        }

        .section-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(248, 249, 250, 0.5) 0%, transparent 100%);
            border-radius: 12px;
            pointer-events: none;
        }

        .section-content {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
        }

        .section-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .section-content p {
            font-family: Georgia, serif;
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 25px;
            text-align: justify;
        }

        .section-content h3 {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin: 35px 0 20px;
            color: #1a1a1a;
        }

        /* Framework Grid */
        .framework-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .framework-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 35px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .framework-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #B8860B, #6c757d);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .framework-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.08);
        }

        .framework-item:hover::before {
            opacity: 1;
        }

        .framework-item h4 {
            font-family: Georgia, serif;
            font-size: 22px;
            font-weight: normal;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        .framework-item p {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #495057;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: left;
        }

        .framework-equation {
            background: rgba(74, 144, 226, 0.05);
            padding: 20px;
            border-left: 3px solid #B8860B;
            border-radius: 4px;
            margin-top: 15px;
            text-align: center;
        }

        .equation-explanation {
            font-family: Georgia, serif;
            font-size: 13px;
            color: #6c757d;
            font-style: italic;
            margin-top: 10px;
            line-height: 1.4;
        }

        /* CRR Demo Section */
        .crr-demo-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        .demo-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
            text-align: center;
        }

        .demo-description {
            text-align: center;
            font-size: 16px;
            color: #6c757d;
            margin-bottom: 40px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

        .demo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .main-canvas-container {
            position: relative;
            width: 100%;
            max-width: 700px;
        }

        .main-canvas {
            width: 100%;
            height: 350px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .demo-metrics {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .metric {
            text-align: center;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            min-width: 140px;
        }

        .metric-label {
            font-family: Georgia, serif;
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .metric-value {
            font-family: Georgia, serif;
            font-size: 24px;
            color: #1a1a1a;
            font-weight: normal;
        }

        .metric-value.coherence { color: #B8860B; }
        .metric-value.omega { color: #6c757d; }
        .metric-value.phase { color: #28a745; }

        .demo-explanation {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            margin-top: 40px;
            max-width: 900px;
        }

        .phase-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .phase-card h4 {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #1a1a1a;
            margin-bottom: 10px;
        }

        .phase-card p {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .phase-card .phase-equation {
            background: rgba(74, 144, 226, 0.05);
            padding: 12px;
            border-left: 3px solid #B8860B;
            border-radius: 4px;
            font-size: 14px;
        }

        .phase-card.active {
            border-color: #B8860B;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.15);
        }

        /* Research Grid */
        .research-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .research-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .research-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: linear-gradient(to right, #B8860B, #6c757d);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .research-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }

        .research-item:hover::before {
            opacity: 1;
        }

        .research-item h4 {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #B8860B;
            margin-bottom: 10px;
        }

        .research-item p {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            text-align: center;
        }

        /* Logo Animation */
        .logo-hive {
            position: relative;
            overflow: visible;
        }

        .logo-bee {
            position: absolute;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .logo-interior {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .logo:hover .logo-interior {
            opacity: 1;
        }

        .logo:hover .logo-bee {
            opacity: 0.3;
        }

        .logo-hive.rupture {
            animation: hiveGlow 3s ease-out;
        }

        @keyframes hiveGlow {
            0% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
            20% { filter: drop-shadow(0 0 20px rgba(74, 144, 226, 0.6)); }
            40% { filter: drop-shadow(0 0 30px rgba(74, 144, 226, 0.4)); }
            70% { filter: drop-shadow(0 0 15px rgba(74, 144, 226, 0.3)); }
            100% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
        }

        /* Footer */
        .footer {
            background: rgba(245, 246, 248, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            padding: 50px 0 40px;
            text-align: center;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .footer-sections {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            margin-bottom: 35px;
            text-align: left;
        }

        .footer-section h4 {
            font-family: Georgia, serif;
            font-size: 14px;
            font-weight: normal;
            font-variant: small-caps;
            letter-spacing: 0.05em;
            color: #1a1a1a;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(184, 134, 11, 0.3);
        }

        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .footer-section li {
            margin-bottom: 10px;
        }

        .footer-section a {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #4a4a4a;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .footer-section a:hover {
            color: #B8860B;
        }

        .footer-section.aliboo h4 {
            color: #B8860B;
        }

        .footer-section.aliboo a {
            color: #6a5a3a;
        }

        .footer-section.aliboo a:hover {
            color: #B8860B;
        }

        .footer-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(184, 134, 11, 0.3), transparent);
            margin: 30px 0;
        }

        .footer-repo-note {
            font-family: Georgia, serif;
            font-size: 13px;
            color: #6c757d;
            font-style: italic;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto 25px;
        }

        .footer-author {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #4a4a4a;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .footer-author a {
            color: #B8860B;
            text-decoration: none;
        }

        .footer-author a:hover {
            text-decoration: underline;
        }

        .footer-tech-note {
            font-family: Georgia, serif;
            font-size: 12px;
            color: #8c8c8c;
            font-style: italic;
            line-height: 1.4;
        }

        .sitemap-header {
            font-family: Georgia, serif;
            font-size: 16px;
            font-style: italic;
            color: #5a5a5a;
            margin: 30px 0 20px;
            text-align: center;
        }

        .anthill-container {
            background: linear-gradient(180deg, #7a6548 0%, #5c4a35 8%, #4a3728 25%, #3d2a1a 60%, #2e1f12 100%);
            border-radius: 0;
            padding: 0;
            margin: 20px auto 30px;
            max-width: 950px;
            height: 420px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.3);
            box-shadow: inset 0 0 60px rgba(0,0,0,0.5), 0 4px 20px rgba(0,0,0,0.3);
        }

        .anthill-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .colony-stats {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-family: Georgia, serif;
            font-size: 10px;
            color: rgba(255, 248, 220, 0.6);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        @media (max-width: 768px) {
            .anthill-container {
                height: 380px;
            }
        }

        @media (max-width: 768px) {
            .footer-sections {
                grid-template-columns: 1fr;
                gap: 30px;
                text-align: center;
            }
            
            .footer-section h4 {
                border-bottom: none;
                padding-bottom: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .demo-explanation {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .framework-grid {
                grid-template-columns: 1fr;
            }

            .research-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .page-container {
                padding: 0 30px;
            }

            .header {
                flex-direction: column;
                gap: 30px;
                text-align: center;
                padding: 30px 0;
            }

            .logo-section {
                flex-direction: column;
                gap: 15px;
            }

            .logo {
                margin-right: 0;
            }

            .site-title {
                font-size: 36px;
            }

            .main-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            .dropdown-menu {
                position: static;
                opacity: 1;
                visibility: visible;
                transform: none;
                box-shadow: none;
                border: none;
                background: rgba(212, 160, 18, 0.08);
                margin-top: 10px;
                border-radius: 0;
                display: none;
            }

            .nav-item:hover .dropdown-menu {
                display: block;
            }

            .hero-section {
                padding: 60px 0 40px;
            }

            .hero-title {
                font-size: 42px;
            }

            .hero-subtitle {
                font-size: 20px;
            }

            .hero-questions {
                padding-left: 20px;
            }

            .hero-questions li {
                font-size: 14px;
            }

            .content-section,
            .crr-demo-section {
                padding: 40px 25px;
                margin: 60px 0;
            }

            .section-title {
                font-size: 28px;
            }

            .research-grid {
                grid-template-columns: 1fr;
            }

            .demo-metrics {
                gap: 15px;
            }

            .metric {
                min-width: 100px;
                padding: 12px 15px;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header class="header">
            <div class="logo-section">
                <!-- ☉ THE ALCHEMICAL SUN — Blake's Vision in CRR ☉ -->
                <div class="crr-sun" id="crrSun" title="Sol Invictus — The Alchemical Furnace">
                    <svg class="crr-sun-svg" viewBox="0 0 52 52" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <!-- Plasma turbulence for photorealistic texture -->
                            <filter id="plasmaTurbulence" x="-20%" y="-20%" width="140%" height="140%">
                                <feTurbulence type="fractalNoise" baseFrequency="0.08" numOctaves="3" seed="42" result="noise"/>
                                <feDisplacementMap in="SourceGraphic" in2="noise" scale="1.5" xChannelSelector="R" yChannelSelector="G"/>
                            </filter>
                            
                            <!-- Soft glow for corona -->
                            <filter id="coronaGlow" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="1" result="blur"/>
                                <feMerge>
                                    <feMergeNode in="blur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                            
                            <!-- Flare bloom -->
                            <filter id="flareBloom" x="-100%" y="-100%" width="300%" height="300%">
                                <feGaussianBlur stdDeviation="2" result="blur"/>
                                <feComposite in="SourceGraphic" in2="blur" operator="over"/>
                            </filter>
                            
                            <!-- ═══ ALCHEMICAL GRADIENTS ═══ -->
                            
                            <!-- Photosphere: Citrinitas to Rubedo (yellow gold to deep red) -->
                            <radialGradient id="photosphereGrad" cx="35%" cy="35%" r="60%">
                                <stop offset="0%" stop-color="#FFFDE7"/>
                                <stop offset="20%" stop-color="#FFE082"/>
                                <stop offset="45%" stop-color="#FFB300"/>
                                <stop offset="70%" stop-color="#E65100"/>
                                <stop offset="90%" stop-color="#BF360C"/>
                                <stop offset="100%" stop-color="#8D1F09"/>
                            </radialGradient>
                            
                            <!-- Limb darkening overlay -->
                            <radialGradient id="limbDarkening" cx="50%" cy="50%" r="50%">
                                <stop offset="0%" stop-color="transparent"/>
                                <stop offset="60%" stop-color="transparent"/>
                                <stop offset="85%" stop-color="rgba(139, 31, 9, 0.3)"/>
                                <stop offset="100%" stop-color="rgba(89, 20, 5, 0.5)"/>
                            </radialGradient>
                            
                            <!-- Corona ray gradient -->
                            <linearGradient id="coronaGrad" x1="50%" y1="100%" x2="50%" y2="0%">
                                <stop offset="0%" stop-color="#FFB300"/>
                                <stop offset="30%" stop-color="#FF8F00"/>
                                <stop offset="60%" stop-color="#E65100"/>
                                <stop offset="100%" stop-color="#BF360C" stop-opacity="0.4"/>
                            </linearGradient>
                            
                            <!-- Secondary ray gradient -->
                            <linearGradient id="coronaGradSoft" x1="50%" y1="100%" x2="50%" y2="0%">
                                <stop offset="0%" stop-color="#FFCA28" stop-opacity="0.8"/>
                                <stop offset="50%" stop-color="#FF9800" stop-opacity="0.5"/>
                                <stop offset="100%" stop-color="#E65100" stop-opacity="0.2"/>
                            </linearGradient>
                            
                            <!-- Chromosphere glow -->
                            <radialGradient id="chromosphereGrad" cx="50%" cy="50%" r="55%">
                                <stop offset="70%" stop-color="transparent"/>
                                <stop offset="85%" stop-color="rgba(255, 138, 101, 0.4)"/>
                                <stop offset="100%" stop-color="rgba(255, 87, 34, 0.2)"/>
                            </radialGradient>
                            
                            <!-- Flare gradient -->
                            <radialGradient id="flareGrad" cx="50%" cy="50%" r="50%">
                                <stop offset="0%" stop-color="#FFFFFF"/>
                                <stop offset="30%" stop-color="#FFF9C4"/>
                                <stop offset="70%" stop-color="#FFE082" stop-opacity="0.6"/>
                                <stop offset="100%" stop-color="#FFB300" stop-opacity="0"/>
                            </radialGradient>
                            
                            <!-- Core furnace glow -->
                            <radialGradient id="coreGlow" cx="50%" cy="50%" r="40%">
                                <stop offset="0%" stop-color="#FFFFFF" stop-opacity="0.9"/>
                                <stop offset="50%" stop-color="#FFF59D" stop-opacity="0.5"/>
                                <stop offset="100%" stop-color="#FFE082" stop-opacity="0"/>
                            </radialGradient>
                            
                        </defs>
                        
                        <!-- ═══ CORONA FLAMES — Living fire ═══ -->
                        <!-- Major flames (8) - organic curved shapes -->
                        <g filter="url(#coronaGlow)">
                            <!-- N (top) - flame licks upward -->
                            <path class="corona-ray ray-1" fill="url(#coronaGrad)" 
                                  d="M26 3 Q28 8 28.5 13 Q27 15.5 26 16 Q25 15.5 23.5 13 Q24 8 26 3"/>
                            <!-- NE -->
                            <path class="corona-ray ray-2" fill="url(#coronaGrad)" 
                                  d="M42 10 Q38 13 34 18 Q33 17 33 16.5 Q34.5 15 35 14 Q37 11 42 10"/>
                            <!-- E (right) -->
                            <path class="corona-ray ray-3" fill="url(#coronaGrad)" 
                                  d="M49 26 Q44 24 38 23.5 Q36.5 25 36 26 Q36.5 27 38 28.5 Q44 28 49 26"/>
                            <!-- SE -->
                            <path class="corona-ray ray-4" fill="url(#coronaGrad)" 
                                  d="M42 42 Q38 39 34 34 Q33 35 33 35.5 Q34.5 37 35 38 Q37 41 42 42"/>
                            <!-- S (bottom) -->
                            <path class="corona-ray ray-5" fill="url(#coronaGrad)" 
                                  d="M26 49 Q24 44 23.5 39 Q25 36.5 26 36 Q27 36.5 28.5 39 Q28 44 26 49"/>
                            <!-- SW -->
                            <path class="corona-ray ray-6" fill="url(#coronaGrad)" 
                                  d="M10 42 Q14 39 18 34 Q19 35 19 35.5 Q17.5 37 17 38 Q15 41 10 42"/>
                            <!-- W (left) -->
                            <path class="corona-ray ray-7" fill="url(#coronaGrad)" 
                                  d="M3 26 Q8 24 14 23.5 Q15.5 25 16 26 Q15.5 27 14 28.5 Q8 28 3 26"/>
                            <!-- NW -->
                            <path class="corona-ray ray-8" fill="url(#coronaGrad)" 
                                  d="M10 10 Q14 13 18 18 Q19 17 19 16.5 Q17.5 15 17 14 Q15 11 10 10"/>
                        </g>
                        
                        <!-- Minor flames (8) - smaller, between major flames -->
                        <g>
                            <!-- NNE -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M31 6 Q30 10 29 14 Q28 15 27.5 15.5 Q28 14 28.5 12 Q29.5 9 31 6"/>
                            <!-- ENE -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M46 21 Q42 22 38 23 Q37 24 36.5 23.5 Q38 23 39 22 Q42 20.5 46 21"/>
                            <!-- ESE -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M46 31 Q42 30 38 29 Q37 28 36.5 28.5 Q38 29 39 30 Q42 31.5 46 31"/>
                            <!-- SSE -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M31 46 Q30 42 29 38 Q28 37 27.5 36.5 Q28 38 28.5 40 Q29.5 43 31 46"/>
                            <!-- SSW -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M21 46 Q22 42 23 38 Q24 37 24.5 36.5 Q24 38 23.5 40 Q22.5 43 21 46"/>
                            <!-- WSW -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M6 31 Q10 30 14 29 Q15 28 15.5 28.5 Q14 29 13 30 Q10 31.5 6 31"/>
                            <!-- WNW -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M6 21 Q10 22 14 23 Q15 24 15.5 23.5 Q14 23 13 22 Q10 20.5 6 21"/>
                            <!-- NNW -->
                            <path class="corona-ray-minor" fill="url(#coronaGradSoft)" 
                                  d="M21 6 Q22 10 23 14 Q24 15 24.5 15.5 Q24 14 23.5 12 Q22.5 9 21 6"/>
                        </g>
                        
                        <!-- ═══ CHROMOSPHERE — Atmospheric glow ═══ -->
                        <circle cx="26" cy="26" r="11" fill="url(#chromosphereGrad)"/>
                        
                        <!-- Chromosphere edge ring - brightens at rupture -->
                        <circle class="chromosphere-ring" cx="26" cy="26" r="10.5" 
                                fill="none" stroke="rgba(255, 120, 60, 0.4)" stroke-width="0.8"/>
                        
                        <!-- ═══ PHOTOSPHERE — The visible surface ═══ -->
                        <g class="photosphere">
                            <!-- Main solar disk with limb darkening -->
                            <circle cx="26" cy="26" r="10" fill="url(#photosphereGrad)"/>
                            <circle cx="26" cy="26" r="10" fill="url(#limbDarkening)"/>
                        </g>
                        
                        <!-- ═══ GRANULATION — Convection cells (micro-CRR) ═══ -->
                        <g>
                            <circle class="granule granule-1" cx="23" cy="24" r="1.6" fill="rgba(255, 248, 210, 0.5)"/>
                            <circle class="granule granule-2" cx="28" cy="25" r="1.3" fill="rgba(255, 245, 195, 0.45)"/>
                            <circle class="granule granule-3" cx="25" cy="28" r="1.4" fill="rgba(255, 242, 180, 0.4)"/>
                            <circle class="granule granule-4" cx="29" cy="28" r="1.1" fill="rgba(255, 248, 200, 0.45)"/>
                            <circle class="granule granule-5" cx="24" cy="22" r="1" fill="rgba(255, 252, 220, 0.5)"/>
                            <circle class="granule granule-6" cx="27" cy="22" r="0.9" fill="rgba(255, 250, 215, 0.42)"/>
                        </g>
                        
                        <!-- ═══ CORONAL LOOP — Magnetic memory arc exp(C/Ω) ═══ -->
                        <path class="coronal-loop" 
                              d="M20 22 Q16 26 20 30" 
                              fill="none" 
                              stroke="rgba(255, 180, 100, 0.8)" 
                              stroke-width="1"
                              stroke-linecap="round"
                              stroke-dasharray="15 5"/>
                        
                        <!-- Second loop - opposite side, slight delay -->
                        <path class="coronal-loop" 
                              d="M32 23 Q36 26 32 29" 
                              fill="none" 
                              stroke="rgba(255, 160, 80, 0.7)" 
                              stroke-width="0.8"
                              stroke-linecap="round"
                              stroke-dasharray="12 4"
                              style="animation-delay: -1s;"/>
                        
                        <!-- ═══ SOLAR FLARE — δ(now) rupture event ═══ -->
                        <circle class="solar-flare" cx="26" cy="26" r="12" fill="url(#flareGrad)" filter="url(#flareBloom)"/>
                        
                        <!-- ═══ CORE GLOW — The inner furnace ═══ -->
                        <circle class="core-glow" cx="26" cy="26" r="4" fill="url(#coreGlow)"/>
                        
                        <!-- ═══ SPECULAR HIGHLIGHT — Divine light ═══ -->
                        <ellipse cx="23" cy="23" rx="2" ry="1.5" fill="rgba(255, 255, 255, 0.35)" transform="rotate(-30 23 23)"/>
                    </svg>
                </div>
               
                <div class="title-group">
                    <h1 class="site-title">CRR</h1>
                    <p class="strapline">A Temporal Grammar</p>
                </div>
            </div>

            <nav class="main-nav">
                <div class="nav-item">
                    <a href="index.html" class="nav-link active">Home</a>
                </div>
                <div class="nav-item">
                    <a href="crr-simulations.html" class="nav-link">
                        CRR Simulations
                        <span class="dropdown-arrow">▼</span>
                    </a>
                    <div class="dropdown-menu">
                        <a href="biological-systems.html" class="dropdown-link">Biological Systems</a>
                        <a href="physical-systems.html" class="dropdown-link">Physical Systems</a>
                        <a href="mathematical-life.html" class="dropdown-link">Mathematical Life</a>
                    </div>
                </div>
                <div class="nav-item">
                    <a href="crr-benchmarks.html" class="nav-link">CRR Benchmarks</a>
                </div>
                <div class="nav-item">
                    <a href="crr-explained.html" class="nav-link">CRR Explained</a>
                </div>
                <div class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </div>
            </nav>
        </header>

        <main>
            <section class="hero-section">
                <div class="hero-background"></div>
                <div class="hero-content">
                    <h2 class="hero-title">Coherence, Rupture, Regeneration</h2>
                    <p class="hero-subtitle">A coarse-grain mathematical framework for exploring transformation, and renewal in complex systems</p>
                    <div class="hero-questions">
                        <ul>
                            <li>How do complex systems maintain identity by processually changing through the Active Inference cycle?</li>
                            <li>How might shared phenomenological and mathematical languages help us better understand intelligence in a shared context?</li>
                            <li>How might we better understand and adapt to the psychological, sociological and ecological impacts of Technology on human and non-human species?</li>
                            <li>How might a minimal mathematical grammar of temporality help us to address contemporary issues of AI alignment, Emergent Capacities and Catastrophic Forgetting?</li>
                        </ul>
                    </div>
                </div>
            </section>
<div class="hero-guide-link">
    <p class="guide-summary">Explore CRR dynamics through interactive simulations spanning human development, attachment, cognition, contemplative practice, creativity, and AI safety.</p>
    <a href="guide.html" class="guide-button">Interactive Guide →</a>
</div>
            <section class="crr-demo-section" id="crrDemoSection">
                <style>
                    /* CRR Demo Specific Styles */
                    .crr-demo-section {
                        margin: 80px 0;
                        padding: 40px;
                        background: rgba(255, 255, 255, 0.95);
                        border: 1px solid rgba(212, 160, 18, 0.2);
                        border-radius: 0;
                    }
                    
                    .demo-title {
                        font-family: Georgia, serif;
                        font-size: 32px;
                        font-weight: normal;
                        margin-bottom: 8px;
                        color: #1a1a1a;
                        text-align: center;
                    }
                    
                    .demo-subtitle {
                        font-family: Georgia, serif;
                        font-size: 16px;
                        font-style: italic;
                        color: #666;
                        text-align: center;
                        margin-bottom: 25px;
                    }
                    
                    .demo-layout {
                        display: grid;
                        grid-template-columns: 1fr 340px;
                        gap: 20px;
                    }
                    
                    @media (max-width: 900px) {
                        .demo-layout { grid-template-columns: 1fr; }
                    }
                    
                    .stage-container {
                        background: #faf8f4;
                        border: 1px solid #d4d0c8;
                        border-radius: 4px;
                        overflow: hidden;
                    }
                    
                    .stage-header {
                        padding: 10px 15px;
                        background: #f4f1ea;
                        border-bottom: 1px solid #d4d0c8;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }
                    
                    .stage-title-text {
                        font-family: Georgia, serif;
                        font-size: 14px;
                        font-weight: 500;
                        color: #1a1a1a;
                    }
                    
                    .auto-badge {
                        font-size: 11px;
                        padding: 3px 8px;
                        background: #234e70;
                        color: white;
                        border-radius: 3px;
                        font-family: Georgia, serif;
                    }
                    
                    #demoCanvas {
                        display: block;
                        width: 100%;
                        height: 380px;
                        cursor: default;
                    }
                    
                    .canvas-wrapper {
                        position: relative;
                    }
                    
                    .agent-speech {
                        position: absolute;
                        background: rgba(255, 255, 255, 0.95);
                        color: #333;
                        font: 13px Georgia, serif;
                        font-style: italic;
                        padding: 8px 12px;
                        border-radius: 12px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.15);
                        max-width: 160px;
                        opacity: 0;
                        transition: opacity 0.3s;
                        pointer-events: none;
                        z-index: 100;
                    }
                    
                    .agent-speech.visible { opacity: 1; }
                    
                    .agent-speech::after {
                        content: '';
                        position: absolute;
                        bottom: -8px;
                        left: 20px;
                        border-width: 8px 6px 0 6px;
                        border-style: solid;
                        border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
                    }
                    
                    /* Commentary Panel */
                    .commentary-panel {
                        background: #fff;
                        border: 1px solid #d4d0c8;
                        border-radius: 4px;
                        display: flex;
                        flex-direction: column;
                        max-height: 440px;
                        overflow: hidden;
                    }
                    
                    .commentary-header {
                        padding: 10px 15px;
                        background: #f4f1ea;
                        border-bottom: 1px solid #d4d0c8;
                        font-family: Georgia, serif;
                        font-weight: 500;
                        font-size: 14px;
                    }
                    
                    .commentary-content {
                        flex: 1;
                        padding: 12px;
                        overflow-y: auto;
                        font-family: Georgia, serif;
                    }
                    
                    /* CRR Display */
                    .crr-display {
                        background: linear-gradient(135deg, #f3e5f5, #ede7f6);
                        border: 1px solid #6a1b9a;
                        padding: 10px;
                        margin-bottom: 10px;
                        border-radius: 4px;
                    }
                    
                    .crr-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 8px;
                    }
                    
                    .crr-title {
                        font-size: 11px;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        color: #6a1b9a;
                        font-weight: 600;
                    }
                    
                    .crr-stage-badge {
                        font-size: 10px;
                        padding: 2px 8px;
                        background: #6a1b9a;
                        color: white;
                        border-radius: 2px;
                    }
                    
                    .crr-stage-badge.rupture {
                        background: #d32f2f;
                        animation: rupturePulse 0.3s infinite;
                    }
                    
                    .crr-stage-badge.regeneration {
                        background: #2e7d32;
                    }
                    
                    @keyframes rupturePulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.6; }
                    }
                    
                    .coherence-container { margin-bottom: 6px; }
                    
                    .coherence-label {
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        margin-bottom: 4px;
                        color: #333;
                    }
                    
                    .coherence-bar {
                        height: 10px;
                        background: rgba(255,255,255,0.8);
                        border: 1px solid rgba(106,27,154,0.3);
                        position: relative;
                        overflow: hidden;
                        border-radius: 2px;
                    }
                    
                    .coherence-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #7b1fa2, #9c27b0, #ab47bc);
                        transition: width 0.4s ease-out;
                    }
                    
                    .coherence-fill.critical {
                        background: linear-gradient(90deg, #c62828, #d32f2f, #e53935);
                        animation: criticalPulse 0.5s infinite;
                    }
                    
                    @keyframes criticalPulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.7; }
                    }
                    
                    .omega-marker {
                        position: absolute;
                        right: 0;
                        top: -2px;
                        bottom: -2px;
                        width: 2px;
                        background: #d32f2f;
                    }
                    
                    .crr-math {
                        font-size: 11px;
                        color: #6a1b9a;
                        font-style: italic;
                        text-align: center;
                        padding-top: 6px;
                        border-top: 1px solid rgba(106,27,154,0.2);
                    }
                    
                    .stage-dots {
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        margin-top: 8px;
                        padding-top: 8px;
                        border-top: 1px solid rgba(106,27,154,0.2);
                    }
                    
                    .stage-dot-container {
                        display: flex;
                        gap: 4px;
                    }
                    
                    .stage-dot {
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: rgba(106,27,154,0.2);
                    }
                    
                    .stage-dot.completed { background: #6a1b9a; }
                    .stage-dot.current { background: #6a1b9a; animation: dotPulse 1s infinite; }
                    
                    @keyframes dotPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.3); }
                    }
                    
                    .stage-name {
                        font-size: 12px;
                        color: #6a1b9a;
                        font-style: italic;
                    }
                    
                    /* Dynamics Display */
                    .dynamics-display {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 8px;
                        margin-bottom: 10px;
                    }
                    
                    .dynamics-bar-container {
                        padding: 8px;
                        border: 1px solid #d4d0c8;
                        background: #fff;
                        border-radius: 3px;
                    }
                    
                    .dynamics-bar-container.fep { border-left: 3px solid #234e70; }
                    .dynamics-bar-container.crr-work { border-left: 3px solid #6a1b9a; }
                    
                    .dynamics-label {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 4px;
                    }
                    
                    .dynamics-title {
                        font-size: 10px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        font-weight: 600;
                    }
                    
                    .dynamics-bar-container.fep .dynamics-title { color: #234e70; }
                    .dynamics-bar-container.crr-work .dynamics-title { color: #6a1b9a; }
                    
                    .dynamics-value {
                        font-size: 11px;
                        font-style: italic;
                    }
                    
                    .dynamics-bar {
                        height: 6px;
                        background: #f4f1ea;
                        border: 1px solid #d4d0c8;
                        overflow: hidden;
                        border-radius: 2px;
                    }
                    
                    .dynamics-fill {
                        height: 100%;
                        transition: width 0.4s ease-out;
                    }
                    
                    .dynamics-bar-container.fep .dynamics-fill {
                        background: linear-gradient(90deg, #1565c0, #1e88e5, #42a5f5);
                    }
                    
                    .dynamics-bar-container.crr-work .dynamics-fill {
                        background: linear-gradient(90deg, #7b1fa2, #9c27b0, #ba68c8);
                    }
                    
                    .dynamics-subtext {
                        font-size: 9px;
                        color: #888;
                        font-style: italic;
                        margin-top: 3px;
                    }
                    
                    /* Status */
                    .status-indicator {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        margin-bottom: 10px;
                        padding: 8px 10px;
                        background: #f4f1ea;
                        border: 1px solid #d4d0c8;
                        border-radius: 3px;
                    }
                    
                    .status-dot {
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: #999;
                    }
                    
                    .status-dot.idle { background: #999; }
                    .status-dot.exploring { background: #ff9800; animation: statusPulse 1s infinite; }
                    .status-dot.surprise { background: #c62828; animation: statusPulse 0.5s infinite; }
                    .status-dot.learning { background: #234e70; animation: statusPulse 0.8s infinite; }
                    
                    @keyframes statusPulse {
                        0%, 100% { opacity: 1; transform: scale(1); }
                        50% { opacity: 0.6; transform: scale(1.2); }
                    }
                    
                    .status-text {
                        font-size: 12px;
                        color: #666;
                        font-style: italic;
                    }
                    
                    /* Commentary */
                    .commentary-text {
                        font-size: 13px;
                        line-height: 1.6;
                        margin-bottom: 10px;
                        color: #333;
                    }
                    
                    /* Framework Comparison */
                    .framework-comparison {
                        display: none;
                        grid-template-columns: 1fr 1fr 1fr;
                        gap: 6px;
                        margin-top: 10px;
                    }
                    
                    .framework-comparison.visible { display: grid; }
                    
                    .framework-box {
                        padding: 8px;
                        font-size: 12px;
                        border-left: 3px solid;
                        border-radius: 2px;
                    }
                    
                    .framework-box.piaget { background: #f5ebe0; border-left-color: #8b4513; }
                    .framework-box.fep { background: #e8f0f5; border-left-color: #234e70; }
                    .framework-box.crr { background: #f3e5f5; border-left-color: #6a1b9a; }
                    
                    .framework-label {
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        font-weight: 600;
                        margin-bottom: 2px;
                    }
                    
                    .piaget .framework-label { color: #8b4513; }
                    .fep .framework-label { color: #234e70; }
                    .crr .framework-label { color: #6a1b9a; }
                    
                    .framework-term {
                        font-weight: 600;
                        font-size: 12px;
                        font-style: italic;
                    }
                    
                    .framework-desc {
                        color: #666;
                        font-size: 10px;
                        margin-top: 2px;
                    }
                    
                    /* Prediction/Error */
                    .prediction-display {
                        display: none;
                        margin-top: 8px;
                        padding: 8px;
                        background: #fff8e1;
                        border: 1px solid #ffca28;
                        font-size: 12px;
                        border-radius: 3px;
                    }
                    
                    .prediction-display.visible { display: block; }
                    
                    .prediction-title {
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        color: #f57f17;
                        margin-bottom: 4px;
                        font-weight: 600;
                    }
                    
                    .error-display {
                        display: none;
                        margin-top: 6px;
                        padding: 8px;
                        background: #ffebee;
                        border: 1px solid #c62828;
                        font-size: 12px;
                        border-radius: 3px;
                    }
                    
                    .error-display.visible { display: block; }
                    .error-display.low-error { background: #e8f5e9; border-color: #2e7d32; }
                    
                    .error-title {
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        color: #c62828;
                        margin-bottom: 4px;
                        font-weight: 600;
                    }
                    
                    .error-display.low-error .error-title { color: #2e7d32; }
                    
                    /* Math note */
                    .math-note {
                        display: none;
                        background: #2c2c2c;
                        color: #e0e0e0;
                        padding: 8px 10px;
                        font-size: 11px;
                        font-style: italic;
                        margin-top: 8px;
                        border-left: 3px solid #666;
                        border-radius: 2px;
                    }
                    
                    .math-note.visible { display: block; }
                    
                    .math-note .label {
                        color: #aaa;
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        display: block;
                        margin-bottom: 3px;
                        font-style: normal;
                    }
                    
                    /* Beliefs */
                    .model-display {
                        background: #f4f1ea;
                        border: 1px solid #d4d0c8;
                        padding: 10px;
                        margin-top: 10px;
                        border-radius: 3px;
                    }
                    
                    .model-title {
                        font-size: 10px;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        color: #666;
                        margin-bottom: 8px;
                    }
                    
                    .belief-item {
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        margin-bottom: 4px;
                        padding: 5px 8px;
                        background: #fff;
                        border: 1px solid #d4d0c8;
                        font-size: 11px;
                        border-radius: 2px;
                    }
                    
                    .belief-item.new { background: #e8f5e9; border-color: #2e7d32; }
                    
                    .belief-icon {
                        width: 18px;
                        height: 18px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                    }
                    
                    .belief-text { flex: 1; }
                    .belief-name { font-weight: 500; font-size: 11px; }
                    .belief-details { font-size: 9px; color: #666; font-style: italic; }
                    
                    .confidence-bar {
                        width: 25px;
                        height: 3px;
                        background: #d4d0c8;
                        border-radius: 1px;
                    }
                    
                    .confidence-fill {
                        height: 100%;
                        background: #2e7d32;
                        transition: width 0.4s;
                        border-radius: 1px;
                    }
                    
                    /* Rupture overlay */
                    .rupture-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(211,47,47,0);
                        pointer-events: none;
                        z-index: 1000;
                    }
                    
                    .rupture-overlay.active {
                        animation: ruptureFlash 2s ease-out;
                    }
                    
                    @keyframes ruptureFlash {
                        0% { background: rgba(211,47,47,0); }
                        10% { background: rgba(211,47,47,0.3); }
                        30% { background: rgba(211,47,47,0.15); }
                        50% { background: rgba(106,27,154,0.2); }
                        100% { background: rgba(106,27,154,0); }
                    }
                </style>
                
                <div class="rupture-overlay" id="ruptureOverlay"></div>
                
                <h2 class="demo-title">Active Inference & CRR in Action</h2>
                <p class="demo-subtitle">Learning through coherence, rupture, and regeneration — watch the agent explore automatically</p>
                
                <div class="demo-layout">
                    <div class="stage-container">
                        <div class="stage-header">
                            <span class="stage-title-text">The Agent's World</span>
                            <span class="auto-badge">Auto-exploring</span>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="demoCanvas"></canvas>
                            <div class="agent-speech" id="agentSpeech"></div>
                        </div>
                    </div>
                    
                    <div class="commentary-panel">
                        <div class="commentary-header">Understanding the Process</div>
                        <div class="commentary-content">
                            <div class="crr-display">
                                <div class="crr-header">
                                    <span class="crr-title">Coherence C(t) = ∫L(τ)dτ</span>
                                    <span class="crr-stage-badge" id="crrStage">Coherence</span>
                                </div>
                                <div class="coherence-container">
                                    <div class="coherence-label">
                                        <span>C(t) = <span id="coherenceValue">0.000</span></span>
                                        <span>Ω = <span id="omegaValue">1.00</span></span>
                                    </div>
                                    <div class="coherence-bar">
                                        <div class="coherence-fill" id="coherenceFill" style="width: 0%"></div>
                                        <div class="omega-marker"></div>
                                    </div>
                                </div>
                                <div class="crr-math" id="crrMath">C(t) = ∫L(τ)dτ — cumulative adaptive work</div>
                                <div class="stage-dots">
                                    <div class="stage-dot-container">
                                        <div class="stage-dot current" id="stageDot1"></div>
                                        <div class="stage-dot" id="stageDot2"></div>
                                        <div class="stage-dot" id="stageDot3"></div>
                                        <div class="stage-dot" id="stageDot4"></div>
                                        <div class="stage-dot" id="stageDot5"></div>
                                    </div>
                                    <span class="stage-name" id="stageName">Stage I: Simple Forms</span>
                                </div>
                            </div>
                            
                            <div class="dynamics-display">
                                <div class="dynamics-bar-container fep">
                                    <div class="dynamics-label">
                                        <span class="dynamics-title">Free Energy F</span>
                                        <span class="dynamics-value" id="vfeValue">F = 1.00</span>
                                    </div>
                                    <div class="dynamics-bar">
                                        <div class="dynamics-fill" id="vfeFill" style="width: 100%"></div>
                                    </div>
                                    <div class="dynamics-subtext">↓ reduced by learning</div>
                                </div>
                                <div class="dynamics-bar-container crr-work">
                                    <div class="dynamics-label">
                                        <span class="dynamics-title">Near-time C<sub>Δ</sub></span>
                                        <span class="dynamics-value" id="accumWorkValue">C_Δ = 0.000</span>
                                    </div>
                                    <div class="dynamics-bar">
                                        <div class="dynamics-fill" id="accumWorkFill" style="width: 0%"></div>
                                    </div>
                                    <div class="dynamics-subtext">↑ recent adaptive load</div>
                                </div>
                            </div>
                            
                            <div class="status-indicator">
                                <div class="status-dot idle" id="statusDot"></div>
                                <span class="status-text" id="statusText">Agent exploring automatically...</span>
                            </div>
                            
                            <div id="commentaryText" class="commentary-text">
                                This agent learns through <em>Active Inference</em> (minimising free energy F) and <em>CRR</em> (cumulative adaptive work C toward capacity Ω). Key insight: <strong>larger errors = more work = faster coherence growth</strong>.
                            </div>
                            
                            <div class="framework-comparison" id="frameworkComparison">
                                <div class="framework-box piaget">
                                    <div class="framework-label">Piaget</div>
                                    <div class="framework-term" id="piagetTerm">—</div>
                                    <div class="framework-desc" id="piagetDesc"></div>
                                </div>
                                <div class="framework-box fep">
                                    <div class="framework-label">Active Inference</div>
                                    <div class="framework-term" id="fepTerm">—</div>
                                    <div class="framework-desc" id="fepDesc"></div>
                                </div>
                                <div class="framework-box crr">
                                    <div class="framework-label">CRR</div>
                                    <div class="framework-term" id="crrTerm">—</div>
                                    <div class="framework-desc" id="crrDesc"></div>
                                </div>
                            </div>
                            
                            <div class="prediction-display" id="predictionDisplay">
                                <div class="prediction-title">Agent's Prediction</div>
                                <div id="predictionContent"></div>
                            </div>
                            
                            <div class="error-display" id="errorDisplay">
                                <div class="error-title">Prediction Error</div>
                                <div id="errorContent"></div>
                            </div>
                            
                            <div class="math-note" id="mathNote">
                                <span class="label">Formal notation</span>
                                <span id="mathContent"></span>
                            </div>
                            
                            <div class="model-display">
                                <div class="model-title">Agent's Generative Model</div>
                                <div id="beliefsList"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">What is CRR?</h2>
                <div class="section-content">
                    <p>CRR formalises how systems accumulate history (Coherence), undergo discrete phase transitions when constraints reach threshold (Rupture), and reconstitute through exponentially-weighted memory selection (Regeneration). Grounded in process philosophy, CRR describes temporal structure as a mathematical grammar by which past becomes future across all scales.</p>

                    <div class="framework-grid">
                        <div class="framework-item">
                            <h4>Coherence</h4>
                            <p>How systems accumulate historical constraint over time. Coherence represents the temporal integration of structure; the past becoming present as accumulated pattern. When coherence reaches threshold (C=Ω), the system can no longer assimilate prediction error, triggering rupture.</p>
                            <div class="framework-equation">
                                $$C(x,t) = \int_0^t L(x,\tau) \, d\tau$$
                                <div class="equation-explanation">
                                    Where L(x,τ) represents information density accumulated at position x over time τ
                                </div>
                            </div>
                        </div>
                        <div class="framework-item">
                            <h4>Rupture</h4>
                            <p>The Dirac delta encodes the dimensionless present—the scale-free moment where C=Ω and phase transition occurs. At rupture, local coherence resets while historical coherence values remain accessible through the regeneration integral, enabling continuity through discontinuity.</p>
                            <div class="framework-equation">
                                $$\delta(t-t_0)$$
                                <div class="equation-explanation">
                                    A Dirac delta function encoding sudden disruptions at time t-zero when C=Omega (Markov Blanket saturation)
                                </div>
                            </div>
                        </div>
                        <div class="framework-item">
                            <h4>Regeneration</h4>
                            <p>The reconstruction process that builds new stable patterns by drawing upon accumulated historical information. Crucially, history is never lost, only selectively weighted. The exponential term exp(C/Ω) determines which past moments reconstitute, enabling continuity through transformation.</p>
                            <div class="framework-equation">
                                $$R[\chi](x,t) = \int_{-\infty}^t \phi(x,\tau) \cdot e^{C(x,\tau)/\Omega} \cdot \Theta(t-\tau) \, d\tau$$
                                <div class="equation-explanation">
                                    Where φ(x,τ) is the field function and Ω governs memory access depth: low Ω weights only highest-coherence moments (rigid reconstitution), high Ω accesses broader history (transformative change)
                                </div>
                            </div>
                        </div>
                        <div class="framework-item" style="background: rgba(248, 245, 240, 0.95);">
                            <h4>Technical Notes</h4>
                            <p style="font-size: 14px; margin-bottom: 12px;"><strong>FEP Correspondence</strong></p>
                            <p style="font-size: 14px; margin-bottom: 8px;">C = accumulated log-evidence (integrated prediction error). We distinguish <em>local</em> coherence (resets at rupture) from <em>nonlocal</em> coherence (accessible through the regeneration kernel).</p>
                            <p style="font-size: 14px; margin-bottom: 8px;">Ω = variance σ² (inverse precision). Rupture occurs when internal model saturation matches external constraint: C = Ω.</p>
                            <p style="font-size: 14px; margin-bottom: 16px;">exp(C/Ω) = precision-weighted memory selection in regeneration.</p>
                            <p style="font-size: 14px; margin-bottom: 12px;"><strong>The π Correspondence</strong></p>
                            <p style="font-size: 14px; margin-bottom: 8px;">Active Inference denotes precision with Π. CRR suggests this may be more than notation: for Z₂ symmetric systems, rupture occurs at π radians of accumulated phase, yielding Ω = 1/π and thus precision = π. For SO(2) systems, the full cycle gives precision = 2π.</p>
                            <p style="font-size: 14px; margin-bottom: 0;">The geometric constant emerges from phase space structure, not symbolic convention. Empirical validation across multiple domains shows CV predictions accurate to approximately 1%.</p>
                        </div>
                    </div>

                    <p>This mathematical structure provides a way to study systems that exhibit memory-dependent behaviour; where past configurations influence present dynamics in ways that Markovian models might miss. The simulations on this site realise this three-part formalism in code, a playful way to explore the deeper mathematical, philosophical and phenomenological concept of how identity persists as change.</p>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Why CRR?</h2>
                <div class="section-content">
                    <h3>Coherence</h3>
                    <p>Systems, from atoms to technological networks to whole ecosystems, exhibit organised patterns that persist through time. Understanding how coherence resists entropy over time offers potential insight for maintaining and creating more stable and resilient systems in various domains.</p>

                    <h3>Rupture</h3>
                    <p>Complex systems frequently undergo periods of reorganisation at various spatial and temporal scales. Rather than viewing these transitions as purely disruptive, the CRR framework examines how such events create space for system adaptation and novel emergent properties. The 'scale-free' nature of the CRR and Dirac Delta makes it a good candidate for modelling the ever-present moment of "now" as a temporal 'rupture' where agentic choice occurs as free will. This choice is based on all past states that have accumulated up to the present moment. Over time, the choices we make build patterns that work, but also accumulated friction, prediction errors. Depending on how we slice time, this can cause sudden change and subsequent Regeneration.</p>

                    <h3>Regeneration</h3>
                    <p>Future states are dependent on what most effectively build coherence and reduced Variational Free Energy in the past. Natural systems, for example, demonstrate remarkable abilities to recover and adapt following disruptions. The Regeneration component of CRR explores how systems use accumulated information to guide reconstruction processes; informing approaches to resilience in engineered systems. Depending on how one 'slices time', rupture is always inevitable, but Regeneration is what "heals". The euler's exponential means that the past is never the same, the system transforms exponentially.</p>

            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Philosophical Grounding</h2>
                <div class="section-content">
                    <p>CRR formalises intuitions that process philosophers have articulated for over a century. The framework provides mathematical structure for positions that have historically resisted formalisation.</p>

                    <h3>Whitehead: Actual Occasions</h3>
                    <p>Alfred North Whitehead rejected substance metaphysics in favour of process: reality consists not of enduring things but of momentary "actual occasions" that prehend their past and perish into objective immortality. The CRR structure maps directly onto this ontology. Coherence is the prehensive accumulation of the past. The Dirac delta at rupture is the moment of concrescence where many become one. Regeneration is the transition to "objective immortality" where the occasion's achieved value becomes available to future prehensions through exp(C/Ω) weighting. The mathematics formalises what Whitehead described philosophically: each moment metabolises its entire history, transforms it, and bequeaths novel pattern to the future.</p>

                    <h3>Bergson: Duration and Memory</h3>
                    <p>Henri Bergson distinguished lived duration (<em>durée</em>) from spatialized clock-time. For Bergson, the past is not gone but preserved whole in the present; memory is not retrieval from storage but the continuous presence of history in current experience. The regeneration integral embodies this directly: exp(C/Ω) ensures that high-coherence moments from the entire past remain actively present in reconstruction. Low Ω creates what Bergson might recognise as habit (only recent, most coherent patterns accessible). High Ω enables what he called creative evolution (the whole of memory available for genuine novelty). CRR provides the mathematical operator for Bergsonian duration.</p>

                    <h3>The Central Claim</h3>
                    <p>Memory accumulates, ruptures, and transforms. This punctuated dynamic, not smooth continuity, is how identity persists through change. Both Whitehead and Bergson grasped this philosophically. CRR offers it mathematically: a grammar of temporal becoming that can be simulated, tested, and applied across scales from neural dynamics to ecosystem succession.</p>
                </div>
            </section>
        </main>
    </div>

<footer class="footer">
    <div class="page-container">
        <div class="footer-content">
            
            <div class="footer-sections">
                <div class="footer-section">
                    <h4>Core Resources</h4>
                    <ul>
                        <li><a href="https://github.com/alexsabine/CRR/" target="_blank" rel="noopener noreferrer">GitHub Repository</a></li>
                        <li><a href="https://github.com/alexsabine/CRR/blob/main/CRR_Repository_Catalogue.md" target="_blank" rel="noopener noreferrer">Repository Catalogue</a> <span style="font-size: 12px; color: #888;">(67+ demos)</span></li>
                        <li><a href="https://www.cohere.org.uk/guide.html" target="_blank" rel="noopener noreferrer">Guide</a></li>
                        <li><a href="https://github.com/alexsabine/CRR/blob/main/CRR_COMPREHENSIVE_SUMMARY.md" target="_blank" rel="noopener noreferrer">Comprehensive Summary</a></li>
                        <li><a href="https://github.com/alexsabine/CRR/blob/main/README.md" target="_blank" rel="noopener noreferrer">README</a></li>
                        <li><a href="https://www.cohere.org.uk/CRR_Plenary.html" target="_blank" rel="noopener noreferrer">CRR in 5-Mins</a></li>
                    </ul>
                </div>
                
                <div class="footer-section">
                    <h4>Theory & Proof Sketches</h4>
                    <ul>
                        <li><a href="https://www.cohere.org.uk/Maths.html" target="_blank" rel="noopener noreferrer">Mathematical Foundations</a></li>
                        <li><a href="https://github.com/alexsabine/CRR/blob/main/crr_martingale_derivation.pdf" target="_blank" rel="noopener noreferrer">Martingale Derivation</a></li>
                        <li><a href="https://github.com/alexsabine/CRR/blob/main/canonical_crr_rigorous_proof_sketch.md" target="_blank" rel="noopener noreferrer">Canonical Proof Sketch</a></li>
                        <li><a href="https://www.cohere.org.uk/crr_first_principles_proofs.md" target="_blank" rel="noopener noreferrer">First Principles (12 domains)</a></li>
                        <li><a href="https://www.cohere.org.uk/16_nats_identity.pdf" target="_blank" rel="noopener noreferrer">16 Nats exploration</a></li>
                        <li><a href="https://www.cohere.org.uk/16nats_simulation.html" target="_blank" rel="noopener noreferrer">16 Nats System 1-2 Demo</a></li>
                        <li><a href="https://www.cohere.org.uk/CRR_Flatness_Commentary.pdf" target="_blank" rel="noopener noreferrer">Response to Mounier, Parr & Friston (2026)</a></li>
                        <li><a href="https://www.cohere.org.uk/CRR_Response_Tucker+Luu.pdf" target="_blank" rel="noopener noreferrer">Response to Tucker & Luu (2025)</a></li>
                        <li><a href="https://www.cohere.org.uk/Tolchinksy.pdf" target="_blank" rel="noopener noreferrer">Response to Tolchinsky et al (2025)</a></li>
                        <li><a href="https://www.cohere.org.uk/CRR_Lateralization_Thesis.pdf" target="_blank" rel="noopener noreferrer">L-R Brain Laterilisation (CRR)</a></li>
                        <li><a href="https://www.cohere.org.uk/CRR_Bounded_Kan_Extension_QED_v2.pdf" target="_blank" rel="noopener noreferrer">Kan Extension</a></li>
                    </ul>
                </div>
                
                <div class="footer-section aliboo">
                    <h4>Aliboo's Wacky Workshop ✿</h4>
                    <ul>
                        <li><a href="https://www.cohere.org.uk/crr-forest-seasonal.html" target="_blank" rel="noopener noreferrer">Season's Forest</a> <span style="font-size: 12px; color: #888;">(no CRR here, just a nice demo)</span></li>
                        <li><a href="https://www.cohere.org.uk/aurora_campfire.html" target="_blank" rel="noopener noreferrer">Aurora Campfire</a></li>
                        <li><a href="https://www.cohere.org.uk/siren-song.html" target="_blank" rel="noopener noreferrer">Siren Song</a></li>
                        <li><a href="https://www.cohere.org.uk/nostalgia_trap.html" target="_blank" rel="noopener noreferrer">Nostalgia Trap</a></li>
                        <li><a href="https://www.cohere.org.uk/CRR_Art.html" target="_blank" rel="noopener noreferrer">CRR Art Gallery</a></li>
                        <li><a href="https://www.cohere.org.uk/crr-explained.html" target="_blank" rel="noopener noreferrer">CRR Explained</a></li>
                        <li><a href="https://www.cohere.org.uk/brain_scientist_v2.html" target="_blank" rel="noopener noreferrer">FEP+CRR Brain (Pedagogical)</a></li>
                        <li><a href="https://www.cohere.org.uk/brain_scientist_verified.html" target="_blank" rel="noopener noreferrer">FEP+CRR Brain (Pedagogical)</a></li>
                        <li><a href="https://www.cohere.org.uk/water-droplet-translucent.html" target="_blank" rel="noopener noreferrer">CRR Water Droplet</a></li>
                        <li><a href="https://www.cohere.org.uk/crr_star.html" target="_blank" rel="noopener noreferrer">CRR Star</a></li>
                        <li><a href="https://www.cohere.org.uk/crr_veil.html" target="_blank" rel="noopener noreferrer">CRR Veil Nebula</a></li>
                        <li><a href="https://www.cohere.org.uk/fep_ink_with_karl.html" target="_blank" rel="noopener noreferrer">The Classic Karl Series - Living Ink Demo (Active Inference explainer, minimum CRR)</a></li>
                        <li><a href="https://www.cohere.org.uk/crr_screen_simulation.html" target="_blank" rel="noopener noreferrer">Meta Claude (fun!)</a></li>
                        <li><a href="https://www.cohere.org.uk/crr_planck_zoom.html" target="_blank" rel="noopener noreferrer">Meta Claude (planck fun)</a></li>
                        <li><a href="https://www.cohere.org.uk/crr_llm_journey.html" target="_blank" rel="noopener noreferrer">Meta Claude (word fun)</a></li>
                        <li><a href="https://www.cohere.org.uk/geometry(eff).html" target="_blank" rel="noopener noreferrer">Fun CRR Geometry</a></li>
                    </ul>
                </div>
            </div>
            
            <div class="footer-divider"></div>
            
            <p class="sitemap-header">Site Map (it's a bit of a Labyrinth!)</p>
            
            <div class="anthill-container" id="anthillContainer">
                <canvas class="anthill-canvas" id="anthillCanvas"></canvas>
                <div class="colony-stats" id="colonyStats"></div>
            </div>
            
            <script>
            (function() {
                const container = document.getElementById('anthillContainer');
                const canvas = document.getElementById('anthillCanvas');
                const ctx = canvas.getContext('2d');
                const statsEl = document.getElementById('colonyStats');
                
                let W, H, dpr;
                
                // Site sections from main nav
                const sections = [
                    { id: 'home', name: 'Home', url: 'index.html', x: 0.5, y: 0.08 },
                    { id: 'simulations', name: 'Simulations', url: 'crr-simulations.html', x: 0.22, y: 0.25 },
                    { id: 'biological', name: 'Biological', url: 'biological-systems.html', x: 0.10, y: 0.50 },
                    { id: 'physical', name: 'Physical', url: 'physical-systems.html', x: 0.28, y: 0.52 },
                    { id: 'mathematical', name: 'Mathematical', url: 'mathematical-life.html', x: 0.18, y: 0.78 },
                    { id: 'benchmarks', name: 'Benchmarks', url: 'crr-benchmarks.html', x: 0.50, y: 0.38 },
                    { id: 'explained', name: 'Explained', url: 'crr-explained.html', x: 0.78, y: 0.25 },
                    { id: 'about', name: 'About', url: 'about.html', x: 0.90, y: 0.50 },
                    { id: 'workshop', name: 'Workshop', url: 'CRR_Art.html', x: 0.70, y: 0.78 },
                    { id: 'maths', name: 'Maths', url: 'Maths.html', x: 0.50, y: 0.62 }
                ];
                
                // Resources that ants carry
                const resourceTypes = [
                    { symbol: '∫', name: 'integral', color: '#FFD700' },
                    { symbol: 'Ω', name: 'omega', color: '#FFA500' },
                    { symbol: 'δ', name: 'delta', color: '#FF6B6B' },
                    { symbol: 'C', name: 'coherence', color: '#90EE90' },
                    { symbol: 'R', name: 'regeneration', color: '#87CEEB' },
                    { symbol: 'π', name: 'pi', color: '#DDA0DD' },
                    { symbol: 'e', name: 'euler', color: '#F0E68C' },
                    { symbol: '∂', name: 'partial', color: '#98FB98' },
                    { symbol: 'Σ', name: 'sum', color: '#FFC0CB' },
                    { symbol: '∞', name: 'infinity', color: '#E6E6FA' }
                ];
                
                let chambers = [];
                let tunnels = [];
                let ants = [];
                let totalResourcesDelivered = 0;
                
                function resize() {
                    const rect = container.getBoundingClientRect();
                    dpr = window.devicePixelRatio || 1;
                    W = rect.width;
                    H = rect.height;
                    canvas.width = W * dpr;
                    canvas.height = H * dpr;
                    ctx.scale(dpr, dpr);
                    canvas.style.width = W + 'px';
                    canvas.style.height = H + 'px';
                    initChambers();
                }
                
                function initChambers() {
                    chambers = sections.map((s, i) => ({
                        ...s,
                        px: s.x * W,
                        py: s.y * H,
                        radius: Math.min(W, H) * 0.052,
                        resources: [],
                        activity: 0
                    }));
                    
                    tunnels = [
                        { from: 0, to: 1 }, { from: 0, to: 5 }, { from: 0, to: 6 },
                        { from: 1, to: 2 }, { from: 1, to: 3 }, { from: 1, to: 5 },
                        { from: 2, to: 4 }, { from: 3, to: 4 }, { from: 3, to: 9 },
                        { from: 5, to: 9 }, { from: 6, to: 7 }, { from: 6, to: 5 },
                        { from: 7, to: 8 }, { from: 8, to: 9 }, { from: 4, to: 8 },
                        { from: 9, to: 8 }, { from: 5, to: 6 }
                    ].map(t => ({
                        ...t,
                        strength: 0.2 + Math.random() * 0.3,
                        pheromone: 0.4 + Math.random() * 0.2
                    }));
                }
                
                class Ant {
                    constructor() {
                        this.reset();
                    }
                    
                    reset() {
                        const startChamber = chambers[Math.floor(Math.random() * chambers.length)];
                        this.x = startChamber.px + (Math.random() - 0.5) * startChamber.radius * 0.5;
                        this.y = startChamber.py + (Math.random() - 0.5) * startChamber.radius * 0.5;
                        this.homeChamber = startChamber;
                        this.targetChamber = null;
                        this.carrying = null;
                        this.coherence = 0;
                        this.omega = 0.25 + Math.random() * 0.5;
                        this.speed = 0.5 + Math.random() * 0.4;
                        this.angle = Math.random() * Math.PI * 2;
                        this.waitTime = 0;
                        this.decideAction();
                    }
                    
                    decideAction() {
                        const memoryWeight = Math.exp(this.coherence / this.omega);
                        this.pickForagingTarget();
                        this.coherence = 0;
                    }
                    
                    pickForagingTarget() {
                        const currentChamberIdx = this.nearestChamberIndex();
                        const connections = tunnels.filter(t => 
                            (t.from === currentChamberIdx || t.to === currentChamberIdx) && t.strength > 0.2
                        );
                        
                        if (connections.length > 0 && Math.random() > 0.2) {
                            connections.sort((a, b) => b.pheromone - a.pheromone);
                            const conn = connections[Math.random() < 0.3 ? Math.floor(Math.random() * connections.length) : 0];
                            const targetIdx = conn.from === currentChamberIdx ? conn.to : conn.from;
                            this.targetChamber = chambers[targetIdx];
                        } else {
                            this.targetChamber = chambers[Math.floor(Math.random() * chambers.length)];
                        }
                    }
                    
                    nearestChamberIndex() {
                        let nearest = 0;
                        let minDist = Infinity;
                        chambers.forEach((ch, i) => {
                            const d = Math.hypot(ch.px - this.x, ch.py - this.y);
                            if (d < minDist) { minDist = d; nearest = i; }
                        });
                        return nearest;
                    }
                    
                    update() {
                        this.waitTime = Math.max(0, this.waitTime - 1);
                        if (this.waitTime > 0) return;
                        
                        this.coherence += 0.006 * this.speed;
                        
                        // Carrying ants are more committed - higher effective omega
                        const effectiveOmega = this.carrying ? this.omega * 2.2 : this.omega;
                        
                        if (this.coherence > effectiveOmega) {
                            // Rupture - but only drop resource if we're actually at a chamber
                            if (this.carrying) {
                                const nearIdx = this.nearestChamberIndex();
                                const nearCh = chambers[nearIdx];
                                const distToNearest = Math.hypot(nearCh.px - this.x, nearCh.py - this.y);
                                
                                // Only drop if we're inside a chamber
                                if (distToNearest < nearCh.radius * 0.8) {
                                    nearCh.resources.push(this.carrying);
                                    nearCh.activity += 0.1;
                                    totalResourcesDelivered++;
                                    this.carrying = null;
                                }
                                // Otherwise keep carrying - don't drop in tunnels
                            }
                            this.waitTime = 8 + Math.random() * 15;
                            this.decideAction();
                            return;
                        }
                        
                        if (this.targetChamber) {
                            this.moveTowardTarget();
                        } else {
                            this.wander();
                        }
                        
                        this.x = Math.max(12, Math.min(W - 12, this.x));
                        this.y = Math.max(12, Math.min(H - 12, this.y));
                    }
                    
                    moveTowardTarget() {
                        const dx = this.targetChamber.px - this.x;
                        const dy = this.targetChamber.py - this.y;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist < this.targetChamber.radius * 0.6) {
                            this.targetChamber.activity += 0.05;
                            
                            if (this.carrying) {
                                this.targetChamber.resources.push(this.carrying);
                                totalResourcesDelivered++;
                                this.carrying = null;
                                this.waitTime = 12;
                            } else if (this.targetChamber.resources.length > 2) {
                                this.carrying = this.targetChamber.resources.pop();
                                this.waitTime = 8;
                            } else if (Math.random() < 0.35) {
                                this.carrying = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            }
                            
                            const fromIdx = this.nearestChamberIndex();
                            tunnels.forEach(t => {
                                if ((t.from === fromIdx && chambers[t.to] === this.targetChamber) ||
                                    (t.to === fromIdx && chambers[t.from] === this.targetChamber)) {
                                    t.pheromone = Math.min(1, t.pheromone + 0.02);
                                    t.strength = Math.min(1, t.strength + 0.003);
                                }
                            });
                            
                            this.pickForagingTarget();
                            return;
                        }
                        
                        const targetAngle = Math.atan2(dy, dx);
                        const memoryWeight = Math.exp(this.coherence / this.omega);
                        const angleBlend = Math.min(0.12 * memoryWeight, 0.35);
                        
                        this.angle += (targetAngle - this.angle) * angleBlend;
                        this.angle += (Math.random() - 0.5) * 0.2;
                        
                        const currentSpeed = this.carrying ? this.speed * 0.65 : this.speed;
                        this.x += Math.cos(this.angle) * currentSpeed;
                        this.y += Math.sin(this.angle) * currentSpeed;
                    }
                    
                    wander() {
                        this.angle += (Math.random() - 0.5) * 0.35;
                        this.x += Math.cos(this.angle) * this.speed * 0.4;
                        this.y += Math.sin(this.angle) * this.speed * 0.4;
                        if (Math.random() < 0.015) this.decideAction();
                    }
                    
                    draw(ctx) {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.angle);
                        
                        ctx.fillStyle = '#1a0a00';
                        
                        ctx.beginPath();
                        ctx.ellipse(3.5, 0, 2, 1.6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(-0.5, 0, 2.5, 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(-5, 0, 3.5, 2.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#1a0a00';
                        ctx.lineWidth = 0.6;
                        const legPhase = Date.now() * 0.012 + this.x * 0.1;
                        for (let i = -1; i <= 1; i++) {
                            const lx = -0.5 + i * 2;
                            const legWave = Math.sin(legPhase + i * 1.1) * 1.8;
                            ctx.beginPath();
                            ctx.moveTo(lx, 1.6);
                            ctx.quadraticCurveTo(lx + 1.2, 2.8 + legWave, lx + 2.5, 4.5 + legWave * 0.5);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(lx, -1.6);
                            ctx.quadraticCurveTo(lx + 1.2, -2.8 - legWave, lx + 2.5, -4.5 - legWave * 0.5);
                            ctx.stroke();
                        }
                        
                        ctx.beginPath();
                        ctx.moveTo(4.5, 0.7);
                        ctx.quadraticCurveTo(6, 1.3, 7.5, 2.5 + Math.sin(Date.now() * 0.007 + this.y) * 0.6);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(4.5, -0.7);
                        ctx.quadraticCurveTo(6, -1.3, 7.5, -2.5 + Math.sin(Date.now() * 0.007 + this.y + 1) * 0.6);
                        ctx.stroke();
                        
                        if (this.carrying) {
                            ctx.fillStyle = this.carrying.color;
                            ctx.font = 'bold 7px Georgia';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0,0,0,0.6)';
                            ctx.shadowBlur = 2;
                            ctx.fillText(this.carrying.symbol, 0, -5);
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.restore();
                    }
                }
                
                function evaporate() {
                    tunnels.forEach(t => { t.pheromone *= 0.9992; });
                }
                
                function drawNest() {
                    ctx.clearRect(0, 0, W, H);
                    
                    ctx.fillStyle = 'rgba(55, 38, 22, 0.25)';
                    for (let i = 0; i < 40; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * W, Math.random() * H, 1 + Math.random() * 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.lineCap = 'round';
                    tunnels.forEach(t => {
                        const fromCh = chambers[t.from];
                        const toCh = chambers[t.to];
                        const tunnelWidth = 10 + t.strength * 12;
                        
                        ctx.strokeStyle = 'rgba(28, 16, 6, ' + (0.35 + t.strength * 0.4) + ')';
                        ctx.lineWidth = tunnelWidth + 5;
                        ctx.beginPath();
                        ctx.moveTo(fromCh.px, fromCh.py);
                        const midX = (fromCh.px + toCh.px) / 2 + (t.from - t.to) * 6;
                        const midY = (fromCh.py + toCh.py) / 2 + (t.from + t.to) * 2;
                        ctx.quadraticCurveTo(midX, midY, toCh.px, toCh.py);
                        ctx.stroke();
                        
                        const bright = 50 + t.strength * 35 + t.pheromone * 18;
                        ctx.strokeStyle = 'rgb(' + (bright + 12) + ',' + (bright - 6) + ',' + (bright - 18) + ')';
                        ctx.lineWidth = tunnelWidth;
                        ctx.stroke();
                        
                        if (t.pheromone > 0.35) {
                            ctx.strokeStyle = 'rgba(170, 130, 55, ' + (t.pheromone * 0.12) + ')';
                            ctx.lineWidth = tunnelWidth + 3;
                            ctx.stroke();
                        }
                    });
                    
                    chambers.forEach(ch => {
                        const glowInt = Math.min(ch.activity, 1);
                        const glow = ctx.createRadialGradient(ch.px, ch.py, 0, ch.px, ch.py, ch.radius * 1.4);
                        glow.addColorStop(0, 'rgba(115, 85, 48, ' + (0.88 + glowInt * 0.1) + ')');
                        glow.addColorStop(0.55, 'rgba(80, 55, 32, ' + (0.82 + glowInt * 0.1) + ')');
                        glow.addColorStop(1, 'rgba(45, 28, 12, 0)');
                        
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.ellipse(ch.px, ch.py, ch.radius * 1.35, ch.radius * 1.15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        const interior = ctx.createRadialGradient(ch.px - ch.radius * 0.18, ch.py - ch.radius * 0.18, 0, ch.px, ch.py, ch.radius);
                        interior.addColorStop(0, 'rgba(' + (100 + glowInt * 18) + ',' + (70 + glowInt * 12) + ',' + (42 + glowInt * 8) + ', 0.94)');
                        interior.addColorStop(0.7, 'rgba(70, 48, 28, 0.88)');
                        interior.addColorStop(1, 'rgba(55, 35, 20, 0.82)');
                        
                        ctx.fillStyle = interior;
                        ctx.beginPath();
                        ctx.ellipse(ch.px, ch.py, ch.radius, ch.radius * 0.82, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255, 246, 218, 0.88)';
                        ctx.font = '10px Georgia';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0,0,0,0.75)';
                        ctx.shadowBlur = 3;
                        ctx.fillText(ch.name, ch.px, ch.py);
                        ctx.shadowBlur = 0;
                        
                        ch.resources.slice(-5).forEach((res, ri) => {
                            const resAngle = (ri / 5) * Math.PI * 2 + Date.now() * 0.00025;
                            const resX = ch.px + Math.cos(resAngle) * (ch.radius * 0.55);
                            const resY = ch.py + Math.sin(resAngle) * (ch.radius * 0.45);
                            ctx.fillStyle = res.color;
                            ctx.font = '6px Georgia';
                            ctx.fillText(res.symbol, resX, resY);
                        });
                        
                        ch.activity *= 0.985;
                    });
                    
                    ants.forEach(ant => ant.draw(ctx));
                    
                    const carriers = ants.filter(a => a.carrying).length;
                    statsEl.textContent = 'Resources moved: ' + totalResourcesDelivered + ' | Carriers: ' + carriers;
                }
                
                let frameCount = 0;
                function animate() {
                    frameCount++;
                    ants.forEach(ant => ant.update());
                    if (frameCount % 4 === 0) evaporate();
                    drawNest();
                    requestAnimationFrame(animate);
                }
                
                resize();
                
                for (let i = 0; i < 22; i++) ants.push(new Ant());
                
                chambers.forEach(ch => {
                    for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                        ch.resources.push(resourceTypes[Math.floor(Math.random() * resourceTypes.length)]);
                    }
                });
                
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    chambers.forEach(ch => {
                        if (Math.hypot(ch.px - mx, ch.py - my) < ch.radius) {
                            window.location.href = ch.url;
                        }
                    });
                });
                
                canvas.style.cursor = 'pointer';
                window.addEventListener('resize', resize);
                animate();
            })();
            </script>
            
            <div class="footer-divider"></div>
            
            <p class="footer-repo-note">
                This repository is an explorable treatise: 67+ interactive demonstrations alongside mathematical documentation. The unusual structure is intentional. Think exhibition space, not code library.
            </p>
            
            <p class="footer-author">
                <strong>Alexander Sabine</strong> · Board of Directors, <a href="https://activeinference.org/" target="_blank" rel="noopener noreferrer">Active Inference Institute</a> (2026)<br>
                Doctoral studies in participatory action mapping (maps and territories)<br>
                Contact: Alexander [at] active-inference [dot] co [dot] uk
            </p>
            
            <p class="footer-tech-note">
                Simulations utilise HTML5, WebGL2, and advanced JavaScript. Desktop browsers recommended for optimal performance.<br>
                Site coded by Claude, with thanks to Anthropic. 
            </p>
            
        </div>
    </div>
</footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
    // ============================================================================
    // AUTO-PLAYING FEP-CRR DEMONSTRATION
    // Faithful recreation of original with automatic navigation
    // ============================================================================
    
    (function() {
    'use strict';
    
    const canvas = document.getElementById('demoCanvas');
    const ctx = canvas.getContext('2d');
    let W, H;
    
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        W = rect.width;
        H = rect.height;
    }
    resizeCanvas();
    window.addEventListener('resize', () => { resizeCanvas(); initializeShapes(); });
    
    // ============================================================================
    // CRR SYSTEM - Exact from original
    // ============================================================================
    
    const CRR = {
        coherence: 0,
        omega: 1.0,
        stage: 1,
        maxStage: 5,
        phase: 'coherence',
        
        addCoherence(L) {
            if (this.phase !== 'coherence') return;
            this.coherence += L;
            this.updateDisplay();
            if (this.coherence >= this.omega) this.triggerRupture();
        },
        
        async triggerRupture() {
            this.phase = 'rupture';
            this.updateDisplay();
            document.getElementById('ruptureOverlay').classList.add('active');
            
            // Enhanced rupture messaging
            AgentSpeech.say("Local minimum reached — transformation required!", 2500);
            
            updateCommentary(
                `RUPTURE! C(t) = Ω. Local free energy minimum exhausted. Current structure cannot accommodate further learning — phase transition required.`,
                { term: 'First Passage', desc: 'Capacity threshold crossed' },
                { term: 'Basin Exhausted', desc: 'No further descent possible' },
                { term: 'δ(now)', desc: 'Punctuated equilibrium' },
                `C = Ω = ${this.omega.toFixed(2)} — structural reorganisation imminent`
            );
            
            await delay(2500);
            this.phase = 'regeneration';
            this.updateDisplay();
            
            AgentSpeech.say("Regenerating... new complexity emerging!", 2000);
            
            updateCommentary(
                `REGENERATION. Higher-order structure emerges. New environment will inject fresh free energy — the cycle continues at greater complexity.`,
                { term: 'Reorganisation', desc: 'Qualitative change' },
                { term: 'R = ∫Φ·exp(C/Ω)·Θ', desc: 'Memory-weighted reconstruction' },
                { term: 'exp(1) = e', desc: 'Euler calibration at rupture' },
                `Stage ${this.stage} → Stage ${Math.min(this.stage + 1, this.maxStage)}`
            );
            
            await delay(2000);
            
            this.stage = Math.min(this.stage + 1, this.maxStage);
            this.coherence = 0;
            this.phase = 'coherence';
            
            document.getElementById('ruptureOverlay').classList.remove('active');
            await regenerateWorld();
            this.updateDisplay();
        },
        
        updateDisplay() {
            const fill = document.getElementById('coherenceFill');
            const valueEl = document.getElementById('coherenceValue');
            const stageEl = document.getElementById('crrStage');
            const mathEl = document.getElementById('crrMath');
            const stageNameEl = document.getElementById('stageName');
            
            const pct = Math.min((this.coherence / this.omega) * 100, 100);
            fill.style.width = pct + '%';
            valueEl.textContent = this.coherence.toFixed(3);
            fill.classList.toggle('critical', pct > 85 && this.phase === 'coherence');
            
            if (this.phase === 'rupture') {
                stageEl.textContent = 'RUPTURE δ(now)';
                stageEl.className = 'crr-stage-badge rupture';
                mathEl.textContent = 'C(t*) = Ω — first passage to capacity';
            } else if (this.phase === 'regeneration') {
                stageEl.textContent = 'Regenerating...';
                stageEl.className = 'crr-stage-badge regeneration';
                mathEl.textContent = 'R = ∫Φ·exp(C/Ω)·Θ dτ — causal reconstruction';
            } else {
                stageEl.textContent = 'Coherence';
                stageEl.className = 'crr-stage-badge';
                mathEl.textContent = 'C(t) = ∫L(τ)dτ — cumulative adaptive work';
            }
            
            for (let i = 1; i <= 5; i++) {
                const dot = document.getElementById('stageDot' + i);
                dot.className = 'stage-dot';
                if (i < this.stage) dot.classList.add('completed');
                if (i === this.stage) dot.classList.add('current');
            }
            
            const names = ['Stage I: Simple Forms', 'Stage II: Compound', 'Stage III: Dynamic', 'Stage IV: Emergent', 'Stage V: Meta-CRR'];
            stageNameEl.textContent = names[Math.min(this.stage - 1, 4)];
        },
        
        reset() {
            this.coherence = 0;
            this.stage = 1;
            this.phase = 'coherence';
            this.updateDisplay();
        }
    };
    
    // ============================================================================
    // SHAPE DEFINITIONS - Exact from original
    // ============================================================================
    
    const SHAPE_TYPES = {
        circle: { name: 'Circle', stage: 1 }, triangle: { name: 'Triangle', stage: 1 },
        square: { name: 'Square', stage: 1 }, pentagon: { name: 'Pentagon', stage: 1 },
        hexagon: { name: 'Hexagon', stage: 1 }, star: { name: 'Star', stage: 1 },
        ring: { name: 'Ring', stage: 2 }, triangleInCircle: { name: 'Inscribed Triangle', stage: 2 },
        nestedSquares: { name: 'Nested Squares', stage: 2 }, hexStar: { name: 'Hex-Star', stage: 2 },
        crescentMoon: { name: 'Crescent', stage: 2 }, diamond: { name: 'Diamond', stage: 2 },
        spiral: { name: 'Spiral', stage: 3 }, pulsingStar: { name: 'Pulsing Star', stage: 3 },
        fractalTriangle: { name: 'Fractal Triangle', stage: 3 }, flowField: { name: 'Flow Field', stage: 3 },
        interference: { name: 'Interference', stage: 3 }, mandala: { name: 'Mandala', stage: 3 },
        flock: { name: 'Flocking Swarm', stage: 4, emergent: true },
        phaseTransition: { name: 'Phase Transition', stage: 4, emergent: true },
        coupledOscillators: { name: 'Coupled Oscillators', stage: 4, emergent: true },
        reactionDiffusion: { name: 'Reaction-Diffusion', stage: 4, emergent: true },
        cellularAutomata: { name: 'Cellular Automata', stage: 4, emergent: true },
        bifurcation: { name: 'Bifurcation', stage: 4, emergent: true },
        crrOscillator: { name: 'CRR Oscillator', stage: 5, metaCRR: true },
        coherenceWave: { name: 'Coherence Wave', stage: 5, metaCRR: true },
        ruptureBloom: { name: 'Rupture Bloom', stage: 5, metaCRR: true },
        regenerativeSpiral: { name: 'Regenerative Spiral', stage: 5, metaCRR: true },
        nestedCRR: { name: 'Nested CRR', stage: 5, metaCRR: true },
        autopoieticRing: { name: 'Autopoietic Ring', stage: 5, metaCRR: true }
    };
    
    const COLORS = {
        red: { name: 'Red', hex: '#e53935' }, blue: { name: 'Blue', hex: '#1e88e5' },
        green: { name: 'Green', hex: '#43a047' }, yellow: { name: 'Yellow', hex: '#fdd835' },
        purple: { name: 'Purple', hex: '#8e24aa' }, orange: { name: 'Orange', hex: '#fb8c00' },
        cyan: { name: 'Cyan', hex: '#00acc1' }, pink: { name: 'Pink', hex: '#d81b60' },
        indigo: { name: 'Indigo', hex: '#3949ab' }, teal: { name: 'Teal', hex: '#00897b' }
    };
    
    const SIZES = { small: { name: 'Small', radius: 25 }, medium: { name: 'Medium', radius: 38 }, large: { name: 'Large', radius: 50 } };
    
    // ============================================================================
    // WORLD STATE
    // ============================================================================
    
    let shapes = [];
    let agent = { x: 60, y: 190, targetX: 60, targetY: 190, size: 16, state: 'idle', currentTarget: null, breathePhase: 0 };
    let generativeModel = { shapes: {}, colors: {}, sizes: {}, abstractions: [] };
    let time = 0, worldPhase = 0;
    
    // Auto-navigation
    let autoNavTimer = 0;
    let autoNavDelay = 1.5;
    let wanderTimer = 0;
    let isWandering = false;
    
    // ============================================================================
    // VFE & NEAR-TIME COHERENCE - Exact from original
    // ============================================================================
    
    let VFE = {
        current: 1.0,
        initial: 1.0,
        externalDrive: 0,
        cumulativeDrive: 0,
        
        update(predictionError, isNovelStimulus) {
            if (isNovelStimulus) {
                this.externalDrive = 0.15 + predictionError * 0.2;
                this.cumulativeDrive += this.externalDrive;
                this.current = Math.min(1.0, this.current + this.externalDrive * 0.5);
            } else {
                this.externalDrive = 0.02;
                this.cumulativeDrive += this.externalDrive;
            }
        },
        
        onLearning(workDone) {
            const baseline = 0.1 + CRR.stage * 0.02;
            const drop = Math.max(0.05, workDone * 1.5);
            this.current = Math.max(baseline, this.current - drop);
        },
        
        tick() { this.updateDisplay(); },
        
        updateDisplay() {
            const pct = Math.max(0, Math.min(100, this.current * 100));
            document.getElementById('vfeFill').style.width = pct + '%';
            document.getElementById('vfeValue').textContent = `F = ${this.current.toFixed(2)}`;
        },
        
        reset() {
            this.current = 1.0;
            this.initial = 1.0;
            this.externalDrive = 0;
            this.cumulativeDrive = 0;
            this.updateDisplay();
        }
    };
    
    let NearTimeCoherence = {
        window: [],
        windowSize: 8,
        current: 0,
        
        addWork(L) {
            this.window.push(L);
            if (this.window.length > this.windowSize) this.window.shift();
            this.current = this.window.reduce((a, b) => a + b, 0) / this.windowSize;
            this.updateDisplay();
        },
        
        updateDisplay() {
            const normalized = Math.min(1, this.current / 0.12);
            const pct = normalized * 100;
            const fill = document.getElementById('accumWorkFill');
            fill.style.width = pct + '%';
            fill.classList.toggle('critical', normalized > 0.7);
            document.getElementById('accumWorkValue').textContent = `C_Δ = ${this.current.toFixed(3)}`;
        },
        
        reset() {
            this.window = [];
            this.current = 0;
            this.updateDisplay();
        }
    };
    
    // ============================================================================
    // TUNED CONSTANTS (Verified by Python Simulation v2.0)
    // ============================================================================
    
    const CRR_KAPPA = 0.20;                    // Scaling factor: L = Ω·ε²·κ
    const ERROR_UNKNOWN_SHAPE = 0.60;          // Never seen this shape type
    const ERROR_DISRUPTED_SHAPE = 0.35;        // Schema disrupted by regeneration
    const ERROR_UNKNOWN_COLOR = 0.25;          // Never seen this color
    const ERROR_BASELINE = 0.12;               // Everything familiar
    const ERROR_REVISIT = 0.06;                // High-confidence revisit
    const INTEGRATION_WORK_MIN = 0.04;
    const INTEGRATION_WORK_MAX = 0.07;
    const PROB_REVISIT_DURING_EXPLORATION = 0.12;
    const PROB_REVISIT_AFTER_EXPLORATION = 0.40;
    
    function calculateAdaptiveWork(predictionError, omega = 1.0) {
        // L = Ω · ε² · κ (verified by Python)
        return omega * (predictionError * predictionError) * CRR_KAPPA;
    }
    
    function calculateIntegrationWork() {
        return INTEGRATION_WORK_MIN + Math.random() * (INTEGRATION_WORK_MAX - INTEGRATION_WORK_MIN);
    }
    
    // ============================================================================
    // AGENT SPEECH - Exact from original
    // ============================================================================
    
    const AgentSpeech = {
        element: null,
        timeout: null,
        
        init() { this.element = document.getElementById('agentSpeech'); },
        
        say(text, duration = 2500) {
            if (this.timeout) clearTimeout(this.timeout);
            this.element.textContent = text;
            this.element.classList.add('visible');
            this.timeout = setTimeout(() => { this.element.classList.remove('visible'); }, duration);
        },
        
        updatePosition(x, y) {
            this.element.style.left = (x - 20) + 'px';
            this.element.style.top = (y - 70) + 'px';
        },
        
        hide() {
            if (this.timeout) clearTimeout(this.timeout);
            this.element.classList.remove('visible');
        }
    };
    
    // Inner monologue - Exact from original
    const innerMonologue = {
        approaching: ["What's this...?", "Let me see...", "Interesting...", "I wonder...", "Something to explore..."],
        predicting: ["I think I know this...", "This looks familiar...", "My model predicts...", "Expecting..."],
        predictingNovel: ["I have no model for this...", "Complete novelty...", "What could it be?", "Unknown territory..."],
        surprised: ["Large error! Much work to do...", "Big mismatch! Steep gradient...", "Significant updating needed...", "This adds a lot to C(t)..."],
        confirmedHigh: ["Small error. Minimal work.", "Prediction was close!", "Gentle gradient descent...", "Easy update."],
        confirmedLow: ["Some adjustment needed...", "Moderate work here...", "Partial match...", "Some gradient to descend..."],
        learning: ["Updating beliefs...", "Descending the gradient...", "Reducing free energy...", "Model adjusting..."],
        learningNovel: ["New schema forming!", "Significant restructuring...", "Major model update...", "Accommodating novelty..."],
        mastery: ["Environment fully explored.", "All patterns encountered.", "Work accumulating...", "Approaching capacity..."],
        nearRupture: ["Cumulative work nearing Ω...", "Capacity almost reached...", "C(t) → Ω...", "Transformation imminent..."],
        rupture: ["C = Ω! First passage!", "Capacity reached!", "δ(now)!", "Rupture threshold!"],
        regeneration: ["C resets to zero...", "New cycle begins...", "Regenerating structure...", "Higher complexity awaits..."],
        stage5Insight: ["This pattern... it's like me!", "I see CRR in these shapes...", "Self-similar dynamics...", "The pattern recognises itself..."],
        wandering: ["Consolidating...", "Integrating knowledge...", "Processing...", "Reflecting on schemas..."]
    };
    
    function getRandomPhrase(category) {
        const phrases = innerMonologue[category];
        return phrases[Math.floor(Math.random() * phrases.length)];
    }
    
    // ============================================================================
    // STAGE CONFIGS - Exact from original
    // ============================================================================
    
    function getStageConfigs(stage) {
        const configs = {
            1: [
                { type: 'circle', color: 'red', size: 'medium' }, { type: 'triangle', color: 'blue', size: 'large' },
                { type: 'square', color: 'green', size: 'small' }, { type: 'pentagon', color: 'yellow', size: 'medium' },
                { type: 'circle', color: 'purple', size: 'small' }, { type: 'star', color: 'orange', size: 'large' },
                { type: 'hexagon', color: 'cyan', size: 'small' }, { type: 'triangle', color: 'pink', size: 'medium' }
            ],
            2: [
                { type: 'ring', color: 'cyan', size: 'large' }, { type: 'triangleInCircle', color: 'purple', size: 'medium' },
                { type: 'nestedSquares', color: 'orange', size: 'large' }, { type: 'hexStar', color: 'blue', size: 'medium' },
                { type: 'crescentMoon', color: 'yellow', size: 'large' }, { type: 'diamond', color: 'pink', size: 'medium' },
                { type: 'ring', color: 'green', size: 'small' }, { type: 'nestedSquares', color: 'red', size: 'small' }
            ],
            3: [
                { type: 'spiral', color: 'purple', size: 'large' }, { type: 'pulsingStar', color: 'orange', size: 'medium' },
                { type: 'fractalTriangle', color: 'cyan', size: 'large' }, { type: 'flowField', color: 'blue', size: 'large' },
                { type: 'interference', color: 'pink', size: 'medium' }, { type: 'mandala', color: 'green', size: 'large' },
                { type: 'spiral', color: 'red', size: 'medium' }, { type: 'pulsingStar', color: 'yellow', size: 'small' }
            ],
            4: [
                { type: 'flock', color: 'blue', size: 'large' }, { type: 'phaseTransition', color: 'purple', size: 'large' },
                { type: 'coupledOscillators', color: 'orange', size: 'medium' }, { type: 'reactionDiffusion', color: 'cyan', size: 'large' },
                { type: 'cellularAutomata', color: 'green', size: 'medium' }, { type: 'bifurcation', color: 'red', size: 'large' },
                { type: 'flock', color: 'pink', size: 'medium' }, { type: 'coupledOscillators', color: 'teal', size: 'small' }
            ],
            5: [
                { type: 'crrOscillator', color: 'purple', size: 'large' }, { type: 'coherenceWave', color: 'indigo', size: 'large' },
                { type: 'ruptureBloom', color: 'red', size: 'large' }, { type: 'regenerativeSpiral', color: 'green', size: 'large' },
                { type: 'nestedCRR', color: 'orange', size: 'large' }, { type: 'autopoieticRing', color: 'cyan', size: 'large' },
                { type: 'crrOscillator', color: 'pink', size: 'medium' }, { type: 'coherenceWave', color: 'teal', size: 'medium' }
            ]
        };
        return configs[stage] || configs[1];
    }
    
    function initializeShapes() {
        shapes = [];
        const configs = getStageConfigs(CRR.stage);
        const positions = [
            { x: W * 0.62, y: H * 0.22 }, { x: W * 0.84, y: H * 0.42 }, { x: W * 0.48, y: H * 0.48 }, { x: W * 0.72, y: H * 0.68 },
            { x: W * 0.34, y: H * 0.28 }, { x: W * 0.54, y: H * 0.78 }, { x: W * 0.38, y: H * 0.58 }, { x: W * 0.80, y: H * 0.16 }
        ];
        
        configs.forEach((config, i) => {
            shapes.push({
                id: i, type: config.type, color: config.color, size: config.size,
                x: positions[i].x, y: positions[i].y, radius: SIZES[config.size].radius,
                explored: false, hovered: false, pulsePhase: Math.random() * Math.PI * 2, phase: Math.random() * Math.PI * 2,
                internalC: 0, internalPhase: 'coherence', internalOmega: 1.0, particles: [], grid: null
            });
        });
        
        shapes.forEach(s => {
            if (SHAPE_TYPES[s.type].emergent) initializeEmergentShape(s);
            if (s.type === 'cellularAutomata') initializeCellularAutomata(s);
        });
    }
    
    function initializeEmergentShape(shape) {
        shape.particles = [];
        const count = shape.type === 'flock' ? 20 : shape.type === 'coupledOscillators' ? 8 : 15;
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * shape.radius * 0.8;
            shape.particles.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, phase: Math.random() * Math.PI * 2, state: Math.random() });
        }
    }
    
    function initializeCellularAutomata(shape) {
        const size = 9;
        shape.grid = [];
        for (let i = 0; i < size; i++) { shape.grid[i] = []; for (let j = 0; j < size; j++) shape.grid[i][j] = Math.random() > 0.5 ? 1 : 0; }
    }
    
    async function regenerateWorld() {
        Object.values(generativeModel.shapes).forEach(s => { s.confidence *= 0.3; s.disrupted = true; });
        updateBeliefDisplay();
        
        // VFE spikes as new environment appears
        VFE.current = 0.95;  // High uncertainty in new world
        VFE.cumulativeDrive = 0;
        NearTimeCoherence.reset();
        
        const stageDesc = ['', 'Simple Forms', 'Compound Structures', 'Dynamic Patterns', 'Emergent Systems', 'Meta-CRR Patterns'];
        
        await delay(1500);
        initializeShapes();
        
        // Announce the VFE spike from new environment
        AgentSpeech.say("New environment! Free energy spike — uncertainty high!", 2500);
        
        updateCommentary(
            `Stage ${CRR.stage}: ${stageDesc[CRR.stage]}. New environment injects uncertainty — VFE spikes! Fresh gradient descent begins.`,
            { term: 'Environmental Input', desc: 'Novel stimuli appear' },
            { term: 'F ↑', desc: 'Free energy spike' },
            { term: 'C = 0', desc: 'Coherence reset' },
            `F = ${VFE.current.toFixed(2)} (high), C = 0 — new descent begins`
        );
        
        agent.x = agent.targetX = 60;
        agent.y = agent.targetY = H / 2;
        agent.state = 'idle';
        agent.currentTarget = null;
        autoNavTimer = 0;
        wanderTimer = 0;
        isWandering = false;
        updateStatus('idle', `Stage ${CRR.stage}: New complexity awaits...`);
        
        await delay(1500);
        AgentSpeech.hide();
    }
    
    // ============================================================================
    // DRAWING FUNCTIONS - Exact from original
    // ============================================================================
    
    function drawBackground() {
        const gradients = [['#f5f5f5', '#e0e0e0'], ['#e8eaf6', '#c5cae9'], ['#ede7f6', '#b39ddb'], ['#e0f7fa', '#80deea'], ['#fce4ec', '#ce93d8']];
        const colors = gradients[CRR.stage - 1] || gradients[0];
        const grad = ctx.createRadialGradient(W * 0.5, H * 0.5, 0, W * 0.5, H * 0.5, W);
        colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), c));
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        
        ctx.strokeStyle = 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        const gridSize = 50 - CRR.stage * 8;
        for (let x = 0; x < W; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
        for (let y = 0; y < H; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
        
        ctx.fillStyle = `rgba(106,27,154,${0.05 + CRR.stage * 0.02})`;
        ctx.font = 'bold 80px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(CRR.stage, W - 50, H - 20);
    }
    
    function drawShape(shape) {
        ctx.save();
        ctx.translate(shape.x, shape.y);
        const pulse = shape.hovered ? Math.sin(shape.pulsePhase) * 3 : 0;
        const r = shape.radius + pulse;
        
        if (shape.hovered) { ctx.shadowColor = COLORS[shape.color].hex; ctx.shadowBlur = 20; }
        if (shape.explored) { ctx.strokeStyle = 'rgba(46,125,50,0.5)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, r + 8, 0, Math.PI * 2); ctx.stroke(); }
        
        const info = SHAPE_TYPES[shape.type];
        const color = COLORS[shape.color].hex;
        
        if (info.stage === 1) drawStage1Shape(shape.type, r, color);
        else if (info.stage === 2) drawStage2Shape(shape.type, r, color);
        else if (info.stage === 3) drawStage3Shape(shape.type, r, color, shape.phase + worldPhase);
        else if (info.stage === 4) drawStage4Shape(shape, r, color);
        else if (info.stage === 5) drawStage5Shape(shape, r, color);
        
        ctx.restore();
    }
    
    function drawStage1Shape(type, r, color) {
        ctx.fillStyle = color; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.beginPath();
        if (type === 'circle') ctx.arc(0, 0, r, 0, Math.PI * 2);
        else if (type === 'triangle') drawPolygon(r, 3);
        else if (type === 'square') drawPolygon(r, 4);
        else if (type === 'pentagon') drawPolygon(r, 5);
        else if (type === 'hexagon') drawPolygon(r, 6);
        else if (type === 'star') drawStar(r, 5);
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(-r * 0.25, -r * 0.25, r * 0.3, 0, Math.PI * 2); ctx.fill();
    }
    
    function drawStage2Shape(type, r, color) {
        ctx.fillStyle = color; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;
        if (type === 'ring') { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2, true); ctx.fill(); ctx.stroke(); }
        else if (type === 'triangleInCircle') { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); drawPolygon(r * 0.7, 3); ctx.fill(); }
        else if (type === 'nestedSquares') { for (let i = 0; i < 3; i++) { ctx.save(); ctx.rotate(i * Math.PI / 8); ctx.globalAlpha = 1 - i * 0.25; ctx.beginPath(); drawPolygon(r * (1 - i * 0.3), 4); if (i === 0) ctx.fill(); ctx.stroke(); ctx.restore(); } }
        else if (type === 'hexStar') { ctx.beginPath(); drawPolygon(r, 6); ctx.stroke(); ctx.beginPath(); drawStar(r * 0.8, 6); ctx.fill(); }
        else if (type === 'crescentMoon') { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f5f5f5'; ctx.beginPath(); ctx.arc(r * 0.3, 0, r * 0.75, 0, Math.PI * 2); ctx.fill(); }
        else if (type === 'diamond') { ctx.beginPath(); ctx.moveTo(0, -r); ctx.lineTo(r * 0.6, 0); ctx.lineTo(0, r); ctx.lineTo(-r * 0.6, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); }
    }
    
    function drawStage3Shape(type, r, color, phase) {
        ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = 2;
        if (type === 'spiral') { ctx.lineWidth = 3; ctx.beginPath(); for (let i = 0; i < 720; i += 5) { const a = (i * Math.PI / 180) + phase, rad = (i / 720) * r; if (i === 0) ctx.moveTo(Math.cos(a) * rad, Math.sin(a) * rad); else ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad); } ctx.stroke(); }
        else if (type === 'pulsingStar') { const pr = r * (0.8 + 0.2 * Math.sin(phase * 2)); ctx.beginPath(); drawStar(pr, 8); ctx.fill(); }
        else if (type === 'fractalTriangle') drawSierpinski(0, 0, r, 3, phase);
        else if (type === 'flowField') { for (let x = -r; x < r; x += 12) for (let y = -r; y < r; y += 12) { if (x*x + y*y > r*r) continue; const a = Math.sin(x * 0.1 + phase) + Math.cos(y * 0.1 + phase); ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(a) * 8, y + Math.sin(a) * 8); ctx.stroke(); } }
        else if (type === 'interference') { for (let i = 0; i < 5; i++) { ctx.globalAlpha = 0.3; const o = Math.sin(phase + i) * 10; ctx.beginPath(); ctx.arc(o, 0, r * (0.3 + i * 0.15), 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(-o, 0, r * (0.3 + i * 0.15), 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; }
        else if (type === 'mandala') { for (let i = 0; i < 12; i++) { ctx.save(); ctx.rotate((i * Math.PI * 2 / 12) + phase * 0.5); ctx.beginPath(); ctx.ellipse(r * 0.5, 0, r * 0.4, r * 0.15, 0, 0, Math.PI * 2); ctx.globalAlpha = 0.7; ctx.fill(); ctx.restore(); } ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(0, 0, r * 0.2, 0, Math.PI * 2); ctx.fill(); }
    }
    
    function drawStage4Shape(shape, r, color) {
        const type = shape.type; ctx.fillStyle = color; ctx.strokeStyle = color;
        if (type === 'flock') { updateFlock(shape); shape.particles.forEach(p => { ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(Math.atan2(p.vy, p.vx)); ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(-4, 3); ctx.lineTo(-4, -3); ctx.closePath(); ctx.fill(); ctx.restore(); }); }
        else if (type === 'phaseTransition') { const temp = (Math.sin(worldPhase * 0.5) + 1) / 2; shape.particles.forEach((p, i) => { const tx = temp < 0.5 ? (i % 4 - 1.5) * r * 0.4 : (Math.random() - 0.5) * r * 1.5; const ty = temp < 0.5 ? (Math.floor(i / 4) - 1.5) * r * 0.4 : (Math.random() - 0.5) * r * 1.5; p.x += (tx - p.x) * 0.05; p.y += (ty - p.y) * 0.05; ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1; ctx.strokeStyle = temp < 0.5 ? '#2196f3' : '#f44336'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); }
        else if (type === 'coupledOscillators') { shape.particles.forEach((p, i) => { const a = (i / shape.particles.length) * Math.PI * 2; const bx = Math.cos(a) * r * 0.6, by = Math.sin(a) * r * 0.6; let coupling = 0; shape.particles.forEach((o, j) => { if (i !== j) coupling += Math.sin(o.phase - p.phase) * 0.1; }); p.phase += 0.05 + coupling; const ox = bx + Math.cos(p.phase) * 10, oy = by + Math.sin(p.phase) * 10; ctx.beginPath(); ctx.arc(ox, oy, 8, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 0.3; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(ox, oy); ctx.stroke(); }); ctx.globalAlpha = 1; }
        else if (type === 'reactionDiffusion') { for (let i = 0; i < 12; i++) { const a = (i / 12) * Math.PI * 2 + worldPhase * 0.2; const d = r * (0.4 + 0.3 * Math.sin(i * 2.3 + worldPhase)); const s = 8 + 4 * Math.sin(i * 1.7 + worldPhase * 0.5); ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(Math.cos(a) * d, Math.sin(a) * d, s, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); }
        else if (type === 'cellularAutomata') { updateCellularAutomata(shape); const cs = r * 2 / shape.grid.length; shape.grid.forEach((row, i) => row.forEach((cell, j) => { if (cell) { ctx.globalAlpha = 0.8; ctx.fillRect((j - shape.grid.length / 2) * cs, (i - shape.grid.length / 2) * cs, cs - 1, cs - 1); } })); ctx.globalAlpha = 1; }
        else if (type === 'bifurcation') { ctx.lineWidth = 1.5; function drawBranch(x, y, len, ang, dep) { if (dep === 0 || len < 3) return; const ex = x + Math.cos(ang) * len, ey = y + Math.sin(ang) * len; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(ex, ey); ctx.stroke(); const sp = 0.4 + Math.sin(worldPhase + dep) * 0.2; drawBranch(ex, ey, len * 0.7, ang - sp, dep - 1); drawBranch(ex, ey, len * 0.7, ang + sp, dep - 1); } drawBranch(0, r * 0.5, r * 0.5, -Math.PI / 2, 5); }
    }
    
    function drawStage5Shape(shape, r, color) {
        const type = shape.type; updateShapeInternalCRR(shape);
        const c = shape.internalC, phase = shape.internalPhase;
        ctx.fillStyle = color; ctx.strokeStyle = color;
        
        if (type === 'crrOscillator') {
            const intensity = c / shape.internalOmega;
            ctx.globalAlpha = 0.3 + intensity * 0.5; ctx.beginPath(); ctx.arc(0, 0, r * (0.3 + intensity * 0.5), 0, Math.PI * 2); ctx.fill();
            const orbs = Math.floor(2 + intensity * 6);
            for (let i = 0; i < orbs; i++) { const a = (i / orbs) * Math.PI * 2 + worldPhase; const d = r * (0.5 + intensity * 0.3); ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(Math.cos(a) * d, Math.sin(a) * d, 4 + intensity * 4, 0, Math.PI * 2); ctx.fill(); }
            if (phase === 'rupture') { ctx.globalAlpha = 0.5; ctx.fillStyle = '#d32f2f'; ctx.beginPath(); ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = color; }
            ctx.globalAlpha = 1; ctx.strokeStyle = phase === 'rupture' ? '#d32f2f' : color; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, r, -Math.PI / 2, -Math.PI / 2 + (c / shape.internalOmega) * Math.PI * 2); ctx.stroke();
        } else if (type === 'coherenceWave') {
            const rings = 3 + Math.floor(c * 4);
            for (let i = 0; i < rings; i++) { ctx.globalAlpha = 0.3 + c * 0.3; ctx.lineWidth = 2 + c * 2; ctx.beginPath(); ctx.arc(0, 0, r * (0.2 + (i / rings) * 0.8), 0, Math.PI * 2); ctx.stroke(); }
            if (phase === 'rupture') { ctx.globalAlpha = 0.7; ctx.strokeStyle = '#d32f2f'; for (let i = 0; i < 8; i++) { const a = (i / 8) * Math.PI * 2; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a) * r * 1.3, Math.sin(a) * r * 1.3); ctx.stroke(); } }
            ctx.globalAlpha = 1;
        } else if (type === 'ruptureBloom') {
            const pc = 5 + Math.floor(c * 8), ps = 0.2 + c * 0.4;
            for (let i = 0; i < pc; i++) { ctx.save(); ctx.rotate((i / pc) * Math.PI * 2 + worldPhase * 0.3); ctx.globalAlpha = 0.6 + c * 0.3; ctx.beginPath(); ctx.ellipse(r * 0.4, 0, r * ps, r * 0.12, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(0, 0, r * 0.15, 0, Math.PI * 2); ctx.fill();
        } else if (type === 'regenerativeSpiral') {
            ctx.lineWidth = 2 + c * 3; const turns = 1 + c * 3; ctx.beginPath();
            for (let i = 0; i < 360 * turns; i += 3) { const a = (i * Math.PI / 180) + worldPhase, rad = (i / (360 * turns)) * r; if (i === 0) ctx.moveTo(Math.cos(a) * rad, Math.sin(a) * rad); else ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad); }
            ctx.stroke(); ctx.fillStyle = phase === 'rupture' ? '#d32f2f' : '#4caf50'; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
        } else if (type === 'nestedCRR') {
            for (let lv = 0; lv < 3; lv++) { const lc = (c + lv * 0.3) % 1, lr = r * (1 - lv * 0.25); ctx.globalAlpha = 0.4 + lc * 0.4; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, lr, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, lr, -Math.PI / 2, -Math.PI / 2 + lc * Math.PI * 2); ctx.stroke(); }
            ctx.globalAlpha = 1;
        } else if (type === 'autopoieticRing') {
            const segs = 12, sa = Math.PI * 2 / segs;
            for (let i = 0; i < segs; i++) { const active = ((i / segs) < c) ? 1 : 0.3; const a = i * sa + worldPhase * 0.2; ctx.globalAlpha = active; ctx.beginPath(); ctx.arc(0, 0, r * 0.7, a, a + sa * 0.8); ctx.lineWidth = 8; ctx.stroke(); }
            ctx.globalAlpha = 0.3; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1;
        }
    }
    
    function updateShapeInternalCRR(shape) {
        if (shape.internalPhase === 'coherence') { shape.internalC += 0.003; if (shape.internalC >= shape.internalOmega) { shape.internalPhase = 'rupture'; shape.ruptureTimer = 30; } }
        else if (shape.internalPhase === 'rupture') { shape.ruptureTimer--; if (shape.ruptureTimer <= 0) { shape.internalPhase = 'regeneration'; shape.regenTimer = 20; } }
        else if (shape.internalPhase === 'regeneration') { shape.regenTimer--; shape.internalC *= 0.9; if (shape.regenTimer <= 0) { shape.internalC = 0; shape.internalPhase = 'coherence'; } }
    }
    
    function drawPolygon(r, sides) { ctx.moveTo(0, -r); for (let i = 1; i <= sides; i++) { const a = (i * 2 * Math.PI / sides) - Math.PI / 2; ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); } ctx.closePath(); }
    function drawStar(r, pts) { const inner = r * 0.4; ctx.moveTo(0, -r); for (let i = 0; i < pts * 2; i++) { const a = (i * Math.PI / pts) - Math.PI / 2, rad = i % 2 === 0 ? r : inner; ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad); } ctx.closePath(); }
    function drawSierpinski(x, y, size, depth, phase) { if (depth === 0) { ctx.beginPath(); ctx.moveTo(x, y - size * 0.5); ctx.lineTo(x - size * 0.5, y + size * 0.5); ctx.lineTo(x + size * 0.5, y + size * 0.5); ctx.closePath(); ctx.fill(); return; } const s = size / 2, o = Math.sin(phase + depth) * 2; drawSierpinski(x + o, y - s * 0.5, s, depth - 1, phase); drawSierpinski(x - s * 0.5 + o, y + s * 0.5, s, depth - 1, phase); drawSierpinski(x + s * 0.5 + o, y + s * 0.5, s, depth - 1, phase); }
    function updateFlock(shape) { const r = shape.radius; shape.particles.forEach(p => { let ax = 0, ay = 0; shape.particles.forEach(o => { if (o === p) return; const dx = o.x - p.x, dy = o.y - p.y, d = Math.sqrt(dx*dx + dy*dy); if (d < 30 && d > 0) { ax += dx * 0.01; ay += dy * 0.01; ax += o.vx * 0.05; ay += o.vy * 0.05; } if (d < 15 && d > 0) { ax -= dx * 0.02; ay -= dy * 0.02; } }); if (p.x < -r * 0.8) ax += 0.5; if (p.x > r * 0.8) ax -= 0.5; if (p.y < -r * 0.8) ay += 0.5; if (p.y > r * 0.8) ay -= 0.5; p.vx += ax; p.vy += ay; const sp = Math.sqrt(p.vx*p.vx + p.vy*p.vy); if (sp > 2) { p.vx = (p.vx/sp)*2; p.vy = (p.vy/sp)*2; } p.x += p.vx; p.y += p.vy; }); }
    function updateCellularAutomata(shape) { if (Math.random() > 0.1) return; const g = shape.grid, sz = g.length, ng = g.map(r => [...r]); for (let i = 0; i < sz; i++) for (let j = 0; j < sz; j++) { let n = 0; for (let di = -1; di <= 1; di++) for (let dj = -1; dj <= 1; dj++) { if (di === 0 && dj === 0) continue; n += g[(i+di+sz)%sz][(j+dj+sz)%sz]; } ng[i][j] = g[i][j] === 1 ? (n === 2 || n === 3 ? 1 : 0) : (n === 3 ? 1 : 0); } shape.grid = ng; }
    
    function drawAgent() {
        ctx.save(); ctx.translate(agent.x, agent.y);
        const breathe = Math.sin(agent.breathePhase) * 2, size = agent.size + breathe;
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.ellipse(0, size * 0.7, size * 0.8, size * 0.3, 0, 0, Math.PI * 2); ctx.fill();
        const glows = { idle: 'rgba(100,100,100,0.3)', exploring: 'rgba(255,152,0,0.4)', examining: 'rgba(255,152,0,0.4)', surprised: 'rgba(198,40,40,0.5)', learning: 'rgba(35,78,112,0.5)' };
        ctx.fillStyle = glows[agent.state] || glows.idle; ctx.beginPath(); ctx.arc(0, 0, size + 8, 0, Math.PI * 2); ctx.fill();
        const grad = ctx.createRadialGradient(-size * 0.3, -size * 0.3, 0, 0, 0, size); grad.addColorStop(0, '#fafafa'); grad.addColorStop(0.5, '#e0e0e0'); grad.addColorStop(1, '#bdbdbd');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.stroke();
        const eo = size * 0.35, es = size * 0.25;
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.ellipse(-eo, -size * 0.1, es, es * 1.2, 0, 0, Math.PI * 2); ctx.ellipse(eo, -size * 0.1, es, es * 1.2, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.stroke();
        let lx = 0, ly = 0; if (agent.currentTarget) { const dx = agent.currentTarget.x - agent.x, dy = agent.currentTarget.y - agent.y, d = Math.sqrt(dx*dx+dy*dy)||1; lx = (dx/d)*es*0.4; ly = (dy/d)*es*0.4; }
        let ps = es * 0.5; if (agent.state === 'surprised') ps = es * 0.7;
        ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(-eo + lx, -size * 0.1 + ly, ps, 0, Math.PI * 2); ctx.arc(eo + lx, -size * 0.1 + ly, ps, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(-eo + lx - 2, -size * 0.1 + ly - 2, 2, 0, Math.PI * 2); ctx.arc(eo + lx - 2, -size * 0.1 + ly - 2, 2, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
        if (agent.state === 'surprised') { ctx.fillStyle = '#666'; ctx.beginPath(); ctx.ellipse(0, size * 0.35, size * 0.18, size * 0.22, 0, 0, Math.PI * 2); ctx.fill(); }
        else { ctx.beginPath(); ctx.arc(0, size * 0.25, size * 0.18, 0.2, Math.PI - 0.2); ctx.stroke(); }
        const syms = { surprised: '!', examining: '?', learning: '✓' };
        if (syms[agent.state]) { ctx.fillStyle = '#234e70'; ctx.font = `bold ${size * 0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(syms[agent.state], 0, -size * 1.2); }
        ctx.restore();
    }
    
    function drawExplorationLine() { if (agent.currentTarget && agent.state !== 'idle') { ctx.save(); ctx.strokeStyle = 'rgba(35,78,112,0.3)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(agent.x, agent.y); ctx.lineTo(agent.currentTarget.x, agent.currentTarget.y); ctx.stroke(); ctx.restore(); } }
    
    // ============================================================================
    // LEARNING SYSTEM - EXACT FROM ORIGINAL
    // ============================================================================
    
    function getPrediction(shape) { 
        const preds = []; 
        let conf = 0; 
        if (generativeModel.shapes[shape.type]) { 
            preds.push(`Shape: ${SHAPE_TYPES[shape.type].name}`); 
            conf += 0.3 * generativeModel.shapes[shape.type].confidence; 
        } 
        if (generativeModel.colors[shape.color]) { 
            preds.push(`Color: ${COLORS[shape.color].name}`); 
            conf += 0.3 * generativeModel.colors[shape.color].confidence; 
        } 
        return { predictions: preds, confidence: Math.min(conf, 0.9), hasKnowledge: preds.length > 0 }; 
    }
    
    function calculatePredictionError(shape, pred) { 
        // Use verified error constants from Python simulation
        const shapeKnown = !!generativeModel.shapes[shape.type];
        const shapeDisrupted = shapeKnown && generativeModel.shapes[shape.type].disrupted;
        const colorKnown = !!generativeModel.colors[shape.color];
        
        let error = 0;
        let messages = [];
        let isNovel = false;
        
        if (!shapeKnown) {
            error += ERROR_UNKNOWN_SHAPE;
            messages.push(`Unknown: ${SHAPE_TYPES[shape.type].name}`);
            isNovel = true;
        } else if (shapeDisrupted) {
            error += ERROR_DISRUPTED_SHAPE;
            messages.push(`Uncertain: ${SHAPE_TYPES[shape.type].name}`);
            isNovel = true;
        }
        
        if (!colorKnown) {
            error += ERROR_UNKNOWN_COLOR;
            messages.push(`Unknown: ${COLORS[shape.color].name}`);
            isNovel = true;
        }
        
        if (error === 0) {
            error = ERROR_BASELINE;
            messages = ['Matches existing schemas'];
        }
        
        return { 
            error: error, 
            message: messages.join('; '),
            isNovel: isNovel
        }; 
    }
    
    function updateGenerativeModel(shape) { 
        const updates = []; 
        if (!generativeModel.shapes[shape.type]) { 
            generativeModel.shapes[shape.type] = { 
                name: SHAPE_TYPES[shape.type].name, 
                stage: SHAPE_TYPES[shape.type].stage, 
                encounters: 1, 
                confidence: 0.6 
            }; 
            updates.push(`New: ${SHAPE_TYPES[shape.type].name}`); 
        } else { 
            generativeModel.shapes[shape.type].encounters++; 
            generativeModel.shapes[shape.type].confidence = Math.min(0.95, generativeModel.shapes[shape.type].confidence + 0.1); 
            generativeModel.shapes[shape.type].disrupted = false; 
        } 
        if (!generativeModel.colors[shape.color]) { 
            generativeModel.colors[shape.color] = { 
                name: COLORS[shape.color].name, 
                encounters: 1, 
                confidence: 0.6 
            }; 
            updates.push(`New: ${COLORS[shape.color].name}`); 
        } else { 
            generativeModel.colors[shape.color].encounters++; 
            generativeModel.colors[shape.color].confidence = Math.min(0.95, generativeModel.colors[shape.color].confidence + 0.1); 
        } 
        return updates; 
    }
    
    // ============================================================================
    // UI FUNCTIONS - Exact from original
    // ============================================================================
    
    function updateStatus(state, text) { 
        document.getElementById('statusDot').className = 'status-dot ' + state; 
        document.getElementById('statusText').textContent = text; 
    }
    
    function updateCommentary(text, piaget, fep, crr, math) { 
        document.getElementById('commentaryText').textContent = text; 
        const comp = document.getElementById('frameworkComparison'); 
        if (piaget && fep) { 
            comp.classList.add('visible'); 
            document.getElementById('piagetTerm').textContent = piaget.term; 
            document.getElementById('piagetDesc').textContent = piaget.desc; 
            document.getElementById('fepTerm').textContent = fep.term; 
            document.getElementById('fepDesc').textContent = fep.desc; 
            if (crr) { 
                document.getElementById('crrTerm').textContent = crr.term; 
                document.getElementById('crrDesc').textContent = crr.desc; 
            }
        } else { 
            comp.classList.remove('visible'); 
        } 
        const m = document.getElementById('mathNote'); 
        if (math) { 
            m.classList.add('visible'); 
            document.getElementById('mathContent').textContent = math; 
        } else { 
            m.classList.remove('visible'); 
        } 
    }
    
    function showPrediction(pred) { 
        const d = document.getElementById('predictionDisplay'); 
        d.classList.add('visible'); 
        document.getElementById('predictionContent').innerHTML = pred.hasKnowledge ? 
            `<strong>Expected:</strong> ${pred.predictions.join(', ')}<br><span style="font-size:10px;color:#666">Confidence: ${Math.round(pred.confidence*100)}%</span>` : 
            `<em>No prediction—novel</em>`; 
    }
    
    function showError(err) { 
        const d = document.getElementById('errorDisplay'); 
        d.classList.add('visible'); 
        d.className = err.error < 0.2 ? 'error-display visible low-error' : 'error-display visible'; 
        document.getElementById('errorContent').innerHTML = `${err.message}<br><span style="font-size:10px;color:${err.error<0.2?'#2e7d32':'#c62828'}">ε ≈ ${err.error.toFixed(2)}</span>`; 
    }
    
    function hidePredictionAndError() { 
        document.getElementById('predictionDisplay').classList.remove('visible'); 
        document.getElementById('errorDisplay').classList.remove('visible'); 
    }
    
    function updateBeliefDisplay(highlight = null) { 
        const c = document.getElementById('beliefsList'); 
        c.innerHTML = ''; 
        if (Object.keys(generativeModel.shapes).length === 0) { 
            c.innerHTML = `<div class="belief-item" style="opacity:0.5"><div class="belief-icon">?</div><div class="belief-text"><div class="belief-name">No schemas</div><div class="belief-details">Exploring...</div></div></div>`; 
            return; 
        } 
        const icons = { circle: '○', triangle: '△', square: '□', pentagon: '⬠', hexagon: '⬡', star: '☆', ring: '◎', nestedSquares: '⊞', diamond: '◇', crescentMoon: '☽', hexStar: '✡', triangleInCircle: '⊿', spiral: '🌀', mandala: '✿', pulsingStar: '✦', fractalTriangle: '△', flowField: '≋', interference: '◉', flock: '🐦', phaseTransition: '⇌', coupledOscillators: '∿', reactionDiffusion: '⊛', cellularAutomata: '⊞', bifurcation: '⑂', crrOscillator: 'Ω', coherenceWave: '∿', ruptureBloom: '❀', regenerativeSpiral: '🌀', nestedCRR: '⊚', autopoieticRing: '◎' }; 
        const sl = ['', 'Simple', 'Compound', 'Dynamic', 'Emergent', 'Meta-CRR']; 
        Object.entries(generativeModel.shapes).forEach(([k, s]) => { 
            const isNew = highlight && highlight.some(h => h.includes(s.name)); 
            const item = document.createElement('div'); 
            item.className = 'belief-item' + (isNew ? ' new' : '') + (s.disrupted ? ' disrupted' : ''); 
            item.innerHTML = `<div class="belief-icon">${icons[k]||'●'}</div><div class="belief-text"><div class="belief-name">${s.name}</div><div class="belief-details">${sl[s.stage]} · ×${s.encounters}</div></div><div class="confidence-bar"><div class="confidence-fill" style="width:${s.confidence*100}%"></div></div>`; 
            c.appendChild(item); 
        }); 
    }
    
    // ============================================================================
    // EXPLORATION - EXACT FROM ORIGINAL
    // ============================================================================
    
    async function exploreShape(shape) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        agent.currentTarget = shape; agent.state = 'exploring'; agent.targetX = shape.x - shape.radius - 40; agent.targetY = shape.y;
        const info = SHAPE_TYPES[shape.type];
        updateStatus('exploring', `Approaching ${info.name}...`);
        updateCommentary(`The agent moves toward a ${info.name}.${info.metaCRR ? ' This meta-pattern embodies CRR itself.' : ''}`, null, null, null, null);
        hidePredictionAndError();
        
        AgentSpeech.say(getRandomPhrase('approaching'));
        
        await waitForArrival();
        agent.state = 'examining';
        const pred = getPrediction(shape); showPrediction(pred);
        updateStatus('exploring', 'Generating predictions...');
        
        AgentSpeech.say(pred.hasKnowledge ? getRandomPhrase('predicting') : getRandomPhrase('predictingNovel'));
        
        updateCommentary(pred.hasKnowledge ? `Generative model produces predictions.` : `No applicable schemas—entirely novel.`, { term: pred.hasKnowledge ? 'Assimilation Attempt' : 'No Schema', desc: pred.hasKnowledge ? 'Testing structures' : 'Cannot assimilate' }, { term: pred.hasKnowledge ? 'Prior Prediction' : 'High Entropy', desc: pred.hasKnowledge ? 'g(μ) generates expectations' : 'Maximal uncertainty' }, info.metaCRR ? { term: 'Recursive Recognition', desc: 'Pattern recognizes pattern' } : null, pred.hasKnowledge ? 'g(μ) = predicted sensation' : 'H[P(s)] = maximum');
        await delay(1600);
        
        const err = calculatePredictionError(shape, pred);
        if (err.error > 0.3) agent.state = 'surprised';
        showError(err);
        
        const isNovelStimulus = !pred.hasKnowledge || !generativeModel.shapes[shape.type];
        const L = calculateAdaptiveWork(err.error);
        
        VFE.update(err.error, isNovelStimulus);
        NearTimeCoherence.addWork(L);
        
        if (err.error > 0.5) {
            AgentSpeech.say(getRandomPhrase('surprised'));
        } else if (err.error > 0.2) {
            AgentSpeech.say(getRandomPhrase('confirmedLow'));
        } else {
            AgentSpeech.say(getRandomPhrase('confirmedHigh'));
        }
        
        const workDesc = err.error > 0.3 ? 'High ε → large ‖∇F‖ → much work' : 'Low ε → small ‖∇F‖ → less work';
        updateCommentary(
            err.error > 0.3 ? `Large prediction error! More adaptive work required.` : `Small error. Minimal updating needed.`, 
            { term: err.error > 0.3 ? 'Disequilibrium' : 'Assimilation', desc: err.error > 0.3 ? 'Schema-experience gap' : 'Experience fits' }, 
            { term: 'L = Ω‖∇F‖²', desc: workDesc }, 
            { term: 'C(t) += L', desc: `Work adds ${L.toFixed(3)} to coherence` }, 
            `L = ${L.toFixed(3)}, C = ${(CRR.coherence + L).toFixed(3)}`
        );
        
        await delay(1800);
        agent.state = 'learning'; updateStatus('learning', 'Updating model...');
        
        // CRITICAL: Check if shape/color were known BEFORE updating the model
        const shapeWasKnownBefore = !!generativeModel.shapes[shape.type];
        const colorWasKnownBefore = !!generativeModel.colors[shape.color];
        
        // Now update the model
        const updates = updateGenerativeModel(shape); 
        shape.explored = true;
        
        VFE.onLearning(L);
        CRR.addCoherence(L);
        
        // Accommodation = new shape schema created
        // Assimilation = shape schema already existed (even if color was new)
        const isAccommodation = !shapeWasKnownBefore;
        
        // Speech based on accommodation vs assimilation
        if (isAccommodation) {
            if (info.metaCRR) {
                AgentSpeech.say(getRandomPhrase('stage5Insight'), 3000);
            } else {
                AgentSpeech.say(getRandomPhrase('learningNovel'));
            }
        } else {
            AgentSpeech.say(getRandomPhrase('learning'));
        }
        
        // Commentary with proper Piagetian terminology
        let commentaryText, piagetTerm, piagetDesc;
        if (isAccommodation) {
            // New shape = Accommodation
            commentaryText = `Accommodation: ${updates.join(', ')}.`;
            piagetTerm = 'Accommodation';
            piagetDesc = 'New schema formed';
        } else if (!colorWasKnownBefore) {
            // Shape known, color new = Assimilation with new info
            commentaryText = `Assimilation: New color integrated into existing ${info.name} schema.`;
            piagetTerm = 'Assimilation';
            piagetDesc = 'Information integrated';
        } else {
            // Everything known = Pure assimilation/reinforcement
            commentaryText = `Assimilation: ${info.name} schema reinforced.`;
            piagetTerm = 'Assimilation';
            piagetDesc = 'Schema reinforced';
        }
        
        updateCommentary(
            commentaryText, 
            { term: piagetTerm, desc: piagetDesc }, 
            { term: 'F decreases', desc: 'VFE reduced by learning' }, 
            { term: 'C accumulates', desc: `Total work: ${CRR.coherence.toFixed(3)}` }, 
            `F = ${VFE.current.toFixed(2)}, C = ${CRR.coherence.toFixed(3)}`
        );
        updateBeliefDisplay(updates);
        await delay(1400);
        
        if (CRR.coherence > CRR.omega * 0.75) {
            AgentSpeech.say(getRandomPhrase('nearRupture'), 2000);
        }
        
        if (shapes.every(s => s.explored) && CRR.phase === 'coherence') {
            const bonusL = 0.05;
            CRR.addCoherence(bonusL);
            NearTimeCoherence.addWork(bonusL);
            
            AgentSpeech.say(getRandomPhrase('mastery'), 2500);
            if (CRR.stage === 5) {
                updateCommentary(`All meta-CRR patterns explored. Cumulative adaptive work approaches capacity Ω. The agent has worked enough to require transformation...`, { term: 'Meta-Cognition', desc: 'Thinking about thinking' }, { term: 'C(t) → Ω', desc: 'First passage imminent' }, { term: 'Rupture Threshold', desc: 'Capacity reached through work' }, `C = ${CRR.coherence.toFixed(3)} → Ω = ${CRR.omega}`);
            } else {
                updateCommentary(`All forms explored. Coherence (cumulative work) approaches capacity Ω.`, { term: 'Stage Mastery', desc: 'Environment fully explored' }, { term: 'C(t) → Ω', desc: 'Work accumulating toward threshold' }, { term: 'Rupture Approaches', desc: 'Structural capacity filling' }, `C = ${CRR.coherence.toFixed(3)} → Ω`);
            }
        }
        agent.state = 'idle'; agent.currentTarget = null; updateStatus('idle', 'Ready...'); 
        await delay(800);
        AgentSpeech.hide();
        hidePredictionAndError();
    }
    
    function waitForArrival() { return new Promise(resolve => { (function check() { if (Math.abs(agent.targetX - agent.x) < 5 && Math.abs(agent.targetY - agent.y) < 5) resolve(); else requestAnimationFrame(check); })(); }); }
    function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    // ============================================================================
    // AUTO-NAVIGATION - Added for homepage
    // ============================================================================
    
    function autoNavigate(dt) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        
        const unexplored = shapes.filter(s => !s.explored);
        const explored = shapes.filter(s => s.explored);
        
        autoNavTimer += dt;
        
        if (autoNavTimer >= autoNavDelay) {
            autoNavTimer = 0;
            
            if (unexplored.length > 0) {
                // Still have shapes to explore
                // Use verified probability for revisiting
                const shouldRevisit = explored.length >= 2 && Math.random() < PROB_REVISIT_DURING_EXPLORATION;
                
                if (shouldRevisit) {
                    // Revisit for assimilation
                    const target = explored[Math.floor(Math.random() * explored.length)];
                    revisitShape(target);
                    autoNavDelay = 1.2 + Math.random() * 0.5;
                } else {
                    // Explore nearest unexplored shape (accommodation)
                    const target = unexplored.reduce((nearest, s) => {
                        const d = Math.hypot(s.x - agent.x, s.y - agent.y);
                        return (!nearest || d < nearest.dist) ? { shape: s, dist: d } : nearest;
                    }, null).shape;
                    
                    exploreShape(target);
                    autoNavDelay = 1.0 + Math.random() * 0.5;
                }
            } else {
                // All explored - integration phase
                isWandering = true;
                
                if (Math.random() < PROB_REVISIT_AFTER_EXPLORATION && explored.length > 0) {
                    // Revisit for final assimilation
                    const target = explored[Math.floor(Math.random() * explored.length)];
                    revisitShape(target);
                    autoNavDelay = 0.9 + Math.random() * 0.4;
                } else {
                    // Integration work (verified calculation)
                    const integrationL = calculateIntegrationWork();
                    CRR.addCoherence(integrationL);
                    NearTimeCoherence.addWork(integrationL);
                    
                    agent.targetX = 50 + Math.random() * (W * 0.3);
                    agent.targetY = H * 0.25 + Math.random() * (H * 0.5);
                    
                    AgentSpeech.say(getRandomPhrase('wandering'), 1500);
                    
                    const pct = ((CRR.coherence / CRR.omega) * 100).toFixed(0);
                    updateCommentary(
                        `Agent integrates learned schemas. Coherence: C = ${CRR.coherence.toFixed(3)} (${pct}% of Ω)`,
                        { term: 'Integration', desc: 'Schema consolidation' },
                        { term: 'C grows', desc: 'Background processing' },
                        { term: 'Toward Ω', desc: `${pct}% capacity` },
                        `C = ${CRR.coherence.toFixed(3)} → Ω = ${CRR.omega.toFixed(2)}`
                    );
                    
                    autoNavDelay = 0.7 + Math.random() * 0.3;
                }
            }
        }
    }
    
    // Revisit an already-explored shape for pure assimilation
    async function revisitShape(shape) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        
        agent.currentTarget = shape;
        agent.state = 'exploring';
        agent.targetX = shape.x - shape.radius - 35;
        agent.targetY = shape.y;
        
        const info = SHAPE_TYPES[shape.type];
        updateStatus('exploring', `Revisiting ${info.name}...`);
        AgentSpeech.say("Let me check this again...", 1500);
        
        await waitForArrival();
        
        // Quick examination - everything is familiar
        agent.state = 'examining';
        const pred = getPrediction(shape);
        showPrediction(pred);
        
        updateCommentary(
            `Revisiting familiar ${info.name}. Generative model already contains this schema.`,
            { term: 'Recognition', desc: 'Schema retrieved' },
            { term: 'Low Uncertainty', desc: 'Predictions accurate' },
            null,
            `Confidence: ${(pred.confidence * 100).toFixed(0)}%`
        );
        
        await delay(1000);
        
        // Use verified error constant for revisit
        const error = ERROR_REVISIT;
        const L = calculateAdaptiveWork(error);
        const err = { error: error, message: "Perfect match to schema." };
        showError(err);
        
        AgentSpeech.say("Assimilating only — the world makes sense.", 2500);
        
        updateCommentary(
            `Minimal prediction error. Pure assimilation: experience fits existing schemas.`,
            { term: 'Assimilation', desc: 'Schema-experience match' },
            { term: 'ε ≈ 0', desc: 'Near-zero error' },
            { term: 'Equilibrium', desc: 'Cognitive harmony' },
            `ε = ${err.error.toFixed(2)}, L = ${L.toFixed(4)} (minimal)`
        );
        
        // Add verified work and reinforce schema
        CRR.addCoherence(L);
        NearTimeCoherence.addWork(L);
        VFE.current = Math.max(0.1, VFE.current - 0.02);
        VFE.updateDisplay();
        
        // Increase confidence in the schema
        if (generativeModel.shapes[shape.type]) {
            generativeModel.shapes[shape.type].confidence = Math.min(0.98, generativeModel.shapes[shape.type].confidence + 0.05);
            generativeModel.shapes[shape.type].encounters++;
        }
        updateBeliefDisplay();
        
        await delay(1200);
        
        // Check if approaching rupture
        if (CRR.coherence > CRR.omega * 0.85) {
            AgentSpeech.say(getRandomPhrase('nearRupture'), 2000);
            updateCommentary(
                `Coherence nearing capacity. Even assimilation adds to cumulative work. Rupture approaches...`,
                { term: 'Saturation', desc: 'Capacity filling' },
                { term: 'C → Ω', desc: 'Threshold imminent' },
                { term: 'Phase Transition', desc: 'Structural limit' },
                `C = ${CRR.coherence.toFixed(3)} → Ω = ${CRR.omega.toFixed(2)}`
            );
        }
        
        agent.state = 'idle';
        agent.currentTarget = null;
        updateStatus('idle', 'Ready...');
        await delay(400);
        hidePredictionAndError();
        AgentSpeech.hide();
    }
    
    // ============================================================================
    // MAIN LOOP
    // ============================================================================
    
    function update(dt) { 
        time += dt; 
        worldPhase += dt * 0.5; 
        agent.x += (agent.targetX - agent.x) * 0.05; 
        agent.y += (agent.targetY - agent.y) * 0.05; 
        agent.breathePhase += dt * 2; 
        shapes.forEach(s => { s.pulsePhase += dt * 5; s.phase += dt; });
        VFE.tick();
        AgentSpeech.updatePosition(agent.x, agent.y);
        
        // Auto-navigate
        autoNavigate(dt);
    }
    
    function render() {
        drawBackground();
        drawExplorationLine();
        shapes.forEach(drawShape);
        drawAgent();
    }
    
    let lastTime = 0;
    function animate(ts) {
        const dt = Math.min((ts - lastTime) / 1000, 0.1);
        lastTime = ts;
        update(dt);
        render();
        requestAnimationFrame(animate);
    }
    
    // ============================================================================
    // INIT
    // ============================================================================
    
    AgentSpeech.init();
    initializeShapes();
    CRR.updateDisplay();
    VFE.updateDisplay();
    NearTimeCoherence.updateDisplay();
    updateBeliefDisplay();
    requestAnimationFrame(animate);
    
    })();
    </script>

    <script>
        /**
         * Logo Animation and Navigation
         */
        class CRRHomepage {
            constructor() {
                this.animationTime = 0;
                this.isAnimating = true;
                this.rafId = null;
                this.elements = this.cacheElements();
                this.ruptureActive = false;
                this.ruptureStartTime = 0;
                this.init();
            }

            cacheElements() {
                return {
                    logo: document.querySelector('.logo'),
                    logoHive: document.querySelector('.logo-hive'),
                    bees: document.querySelectorAll('.logo-bee'),
                    interiorBees: document.querySelectorAll('[class*="interior-bee"]'),
                    navLinks: document.querySelectorAll('.nav-link')
                };
            }

            init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.start());
                } else {
                    this.start();
                }
            }

            start() {
                try {
                    this.setupLogoInteractions();
                    this.setupNavigationInteractions();
                    
                    if (!this.respectsReducedMotion()) {
                        this.startAnimation();
                    }
                    
                    this.setupVisibilityChange();
                } catch (error) {
                    console.error('Initialisation error:', error);
                }
            }

            setupLogoInteractions() {
                if (!this.elements.logo) return;

                this.elements.logo.addEventListener('click', () => {
                    this.triggerDiracRupture();
                });
            }

            triggerDiracRupture() {
                if (this.ruptureActive) return;

                this.ruptureActive = true;
                this.ruptureStartTime = this.animationTime;
                
                this.elements.logoHive.classList.add('rupture');
                
                setTimeout(() => {
                    this.elements.logoHive.classList.remove('rupture');
                }, 3000);

                setTimeout(() => {
                    this.ruptureActive = false;
                }, 4000);
            }

            setupNavigationInteractions() {
                this.elements.navLinks.forEach((link) => {
                    link.addEventListener('mouseenter', () => {
                        if (!link.classList.contains('active')) {
                            link.style.transform = 'translateY(-2px)';
                        }
                    });
                    
                    link.addEventListener('mouseleave', () => {
                        link.style.transform = 'translateY(0)';
                    });
                });
            }

            startAnimation() {
                const animate = () => {
                    if (!this.isAnimating) return;
                    
                    this.animationTime += 0.025;
                    this.animateBees();
                    this.animateInteriorBees();
                    
                    this.rafId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            animateBees() {
                this.elements.bees.forEach((bee, index) => {
                    if (this.ruptureActive) {
                        this.animateRuptureBees(bee, index);
                    } else {
                        this.animateNormalBees(bee, index);
                    }
                });
            }

            animateNormalBees(bee, index) {
                const baseAngle = (index * Math.PI * 0.5) + this.animationTime * (0.4 + index * 0.15);
                const radius = 20 + Math.sin(this.animationTime * 0.7 + index) * 6;
                
                const figure8 = Math.sin(this.animationTime * 0.6 + index * 0.8) * 8;
                
                const x = 50 + Math.cos(baseAngle) * radius + figure8 * Math.cos(baseAngle * 2);
                const y = 50 + Math.sin(baseAngle) * radius * 0.8 + figure8 * 0.3 * Math.sin(baseAngle * 3);
                
                bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                
                const wingBeat = 0.6 + 0.4 * Math.sin(this.animationTime * 12 + index * 2.5);
                bee.style.opacity = wingBeat;
            }

            animateRuptureBees(bee, index) {
                const elapsedTime = this.animationTime - this.ruptureStartTime;
                
                if (elapsedTime < 60) {
                    const disperseProgress = elapsedTime / 60;
                    const disperseAngle = (index * Math.PI * 0.5) + this.animationTime * (2.5 + index * 0.6);
                    const disperseRadius = 20 + disperseProgress * (70 + index * 12);
                    
                    const x = 50 + Math.cos(disperseAngle) * disperseRadius;
                    const y = 50 + Math.sin(disperseAngle) * disperseRadius;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.2 + 0.8 * Math.sin(this.animationTime * 25 + index * 3.5);
                    
                } else if (elapsedTime < 140) {
                    const recohereProgress = (elapsedTime - 60) / 80;
                    const smoothProgress = 1 - Math.pow(1 - recohereProgress, 3);
                    
                    const currentRadius = 90 - smoothProgress * 70;
                    const angle = (index * Math.PI * 0.5) + this.animationTime * (1.8 - smoothProgress * 1.4);
                    
                    const x = 50 + Math.cos(angle) * currentRadius;
                    const y = 50 + Math.sin(angle) * currentRadius * 0.8;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.6 + 0.4 * Math.sin(this.animationTime * (15 - smoothProgress * 5) + index * 2.5);
                }
            }

            animateInteriorBees() {
                this.elements.interiorBees.forEach((bee, index) => {
                    const movement = Math.sin(this.animationTime * 2.5 + index * 3.5) * 2;
                    const rotation = Math.sin(this.animationTime * 2 + index * 2.5) * 8;
                    
                    bee.setAttribute('transform', `translate(${movement}, ${movement * 0.6}) rotate(${rotation})`);
                });
            }

            setupVisibilityChange() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.isAnimating = false;
                        if (this.rafId) {
                            cancelAnimationFrame(this.rafId);
                        }
                    } else if (!this.respectsReducedMotion()) {
                        this.isAnimating = true;
                        this.startAnimation();
                    }
                });
            }

            respectsReducedMotion() {
                return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }

            destroy() {
                this.isAnimating = false;
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                }
            }
        }

        // Initialize
        new CRRHomepage();

        // Sol Invictus click handler — Trigger CME rupture
        (function() {
            const sun = document.getElementById('crrSun');
            if (!sun) return;
            
            sun.addEventListener('click', function() {
                sun.classList.remove('erupting');
                void sun.offsetWidth; // Force reflow
                sun.classList.add('erupting');
                setTimeout(() => sun.classList.remove('erupting'), 800);
            });
        })();
    </script>
</body>
</html>
