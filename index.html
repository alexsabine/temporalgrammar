<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cohere.org.uk - Mathematical Life and Living Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        .hero-guide-link {
    margin-top: 40px;
    text-align: center;
}
.guide-summary {
    font-family: Georgia, serif;
    font-size: 15px;
    font-style: italic;
    color: #6c757d;
    margin-bottom: 15px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}
.guide-button {
    display: inline-block;
    font-family: Georgia, serif;
    font-size: 16px;
    color: #4a90e2;
    text-decoration: none;
    padding: 12px 28px;
    border: 1px solid #4a90e2;
    border-radius: 4px;
    transition: all 0.3s ease;
}
.guide-button:hover {
    background: rgba(74, 144, 226, 0.08);
    transform: translateY(-2px);
}
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
            font-family: Georgia, serif;
            line-height: 1.6;
            color: #2c2c2c;
            overflow-x: hidden;
        }

        /* Main Container */
        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 60px;
        }

        /* Header Section */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .title-group {
            display: flex;
            flex-direction: column;
        }

        .site-title {
            font-family: Georgia, serif;
            font-size: 48px;
            font-weight: normal;
            color: #1a1a1a;
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .strapline {
            font-family: Georgia, serif;
            font-size: 18px;
            font-style: italic;
            color: #6c757d;
            letter-spacing: 0.5px;
        }

        /* Navigation System */
        .main-nav {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #495057;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #1a1a1a;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: #4a90e2;
            color: white;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .nav-item:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        /* Robust Dropdown Menu System */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 8px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 1000;
            overflow: hidden;
        }

        /* Critical: No gap between nav item and dropdown */
        .nav-item:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Keep dropdown visible when hovering over dropdown itself */
        .dropdown-menu:hover {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Ensure dropdown stays open during mouse travel */
        .nav-item::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-link {
            display: block;
            padding: 12px 20px;
            color: #495057;
            text-decoration: none;
            font-size: 16px;
            font-family: Georgia, serif;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #4a90e2;
            border-left-color: #4a90e2;
        }

        /* Hero Section */
        .hero-section {
            padding: 100px 0 80px;
            text-align: center;
            position: relative;
        }

        .hero-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(74, 144, 226, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(108, 117, 125, 0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 1;
        }

        .hero-title {
            font-family: Georgia, serif;
            font-size: 56px;
            font-weight: normal;
            line-height: 1.1;
            margin-bottom: 30px;
            color: #1a1a1a;
            letter-spacing: -1px;
        }

        .hero-subtitle {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            color: #495057;
            margin-bottom: 30px;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .hero-questions {
            max-width: 800px;
            margin: 0 auto;
            text-align: left;
            padding-left: 40px;
        }

        .hero-questions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .hero-questions li {
            font-family: Georgia, serif;
            font-size: 16px;
            font-style: italic;
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 8px;
            position: relative;
            padding-left: 20px;
        }

        .hero-questions li::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #4a90e2;
            font-size: 18px;
        }

        /* Content Sections */
        .content-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            position: relative;
        }

        .section-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(248, 249, 250, 0.5) 0%, transparent 100%);
            border-radius: 12px;
            pointer-events: none;
        }

        .section-content {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
        }

        .section-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .section-content p {
            font-family: Georgia, serif;
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 25px;
            text-align: justify;
        }

        .section-content h3 {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin: 35px 0 20px;
            color: #1a1a1a;
        }

        /* Framework Grid */
        .framework-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .framework-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 35px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .framework-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #4a90e2, #6c757d);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .framework-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.08);
        }

        .framework-item:hover::before {
            opacity: 1;
        }

        .framework-item h4 {
            font-family: Georgia, serif;
            font-size: 22px;
            font-weight: normal;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        .framework-item p {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #495057;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: left;
        }

        .framework-equation {
            background: rgba(74, 144, 226, 0.05);
            padding: 20px;
            border-left: 3px solid #4a90e2;
            border-radius: 4px;
            margin-top: 15px;
            text-align: center;
        }

        .equation-explanation {
            font-family: Georgia, serif;
            font-size: 13px;
            color: #6c757d;
            font-style: italic;
            margin-top: 10px;
            line-height: 1.4;
        }

        /* CRR Demo Section */
        .crr-demo-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        .demo-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 20px;
            color: #1a1a1a;
            text-align: center;
        }

        .demo-description {
            text-align: center;
            font-size: 16px;
            color: #6c757d;
            margin-bottom: 40px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

        .demo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .main-canvas-container {
            position: relative;
            width: 100%;
            max-width: 700px;
        }

        .main-canvas {
            width: 100%;
            height: 350px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .demo-metrics {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .metric {
            text-align: center;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            min-width: 140px;
        }

        .metric-label {
            font-family: Georgia, serif;
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .metric-value {
            font-family: Georgia, serif;
            font-size: 24px;
            color: #1a1a1a;
            font-weight: normal;
        }

        .metric-value.coherence { color: #4a90e2; }
        .metric-value.omega { color: #6c757d; }
        .metric-value.phase { color: #28a745; }

        .demo-explanation {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            margin-top: 40px;
            max-width: 900px;
        }

        .phase-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            text-align: center;
        }

        .phase-card h4 {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #1a1a1a;
            margin-bottom: 10px;
        }

        .phase-card p {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .phase-card .phase-equation {
            background: rgba(74, 144, 226, 0.05);
            padding: 12px;
            border-left: 3px solid #4a90e2;
            border-radius: 4px;
            font-size: 14px;
        }

        .phase-card.active {
            border-color: #4a90e2;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.15);
        }

        /* Research Grid */
        .research-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .research-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .research-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: linear-gradient(to right, #4a90e2, #6c757d);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .research-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }

        .research-item:hover::before {
            opacity: 1;
        }

        .research-item h4 {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #4a90e2;
            margin-bottom: 10px;
        }

        .research-item p {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            text-align: center;
        }

        /* Logo Animation */
        .logo-hive {
            position: relative;
            overflow: visible;
        }

        .logo-bee {
            position: absolute;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .logo-interior {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .logo:hover .logo-interior {
            opacity: 1;
        }

        .logo:hover .logo-bee {
            opacity: 0.3;
        }

        .logo-hive.rupture {
            animation: hiveGlow 3s ease-out;
        }

        @keyframes hiveGlow {
            0% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
            20% { filter: drop-shadow(0 0 20px rgba(74, 144, 226, 0.6)); }
            40% { filter: drop-shadow(0 0 30px rgba(74, 144, 226, 0.4)); }
            70% { filter: drop-shadow(0 0 15px rgba(74, 144, 226, 0.3)); }
            100% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
        }

        /* Footer */
        .footer {
            background: rgba(245, 246, 248, 0.9);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            padding: 50px 0 40px;
            text-align: center;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1000px;
            margin: 0 auto;
        }

        .copyright {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #1a1a1a;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .footer-tech-note {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            font-style: italic;
            line-height: 1.4;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .demo-explanation {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .framework-grid {
                grid-template-columns: 1fr;
            }

            .research-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .page-container {
                padding: 0 30px;
            }

            .header {
                flex-direction: column;
                gap: 30px;
                text-align: center;
                padding: 30px 0;
            }

            .logo-section {
                flex-direction: column;
                gap: 15px;
            }

            .logo {
                margin-right: 0;
            }

            .site-title {
                font-size: 36px;
            }

            .main-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            .dropdown-menu {
                position: static;
                opacity: 1;
                visibility: visible;
                transform: none;
                box-shadow: none;
                border: none;
                background: rgba(74, 144, 226, 0.05);
                margin-top: 10px;
                border-radius: 4px;
                display: none;
            }

            .nav-item:hover .dropdown-menu {
                display: block;
            }

            .hero-section {
                padding: 60px 0 40px;
            }

            .hero-title {
                font-size: 42px;
            }

            .hero-subtitle {
                font-size: 20px;
            }

            .hero-questions {
                padding-left: 20px;
            }

            .hero-questions li {
                font-size: 14px;
            }

            .content-section,
            .crr-demo-section {
                padding: 40px 25px;
                margin: 60px 0;
            }

            .section-title {
                font-size: 28px;
            }

            .research-grid {
                grid-template-columns: 1fr;
            }

            .demo-metrics {
                gap: 15px;
            }

            .metric {
                min-width: 100px;
                padding: 12px 15px;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header class="header">
            <div class="logo-section">               
                <div class="title-group">
                    <h1 class="site-title">Cohere.org.uk</h1>
                    <p class="strapline">A Temporal Grammar</p>
                </div>
            </div>

            <nav class="main-nav">
                <div class="nav-item">
                    <a href="index.html" class="nav-link active">Home</a>
                </div>
                <div class="nav-item">
                    <a href="crr-simulations.html" class="nav-link">
                        CRR Simulations
                        <span class="dropdown-arrow">▼</span>
                    </a>
                    <div class="dropdown-menu">
                        <a href="biological-systems.html" class="dropdown-link">Biological Systems</a>
                        <a href="physical-systems.html" class="dropdown-link">Physical Systems</a>
                        <a href="mathematical-life.html" class="dropdown-link">Mathematical Life</a>
                    </div>
                </div>
                <div class="nav-item">
                    <a href="crr-benchmarks.html" class="nav-link">CRR Benchmarks</a>
                </div>
                <div class="nav-item">
                    <a href="crr-explained.html" class="nav-link">CRR Explained</a>
                </div>
                <div class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </div>
            </nav>
        </header>

        <main>
            <section class="hero-section">
                <div class="hero-background"></div>
                <div class="hero-content">
                    <h2 class="hero-title">Coherence, Rupture, Regeneration</h2>
                    <p class="hero-subtitle">A coarse-grain mathematical framework for exploring transformation, and renewal in complex systems</p>
                    <div class="hero-questions">
                        <ul>
                            <li>How do complex systems maintain identity by processually changing through the Active Inference cycle?</li>
                            <li>How might shared phenomenological and mathematical languages help us better understand intelligence in a shared context?</li>
                            <li>How might we better understand and adapt to the psychological, sociological and ecological impacts of Technology on human and non-human species?</li>
                            <li>How might a minimal mathematical grammar of temporality help us to address contemporary issues of AI alignment, Emergent Capacities and Catastrophic Forgetting?</li>
                        </ul>
                    </div>
                </div>
            </section>
<div class="hero-guide-link">
    <p class="guide-summary">Explore CRR dynamics through interactive simulations spanning human development, attachment, cognition, contemplative practice, creativity, and AI safety.</p>
    <a href="guide.html" class="guide-button">Interactive Guide →</a>
</div>
            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">What is CRR?</h2>
                <div class="section-content">
                    <p>CRR formalises how systems accumulate history (Coherence), undergo discrete phase transitions when constraints reach threshold (Rupture), and reconstitute through exponentially-weighted memory selection (Regeneration). Grounded in process philosophy, CRR describes temporal structure as a mathematical grammar by which past becomes future across all scales.</p>

                    <div class="framework-grid">
                        <div class="framework-item">
                            <h4>Coherence</h4>
                            <p>How systems accumulate historical constraint over time. Coherence represents the temporal integration of structure; the past becoming present as accumulated pattern. When coherence reaches threshold (C=Ω), the system can no longer assimilate prediction error, triggering rupture.</p>
                            <div class="framework-equation">
                                $$C(x,t) = \int_0^t L(x,\tau) \, d\tau$$
                                <div class="equation-explanation">
                                    Where L(x,τ) represents information density accumulated at position x over time τ
                                </div>
                            </div>
                        </div>
                        <div class="framework-item">
                            <h4>Rupture</h4>
                            <p>The Dirac delta encodes the dimensionless present—the scale-free moment where C=Ω and phase transition occurs. At rupture, local coherence resets while historical coherence values remain accessible through the regeneration integral, enabling continuity through discontinuity.</p>
                            <div class="framework-equation">
                                $$\delta(t-t_0)$$
                                <div class="equation-explanation">
                                    A Dirac delta function encoding sudden disruptions at time t-zero when C=Omega (Markov Blanket saturation)
                                </div>
                            </div>
                        </div>
                        <div class="framework-item">
                            <h4>Regeneration</h4>
                            <p>The reconstruction process that builds new stable patterns by drawing upon accumulated historical information. Crucially, history is never lost, only selectively weighted. The exponential term exp(C/Ω) determines which past moments reconstitute, enabling continuity through transformation.</p>
                            <div class="framework-equation">
                                $$R[\chi](x,t) = \int_{-\infty}^t \phi(x,\tau) \cdot e^{C(x,\tau)/\Omega} \cdot \Theta(t-\tau) \, d\tau$$
                                <div class="equation-explanation">
                                    Where φ(x,τ) is the field function and Ω governs memory access depth: low Ω weights only highest-coherence moments (rigid reconstitution), high Ω accesses broader history (transformative change)
                                </div>
                            </div>
                        </div>
                    </div>

                    <p>This mathematical structure provides a way to study systems that exhibit memory-dependent behaviour; where past configurations influence present dynamics in ways that Markovian models might miss. The simulations on this site realise this three-part formalism in code, a playful way to explore the deeper mathematical, philosophical and phenomenological concept of how identity persists as change.</p>
                </div>
            </section>

            <section class="crr-demo-section" id="crrDemoSection">
                <style>
                    /* CRR Demo Specific Styles */
                    .crr-demo-section {
                        margin: 80px 0;
                        padding: 40px;
                        background: rgba(255, 255, 255, 0.95);
                        border: 1px solid rgba(0, 0, 0, 0.08);
                        border-radius: 12px;
                    }
                    
                    .demo-title {
                        font-family: Georgia, serif;
                        font-size: 32px;
                        font-weight: normal;
                        margin-bottom: 8px;
                        color: #1a1a1a;
                        text-align: center;
                    }
                    
                    .demo-subtitle {
                        font-family: Georgia, serif;
                        font-size: 16px;
                        font-style: italic;
                        color: #666;
                        text-align: center;
                        margin-bottom: 25px;
                    }
                    
                    .demo-layout {
                        display: grid;
                        grid-template-columns: 1fr 340px;
                        gap: 20px;
                    }
                    
                    @media (max-width: 900px) {
                        .demo-layout { grid-template-columns: 1fr; }
                    }
                    
                    .stage-container {
                        background: #faf8f4;
                        border: 1px solid #d4d0c8;
                        border-radius: 4px;
                        overflow: hidden;
                    }
                    
                    .stage-header {
                        padding: 10px 15px;
                        background: #f4f1ea;
                        border-bottom: 1px solid #d4d0c8;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }
                    
                    .stage-title-text {
                        font-family: Georgia, serif;
                        font-size: 14px;
                        font-weight: 500;
                        color: #1a1a1a;
                    }
                    
                    .auto-badge {
                        font-size: 11px;
                        padding: 3px 8px;
                        background: #234e70;
                        color: white;
                        border-radius: 3px;
                        font-family: Georgia, serif;
                    }
                    
                    #demoCanvas {
                        display: block;
                        width: 100%;
                        height: 380px;
                        cursor: default;
                    }
                    
                    .canvas-wrapper {
                        position: relative;
                    }
                    
                    .agent-speech {
                        position: absolute;
                        background: rgba(255, 255, 255, 0.95);
                        color: #333;
                        font: 13px Georgia, serif;
                        font-style: italic;
                        padding: 8px 12px;
                        border-radius: 12px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.15);
                        max-width: 160px;
                        opacity: 0;
                        transition: opacity 0.3s;
                        pointer-events: none;
                        z-index: 100;
                    }
                    
                    .agent-speech.visible { opacity: 1; }
                    
                    .agent-speech::after {
                        content: '';
                        position: absolute;
                        bottom: -8px;
                        left: 20px;
                        border-width: 8px 6px 0 6px;
                        border-style: solid;
                        border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
                    }
                    
                    /* Commentary Panel */
                    .commentary-panel {
                        background: #fff;
                        border: 1px solid #d4d0c8;
                        border-radius: 4px;
                        display: flex;
                        flex-direction: column;
                        max-height: 440px;
                        overflow: hidden;
                    }
                    
                    .commentary-header {
                        padding: 10px 15px;
                        background: #f4f1ea;
                        border-bottom: 1px solid #d4d0c8;
                        font-family: Georgia, serif;
                        font-weight: 500;
                        font-size: 14px;
                    }
                    
                    .commentary-content {
                        flex: 1;
                        padding: 12px;
                        overflow-y: auto;
                        font-family: Georgia, serif;
                    }
                    
                    /* CRR Display */
                    .crr-display {
                        background: linear-gradient(135deg, #f3e5f5, #ede7f6);
                        border: 1px solid #6a1b9a;
                        padding: 10px;
                        margin-bottom: 10px;
                        border-radius: 4px;
                    }
                    
                    .crr-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 8px;
                    }
                    
                    .crr-title {
                        font-size: 11px;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        color: #6a1b9a;
                        font-weight: 600;
                    }
                    
                    .crr-stage-badge {
                        font-size: 10px;
                        padding: 2px 8px;
                        background: #6a1b9a;
                        color: white;
                        border-radius: 2px;
                    }
                    
                    .crr-stage-badge.rupture {
                        background: #d32f2f;
                        animation: rupturePulse 0.3s infinite;
                    }
                    
                    .crr-stage-badge.regeneration {
                        background: #2e7d32;
                    }
                    
                    @keyframes rupturePulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.6; }
                    }
                    
                    .coherence-container { margin-bottom: 6px; }
                    
                    .coherence-label {
                        display: flex;
                        justify-content: space-between;
                        font-size: 12px;
                        margin-bottom: 4px;
                        color: #333;
                    }
                    
                    .coherence-bar {
                        height: 10px;
                        background: rgba(255,255,255,0.8);
                        border: 1px solid rgba(106,27,154,0.3);
                        position: relative;
                        overflow: hidden;
                        border-radius: 2px;
                    }
                    
                    .coherence-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #7b1fa2, #9c27b0, #ab47bc);
                        transition: width 0.4s ease-out;
                    }
                    
                    .coherence-fill.critical {
                        background: linear-gradient(90deg, #c62828, #d32f2f, #e53935);
                        animation: criticalPulse 0.5s infinite;
                    }
                    
                    @keyframes criticalPulse {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.7; }
                    }
                    
                    .omega-marker {
                        position: absolute;
                        right: 0;
                        top: -2px;
                        bottom: -2px;
                        width: 2px;
                        background: #d32f2f;
                    }
                    
                    .crr-math {
                        font-size: 11px;
                        color: #6a1b9a;
                        font-style: italic;
                        text-align: center;
                        padding-top: 6px;
                        border-top: 1px solid rgba(106,27,154,0.2);
                    }
                    
                    .stage-dots {
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        margin-top: 8px;
                        padding-top: 8px;
                        border-top: 1px solid rgba(106,27,154,0.2);
                    }
                    
                    .stage-dot-container {
                        display: flex;
                        gap: 4px;
                    }
                    
                    .stage-dot {
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: rgba(106,27,154,0.2);
                    }
                    
                    .stage-dot.completed { background: #6a1b9a; }
                    .stage-dot.current { background: #6a1b9a; animation: dotPulse 1s infinite; }
                    
                    @keyframes dotPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.3); }
                    }
                    
                    .stage-name {
                        font-size: 12px;
                        color: #6a1b9a;
                        font-style: italic;
                    }
                    
                    /* Dynamics Display */
                    .dynamics-display {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 8px;
                        margin-bottom: 10px;
                    }
                    
                    .dynamics-bar-container {
                        padding: 8px;
                        border: 1px solid #d4d0c8;
                        background: #fff;
                        border-radius: 3px;
                    }
                    
                    .dynamics-bar-container.fep { border-left: 3px solid #234e70; }
                    .dynamics-bar-container.crr-work { border-left: 3px solid #6a1b9a; }
                    
                    .dynamics-label {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 4px;
                    }
                    
                    .dynamics-title {
                        font-size: 10px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        font-weight: 600;
                    }
                    
                    .dynamics-bar-container.fep .dynamics-title { color: #234e70; }
                    .dynamics-bar-container.crr-work .dynamics-title { color: #6a1b9a; }
                    
                    .dynamics-value {
                        font-size: 11px;
                        font-style: italic;
                    }
                    
                    .dynamics-bar {
                        height: 6px;
                        background: #f4f1ea;
                        border: 1px solid #d4d0c8;
                        overflow: hidden;
                        border-radius: 2px;
                    }
                    
                    .dynamics-fill {
                        height: 100%;
                        transition: width 0.4s ease-out;
                    }
                    
                    .dynamics-bar-container.fep .dynamics-fill {
                        background: linear-gradient(90deg, #1565c0, #1e88e5, #42a5f5);
                    }
                    
                    .dynamics-bar-container.crr-work .dynamics-fill {
                        background: linear-gradient(90deg, #7b1fa2, #9c27b0, #ba68c8);
                    }
                    
                    .dynamics-subtext {
                        font-size: 9px;
                        color: #888;
                        font-style: italic;
                        margin-top: 3px;
                    }
                    
                    /* Status */
                    .status-indicator {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        margin-bottom: 10px;
                        padding: 8px 10px;
                        background: #f4f1ea;
                        border: 1px solid #d4d0c8;
                        border-radius: 3px;
                    }
                    
                    .status-dot {
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: #999;
                    }
                    
                    .status-dot.idle { background: #999; }
                    .status-dot.exploring { background: #ff9800; animation: statusPulse 1s infinite; }
                    .status-dot.surprise { background: #c62828; animation: statusPulse 0.5s infinite; }
                    .status-dot.learning { background: #234e70; animation: statusPulse 0.8s infinite; }
                    
                    @keyframes statusPulse {
                        0%, 100% { opacity: 1; transform: scale(1); }
                        50% { opacity: 0.6; transform: scale(1.2); }
                    }
                    
                    .status-text {
                        font-size: 12px;
                        color: #666;
                        font-style: italic;
                    }
                    
                    /* Commentary */
                    .commentary-text {
                        font-size: 13px;
                        line-height: 1.6;
                        margin-bottom: 10px;
                        color: #333;
                    }
                    
                    /* Framework Comparison */
                    .framework-comparison {
                        display: none;
                        grid-template-columns: 1fr 1fr 1fr;
                        gap: 6px;
                        margin-top: 10px;
                    }
                    
                    .framework-comparison.visible { display: grid; }
                    
                    .framework-box {
                        padding: 8px;
                        font-size: 12px;
                        border-left: 3px solid;
                        border-radius: 2px;
                    }
                    
                    .framework-box.piaget { background: #f5ebe0; border-left-color: #8b4513; }
                    .framework-box.fep { background: #e8f0f5; border-left-color: #234e70; }
                    .framework-box.crr { background: #f3e5f5; border-left-color: #6a1b9a; }
                    
                    .framework-label {
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        font-weight: 600;
                        margin-bottom: 2px;
                    }
                    
                    .piaget .framework-label { color: #8b4513; }
                    .fep .framework-label { color: #234e70; }
                    .crr .framework-label { color: #6a1b9a; }
                    
                    .framework-term {
                        font-weight: 600;
                        font-size: 12px;
                        font-style: italic;
                    }
                    
                    .framework-desc {
                        color: #666;
                        font-size: 10px;
                        margin-top: 2px;
                    }
                    
                    /* Prediction/Error */
                    .prediction-display {
                        display: none;
                        margin-top: 8px;
                        padding: 8px;
                        background: #fff8e1;
                        border: 1px solid #ffca28;
                        font-size: 12px;
                        border-radius: 3px;
                    }
                    
                    .prediction-display.visible { display: block; }
                    
                    .prediction-title {
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        color: #f57f17;
                        margin-bottom: 4px;
                        font-weight: 600;
                    }
                    
                    .error-display {
                        display: none;
                        margin-top: 6px;
                        padding: 8px;
                        background: #ffebee;
                        border: 1px solid #c62828;
                        font-size: 12px;
                        border-radius: 3px;
                    }
                    
                    .error-display.visible { display: block; }
                    .error-display.low-error { background: #e8f5e9; border-color: #2e7d32; }
                    
                    .error-title {
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        color: #c62828;
                        margin-bottom: 4px;
                        font-weight: 600;
                    }
                    
                    .error-display.low-error .error-title { color: #2e7d32; }
                    
                    /* Math note */
                    .math-note {
                        display: none;
                        background: #2c2c2c;
                        color: #e0e0e0;
                        padding: 8px 10px;
                        font-size: 11px;
                        font-style: italic;
                        margin-top: 8px;
                        border-left: 3px solid #666;
                        border-radius: 2px;
                    }
                    
                    .math-note.visible { display: block; }
                    
                    .math-note .label {
                        color: #aaa;
                        font-size: 9px;
                        text-transform: uppercase;
                        letter-spacing: 0.06em;
                        display: block;
                        margin-bottom: 3px;
                        font-style: normal;
                    }
                    
                    /* Beliefs */
                    .model-display {
                        background: #f4f1ea;
                        border: 1px solid #d4d0c8;
                        padding: 10px;
                        margin-top: 10px;
                        border-radius: 3px;
                    }
                    
                    .model-title {
                        font-size: 10px;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        color: #666;
                        margin-bottom: 8px;
                    }
                    
                    .belief-item {
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        margin-bottom: 4px;
                        padding: 5px 8px;
                        background: #fff;
                        border: 1px solid #d4d0c8;
                        font-size: 11px;
                        border-radius: 2px;
                    }
                    
                    .belief-item.new { background: #e8f5e9; border-color: #2e7d32; }
                    
                    .belief-icon {
                        width: 18px;
                        height: 18px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                    }
                    
                    .belief-text { flex: 1; }
                    .belief-name { font-weight: 500; font-size: 11px; }
                    .belief-details { font-size: 9px; color: #666; font-style: italic; }
                    
                    .confidence-bar {
                        width: 25px;
                        height: 3px;
                        background: #d4d0c8;
                        border-radius: 1px;
                    }
                    
                    .confidence-fill {
                        height: 100%;
                        background: #2e7d32;
                        transition: width 0.4s;
                        border-radius: 1px;
                    }
                    
                    /* Rupture overlay */
                    .rupture-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(211,47,47,0);
                        pointer-events: none;
                        z-index: 1000;
                    }
                    
                    .rupture-overlay.active {
                        animation: ruptureFlash 2s ease-out;
                    }
                    
                    @keyframes ruptureFlash {
                        0% { background: rgba(211,47,47,0); }
                        10% { background: rgba(211,47,47,0.3); }
                        30% { background: rgba(211,47,47,0.15); }
                        50% { background: rgba(106,27,154,0.2); }
                        100% { background: rgba(106,27,154,0); }
                    }
                </style>
                
                <div class="rupture-overlay" id="ruptureOverlay"></div>
                
                <h2 class="demo-title">Active Inference & CRR in Action</h2>
                <p class="demo-subtitle">Learning through coherence, rupture, and regeneration — watch the agent explore automatically</p>
                
                <div class="demo-layout">
                    <div class="stage-container">
                        <div class="stage-header">
                            <span class="stage-title-text">The Agent's World</span>
                            <span class="auto-badge">Auto-exploring</span>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="demoCanvas"></canvas>
                            <div class="agent-speech" id="agentSpeech"></div>
                        </div>
                    </div>
                    
                    <div class="commentary-panel">
                        <div class="commentary-header">Understanding the Process</div>
                        <div class="commentary-content">
                            <div class="crr-display">
                                <div class="crr-header">
                                    <span class="crr-title">Coherence C(t) = ∫L(τ)dτ</span>
                                    <span class="crr-stage-badge" id="crrStage">Coherence</span>
                                </div>
                                <div class="coherence-container">
                                    <div class="coherence-label">
                                        <span>C(t) = <span id="coherenceValue">0.000</span></span>
                                        <span>Ω = <span id="omegaValue">1.00</span></span>
                                    </div>
                                    <div class="coherence-bar">
                                        <div class="coherence-fill" id="coherenceFill" style="width: 0%"></div>
                                        <div class="omega-marker"></div>
                                    </div>
                                </div>
                                <div class="crr-math" id="crrMath">C(t) = ∫L(τ)dτ — cumulative adaptive work</div>
                                <div class="stage-dots">
                                    <div class="stage-dot-container">
                                        <div class="stage-dot current" id="stageDot1"></div>
                                        <div class="stage-dot" id="stageDot2"></div>
                                        <div class="stage-dot" id="stageDot3"></div>
                                        <div class="stage-dot" id="stageDot4"></div>
                                        <div class="stage-dot" id="stageDot5"></div>
                                    </div>
                                    <span class="stage-name" id="stageName">Stage I: Simple Forms</span>
                                </div>
                            </div>
                            
                            <div class="dynamics-display">
                                <div class="dynamics-bar-container fep">
                                    <div class="dynamics-label">
                                        <span class="dynamics-title">Free Energy F</span>
                                        <span class="dynamics-value" id="vfeValue">F = 1.00</span>
                                    </div>
                                    <div class="dynamics-bar">
                                        <div class="dynamics-fill" id="vfeFill" style="width: 100%"></div>
                                    </div>
                                    <div class="dynamics-subtext">↓ reduced by learning</div>
                                </div>
                                <div class="dynamics-bar-container crr-work">
                                    <div class="dynamics-label">
                                        <span class="dynamics-title">Near-time C<sub>Δ</sub></span>
                                        <span class="dynamics-value" id="accumWorkValue">C_Δ = 0.000</span>
                                    </div>
                                    <div class="dynamics-bar">
                                        <div class="dynamics-fill" id="accumWorkFill" style="width: 0%"></div>
                                    </div>
                                    <div class="dynamics-subtext">↑ recent adaptive load</div>
                                </div>
                            </div>
                            
                            <div class="status-indicator">
                                <div class="status-dot idle" id="statusDot"></div>
                                <span class="status-text" id="statusText">Agent exploring automatically...</span>
                            </div>
                            
                            <div id="commentaryText" class="commentary-text">
                                This agent learns through <em>Active Inference</em> (minimising free energy F) and <em>CRR</em> (cumulative adaptive work C toward capacity Ω). Key insight: <strong>larger errors = more work = faster coherence growth</strong>.
                            </div>
                            
                            <div class="framework-comparison" id="frameworkComparison">
                                <div class="framework-box piaget">
                                    <div class="framework-label">Piaget</div>
                                    <div class="framework-term" id="piagetTerm">—</div>
                                    <div class="framework-desc" id="piagetDesc"></div>
                                </div>
                                <div class="framework-box fep">
                                    <div class="framework-label">Active Inference</div>
                                    <div class="framework-term" id="fepTerm">—</div>
                                    <div class="framework-desc" id="fepDesc"></div>
                                </div>
                                <div class="framework-box crr">
                                    <div class="framework-label">CRR</div>
                                    <div class="framework-term" id="crrTerm">—</div>
                                    <div class="framework-desc" id="crrDesc"></div>
                                </div>
                            </div>
                            
                            <div class="prediction-display" id="predictionDisplay">
                                <div class="prediction-title">Agent's Prediction</div>
                                <div id="predictionContent"></div>
                            </div>
                            
                            <div class="error-display" id="errorDisplay">
                                <div class="error-title">Prediction Error</div>
                                <div id="errorContent"></div>
                            </div>
                            
                            <div class="math-note" id="mathNote">
                                <span class="label">Formal notation</span>
                                <span id="mathContent"></span>
                            </div>
                            
                            <div class="model-display">
                                <div class="model-title">Agent's Generative Model</div>
                                <div id="beliefsList"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Why CRR?</h2>
                <div class="section-content">
                    <h3>Coherence</h3>
                    <p>Systems, from atoms to technological networks to whole ecosystems, exhibit organised patterns that persist through time. Understanding how coherence resists entropy over time offers potential insight for maintaining and creating more stable and resilient systems in various domains.</p>

                    <h3>Rupture</h3>
                    <p>Complex systems frequently undergo periods of reorganisation at various spatial and temporal scales. Rather than viewing these transitions as purely disruptive, the CRR framework examines how such events create space for system adaptation and novel emergent properties. The 'scale-free' nature of the CRR and Dirac Delta makes it a good candidate for modelling the ever-present moment of "now" as a temporal 'rupture' where agentic choice occurs as free will. This choice is based on all past states that have accumulated up to the present moment. Over time, the choices we make build patterns that work, but also accumulated friction, prediction errors. Depending on how we slice time, this can cause sudden change and subsequent Regeneration.</p>

                    <h3>Regeneration</h3>
                    <p>Future states are dependent on what most effectively build coherence and reduced Variational Free Energy in the past. Natural systems, for example, demonstrate remarkable abilities to recover and adapt following disruptions. The Regeneration component of CRR explores how systems use accumulated information to guide reconstruction processes; informing approaches to resilience in engineered systems. Depending on how one 'slices time', rupture is always inevitable, but Regeneration is what "heals". The euler's exponential means that the past is never the same, the system transforms exponentially.</p>

            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Research Interests</h2>
                <div class="section-content">
                    <p>This work may be of interest to researchers exploring mathematical approaches to complex systems. Potential areas of collaboration include:</p>

                    <div class="research-grid">
                        <div class="research-item">
                            <h4>Computational Biology</h4>
                            <p>Mathematical models of development, adaptation, and ecosystem dynamics</p>
                        </div>
                        <div class="research-item">
                            <h4>Dynamical Systems</h4>
                            <p>Non-Markovian processes and memory-dependent dynamics</p>
                        </div>
                        <div class="research-item">
                            <h4>Machine Learning</h4>
                            <p>Continual learning and memory-augmented neural networks</p>
                        </div>
                        <div class="research-item">
                            <h4>Pattern Formation</h4>
                            <p>Reaction-diffusion systems with memory effects</p>
                        </div>
                        <div class="research-item">
                            <h4>Network Science</h4>
                            <p>Adaptive networks and resilience mechanisms</p>
                        </div>
                        <div class="research-item">
                            <h4>Cognitive Science</h4>
                            <p>Mathematical approaches to Psychology and Development</p>
                        </div>
                        <div class="research-item">
                            <h4>Systems Biology</h4>
                            <p>Mathematical frameworks for biological complexity</p>
                        </div>
                        <div class="research-item">
                            <h4>Applied Mathematics</h4>
                            <p>Novel mathematical structures and computational methods</p>
                        </div>
                        <div class="research-item">
                            <h4>Philosophy</h4>
                            <p>Philosophical conjecture and ontological lens</p>
                        </div>
                    </div>

                    <p style="text-align: center; margin-top: 40px; font-size: 18px; color: #4a90e2;">
                        Interested in collaborative research? Contact: <strong>alexander@cohere.org.uk</strong>
                    </p>
                </div>
            </section>
        </main>
    </div>

<footer class="footer">
    <div class="page-container">
        <div class="footer-content">
            <p class="copyright">
                <strong>GitHub Repository:</strong> <a href="https://github.com/alexsabine/CRR/" target="_blank" rel="noopener noreferrer" style="color: #4a90e2; text-decoration: none;">github.com/alexsabine/CRR</a>
            </p>
            <p class="copyright" style="margin-top: 15px;">
                <strong>Season's Greetings from Cohere:</strong> <a href="https://www.cohere.org.uk/crr-forest-seasonal.html" target="_blank" rel="noopener noreferrer" style="color: #4a90e2; text-decoration: none;">cohere.org.uk/crr-forest-seasonal</a>
                <strong>CRR Art:</strong> <a href="https://www.cohere.org.uk/CRR_Art.html" target="_blank" rel="noopener noreferrer" style="color: #4a90e2; text-decoration: none;">cohere.org.uk/CRR_Art.html</a> 
                <strong>Proof Sketches in 12 domains</strong> <a href="https://www.cohere.org.uk/crr_first_principles_proofs.md" target="_blank" rel="noopener noreferrer" style="color: #4a90e2; text-decoration: none;">cohere.org.uk/crr_first_principles_proofs.md</a>
            </p>
            <p class="footer-tech-note">
                Note: These simulations utilise HTML5, WebGL2, and advanced JavaScript. Desktop browsers recommended for optimal performance.
            </p>
        </div>
    </div>
</footer>

    <script>
    // ============================================================================
    // AUTO-PLAYING FEP-CRR DEMONSTRATION
    // Faithful recreation of original with automatic navigation
    // ============================================================================
    
    (function() {
    'use strict';
    
    const canvas = document.getElementById('demoCanvas');
    const ctx = canvas.getContext('2d');
    let W, H;
    
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        W = rect.width;
        H = rect.height;
    }
    resizeCanvas();
    window.addEventListener('resize', () => { resizeCanvas(); initializeShapes(); });
    
    // ============================================================================
    // CRR SYSTEM - Exact from original
    // ============================================================================
    
    const CRR = {
        coherence: 0,
        omega: 1.0,
        stage: 1,
        maxStage: 5,
        phase: 'coherence',
        
        addCoherence(L) {
            if (this.phase !== 'coherence') return;
            this.coherence += L;
            this.updateDisplay();
            if (this.coherence >= this.omega) this.triggerRupture();
        },
        
        async triggerRupture() {
            this.phase = 'rupture';
            this.updateDisplay();
            document.getElementById('ruptureOverlay').classList.add('active');
            
            // Enhanced rupture messaging
            AgentSpeech.say("Local minimum reached — transformation required!", 2500);
            
            updateCommentary(
                `RUPTURE! C(t) = Ω. Local free energy minimum exhausted. Current structure cannot accommodate further learning — phase transition required.`,
                { term: 'First Passage', desc: 'Capacity threshold crossed' },
                { term: 'Basin Exhausted', desc: 'No further descent possible' },
                { term: 'δ(now)', desc: 'Punctuated equilibrium' },
                `C = Ω = ${this.omega.toFixed(2)} — structural reorganisation imminent`
            );
            
            await delay(2500);
            this.phase = 'regeneration';
            this.updateDisplay();
            
            AgentSpeech.say("Regenerating... new complexity emerging!", 2000);
            
            updateCommentary(
                `REGENERATION. Higher-order structure emerges. New environment will inject fresh free energy — the cycle continues at greater complexity.`,
                { term: 'Reorganisation', desc: 'Qualitative change' },
                { term: 'R = ∫Φ·exp(C/Ω)·Θ', desc: 'Memory-weighted reconstruction' },
                { term: 'exp(1) = e', desc: 'Euler calibration at rupture' },
                `Stage ${this.stage} → Stage ${Math.min(this.stage + 1, this.maxStage)}`
            );
            
            await delay(2000);
            
            this.stage = Math.min(this.stage + 1, this.maxStage);
            this.coherence = 0;
            this.phase = 'coherence';
            
            document.getElementById('ruptureOverlay').classList.remove('active');
            await regenerateWorld();
            this.updateDisplay();
        },
        
        updateDisplay() {
            const fill = document.getElementById('coherenceFill');
            const valueEl = document.getElementById('coherenceValue');
            const stageEl = document.getElementById('crrStage');
            const mathEl = document.getElementById('crrMath');
            const stageNameEl = document.getElementById('stageName');
            
            const pct = Math.min((this.coherence / this.omega) * 100, 100);
            fill.style.width = pct + '%';
            valueEl.textContent = this.coherence.toFixed(3);
            fill.classList.toggle('critical', pct > 85 && this.phase === 'coherence');
            
            if (this.phase === 'rupture') {
                stageEl.textContent = 'RUPTURE δ(now)';
                stageEl.className = 'crr-stage-badge rupture';
                mathEl.textContent = 'C(t*) = Ω — first passage to capacity';
            } else if (this.phase === 'regeneration') {
                stageEl.textContent = 'Regenerating...';
                stageEl.className = 'crr-stage-badge regeneration';
                mathEl.textContent = 'R = ∫Φ·exp(C/Ω)·Θ dτ — causal reconstruction';
            } else {
                stageEl.textContent = 'Coherence';
                stageEl.className = 'crr-stage-badge';
                mathEl.textContent = 'C(t) = ∫L(τ)dτ — cumulative adaptive work';
            }
            
            for (let i = 1; i <= 5; i++) {
                const dot = document.getElementById('stageDot' + i);
                dot.className = 'stage-dot';
                if (i < this.stage) dot.classList.add('completed');
                if (i === this.stage) dot.classList.add('current');
            }
            
            const names = ['Stage I: Simple Forms', 'Stage II: Compound', 'Stage III: Dynamic', 'Stage IV: Emergent', 'Stage V: Meta-CRR'];
            stageNameEl.textContent = names[Math.min(this.stage - 1, 4)];
        },
        
        reset() {
            this.coherence = 0;
            this.stage = 1;
            this.phase = 'coherence';
            this.updateDisplay();
        }
    };
    
    // ============================================================================
    // SHAPE DEFINITIONS - Exact from original
    // ============================================================================
    
    const SHAPE_TYPES = {
        circle: { name: 'Circle', stage: 1 }, triangle: { name: 'Triangle', stage: 1 },
        square: { name: 'Square', stage: 1 }, pentagon: { name: 'Pentagon', stage: 1 },
        hexagon: { name: 'Hexagon', stage: 1 }, star: { name: 'Star', stage: 1 },
        ring: { name: 'Ring', stage: 2 }, triangleInCircle: { name: 'Inscribed Triangle', stage: 2 },
        nestedSquares: { name: 'Nested Squares', stage: 2 }, hexStar: { name: 'Hex-Star', stage: 2 },
        crescentMoon: { name: 'Crescent', stage: 2 }, diamond: { name: 'Diamond', stage: 2 },
        spiral: { name: 'Spiral', stage: 3 }, pulsingStar: { name: 'Pulsing Star', stage: 3 },
        fractalTriangle: { name: 'Fractal Triangle', stage: 3 }, flowField: { name: 'Flow Field', stage: 3 },
        interference: { name: 'Interference', stage: 3 }, mandala: { name: 'Mandala', stage: 3 },
        flock: { name: 'Flocking Swarm', stage: 4, emergent: true },
        phaseTransition: { name: 'Phase Transition', stage: 4, emergent: true },
        coupledOscillators: { name: 'Coupled Oscillators', stage: 4, emergent: true },
        reactionDiffusion: { name: 'Reaction-Diffusion', stage: 4, emergent: true },
        cellularAutomata: { name: 'Cellular Automata', stage: 4, emergent: true },
        bifurcation: { name: 'Bifurcation', stage: 4, emergent: true },
        crrOscillator: { name: 'CRR Oscillator', stage: 5, metaCRR: true },
        coherenceWave: { name: 'Coherence Wave', stage: 5, metaCRR: true },
        ruptureBloom: { name: 'Rupture Bloom', stage: 5, metaCRR: true },
        regenerativeSpiral: { name: 'Regenerative Spiral', stage: 5, metaCRR: true },
        nestedCRR: { name: 'Nested CRR', stage: 5, metaCRR: true },
        autopoieticRing: { name: 'Autopoietic Ring', stage: 5, metaCRR: true }
    };
    
    const COLORS = {
        red: { name: 'Red', hex: '#e53935' }, blue: { name: 'Blue', hex: '#1e88e5' },
        green: { name: 'Green', hex: '#43a047' }, yellow: { name: 'Yellow', hex: '#fdd835' },
        purple: { name: 'Purple', hex: '#8e24aa' }, orange: { name: 'Orange', hex: '#fb8c00' },
        cyan: { name: 'Cyan', hex: '#00acc1' }, pink: { name: 'Pink', hex: '#d81b60' },
        indigo: { name: 'Indigo', hex: '#3949ab' }, teal: { name: 'Teal', hex: '#00897b' }
    };
    
    const SIZES = { small: { name: 'Small', radius: 25 }, medium: { name: 'Medium', radius: 38 }, large: { name: 'Large', radius: 50 } };
    
    // ============================================================================
    // WORLD STATE
    // ============================================================================
    
    let shapes = [];
    let agent = { x: 60, y: 190, targetX: 60, targetY: 190, size: 16, state: 'idle', currentTarget: null, breathePhase: 0 };
    let generativeModel = { shapes: {}, colors: {}, sizes: {}, abstractions: [] };
    let time = 0, worldPhase = 0;
    
    // Auto-navigation
    let autoNavTimer = 0;
    let autoNavDelay = 1.5;
    let wanderTimer = 0;
    let isWandering = false;
    
    // ============================================================================
    // VFE & NEAR-TIME COHERENCE - Exact from original
    // ============================================================================
    
    let VFE = {
        current: 1.0,
        initial: 1.0,
        externalDrive: 0,
        cumulativeDrive: 0,
        
        update(predictionError, isNovelStimulus) {
            if (isNovelStimulus) {
                this.externalDrive = 0.15 + predictionError * 0.2;
                this.cumulativeDrive += this.externalDrive;
                this.current = Math.min(1.0, this.current + this.externalDrive * 0.5);
            } else {
                this.externalDrive = 0.02;
                this.cumulativeDrive += this.externalDrive;
            }
        },
        
        onLearning(workDone) {
            const baseline = 0.1 + CRR.stage * 0.02;
            const drop = Math.max(0.05, workDone * 1.5);
            this.current = Math.max(baseline, this.current - drop);
        },
        
        tick() { this.updateDisplay(); },
        
        updateDisplay() {
            const pct = Math.max(0, Math.min(100, this.current * 100));
            document.getElementById('vfeFill').style.width = pct + '%';
            document.getElementById('vfeValue').textContent = `F = ${this.current.toFixed(2)}`;
        },
        
        reset() {
            this.current = 1.0;
            this.initial = 1.0;
            this.externalDrive = 0;
            this.cumulativeDrive = 0;
            this.updateDisplay();
        }
    };
    
    let NearTimeCoherence = {
        window: [],
        windowSize: 8,
        current: 0,
        
        addWork(L) {
            this.window.push(L);
            if (this.window.length > this.windowSize) this.window.shift();
            this.current = this.window.reduce((a, b) => a + b, 0) / this.windowSize;
            this.updateDisplay();
        },
        
        updateDisplay() {
            const normalized = Math.min(1, this.current / 0.12);
            const pct = normalized * 100;
            const fill = document.getElementById('accumWorkFill');
            fill.style.width = pct + '%';
            fill.classList.toggle('critical', normalized > 0.7);
            document.getElementById('accumWorkValue').textContent = `C_Δ = ${this.current.toFixed(3)}`;
        },
        
        reset() {
            this.window = [];
            this.current = 0;
            this.updateDisplay();
        }
    };
    
    // ============================================================================
    // TUNED CONSTANTS (Verified by Python Simulation v2.0)
    // ============================================================================
    
    const CRR_KAPPA = 0.20;                    // Scaling factor: L = Ω·ε²·κ
    const ERROR_UNKNOWN_SHAPE = 0.60;          // Never seen this shape type
    const ERROR_DISRUPTED_SHAPE = 0.35;        // Schema disrupted by regeneration
    const ERROR_UNKNOWN_COLOR = 0.25;          // Never seen this color
    const ERROR_BASELINE = 0.12;               // Everything familiar
    const ERROR_REVISIT = 0.06;                // High-confidence revisit
    const INTEGRATION_WORK_MIN = 0.04;
    const INTEGRATION_WORK_MAX = 0.07;
    const PROB_REVISIT_DURING_EXPLORATION = 0.12;
    const PROB_REVISIT_AFTER_EXPLORATION = 0.40;
    
    function calculateAdaptiveWork(predictionError, omega = 1.0) {
        // L = Ω · ε² · κ (verified by Python)
        return omega * (predictionError * predictionError) * CRR_KAPPA;
    }
    
    function calculateIntegrationWork() {
        return INTEGRATION_WORK_MIN + Math.random() * (INTEGRATION_WORK_MAX - INTEGRATION_WORK_MIN);
    }
    
    // ============================================================================
    // AGENT SPEECH - Exact from original
    // ============================================================================
    
    const AgentSpeech = {
        element: null,
        timeout: null,
        
        init() { this.element = document.getElementById('agentSpeech'); },
        
        say(text, duration = 2500) {
            if (this.timeout) clearTimeout(this.timeout);
            this.element.textContent = text;
            this.element.classList.add('visible');
            this.timeout = setTimeout(() => { this.element.classList.remove('visible'); }, duration);
        },
        
        updatePosition(x, y) {
            this.element.style.left = (x - 20) + 'px';
            this.element.style.top = (y - 70) + 'px';
        },
        
        hide() {
            if (this.timeout) clearTimeout(this.timeout);
            this.element.classList.remove('visible');
        }
    };
    
    // Inner monologue - Exact from original
    const innerMonologue = {
        approaching: ["What's this...?", "Let me see...", "Interesting...", "I wonder...", "Something to explore..."],
        predicting: ["I think I know this...", "This looks familiar...", "My model predicts...", "Expecting..."],
        predictingNovel: ["I have no model for this...", "Complete novelty...", "What could it be?", "Unknown territory..."],
        surprised: ["Large error! Much work to do...", "Big mismatch! Steep gradient...", "Significant updating needed...", "This adds a lot to C(t)..."],
        confirmedHigh: ["Small error. Minimal work.", "Prediction was close!", "Gentle gradient descent...", "Easy update."],
        confirmedLow: ["Some adjustment needed...", "Moderate work here...", "Partial match...", "Some gradient to descend..."],
        learning: ["Updating beliefs...", "Descending the gradient...", "Reducing free energy...", "Model adjusting..."],
        learningNovel: ["New schema forming!", "Significant restructuring...", "Major model update...", "Accommodating novelty..."],
        mastery: ["Environment fully explored.", "All patterns encountered.", "Work accumulating...", "Approaching capacity..."],
        nearRupture: ["Cumulative work nearing Ω...", "Capacity almost reached...", "C(t) → Ω...", "Transformation imminent..."],
        rupture: ["C = Ω! First passage!", "Capacity reached!", "δ(now)!", "Rupture threshold!"],
        regeneration: ["C resets to zero...", "New cycle begins...", "Regenerating structure...", "Higher complexity awaits..."],
        stage5Insight: ["This pattern... it's like me!", "I see CRR in these shapes...", "Self-similar dynamics...", "The pattern recognises itself..."],
        wandering: ["Consolidating...", "Integrating knowledge...", "Processing...", "Reflecting on schemas..."]
    };
    
    function getRandomPhrase(category) {
        const phrases = innerMonologue[category];
        return phrases[Math.floor(Math.random() * phrases.length)];
    }
    
    // ============================================================================
    // STAGE CONFIGS - Exact from original
    // ============================================================================
    
    function getStageConfigs(stage) {
        const configs = {
            1: [
                { type: 'circle', color: 'red', size: 'medium' }, { type: 'triangle', color: 'blue', size: 'large' },
                { type: 'square', color: 'green', size: 'small' }, { type: 'pentagon', color: 'yellow', size: 'medium' },
                { type: 'circle', color: 'purple', size: 'small' }, { type: 'star', color: 'orange', size: 'large' },
                { type: 'hexagon', color: 'cyan', size: 'small' }, { type: 'triangle', color: 'pink', size: 'medium' }
            ],
            2: [
                { type: 'ring', color: 'cyan', size: 'large' }, { type: 'triangleInCircle', color: 'purple', size: 'medium' },
                { type: 'nestedSquares', color: 'orange', size: 'large' }, { type: 'hexStar', color: 'blue', size: 'medium' },
                { type: 'crescentMoon', color: 'yellow', size: 'large' }, { type: 'diamond', color: 'pink', size: 'medium' },
                { type: 'ring', color: 'green', size: 'small' }, { type: 'nestedSquares', color: 'red', size: 'small' }
            ],
            3: [
                { type: 'spiral', color: 'purple', size: 'large' }, { type: 'pulsingStar', color: 'orange', size: 'medium' },
                { type: 'fractalTriangle', color: 'cyan', size: 'large' }, { type: 'flowField', color: 'blue', size: 'large' },
                { type: 'interference', color: 'pink', size: 'medium' }, { type: 'mandala', color: 'green', size: 'large' },
                { type: 'spiral', color: 'red', size: 'medium' }, { type: 'pulsingStar', color: 'yellow', size: 'small' }
            ],
            4: [
                { type: 'flock', color: 'blue', size: 'large' }, { type: 'phaseTransition', color: 'purple', size: 'large' },
                { type: 'coupledOscillators', color: 'orange', size: 'medium' }, { type: 'reactionDiffusion', color: 'cyan', size: 'large' },
                { type: 'cellularAutomata', color: 'green', size: 'medium' }, { type: 'bifurcation', color: 'red', size: 'large' },
                { type: 'flock', color: 'pink', size: 'medium' }, { type: 'coupledOscillators', color: 'teal', size: 'small' }
            ],
            5: [
                { type: 'crrOscillator', color: 'purple', size: 'large' }, { type: 'coherenceWave', color: 'indigo', size: 'large' },
                { type: 'ruptureBloom', color: 'red', size: 'large' }, { type: 'regenerativeSpiral', color: 'green', size: 'large' },
                { type: 'nestedCRR', color: 'orange', size: 'large' }, { type: 'autopoieticRing', color: 'cyan', size: 'large' },
                { type: 'crrOscillator', color: 'pink', size: 'medium' }, { type: 'coherenceWave', color: 'teal', size: 'medium' }
            ]
        };
        return configs[stage] || configs[1];
    }
    
    function initializeShapes() {
        shapes = [];
        const configs = getStageConfigs(CRR.stage);
        const positions = [
            { x: W * 0.62, y: H * 0.22 }, { x: W * 0.84, y: H * 0.42 }, { x: W * 0.48, y: H * 0.48 }, { x: W * 0.72, y: H * 0.68 },
            { x: W * 0.34, y: H * 0.28 }, { x: W * 0.54, y: H * 0.78 }, { x: W * 0.38, y: H * 0.58 }, { x: W * 0.80, y: H * 0.16 }
        ];
        
        configs.forEach((config, i) => {
            shapes.push({
                id: i, type: config.type, color: config.color, size: config.size,
                x: positions[i].x, y: positions[i].y, radius: SIZES[config.size].radius,
                explored: false, hovered: false, pulsePhase: Math.random() * Math.PI * 2, phase: Math.random() * Math.PI * 2,
                internalC: 0, internalPhase: 'coherence', internalOmega: 1.0, particles: [], grid: null
            });
        });
        
        shapes.forEach(s => {
            if (SHAPE_TYPES[s.type].emergent) initializeEmergentShape(s);
            if (s.type === 'cellularAutomata') initializeCellularAutomata(s);
        });
    }
    
    function initializeEmergentShape(shape) {
        shape.particles = [];
        const count = shape.type === 'flock' ? 20 : shape.type === 'coupledOscillators' ? 8 : 15;
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * shape.radius * 0.8;
            shape.particles.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, phase: Math.random() * Math.PI * 2, state: Math.random() });
        }
    }
    
    function initializeCellularAutomata(shape) {
        const size = 9;
        shape.grid = [];
        for (let i = 0; i < size; i++) { shape.grid[i] = []; for (let j = 0; j < size; j++) shape.grid[i][j] = Math.random() > 0.5 ? 1 : 0; }
    }
    
    async function regenerateWorld() {
        Object.values(generativeModel.shapes).forEach(s => { s.confidence *= 0.3; s.disrupted = true; });
        updateBeliefDisplay();
        
        // VFE spikes as new environment appears
        VFE.current = 0.95;  // High uncertainty in new world
        VFE.cumulativeDrive = 0;
        NearTimeCoherence.reset();
        
        const stageDesc = ['', 'Simple Forms', 'Compound Structures', 'Dynamic Patterns', 'Emergent Systems', 'Meta-CRR Patterns'];
        
        await delay(1500);
        initializeShapes();
        
        // Announce the VFE spike from new environment
        AgentSpeech.say("New environment! Free energy spike — uncertainty high!", 2500);
        
        updateCommentary(
            `Stage ${CRR.stage}: ${stageDesc[CRR.stage]}. New environment injects uncertainty — VFE spikes! Fresh gradient descent begins.`,
            { term: 'Environmental Input', desc: 'Novel stimuli appear' },
            { term: 'F ↑', desc: 'Free energy spike' },
            { term: 'C = 0', desc: 'Coherence reset' },
            `F = ${VFE.current.toFixed(2)} (high), C = 0 — new descent begins`
        );
        
        agent.x = agent.targetX = 60;
        agent.y = agent.targetY = H / 2;
        agent.state = 'idle';
        agent.currentTarget = null;
        autoNavTimer = 0;
        wanderTimer = 0;
        isWandering = false;
        updateStatus('idle', `Stage ${CRR.stage}: New complexity awaits...`);
        
        await delay(1500);
        AgentSpeech.hide();
    }
    
    // ============================================================================
    // DRAWING FUNCTIONS - Exact from original
    // ============================================================================
    
    function drawBackground() {
        const gradients = [['#f5f5f5', '#e0e0e0'], ['#e8eaf6', '#c5cae9'], ['#ede7f6', '#b39ddb'], ['#e0f7fa', '#80deea'], ['#fce4ec', '#ce93d8']];
        const colors = gradients[CRR.stage - 1] || gradients[0];
        const grad = ctx.createRadialGradient(W * 0.5, H * 0.5, 0, W * 0.5, H * 0.5, W);
        colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), c));
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        
        ctx.strokeStyle = 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        const gridSize = 50 - CRR.stage * 8;
        for (let x = 0; x < W; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
        for (let y = 0; y < H; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
        
        ctx.fillStyle = `rgba(106,27,154,${0.05 + CRR.stage * 0.02})`;
        ctx.font = 'bold 80px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(CRR.stage, W - 50, H - 20);
    }
    
    function drawShape(shape) {
        ctx.save();
        ctx.translate(shape.x, shape.y);
        const pulse = shape.hovered ? Math.sin(shape.pulsePhase) * 3 : 0;
        const r = shape.radius + pulse;
        
        if (shape.hovered) { ctx.shadowColor = COLORS[shape.color].hex; ctx.shadowBlur = 20; }
        if (shape.explored) { ctx.strokeStyle = 'rgba(46,125,50,0.5)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, r + 8, 0, Math.PI * 2); ctx.stroke(); }
        
        const info = SHAPE_TYPES[shape.type];
        const color = COLORS[shape.color].hex;
        
        if (info.stage === 1) drawStage1Shape(shape.type, r, color);
        else if (info.stage === 2) drawStage2Shape(shape.type, r, color);
        else if (info.stage === 3) drawStage3Shape(shape.type, r, color, shape.phase + worldPhase);
        else if (info.stage === 4) drawStage4Shape(shape, r, color);
        else if (info.stage === 5) drawStage5Shape(shape, r, color);
        
        ctx.restore();
    }
    
    function drawStage1Shape(type, r, color) {
        ctx.fillStyle = color; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.beginPath();
        if (type === 'circle') ctx.arc(0, 0, r, 0, Math.PI * 2);
        else if (type === 'triangle') drawPolygon(r, 3);
        else if (type === 'square') drawPolygon(r, 4);
        else if (type === 'pentagon') drawPolygon(r, 5);
        else if (type === 'hexagon') drawPolygon(r, 6);
        else if (type === 'star') drawStar(r, 5);
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(-r * 0.25, -r * 0.25, r * 0.3, 0, Math.PI * 2); ctx.fill();
    }
    
    function drawStage2Shape(type, r, color) {
        ctx.fillStyle = color; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;
        if (type === 'ring') { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2, true); ctx.fill(); ctx.stroke(); }
        else if (type === 'triangleInCircle') { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); drawPolygon(r * 0.7, 3); ctx.fill(); }
        else if (type === 'nestedSquares') { for (let i = 0; i < 3; i++) { ctx.save(); ctx.rotate(i * Math.PI / 8); ctx.globalAlpha = 1 - i * 0.25; ctx.beginPath(); drawPolygon(r * (1 - i * 0.3), 4); if (i === 0) ctx.fill(); ctx.stroke(); ctx.restore(); } }
        else if (type === 'hexStar') { ctx.beginPath(); drawPolygon(r, 6); ctx.stroke(); ctx.beginPath(); drawStar(r * 0.8, 6); ctx.fill(); }
        else if (type === 'crescentMoon') { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f5f5f5'; ctx.beginPath(); ctx.arc(r * 0.3, 0, r * 0.75, 0, Math.PI * 2); ctx.fill(); }
        else if (type === 'diamond') { ctx.beginPath(); ctx.moveTo(0, -r); ctx.lineTo(r * 0.6, 0); ctx.lineTo(0, r); ctx.lineTo(-r * 0.6, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); }
    }
    
    function drawStage3Shape(type, r, color, phase) {
        ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = 2;
        if (type === 'spiral') { ctx.lineWidth = 3; ctx.beginPath(); for (let i = 0; i < 720; i += 5) { const a = (i * Math.PI / 180) + phase, rad = (i / 720) * r; if (i === 0) ctx.moveTo(Math.cos(a) * rad, Math.sin(a) * rad); else ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad); } ctx.stroke(); }
        else if (type === 'pulsingStar') { const pr = r * (0.8 + 0.2 * Math.sin(phase * 2)); ctx.beginPath(); drawStar(pr, 8); ctx.fill(); }
        else if (type === 'fractalTriangle') drawSierpinski(0, 0, r, 3, phase);
        else if (type === 'flowField') { for (let x = -r; x < r; x += 12) for (let y = -r; y < r; y += 12) { if (x*x + y*y > r*r) continue; const a = Math.sin(x * 0.1 + phase) + Math.cos(y * 0.1 + phase); ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(a) * 8, y + Math.sin(a) * 8); ctx.stroke(); } }
        else if (type === 'interference') { for (let i = 0; i < 5; i++) { ctx.globalAlpha = 0.3; const o = Math.sin(phase + i) * 10; ctx.beginPath(); ctx.arc(o, 0, r * (0.3 + i * 0.15), 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(-o, 0, r * (0.3 + i * 0.15), 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; }
        else if (type === 'mandala') { for (let i = 0; i < 12; i++) { ctx.save(); ctx.rotate((i * Math.PI * 2 / 12) + phase * 0.5); ctx.beginPath(); ctx.ellipse(r * 0.5, 0, r * 0.4, r * 0.15, 0, 0, Math.PI * 2); ctx.globalAlpha = 0.7; ctx.fill(); ctx.restore(); } ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(0, 0, r * 0.2, 0, Math.PI * 2); ctx.fill(); }
    }
    
    function drawStage4Shape(shape, r, color) {
        const type = shape.type; ctx.fillStyle = color; ctx.strokeStyle = color;
        if (type === 'flock') { updateFlock(shape); shape.particles.forEach(p => { ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(Math.atan2(p.vy, p.vx)); ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(-4, 3); ctx.lineTo(-4, -3); ctx.closePath(); ctx.fill(); ctx.restore(); }); }
        else if (type === 'phaseTransition') { const temp = (Math.sin(worldPhase * 0.5) + 1) / 2; shape.particles.forEach((p, i) => { const tx = temp < 0.5 ? (i % 4 - 1.5) * r * 0.4 : (Math.random() - 0.5) * r * 1.5; const ty = temp < 0.5 ? (Math.floor(i / 4) - 1.5) * r * 0.4 : (Math.random() - 0.5) * r * 1.5; p.x += (tx - p.x) * 0.05; p.y += (ty - p.y) * 0.05; ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1; ctx.strokeStyle = temp < 0.5 ? '#2196f3' : '#f44336'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); }
        else if (type === 'coupledOscillators') { shape.particles.forEach((p, i) => { const a = (i / shape.particles.length) * Math.PI * 2; const bx = Math.cos(a) * r * 0.6, by = Math.sin(a) * r * 0.6; let coupling = 0; shape.particles.forEach((o, j) => { if (i !== j) coupling += Math.sin(o.phase - p.phase) * 0.1; }); p.phase += 0.05 + coupling; const ox = bx + Math.cos(p.phase) * 10, oy = by + Math.sin(p.phase) * 10; ctx.beginPath(); ctx.arc(ox, oy, 8, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 0.3; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(ox, oy); ctx.stroke(); }); ctx.globalAlpha = 1; }
        else if (type === 'reactionDiffusion') { for (let i = 0; i < 12; i++) { const a = (i / 12) * Math.PI * 2 + worldPhase * 0.2; const d = r * (0.4 + 0.3 * Math.sin(i * 2.3 + worldPhase)); const s = 8 + 4 * Math.sin(i * 1.7 + worldPhase * 0.5); ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(Math.cos(a) * d, Math.sin(a) * d, s, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); }
        else if (type === 'cellularAutomata') { updateCellularAutomata(shape); const cs = r * 2 / shape.grid.length; shape.grid.forEach((row, i) => row.forEach((cell, j) => { if (cell) { ctx.globalAlpha = 0.8; ctx.fillRect((j - shape.grid.length / 2) * cs, (i - shape.grid.length / 2) * cs, cs - 1, cs - 1); } })); ctx.globalAlpha = 1; }
        else if (type === 'bifurcation') { ctx.lineWidth = 1.5; function drawBranch(x, y, len, ang, dep) { if (dep === 0 || len < 3) return; const ex = x + Math.cos(ang) * len, ey = y + Math.sin(ang) * len; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(ex, ey); ctx.stroke(); const sp = 0.4 + Math.sin(worldPhase + dep) * 0.2; drawBranch(ex, ey, len * 0.7, ang - sp, dep - 1); drawBranch(ex, ey, len * 0.7, ang + sp, dep - 1); } drawBranch(0, r * 0.5, r * 0.5, -Math.PI / 2, 5); }
    }
    
    function drawStage5Shape(shape, r, color) {
        const type = shape.type; updateShapeInternalCRR(shape);
        const c = shape.internalC, phase = shape.internalPhase;
        ctx.fillStyle = color; ctx.strokeStyle = color;
        
        if (type === 'crrOscillator') {
            const intensity = c / shape.internalOmega;
            ctx.globalAlpha = 0.3 + intensity * 0.5; ctx.beginPath(); ctx.arc(0, 0, r * (0.3 + intensity * 0.5), 0, Math.PI * 2); ctx.fill();
            const orbs = Math.floor(2 + intensity * 6);
            for (let i = 0; i < orbs; i++) { const a = (i / orbs) * Math.PI * 2 + worldPhase; const d = r * (0.5 + intensity * 0.3); ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(Math.cos(a) * d, Math.sin(a) * d, 4 + intensity * 4, 0, Math.PI * 2); ctx.fill(); }
            if (phase === 'rupture') { ctx.globalAlpha = 0.5; ctx.fillStyle = '#d32f2f'; ctx.beginPath(); ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = color; }
            ctx.globalAlpha = 1; ctx.strokeStyle = phase === 'rupture' ? '#d32f2f' : color; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, r, -Math.PI / 2, -Math.PI / 2 + (c / shape.internalOmega) * Math.PI * 2); ctx.stroke();
        } else if (type === 'coherenceWave') {
            const rings = 3 + Math.floor(c * 4);
            for (let i = 0; i < rings; i++) { ctx.globalAlpha = 0.3 + c * 0.3; ctx.lineWidth = 2 + c * 2; ctx.beginPath(); ctx.arc(0, 0, r * (0.2 + (i / rings) * 0.8), 0, Math.PI * 2); ctx.stroke(); }
            if (phase === 'rupture') { ctx.globalAlpha = 0.7; ctx.strokeStyle = '#d32f2f'; for (let i = 0; i < 8; i++) { const a = (i / 8) * Math.PI * 2; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a) * r * 1.3, Math.sin(a) * r * 1.3); ctx.stroke(); } }
            ctx.globalAlpha = 1;
        } else if (type === 'ruptureBloom') {
            const pc = 5 + Math.floor(c * 8), ps = 0.2 + c * 0.4;
            for (let i = 0; i < pc; i++) { ctx.save(); ctx.rotate((i / pc) * Math.PI * 2 + worldPhase * 0.3); ctx.globalAlpha = 0.6 + c * 0.3; ctx.beginPath(); ctx.ellipse(r * 0.4, 0, r * ps, r * 0.12, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(0, 0, r * 0.15, 0, Math.PI * 2); ctx.fill();
        } else if (type === 'regenerativeSpiral') {
            ctx.lineWidth = 2 + c * 3; const turns = 1 + c * 3; ctx.beginPath();
            for (let i = 0; i < 360 * turns; i += 3) { const a = (i * Math.PI / 180) + worldPhase, rad = (i / (360 * turns)) * r; if (i === 0) ctx.moveTo(Math.cos(a) * rad, Math.sin(a) * rad); else ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad); }
            ctx.stroke(); ctx.fillStyle = phase === 'rupture' ? '#d32f2f' : '#4caf50'; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
        } else if (type === 'nestedCRR') {
            for (let lv = 0; lv < 3; lv++) { const lc = (c + lv * 0.3) % 1, lr = r * (1 - lv * 0.25); ctx.globalAlpha = 0.4 + lc * 0.4; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, lr, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, lr, -Math.PI / 2, -Math.PI / 2 + lc * Math.PI * 2); ctx.stroke(); }
            ctx.globalAlpha = 1;
        } else if (type === 'autopoieticRing') {
            const segs = 12, sa = Math.PI * 2 / segs;
            for (let i = 0; i < segs; i++) { const active = ((i / segs) < c) ? 1 : 0.3; const a = i * sa + worldPhase * 0.2; ctx.globalAlpha = active; ctx.beginPath(); ctx.arc(0, 0, r * 0.7, a, a + sa * 0.8); ctx.lineWidth = 8; ctx.stroke(); }
            ctx.globalAlpha = 0.3; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1;
        }
    }
    
    function updateShapeInternalCRR(shape) {
        if (shape.internalPhase === 'coherence') { shape.internalC += 0.003; if (shape.internalC >= shape.internalOmega) { shape.internalPhase = 'rupture'; shape.ruptureTimer = 30; } }
        else if (shape.internalPhase === 'rupture') { shape.ruptureTimer--; if (shape.ruptureTimer <= 0) { shape.internalPhase = 'regeneration'; shape.regenTimer = 20; } }
        else if (shape.internalPhase === 'regeneration') { shape.regenTimer--; shape.internalC *= 0.9; if (shape.regenTimer <= 0) { shape.internalC = 0; shape.internalPhase = 'coherence'; } }
    }
    
    function drawPolygon(r, sides) { ctx.moveTo(0, -r); for (let i = 1; i <= sides; i++) { const a = (i * 2 * Math.PI / sides) - Math.PI / 2; ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); } ctx.closePath(); }
    function drawStar(r, pts) { const inner = r * 0.4; ctx.moveTo(0, -r); for (let i = 0; i < pts * 2; i++) { const a = (i * Math.PI / pts) - Math.PI / 2, rad = i % 2 === 0 ? r : inner; ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad); } ctx.closePath(); }
    function drawSierpinski(x, y, size, depth, phase) { if (depth === 0) { ctx.beginPath(); ctx.moveTo(x, y - size * 0.5); ctx.lineTo(x - size * 0.5, y + size * 0.5); ctx.lineTo(x + size * 0.5, y + size * 0.5); ctx.closePath(); ctx.fill(); return; } const s = size / 2, o = Math.sin(phase + depth) * 2; drawSierpinski(x + o, y - s * 0.5, s, depth - 1, phase); drawSierpinski(x - s * 0.5 + o, y + s * 0.5, s, depth - 1, phase); drawSierpinski(x + s * 0.5 + o, y + s * 0.5, s, depth - 1, phase); }
    function updateFlock(shape) { const r = shape.radius; shape.particles.forEach(p => { let ax = 0, ay = 0; shape.particles.forEach(o => { if (o === p) return; const dx = o.x - p.x, dy = o.y - p.y, d = Math.sqrt(dx*dx + dy*dy); if (d < 30 && d > 0) { ax += dx * 0.01; ay += dy * 0.01; ax += o.vx * 0.05; ay += o.vy * 0.05; } if (d < 15 && d > 0) { ax -= dx * 0.02; ay -= dy * 0.02; } }); if (p.x < -r * 0.8) ax += 0.5; if (p.x > r * 0.8) ax -= 0.5; if (p.y < -r * 0.8) ay += 0.5; if (p.y > r * 0.8) ay -= 0.5; p.vx += ax; p.vy += ay; const sp = Math.sqrt(p.vx*p.vx + p.vy*p.vy); if (sp > 2) { p.vx = (p.vx/sp)*2; p.vy = (p.vy/sp)*2; } p.x += p.vx; p.y += p.vy; }); }
    function updateCellularAutomata(shape) { if (Math.random() > 0.1) return; const g = shape.grid, sz = g.length, ng = g.map(r => [...r]); for (let i = 0; i < sz; i++) for (let j = 0; j < sz; j++) { let n = 0; for (let di = -1; di <= 1; di++) for (let dj = -1; dj <= 1; dj++) { if (di === 0 && dj === 0) continue; n += g[(i+di+sz)%sz][(j+dj+sz)%sz]; } ng[i][j] = g[i][j] === 1 ? (n === 2 || n === 3 ? 1 : 0) : (n === 3 ? 1 : 0); } shape.grid = ng; }
    
    function drawAgent() {
        ctx.save(); ctx.translate(agent.x, agent.y);
        const breathe = Math.sin(agent.breathePhase) * 2, size = agent.size + breathe;
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.ellipse(0, size * 0.7, size * 0.8, size * 0.3, 0, 0, Math.PI * 2); ctx.fill();
        const glows = { idle: 'rgba(100,100,100,0.3)', exploring: 'rgba(255,152,0,0.4)', examining: 'rgba(255,152,0,0.4)', surprised: 'rgba(198,40,40,0.5)', learning: 'rgba(35,78,112,0.5)' };
        ctx.fillStyle = glows[agent.state] || glows.idle; ctx.beginPath(); ctx.arc(0, 0, size + 8, 0, Math.PI * 2); ctx.fill();
        const grad = ctx.createRadialGradient(-size * 0.3, -size * 0.3, 0, 0, 0, size); grad.addColorStop(0, '#fafafa'); grad.addColorStop(0.5, '#e0e0e0'); grad.addColorStop(1, '#bdbdbd');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.stroke();
        const eo = size * 0.35, es = size * 0.25;
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.ellipse(-eo, -size * 0.1, es, es * 1.2, 0, 0, Math.PI * 2); ctx.ellipse(eo, -size * 0.1, es, es * 1.2, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.stroke();
        let lx = 0, ly = 0; if (agent.currentTarget) { const dx = agent.currentTarget.x - agent.x, dy = agent.currentTarget.y - agent.y, d = Math.sqrt(dx*dx+dy*dy)||1; lx = (dx/d)*es*0.4; ly = (dy/d)*es*0.4; }
        let ps = es * 0.5; if (agent.state === 'surprised') ps = es * 0.7;
        ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(-eo + lx, -size * 0.1 + ly, ps, 0, Math.PI * 2); ctx.arc(eo + lx, -size * 0.1 + ly, ps, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(-eo + lx - 2, -size * 0.1 + ly - 2, 2, 0, Math.PI * 2); ctx.arc(eo + lx - 2, -size * 0.1 + ly - 2, 2, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
        if (agent.state === 'surprised') { ctx.fillStyle = '#666'; ctx.beginPath(); ctx.ellipse(0, size * 0.35, size * 0.18, size * 0.22, 0, 0, Math.PI * 2); ctx.fill(); }
        else { ctx.beginPath(); ctx.arc(0, size * 0.25, size * 0.18, 0.2, Math.PI - 0.2); ctx.stroke(); }
        const syms = { surprised: '!', examining: '?', learning: '✓' };
        if (syms[agent.state]) { ctx.fillStyle = '#234e70'; ctx.font = `bold ${size * 0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText(syms[agent.state], 0, -size * 1.2); }
        ctx.restore();
    }
    
    function drawExplorationLine() { if (agent.currentTarget && agent.state !== 'idle') { ctx.save(); ctx.strokeStyle = 'rgba(35,78,112,0.3)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(agent.x, agent.y); ctx.lineTo(agent.currentTarget.x, agent.currentTarget.y); ctx.stroke(); ctx.restore(); } }
    
    // ============================================================================
    // LEARNING SYSTEM - EXACT FROM ORIGINAL
    // ============================================================================
    
    function getPrediction(shape) { 
        const preds = []; 
        let conf = 0; 
        if (generativeModel.shapes[shape.type]) { 
            preds.push(`Shape: ${SHAPE_TYPES[shape.type].name}`); 
            conf += 0.3 * generativeModel.shapes[shape.type].confidence; 
        } 
        if (generativeModel.colors[shape.color]) { 
            preds.push(`Color: ${COLORS[shape.color].name}`); 
            conf += 0.3 * generativeModel.colors[shape.color].confidence; 
        } 
        return { predictions: preds, confidence: Math.min(conf, 0.9), hasKnowledge: preds.length > 0 }; 
    }
    
    function calculatePredictionError(shape, pred) { 
        // Use verified error constants from Python simulation
        const shapeKnown = !!generativeModel.shapes[shape.type];
        const shapeDisrupted = shapeKnown && generativeModel.shapes[shape.type].disrupted;
        const colorKnown = !!generativeModel.colors[shape.color];
        
        let error = 0;
        let messages = [];
        let isNovel = false;
        
        if (!shapeKnown) {
            error += ERROR_UNKNOWN_SHAPE;
            messages.push(`Unknown: ${SHAPE_TYPES[shape.type].name}`);
            isNovel = true;
        } else if (shapeDisrupted) {
            error += ERROR_DISRUPTED_SHAPE;
            messages.push(`Uncertain: ${SHAPE_TYPES[shape.type].name}`);
            isNovel = true;
        }
        
        if (!colorKnown) {
            error += ERROR_UNKNOWN_COLOR;
            messages.push(`Unknown: ${COLORS[shape.color].name}`);
            isNovel = true;
        }
        
        if (error === 0) {
            error = ERROR_BASELINE;
            messages = ['Matches existing schemas'];
        }
        
        return { 
            error: error, 
            message: messages.join('; '),
            isNovel: isNovel
        }; 
    }
    
    function updateGenerativeModel(shape) { 
        const updates = []; 
        if (!generativeModel.shapes[shape.type]) { 
            generativeModel.shapes[shape.type] = { 
                name: SHAPE_TYPES[shape.type].name, 
                stage: SHAPE_TYPES[shape.type].stage, 
                encounters: 1, 
                confidence: 0.6 
            }; 
            updates.push(`New: ${SHAPE_TYPES[shape.type].name}`); 
        } else { 
            generativeModel.shapes[shape.type].encounters++; 
            generativeModel.shapes[shape.type].confidence = Math.min(0.95, generativeModel.shapes[shape.type].confidence + 0.1); 
            generativeModel.shapes[shape.type].disrupted = false; 
        } 
        if (!generativeModel.colors[shape.color]) { 
            generativeModel.colors[shape.color] = { 
                name: COLORS[shape.color].name, 
                encounters: 1, 
                confidence: 0.6 
            }; 
            updates.push(`New: ${COLORS[shape.color].name}`); 
        } else { 
            generativeModel.colors[shape.color].encounters++; 
            generativeModel.colors[shape.color].confidence = Math.min(0.95, generativeModel.colors[shape.color].confidence + 0.1); 
        } 
        return updates; 
    }
    
    // ============================================================================
    // UI FUNCTIONS - Exact from original
    // ============================================================================
    
    function updateStatus(state, text) { 
        document.getElementById('statusDot').className = 'status-dot ' + state; 
        document.getElementById('statusText').textContent = text; 
    }
    
    function updateCommentary(text, piaget, fep, crr, math) { 
        document.getElementById('commentaryText').textContent = text; 
        const comp = document.getElementById('frameworkComparison'); 
        if (piaget && fep) { 
            comp.classList.add('visible'); 
            document.getElementById('piagetTerm').textContent = piaget.term; 
            document.getElementById('piagetDesc').textContent = piaget.desc; 
            document.getElementById('fepTerm').textContent = fep.term; 
            document.getElementById('fepDesc').textContent = fep.desc; 
            if (crr) { 
                document.getElementById('crrTerm').textContent = crr.term; 
                document.getElementById('crrDesc').textContent = crr.desc; 
            }
        } else { 
            comp.classList.remove('visible'); 
        } 
        const m = document.getElementById('mathNote'); 
        if (math) { 
            m.classList.add('visible'); 
            document.getElementById('mathContent').textContent = math; 
        } else { 
            m.classList.remove('visible'); 
        } 
    }
    
    function showPrediction(pred) { 
        const d = document.getElementById('predictionDisplay'); 
        d.classList.add('visible'); 
        document.getElementById('predictionContent').innerHTML = pred.hasKnowledge ? 
            `<strong>Expected:</strong> ${pred.predictions.join(', ')}<br><span style="font-size:10px;color:#666">Confidence: ${Math.round(pred.confidence*100)}%</span>` : 
            `<em>No prediction—novel</em>`; 
    }
    
    function showError(err) { 
        const d = document.getElementById('errorDisplay'); 
        d.classList.add('visible'); 
        d.className = err.error < 0.2 ? 'error-display visible low-error' : 'error-display visible'; 
        document.getElementById('errorContent').innerHTML = `${err.message}<br><span style="font-size:10px;color:${err.error<0.2?'#2e7d32':'#c62828'}">ε ≈ ${err.error.toFixed(2)}</span>`; 
    }
    
    function hidePredictionAndError() { 
        document.getElementById('predictionDisplay').classList.remove('visible'); 
        document.getElementById('errorDisplay').classList.remove('visible'); 
    }
    
    function updateBeliefDisplay(highlight = null) { 
        const c = document.getElementById('beliefsList'); 
        c.innerHTML = ''; 
        if (Object.keys(generativeModel.shapes).length === 0) { 
            c.innerHTML = `<div class="belief-item" style="opacity:0.5"><div class="belief-icon">?</div><div class="belief-text"><div class="belief-name">No schemas</div><div class="belief-details">Exploring...</div></div></div>`; 
            return; 
        } 
        const icons = { circle: '○', triangle: '△', square: '□', pentagon: '⬠', hexagon: '⬡', star: '☆', ring: '◎', nestedSquares: '⊞', diamond: '◇', crescentMoon: '☽', hexStar: '✡', triangleInCircle: '⊿', spiral: '🌀', mandala: '✿', pulsingStar: '✦', fractalTriangle: '△', flowField: '≋', interference: '◉', flock: '🐦', phaseTransition: '⇌', coupledOscillators: '∿', reactionDiffusion: '⊛', cellularAutomata: '⊞', bifurcation: '⑂', crrOscillator: 'Ω', coherenceWave: '∿', ruptureBloom: '❀', regenerativeSpiral: '🌀', nestedCRR: '⊚', autopoieticRing: '◎' }; 
        const sl = ['', 'Simple', 'Compound', 'Dynamic', 'Emergent', 'Meta-CRR']; 
        Object.entries(generativeModel.shapes).forEach(([k, s]) => { 
            const isNew = highlight && highlight.some(h => h.includes(s.name)); 
            const item = document.createElement('div'); 
            item.className = 'belief-item' + (isNew ? ' new' : '') + (s.disrupted ? ' disrupted' : ''); 
            item.innerHTML = `<div class="belief-icon">${icons[k]||'●'}</div><div class="belief-text"><div class="belief-name">${s.name}</div><div class="belief-details">${sl[s.stage]} · ×${s.encounters}</div></div><div class="confidence-bar"><div class="confidence-fill" style="width:${s.confidence*100}%"></div></div>`; 
            c.appendChild(item); 
        }); 
    }
    
    // ============================================================================
    // EXPLORATION - EXACT FROM ORIGINAL
    // ============================================================================
    
    async function exploreShape(shape) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        agent.currentTarget = shape; agent.state = 'exploring'; agent.targetX = shape.x - shape.radius - 40; agent.targetY = shape.y;
        const info = SHAPE_TYPES[shape.type];
        updateStatus('exploring', `Approaching ${info.name}...`);
        updateCommentary(`The agent moves toward a ${info.name}.${info.metaCRR ? ' This meta-pattern embodies CRR itself.' : ''}`, null, null, null, null);
        hidePredictionAndError();
        
        AgentSpeech.say(getRandomPhrase('approaching'));
        
        await waitForArrival();
        agent.state = 'examining';
        const pred = getPrediction(shape); showPrediction(pred);
        updateStatus('exploring', 'Generating predictions...');
        
        AgentSpeech.say(pred.hasKnowledge ? getRandomPhrase('predicting') : getRandomPhrase('predictingNovel'));
        
        updateCommentary(pred.hasKnowledge ? `Generative model produces predictions.` : `No applicable schemas—entirely novel.`, { term: pred.hasKnowledge ? 'Assimilation Attempt' : 'No Schema', desc: pred.hasKnowledge ? 'Testing structures' : 'Cannot assimilate' }, { term: pred.hasKnowledge ? 'Prior Prediction' : 'High Entropy', desc: pred.hasKnowledge ? 'g(μ) generates expectations' : 'Maximal uncertainty' }, info.metaCRR ? { term: 'Recursive Recognition', desc: 'Pattern recognizes pattern' } : null, pred.hasKnowledge ? 'g(μ) = predicted sensation' : 'H[P(s)] = maximum');
        await delay(1600);
        
        const err = calculatePredictionError(shape, pred);
        if (err.error > 0.3) agent.state = 'surprised';
        showError(err);
        
        const isNovelStimulus = !pred.hasKnowledge || !generativeModel.shapes[shape.type];
        const L = calculateAdaptiveWork(err.error);
        
        VFE.update(err.error, isNovelStimulus);
        NearTimeCoherence.addWork(L);
        
        if (err.error > 0.5) {
            AgentSpeech.say(getRandomPhrase('surprised'));
        } else if (err.error > 0.2) {
            AgentSpeech.say(getRandomPhrase('confirmedLow'));
        } else {
            AgentSpeech.say(getRandomPhrase('confirmedHigh'));
        }
        
        const workDesc = err.error > 0.3 ? 'High ε → large ‖∇F‖ → much work' : 'Low ε → small ‖∇F‖ → less work';
        updateCommentary(
            err.error > 0.3 ? `Large prediction error! More adaptive work required.` : `Small error. Minimal updating needed.`, 
            { term: err.error > 0.3 ? 'Disequilibrium' : 'Assimilation', desc: err.error > 0.3 ? 'Schema-experience gap' : 'Experience fits' }, 
            { term: 'L = Ω‖∇F‖²', desc: workDesc }, 
            { term: 'C(t) += L', desc: `Work adds ${L.toFixed(3)} to coherence` }, 
            `L = ${L.toFixed(3)}, C = ${(CRR.coherence + L).toFixed(3)}`
        );
        
        await delay(1800);
        agent.state = 'learning'; updateStatus('learning', 'Updating model...');
        
        // CRITICAL: Check if shape/color were known BEFORE updating the model
        const shapeWasKnownBefore = !!generativeModel.shapes[shape.type];
        const colorWasKnownBefore = !!generativeModel.colors[shape.color];
        
        // Now update the model
        const updates = updateGenerativeModel(shape); 
        shape.explored = true;
        
        VFE.onLearning(L);
        CRR.addCoherence(L);
        
        // Accommodation = new shape schema created
        // Assimilation = shape schema already existed (even if color was new)
        const isAccommodation = !shapeWasKnownBefore;
        
        // Speech based on accommodation vs assimilation
        if (isAccommodation) {
            if (info.metaCRR) {
                AgentSpeech.say(getRandomPhrase('stage5Insight'), 3000);
            } else {
                AgentSpeech.say(getRandomPhrase('learningNovel'));
            }
        } else {
            AgentSpeech.say(getRandomPhrase('learning'));
        }
        
        // Commentary with proper Piagetian terminology
        let commentaryText, piagetTerm, piagetDesc;
        if (isAccommodation) {
            // New shape = Accommodation
            commentaryText = `Accommodation: ${updates.join(', ')}.`;
            piagetTerm = 'Accommodation';
            piagetDesc = 'New schema formed';
        } else if (!colorWasKnownBefore) {
            // Shape known, color new = Assimilation with new info
            commentaryText = `Assimilation: New color integrated into existing ${info.name} schema.`;
            piagetTerm = 'Assimilation';
            piagetDesc = 'Information integrated';
        } else {
            // Everything known = Pure assimilation/reinforcement
            commentaryText = `Assimilation: ${info.name} schema reinforced.`;
            piagetTerm = 'Assimilation';
            piagetDesc = 'Schema reinforced';
        }
        
        updateCommentary(
            commentaryText, 
            { term: piagetTerm, desc: piagetDesc }, 
            { term: 'F decreases', desc: 'VFE reduced by learning' }, 
            { term: 'C accumulates', desc: `Total work: ${CRR.coherence.toFixed(3)}` }, 
            `F = ${VFE.current.toFixed(2)}, C = ${CRR.coherence.toFixed(3)}`
        );
        updateBeliefDisplay(updates);
        await delay(1400);
        
        if (CRR.coherence > CRR.omega * 0.75) {
            AgentSpeech.say(getRandomPhrase('nearRupture'), 2000);
        }
        
        if (shapes.every(s => s.explored) && CRR.phase === 'coherence') {
            const bonusL = 0.05;
            CRR.addCoherence(bonusL);
            NearTimeCoherence.addWork(bonusL);
            
            AgentSpeech.say(getRandomPhrase('mastery'), 2500);
            if (CRR.stage === 5) {
                updateCommentary(`All meta-CRR patterns explored. Cumulative adaptive work approaches capacity Ω. The agent has worked enough to require transformation...`, { term: 'Meta-Cognition', desc: 'Thinking about thinking' }, { term: 'C(t) → Ω', desc: 'First passage imminent' }, { term: 'Rupture Threshold', desc: 'Capacity reached through work' }, `C = ${CRR.coherence.toFixed(3)} → Ω = ${CRR.omega}`);
            } else {
                updateCommentary(`All forms explored. Coherence (cumulative work) approaches capacity Ω.`, { term: 'Stage Mastery', desc: 'Environment fully explored' }, { term: 'C(t) → Ω', desc: 'Work accumulating toward threshold' }, { term: 'Rupture Approaches', desc: 'Structural capacity filling' }, `C = ${CRR.coherence.toFixed(3)} → Ω`);
            }
        }
        agent.state = 'idle'; agent.currentTarget = null; updateStatus('idle', 'Ready...'); 
        await delay(800);
        AgentSpeech.hide();
        hidePredictionAndError();
    }
    
    function waitForArrival() { return new Promise(resolve => { (function check() { if (Math.abs(agent.targetX - agent.x) < 5 && Math.abs(agent.targetY - agent.y) < 5) resolve(); else requestAnimationFrame(check); })(); }); }
    function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    // ============================================================================
    // AUTO-NAVIGATION - Added for homepage
    // ============================================================================
    
    function autoNavigate(dt) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        
        const unexplored = shapes.filter(s => !s.explored);
        const explored = shapes.filter(s => s.explored);
        
        autoNavTimer += dt;
        
        if (autoNavTimer >= autoNavDelay) {
            autoNavTimer = 0;
            
            if (unexplored.length > 0) {
                // Still have shapes to explore
                // Use verified probability for revisiting
                const shouldRevisit = explored.length >= 2 && Math.random() < PROB_REVISIT_DURING_EXPLORATION;
                
                if (shouldRevisit) {
                    // Revisit for assimilation
                    const target = explored[Math.floor(Math.random() * explored.length)];
                    revisitShape(target);
                    autoNavDelay = 1.2 + Math.random() * 0.5;
                } else {
                    // Explore nearest unexplored shape (accommodation)
                    const target = unexplored.reduce((nearest, s) => {
                        const d = Math.hypot(s.x - agent.x, s.y - agent.y);
                        return (!nearest || d < nearest.dist) ? { shape: s, dist: d } : nearest;
                    }, null).shape;
                    
                    exploreShape(target);
                    autoNavDelay = 1.0 + Math.random() * 0.5;
                }
            } else {
                // All explored - integration phase
                isWandering = true;
                
                if (Math.random() < PROB_REVISIT_AFTER_EXPLORATION && explored.length > 0) {
                    // Revisit for final assimilation
                    const target = explored[Math.floor(Math.random() * explored.length)];
                    revisitShape(target);
                    autoNavDelay = 0.9 + Math.random() * 0.4;
                } else {
                    // Integration work (verified calculation)
                    const integrationL = calculateIntegrationWork();
                    CRR.addCoherence(integrationL);
                    NearTimeCoherence.addWork(integrationL);
                    
                    agent.targetX = 50 + Math.random() * (W * 0.3);
                    agent.targetY = H * 0.25 + Math.random() * (H * 0.5);
                    
                    AgentSpeech.say(getRandomPhrase('wandering'), 1500);
                    
                    const pct = ((CRR.coherence / CRR.omega) * 100).toFixed(0);
                    updateCommentary(
                        `Agent integrates learned schemas. Coherence: C = ${CRR.coherence.toFixed(3)} (${pct}% of Ω)`,
                        { term: 'Integration', desc: 'Schema consolidation' },
                        { term: 'C grows', desc: 'Background processing' },
                        { term: 'Toward Ω', desc: `${pct}% capacity` },
                        `C = ${CRR.coherence.toFixed(3)} → Ω = ${CRR.omega.toFixed(2)}`
                    );
                    
                    autoNavDelay = 0.7 + Math.random() * 0.3;
                }
            }
        }
    }
    
    // Revisit an already-explored shape for pure assimilation
    async function revisitShape(shape) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        
        agent.currentTarget = shape;
        agent.state = 'exploring';
        agent.targetX = shape.x - shape.radius - 35;
        agent.targetY = shape.y;
        
        const info = SHAPE_TYPES[shape.type];
        updateStatus('exploring', `Revisiting ${info.name}...`);
        AgentSpeech.say("Let me check this again...", 1500);
        
        await waitForArrival();
        
        // Quick examination - everything is familiar
        agent.state = 'examining';
        const pred = getPrediction(shape);
        showPrediction(pred);
        
        updateCommentary(
            `Revisiting familiar ${info.name}. Generative model already contains this schema.`,
            { term: 'Recognition', desc: 'Schema retrieved' },
            { term: 'Low Uncertainty', desc: 'Predictions accurate' },
            null,
            `Confidence: ${(pred.confidence * 100).toFixed(0)}%`
        );
        
        await delay(1000);
        
        // Use verified error constant for revisit
        const error = ERROR_REVISIT;
        const L = calculateAdaptiveWork(error);
        const err = { error: error, message: "Perfect match to schema." };
        showError(err);
        
        AgentSpeech.say("Assimilating only — the world makes sense.", 2500);
        
        updateCommentary(
            `Minimal prediction error. Pure assimilation: experience fits existing schemas.`,
            { term: 'Assimilation', desc: 'Schema-experience match' },
            { term: 'ε ≈ 0', desc: 'Near-zero error' },
            { term: 'Equilibrium', desc: 'Cognitive harmony' },
            `ε = ${err.error.toFixed(2)}, L = ${L.toFixed(4)} (minimal)`
        );
        
        // Add verified work and reinforce schema
        CRR.addCoherence(L);
        NearTimeCoherence.addWork(L);
        VFE.current = Math.max(0.1, VFE.current - 0.02);
        VFE.updateDisplay();
        
        // Increase confidence in the schema
        if (generativeModel.shapes[shape.type]) {
            generativeModel.shapes[shape.type].confidence = Math.min(0.98, generativeModel.shapes[shape.type].confidence + 0.05);
            generativeModel.shapes[shape.type].encounters++;
        }
        updateBeliefDisplay();
        
        await delay(1200);
        
        // Check if approaching rupture
        if (CRR.coherence > CRR.omega * 0.85) {
            AgentSpeech.say(getRandomPhrase('nearRupture'), 2000);
            updateCommentary(
                `Coherence nearing capacity. Even assimilation adds to cumulative work. Rupture approaches...`,
                { term: 'Saturation', desc: 'Capacity filling' },
                { term: 'C → Ω', desc: 'Threshold imminent' },
                { term: 'Phase Transition', desc: 'Structural limit' },
                `C = ${CRR.coherence.toFixed(3)} → Ω = ${CRR.omega.toFixed(2)}`
            );
        }
        
        agent.state = 'idle';
        agent.currentTarget = null;
        updateStatus('idle', 'Ready...');
        await delay(400);
        hidePredictionAndError();
        AgentSpeech.hide();
    }
    
    // ============================================================================
    // MAIN LOOP
    // ============================================================================
    
    function update(dt) { 
        time += dt; 
        worldPhase += dt * 0.5; 
        agent.x += (agent.targetX - agent.x) * 0.05; 
        agent.y += (agent.targetY - agent.y) * 0.05; 
        agent.breathePhase += dt * 2; 
        shapes.forEach(s => { s.pulsePhase += dt * 5; s.phase += dt; });
        VFE.tick();
        AgentSpeech.updatePosition(agent.x, agent.y);
        
        // Auto-navigate
        autoNavigate(dt);
    }
    
    function render() {
        drawBackground();
        drawExplorationLine();
        shapes.forEach(drawShape);
        drawAgent();
    }
    
    let lastTime = 0;
    function animate(ts) {
        const dt = Math.min((ts - lastTime) / 1000, 0.1);
        lastTime = ts;
        update(dt);
        render();
        requestAnimationFrame(animate);
    }
    
    // ============================================================================
    // INIT
    // ============================================================================
    
    AgentSpeech.init();
    initializeShapes();
    CRR.updateDisplay();
    VFE.updateDisplay();
    NearTimeCoherence.updateDisplay();
    updateBeliefDisplay();
    requestAnimationFrame(animate);
    
    })();
    </script>

    <script>
        /**
         * Logo Animation and Navigation
         */
        class CRRHomepage {
            constructor() {
                this.animationTime = 0;
                this.isAnimating = true;
                this.rafId = null;
                this.elements = this.cacheElements();
                this.ruptureActive = false;
                this.ruptureStartTime = 0;
                this.init();
            }

            cacheElements() {
                return {
                    logo: document.querySelector('.logo'),
                    logoHive: document.querySelector('.logo-hive'),
                    bees: document.querySelectorAll('.logo-bee'),
                    interiorBees: document.querySelectorAll('[class*="interior-bee"]'),
                    navLinks: document.querySelectorAll('.nav-link')
                };
            }

            init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.start());
                } else {
                    this.start();
                }
            }

            start() {
                try {
                    this.setupLogoInteractions();
                    this.setupNavigationInteractions();
                    
                    if (!this.respectsReducedMotion()) {
                        this.startAnimation();
                    }
                    
                    this.setupVisibilityChange();
                } catch (error) {
                    console.error('Initialisation error:', error);
                }
            }

            setupLogoInteractions() {
                if (!this.elements.logo) return;

                this.elements.logo.addEventListener('click', () => {
                    this.triggerDiracRupture();
                });
            }

            triggerDiracRupture() {
                if (this.ruptureActive) return;

                this.ruptureActive = true;
                this.ruptureStartTime = this.animationTime;
                
                this.elements.logoHive.classList.add('rupture');
                
                setTimeout(() => {
                    this.elements.logoHive.classList.remove('rupture');
                }, 3000);

                setTimeout(() => {
                    this.ruptureActive = false;
                }, 4000);
            }

            setupNavigationInteractions() {
                this.elements.navLinks.forEach((link) => {
                    link.addEventListener('mouseenter', () => {
                        if (!link.classList.contains('active')) {
                            link.style.transform = 'translateY(-2px)';
                        }
                    });
                    
                    link.addEventListener('mouseleave', () => {
                        link.style.transform = 'translateY(0)';
                    });
                });
            }

            startAnimation() {
                const animate = () => {
                    if (!this.isAnimating) return;
                    
                    this.animationTime += 0.025;
                    this.animateBees();
                    this.animateInteriorBees();
                    
                    this.rafId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            animateBees() {
                this.elements.bees.forEach((bee, index) => {
                    if (this.ruptureActive) {
                        this.animateRuptureBees(bee, index);
                    } else {
                        this.animateNormalBees(bee, index);
                    }
                });
            }

            animateNormalBees(bee, index) {
                const baseAngle = (index * Math.PI * 0.5) + this.animationTime * (0.4 + index * 0.15);
                const radius = 20 + Math.sin(this.animationTime * 0.7 + index) * 6;
                
                const figure8 = Math.sin(this.animationTime * 0.6 + index * 0.8) * 8;
                
                const x = 50 + Math.cos(baseAngle) * radius + figure8 * Math.cos(baseAngle * 2);
                const y = 50 + Math.sin(baseAngle) * radius * 0.8 + figure8 * 0.3 * Math.sin(baseAngle * 3);
                
                bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                
                const wingBeat = 0.6 + 0.4 * Math.sin(this.animationTime * 12 + index * 2.5);
                bee.style.opacity = wingBeat;
            }

            animateRuptureBees(bee, index) {
                const elapsedTime = this.animationTime - this.ruptureStartTime;
                
                if (elapsedTime < 60) {
                    const disperseProgress = elapsedTime / 60;
                    const disperseAngle = (index * Math.PI * 0.5) + this.animationTime * (2.5 + index * 0.6);
                    const disperseRadius = 20 + disperseProgress * (70 + index * 12);
                    
                    const x = 50 + Math.cos(disperseAngle) * disperseRadius;
                    const y = 50 + Math.sin(disperseAngle) * disperseRadius;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.2 + 0.8 * Math.sin(this.animationTime * 25 + index * 3.5);
                    
                } else if (elapsedTime < 140) {
                    const recohereProgress = (elapsedTime - 60) / 80;
                    const smoothProgress = 1 - Math.pow(1 - recohereProgress, 3);
                    
                    const currentRadius = 90 - smoothProgress * 70;
                    const angle = (index * Math.PI * 0.5) + this.animationTime * (1.8 - smoothProgress * 1.4);
                    
                    const x = 50 + Math.cos(angle) * currentRadius;
                    const y = 50 + Math.sin(angle) * currentRadius * 0.8;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.6 + 0.4 * Math.sin(this.animationTime * (15 - smoothProgress * 5) + index * 2.5);
                }
            }

            animateInteriorBees() {
                this.elements.interiorBees.forEach((bee, index) => {
                    const movement = Math.sin(this.animationTime * 2.5 + index * 3.5) * 2;
                    const rotation = Math.sin(this.animationTime * 2 + index * 2.5) * 8;
                    
                    bee.setAttribute('transform', `translate(${movement}, ${movement * 0.6}) rotate(${rotation})`);
                });
            }

            setupVisibilityChange() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.isAnimating = false;
                        if (this.rafId) {
                            cancelAnimationFrame(this.rafId);
                        }
                    } else if (!this.respectsReducedMotion()) {
                        this.isAnimating = true;
                        this.startAnimation();
                    }
                });
            }

            respectsReducedMotion() {
                return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }

            destroy() {
                this.isAnimating = false;
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                }
            }
        }

        // Initialize application
        const app = new CRRHomepage();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (app) app.destroy();
        });
    </script>
</body>
</html>
