<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cohere.org.uk - Mathematical Life and Living Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
            font-family: Georgia, serif;
            line-height: 1.6;
            color: #2c2c2c;
            overflow-x: hidden;
        }

        /* Main Container */
        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 60px;
        }

        /* Header Section */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            z-index: 100;
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .title-group {
            display: flex;
            flex-direction: column;
        }

        .site-title {
            font-family: Georgia, serif;
            font-size: 48px;
            font-weight: normal;
            color: #1a1a1a;
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .strapline {
            font-family: Georgia, serif;
            font-size: 18px;
            font-style: italic;
            color: #6c757d;
            letter-spacing: 0.5px;
        }

        /* Navigation System */
        .main-nav {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #495057;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .nav-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #1a1a1a;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: #4a90e2;
            color: white;
        }

        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .nav-item:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        /* Robust Dropdown Menu System */
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 8px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 1000;
            overflow: hidden;
        }

        /* Critical: No gap between nav item and dropdown */
        .nav-item:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Keep dropdown visible when hovering over dropdown itself */
        .dropdown-menu:hover {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Ensure dropdown stays open during mouse travel */
        .nav-item::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-link {
            display: block;
            padding: 12px 20px;
            color: #495057;
            text-decoration: none;
            font-size: 16px;
            font-family: Georgia, serif;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-link:hover {
            background: rgba(74, 144, 226, 0.08);
            color: #4a90e2;
            border-left-color: #4a90e2;
        }

        /* Hero Section */
        .hero-section {
            padding: 100px 0 80px;
            text-align: center;
            position: relative;
        }

        .hero-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(74, 144, 226, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(108, 117, 125, 0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 1;
        }

        .hero-title {
            font-family: Georgia, serif;
            font-size: 56px;
            font-weight: normal;
            line-height: 1.1;
            margin-bottom: 30px;
            color: #1a1a1a;
            letter-spacing: -1px;
        }

        .hero-subtitle {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            color: #495057;
            margin-bottom: 30px;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .hero-questions {
            max-width: 800px;
            margin: 0 auto;
            text-align: left;
            padding-left: 40px;
        }

        .hero-questions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .hero-questions li {
            font-family: Georgia, serif;
            font-size: 16px;
            font-style: italic;
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 8px;
            position: relative;
            padding-left: 20px;
        }

        .hero-questions li::before {
            content: '•';
            position: absolute;
            left: 0;
            color: #4a90e2;
            font-size: 18px;
        }

        /* Content Sections */
        .content-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            position: relative;
        }

        .section-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(248, 249, 250, 0.5) 0%, transparent 100%);
            border-radius: 12px;
            pointer-events: none;
        }

        .section-content {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
        }

        .section-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .section-content p {
            font-family: Georgia, serif;
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 25px;
            text-align: justify;
        }

        .section-content h3 {
            font-family: Georgia, serif;
            font-size: 24px;
            font-weight: normal;
            margin: 35px 0 20px;
            color: #1a1a1a;
        }

        /* Framework Grid */
        .framework-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .framework-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 35px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .framework-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #4a90e2, #6c757d);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .framework-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.08);
        }

        .framework-item:hover::before {
            opacity: 1;
        }

        .framework-item h4 {
            font-family: Georgia, serif;
            font-size: 22px;
            font-weight: normal;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        .framework-item p {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #495057;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: left;
        }

        .framework-equation {
            background: rgba(74, 144, 226, 0.05);
            padding: 20px;
            border-left: 3px solid #4a90e2;
            border-radius: 4px;
            margin-top: 15px;
            text-align: center;
        }

        .equation-explanation {
            font-family: Georgia, serif;
            font-size: 13px;
            color: #6c757d;
            font-style: italic;
            margin-top: 10px;
            line-height: 1.4;
        }

        /* Bee Journey Section */
        .crr-journey-section {
            margin: 80px 0;
            padding: 60px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        .journey-title {
            font-family: Georgia, serif;
            font-size: 36px;
            font-weight: normal;
            margin-bottom: 30px;
            color: #1a1a1a;
            text-align: center;
        }

        .journey-description {
            text-align: center;
            font-size: 16px;
            color: #6c757d;
            margin-bottom: 40px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .journey-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            margin-top: 40px;
        }

        .journey-stage {
            text-align: center;
            padding: 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
        }

        .journey-stage:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.08);
        }

        .stage-canvas {
            width: 280px;
            height: 200px;
            margin: 20px auto;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background: #e8f5e8;
        }

        .stage-title {
            font-family: Georgia, serif;
            font-size: 20px;
            font-weight: normal;
            color: #1a1a1a;
            margin-bottom: 15px;
        }

        .stage-description {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .stage-equation {
            background: rgba(74, 144, 226, 0.05);
            padding: 15px;
            border-left: 3px solid #4a90e2;
            border-radius: 4px;
            font-size: 16px;
            margin-top: 20px;
        }

        /* Research Grid */
        .research-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .research-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .research-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: linear-gradient(to right, #4a90e2, #6c757d);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .research-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }

        .research-item:hover::before {
            opacity: 1;
        }

        .research-item h4 {
            font-family: Georgia, serif;
            font-size: 18px;
            font-weight: normal;
            color: #4a90e2;
            margin-bottom: 10px;
        }

        .research-item p {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            text-align: center;
        }

        /* Logo Animation */
        .logo-hive {
            position: relative;
            overflow: visible;
        }

        .logo-bee {
            position: absolute;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .logo-interior {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .logo:hover .logo-interior {
            opacity: 1;
        }

        .logo:hover .logo-bee {
            opacity: 0.3;
        }

        .logo-hive.rupture {
            animation: hiveGlow 3s ease-out;
        }

        @keyframes hiveGlow {
            0% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
            20% { filter: drop-shadow(0 0 20px rgba(74, 144, 226, 0.6)); }
            40% { filter: drop-shadow(0 0 30px rgba(74, 144, 226, 0.4)); }
            70% { filter: drop-shadow(0 0 15px rgba(74, 144, 226, 0.3)); }
            100% { filter: drop-shadow(0 0 0 rgba(74, 144, 226, 0)); }
        }

        /* Footer */
        .footer {
            background: rgba(245, 246, 248, 0.9);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            padding: 50px 0 40px;
            text-align: center;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1000px;
            margin: 0 auto;
        }

        .copyright {
            font-family: Georgia, serif;
            font-size: 16px;
            color: #1a1a1a;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .footer-tech-note {
            font-family: Georgia, serif;
            font-size: 14px;
            color: #6c757d;
            font-style: italic;
            line-height: 1.4;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .journey-grid {
                grid-template-columns: 1fr;
                gap: 30px;
            }

            .framework-grid {
                grid-template-columns: 1fr;
            }

            .research-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .page-container {
                padding: 0 30px;
            }

            .header {
                flex-direction: column;
                gap: 30px;
                text-align: center;
                padding: 30px 0;
            }

            .logo-section {
                flex-direction: column;
                gap: 15px;
            }

            .logo {
                margin-right: 0;
            }

            .site-title {
                font-size: 36px;
            }

            .main-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }

            .dropdown-menu {
                position: static;
                opacity: 1;
                visibility: visible;
                transform: none;
                box-shadow: none;
                border: none;
                background: rgba(74, 144, 226, 0.05);
                margin-top: 10px;
                border-radius: 4px;
                display: none;
            }

            .nav-item:hover .dropdown-menu {
                display: block;
            }

            .hero-section {
                padding: 60px 0 40px;
            }

            .hero-title {
                font-size: 42px;
            }

            .hero-subtitle {
                font-size: 20px;
            }

            .hero-questions {
                padding-left: 20px;
            }

            .hero-questions li {
                font-size: 14px;
            }

            .content-section,
            .crr-journey-section {
                padding: 40px 25px;
                margin: 60px 0;
            }

            .section-title {
                font-size: 28px;
            }

            .research-grid {
                grid-template-columns: 1fr;
            }

            .stage-canvas {
                width: 250px;
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header class="header">
            <div class="logo-section">
                <svg class="logo logo-hive" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <radialGradient id="hiveGrad" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" style="stop-color:#8B4513;stop-opacity:0.9" />
                            <stop offset="70%" style="stop-color:#A0522D;stop-opacity:0.8" />
                            <stop offset="100%" style="stop-color:#654321;stop-opacity:0.7" />
                        </radialGradient>
                        <radialGradient id="honeyGrad" cx="50%" cy="50%" r="40%">
                            <stop offset="0%" style="stop-color:#FFD700;stop-opacity:0.8" />
                            <stop offset="100%" style="stop-color:#FFA500;stop-opacity:0.6" />
                        </radialGradient>
                    </defs>
                    
                    <ellipse cx="50" cy="55" rx="25" ry="30" fill="url(#hiveGrad)" stroke="#654321" stroke-width="1"/>
                    <ellipse cx="50" cy="75" rx="6" ry="8" fill="#3D2F1F"/>
                    
                    <path d="M30 40 Q50 38 70 40" stroke="#654321" stroke-width="1" fill="none" opacity="0.7"/>
                    <path d="M32 50 Q50 48 68 50" stroke="#654321" stroke-width="1" fill="none" opacity="0.7"/>
                    <path d="M34 60 Q50 58 66 60" stroke="#654321" stroke-width="1" fill="none" opacity="0.7"/>
                    
                    <g class="logo-interior">
                        <polygon points="45,45 47,43 52,43 54,45 52,47 47,47" fill="url(#honeyGrad)" opacity="0.8"/>
                        <polygon points="52,45 54,43 59,43 61,45 59,47 54,47" fill="url(#honeyGrad)" opacity="0.7"/>
                        <polygon points="38,45 40,43 45,43 47,45 45,47 40,47" fill="url(#honeyGrad)" opacity="0.9"/>
                        <polygon points="41,53 43,51 48,51 50,53 48,55 43,55" fill="url(#honeyGrad)" opacity="0.8"/>
                        <polygon points="48,53 50,51 55,51 57,53 55,55 50,55" fill="url(#honeyGrad)" opacity="0.7"/>
                        
                        <ellipse class="interior-bee-1" cx="46" cy="46" rx="2" ry="1.5" fill="#FFD700" opacity="0.8"/>
                        <ellipse class="interior-bee-2" cx="53" cy="52" rx="2" ry="1.5" fill="#FFD700" opacity="0.9"/>
                    </g>
                    
                    <g class="logo-bee bee-1">
                        <ellipse cx="25" cy="35" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="24" cy="35" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="26" cy="33" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="26" cy="37" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                    
                    <g class="logo-bee bee-2">
                        <ellipse cx="75" cy="45" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="74" cy="45" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="76" cy="43" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="76" cy="47" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                    
                    <g class="logo-bee bee-3">
                        <ellipse cx="40" cy="25" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="39" cy="25" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="41" cy="23" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="41" cy="27" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                    
                    <g class="logo-bee bee-4">
                        <ellipse cx="65" cy="25" rx="3" ry="2" fill="#FFD700"/>
                        <ellipse cx="64" cy="25" rx="1.5" ry="1" fill="#000000"/>
                        <ellipse cx="66" cy="23" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                        <ellipse cx="66" cy="27" rx="2" ry="1" fill="rgba(255,255,255,0.7)"/>
                    </g>
                </svg>
                
                <div class="title-group">
                    <h1 class="site-title">Cohere.org.uk</h1>
                    <p class="strapline">Made of Maths</p>
                </div>
            </div>

            <nav class="main-nav">
                <div class="nav-item">
                    <a href="index.html" class="nav-link active">Home</a>
                </div>
                <div class="nav-item">
                    <a href="crr-simulations.html" class="nav-link">
                        CRR Simulations
                        <span class="dropdown-arrow">▼</span>
                    </a>
                    <div class="dropdown-menu">
                        <a href="biological-systems.html" class="dropdown-link">Biological Systems</a>
                        <a href="physical-systems.html" class="dropdown-link">Physical Systems</a>
                        <a href="mathematical-life.html" class="dropdown-link">Mathematical Life</a>
                    </div>
                </div>
                <div class="nav-item">
                    <a href="crr-benchmarks.html" class="nav-link">CRR Benchmarks</a>
                </div>
                <div class="nav-item">
                    <a href="crr-explained.html" class="nav-link">CRR Explained</a>
                </div>
                <div class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </div>
            </nav>
        </header>

        <main>
            <section class="hero-section">
                <div class="hero-background"></div>
                <div class="hero-content">
                    <h2 class="hero-title">Coherence, Rupture, Regeneration</h2>
                    <p class="hero-subtitle">A coarse-grain mathematical framework for exploring transformation, and renewal in complex systems</p>
                    <div class="hero-questions">
                        <ul>
                            <li>How do complex systems maintain identity by processually changing through the Active Inference cycle?</li>
                            <li>How might shared phenomenological and mathematical languages help us better understand intelligence in a shared context?</li>
                            <li>How might we better understand and adapt to the psychological, sociological and ecological impacts of Technology on human and non-human species?</li>
                            <li>How can we use AI safely, creatively and effectively to further develop our understanding of Systems Theory and Variational Free Energy Reduction through time?</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">What is CRR?</h2>
                <div class="section-content">
                    <p>CRR (Coherence, Rupture, Regeneration) is a three-part mathematical formalism aiming to describe how systems maintain themselves, undergo transformations, and emerge in new configurations across time. This approach captures the dynamic interplay between stability, disruption, and reconstruction that appears in many natural and artificial systems.</p>

                    <div class="framework-grid">
                        <div class="framework-item">
                            <h4>Coherence</h4>
                            <p>The mathematical representation of how systems maintain organised patterns over time. Coherence captures the accumulated memory and structural relationships that maintain a system's identity as it changes state through time (Rupture).</p>
                            <div class="framework-equation">
                                $$C(x,t) = \int_0^t L(x,\tau) \, d\tau$$
                                <div class="equation-explanation">
                                    Where L(x,tau) represents information density accumulated at position x over time tau
                                </div>
                            </div>
                        </div>
                        <div class="framework-item">
                            <h4>Rupture</h4>
                            <p>Represents critical thresholds where existing patterns undergo scale-invariant transitions. These events create opportunities for system reorganisation and the emergence of novel structural arrangements (Regeneration).</p>
                            <div class="framework-equation">
                                $$\delta(t-t_0)$$
                                <div class="equation-explanation">
                                    A Dirac delta function encoding sudden disruptions at time t-zero
                                </div>
                            </div>
                        </div>
                        <div class="framework-item">
                            <h4>Regeneration</h4>
                            <p>The reconstruction process that builds new stable patterns whilst drawing upon the historical information, C(x,t), which is never lost, only transformed. This phase enables systems to maintain continuity whilst expressing novel configurations.</p>
                            <div class="framework-equation">
                                $$R[\chi](x,t) = \int_{-\infty}^t \phi(x,\tau) \cdot e^{C(x,\tau)/\Omega} \cdot \Theta(t-\tau) \, d\tau$$
                                <div class="equation-explanation">
                                    Where phi(x,tau) is the field function and Omega is the coupling constant
                                </div>
                            </div>
                        </div>
                    </div>

                    <p>This mathematical structure provides a way to study systems that exhibit memory-dependent behaviour; where past configurations influence present dynamics in ways that Markovian models might miss. The toy simulations on this site realise this three-part formalism in code, a playful way to explore the deeper mathematical, philosophical and phenomenological concept of how identity persists through change.</p>
                </div>
            </section>

            <section class="crr-journey-section">
                <h2 class="journey-title">The Bee Journey: CRR in Action</h2>
                <p class="journey-description">
                    Watch the same bees travel through all three phases: collecting nectar from flowers, surviving predator attacks, and creating honey in the hive. Each bee maintains memory of its journey, demonstrating non-Markovian dynamics.
                </p>
                
                <div class="journey-grid">
                    <div class="journey-stage">
                        <h3 class="stage-title">Coherence</h3>
                        <canvas class="stage-canvas" id="coherenceCanvas" width="280" height="200"></canvas>
                        <p class="stage-description">Bees pollinate flowers, building memory traces and collecting nectar through organised foraging behaviour</p>
                        <div class="stage-equation">
                            $$C(x,t) = \int_0^t L(x,\tau) \, d\tau$$
                        </div>
                    </div>
                    
                    <div class="journey-stage">
                        <h3 class="stage-title">Rupture</h3>
                        <canvas class="stage-canvas" id="ruptureCanvas" width="280" height="200"></canvas>
                        <p class="stage-description">Bees encounter a predator whilst travelling to the hive, causing sudden dispersal and flight behaviour</p>
                        <div class="stage-equation">
                            $$\delta(t-t_0)$$
                        </div>
                    </div>
                    
                    <div class="journey-stage">
                        <h3 class="stage-title">Regeneration</h3>
                        <canvas class="stage-canvas" id="RegenerationCanvas" width="280" height="200"></canvas>
                        <p class="stage-description">Surviving bees reach the hive and create honey, using accumulated memory from their journey</p>
                        <div class="stage-equation">
                            $$R[\chi](x,t) = \int_{-\infty}^t \phi(x,\tau) \cdot e^{C(x,\tau)/\Omega} \cdot \Theta(t-\tau) \, d\tau$$
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Why CRR?</h2>
                <div class="section-content">
                    <h3>Coherence</h3>
                    <p>Systems, from atoms to technological networks to whole ecosystems, exhibit organised patterns that persist through time. Understanding how coherence resists entropy over time offers potential insight for maintaining and creating more stable and resilient systems in various domains.</p>

                    <h3>Rupture</h3>
                    <p>Complex systems frequently undergo periods of reorganisation at various spatial and temporal scales. Rather than viewing these transitions as purely disruptive, the CRR framework examines how such events create space for system adaptation and novel emergent properties. The 'scale-invariance' of the Dirac Delta makes it a good candidate for modelling the ever-present moment of "now" as a temporal 'rupture' where agentic choice occurs, as well as for modelling any discrete or prolonged shock to a system, causing change and subsequent Regeneration.</p>

                    <h3>Regeneration</h3>
                    <p>Natural systems demonstrate remarkable abilities to recover and adapt following disruptions. The Regeneration component of CRR explores how systems use accumulated information to guide reconstruction processes; informing approaches to resilience in engineered systems.</p>

                    <h4>NB.</h4>
                    <p><em>The CRR formalism was approximated and simplified to model every working simulation showcased on this website. These simulations are mathematically driven, and do not use any external textures, hard-coded animations, or dependencies. It should also be noted, that once an algorithm has been isolated using the CRR derivations, it can be implemented without the CRR pipeline. For example, pearlescence values were derived from Reaction-Diffusion (with memory) experiments, using the CRR, but enabling pearlescence in a simulation does not require the full CRR pipeline. This, perhaps, says something about how algorithms in separate systems can be locally implemented, but are all compatible, or 'coherent', between each other</em></p>
                </div>
            </section>

            <section class="content-section">
                <div class="section-background"></div>
                <h2 class="section-title">Research Interests</h2>
                <div class="section-content">
                    <p>This work may be of interest to researchers exploring mathematical approaches to complex systems. Potential areas of collaboration include:</p>

                    <div class="research-grid">
                        <div class="research-item">
                            <h4>Computational Biology</h4>
                            <p>Mathematical models of development, adaptation, and ecosystem dynamics</p>
                        </div>
                        <div class="research-item">
                            <h4>Dynamical Systems</h4>
                            <p>Non-Markovian processes and memory-dependent dynamics</p>
                        </div>
                        <div class="research-item">
                            <h4>Machine Learning</h4>
                            <p>Continual learning and memory-augmented neural networks</p>
                        </div>
                        <div class="research-item">
                            <h4>Pattern Formation</h4>
                            <p>Reaction-diffusion systems with memory effects</p>
                        </div>
                        <div class="research-item">
                            <h4>Network Science</h4>
                            <p>Adaptive networks and resilience mechanisms</p>
                        </div>
                        <div class="research-item">
                            <h4>Cognitive Science</h4>
                            <p>Mathematical approaches to Psychology and Development</p>
                        </div>
                        <div class="research-item">
                            <h4>Systems Biology</h4>
                            <p>Mathematical frameworks for biological complexity</p>
                        </div>
                        <div class="research-item">
                            <h4>Applied Mathematics</h4>
                            <p>Novel mathematical structures and computational methods</p>
                        </div>
                        <div class="research-item">
                            <h4>Philosophy</h4>
                            <p>Philosophical conjecture and ontological lens</p>
                        </div>
                    </div>

                    <p style="text-align: center; margin-top: 40px; font-size: 18px; color: #4a90e2;">
                        Interested in collaborative research? Contact: <strong>alexander@cohere.org.uk</strong>
                    </p>
                </div>
            </section>
        </main>
    </div>

    <footer class="footer">
        <div class="page-container">
            <div class="footer-content">
                <p class="copyright">
                    <strong>Github Repo: https://github.com/alexsabine/CRR/</strong>
                </p>
                <p class="footer-tech-note">
                    Note: These simulations utilise HTML5, WebGL2, and advanced JavaScript. Desktop browsers recommended for optimal performance.
                </p>
            </div>
        </div>
    </footer>

    <script>
        'use strict';

        /**
         * CRR Bee Journey Demonstration
         */
        class CRRBeeJourney {
            constructor() {
                this.canvases = {
                    coherence: document.getElementById('coherenceCanvas'),
                    rupture: document.getElementById('ruptureCanvas'),
                    Regeneration: document.getElementById('RegenerationCanvas')
                };
                
                this.contexts = {
                    coherence: this.canvases.coherence.getContext('2d'),
                    rupture: this.canvases.rupture.getContext('2d'),
                    Regeneration: this.canvases.Regeneration.getContext('2d')
                };
                
                this.bees = [];
                this.flowers = [];
                this.predator = null;
                this.hive = null;
                this.time = 0;
                this.phaseTimer = 0;
                
                this.init();
            }
            
            init() {
                this.setupEnvironments();
                this.createBees();
                this.startAnimation();
            }
            
            setupEnvironments() {
                // Create flowers in coherence stage
                for (let i = 0; i < 8; i++) {
                    this.flowers.push({
                        x: 40 + Math.random() * 200,
                        y: 40 + Math.random() * 120,
                        nectar: 0.8 + Math.random() * 0.2,
                        size: 4 + Math.random() * 3,
                        color: ['#FF69B4', '#FF1493', '#FFB6C1', '#FF8C69'][Math.floor(Math.random() * 4)],
                        bloomPhase: Math.random() * Math.PI * 2
                    });
                }
                
                // Create predator in rupture stage
                this.predator = {
                    x: 420,
                    y: 100,
                    vx: 0,
                    vy: 0,
                    size: 12,
                    huntRadius: 50,
                    patrolAngle: 0,
                    patrolRadius: 30,
                    baseX: 420,
                    baseY: 100
                };
                
                // Create hive in Regeneration stage
                this.hive = {
                    x: 700,
                    y: 100,
                    size: 25,
                    honeyLevel: 0,
                    activity: 0
                };
            }
            
            createBees() {
                for (let i = 0; i < 8; i++) {
                    this.bees.push({
                        id: i,
                        x: 50 + Math.random() * 50,
                        y: 50 + Math.random() * 50,
                        vx: 0,
                        vy: 0,
                        targetX: 100,
                        targetY: 100,
                        phase: 'foraging',
                        memoryTrace: [],
                        nectar: 0,
                        alive: true,
                        coherenceLevel: 0.5,
                        targetFlower: null,
                        fleeDirection: Math.random() * Math.PI * 2,
                        reachedHive: false
                    });
                }
            }
            
            update() {
                this.time++;
                this.phaseTimer++;
                
                this.bees.forEach(bee => {
                    if (!bee.alive) return;
                    
                    bee.memoryTrace.push({
                        x: bee.x,
                        y: bee.y,
                        nectar: bee.nectar,
                        coherence: bee.coherenceLevel,
                        time: this.time
                    });
                    
                    if (bee.memoryTrace.length > 120) {
                        bee.memoryTrace.shift();
                    }
                    
                    this.updateBeePhase(bee);
                    this.updateBeeMovement(bee);
                });
                
                this.flowers.forEach(flower => {
                    flower.bloomPhase += 0.03;
                    if (flower.nectar < 1.0) {
                        flower.nectar += 0.001;
                    }
                });
                
                if (this.predator) {
                    this.predator.patrolAngle += 0.05;
                    this.predator.x = this.predator.baseX + Math.cos(this.predator.patrolAngle) * this.predator.patrolRadius;
                    this.predator.y = this.predator.baseY + Math.sin(this.predator.patrolAngle) * this.predator.patrolRadius;
                }
                
                if (this.hive) {
                    const nearbyBees = this.bees.filter(bee => 
                        bee.alive && 
                        Math.sqrt((bee.x - this.hive.x) ** 2 + (bee.y - this.hive.y) ** 2) < this.hive.size
                    );
                    this.hive.activity = nearbyBees.length / this.bees.filter(b => b.alive).length;
                    this.hive.honeyLevel += nearbyBees.reduce((sum, bee) => sum + bee.nectar, 0) * 0.001;
                }
                
                this.checkPhaseTransitions();
            }
            
            updateBeePhase(bee) {
                switch (bee.phase) {
                    case 'foraging':
                        this.updateForagingBee(bee);
                        break;
                    case 'traveling':
                        this.updateTravelingBee(bee);
                        break;
                    case 'fleeing':
                        this.updateFleeingBee(bee);
                        break;
                    case 'hive_activity':
                        this.updateHiveBee(bee);
                        break;
                }
            }
            
            updateForagingBee(bee) {
                if (!bee.targetFlower || bee.targetFlower.nectar < 0.1) {
                    const availableFlowers = this.flowers.filter(f => f.nectar > 0.1);
                    if (availableFlowers.length > 0) {
                        bee.targetFlower = availableFlowers.reduce((nearest, flower) => {
                            const dist = Math.sqrt((flower.x - bee.x) ** 2 + (flower.y - bee.y) ** 2);
                            return !nearest || dist < nearest.dist ? { flower, dist } : nearest;
                        }, null)?.flower;
                    }
                }
                
                if (bee.targetFlower) {
                    const dx = bee.targetFlower.x - bee.x;
                    const dy = bee.targetFlower.y - bee.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 8) {
                        const collected = Math.min(0.05, bee.targetFlower.nectar);
                        bee.targetFlower.nectar -= collected;
                        bee.nectar += collected;
                        bee.coherenceLevel += collected * 0.1;
                        
                        if (bee.nectar > 0.3) {
                            bee.phase = 'traveling';
                            bee.targetX = this.predator.x;
                            bee.targetY = this.predator.y;
                        }
                    } else {
                        bee.vx += (dx / distance) * 0.3;
                        bee.vy += (dy / distance) * 0.3;
                    }
                }
                
                this.applyMemoryBasedCohesion(bee);
            }
            
            updateTravelingBee(bee) {
                const dx = bee.targetX - bee.x;
                const dy = bee.targetY - bee.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    bee.vx += (dx / distance) * 0.2;
                    bee.vy += (dy / distance) * 0.2;
                }
                
                if (bee.x >= 280 && bee.x <= 560) {
                    this.checkPredatorThreat(bee);
                    
                    if (bee.phase === 'traveling' && Math.abs(bee.x - this.predator.x) < 50) {
                        bee.targetX = this.hive.x;
                        bee.targetY = this.hive.y;
                    }
                }
                
                if (bee.x > 560) {
                    bee.phase = 'hive_activity';
                    bee.targetX = this.hive.x;
                    bee.targetY = this.hive.y;
                    bee.reachedHive = true;
                }
            }
            
            updateFleeingBee(bee) {
                const dx = bee.x - this.predator.x;
                const dy = bee.y - this.predator.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const fleeForce = Math.max(0, 1 - distance / this.predator.huntRadius) * 2;
                    bee.vx += (dx / distance) * fleeForce;
                    bee.vy += (dy / distance) * fleeForce;
                }
                
                bee.vx += (Math.random() - 0.5) * 0.8;
                bee.vy += (Math.random() - 0.5) * 0.8;
                
                if (distance < 8 && Math.random() < 0.02) {
                    bee.alive = false;
                }
                
                if (distance > this.predator.huntRadius * 1.5) {
                    bee.phase = 'traveling';
                    bee.targetX = this.hive.x;
                    bee.targetY = this.hive.y;
                }
            }
            
            updateHiveBee(bee) {
                const dx = this.hive.x - bee.x;
                const dy = this.hive.y - bee.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.hive.size) {
                    bee.vx += (dx / distance) * 0.4;
                    bee.vy += (dy / distance) * 0.4;
                } else {
                    if (bee.nectar > 0) {
                        const honeyProduction = bee.nectar * 0.02;
                        bee.nectar -= honeyProduction;
                        
                        const memoryBonus = bee.memoryTrace.length / 120;
                        this.hive.honeyLevel += honeyProduction * (1 + memoryBonus);
                    }
                    
                    bee.vx += (Math.random() - 0.5) * 0.1;
                    bee.vy += (Math.random() - 0.5) * 0.1;
                }
            }
            
            checkPredatorThreat(bee) {
                const dx = bee.x - this.predator.x;
                const dy = bee.y - this.predator.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.predator.huntRadius) {
                    bee.phase = 'fleeing';
                    bee.coherenceLevel *= 0.5;
                }
            }
            
            applyMemoryBasedCohesion(bee) {
                if (bee.memoryTrace.length > 10) {
                    const recentMemory = bee.memoryTrace.slice(-30);
                    const avgX = recentMemory.reduce((sum, m) => sum + m.x, 0) / recentMemory.length;
                    const avgY = recentMemory.reduce((sum, m) => sum + m.y, 0) / recentMemory.length;
                    
                    bee.vx += (avgX - bee.x) * 0.01;
                    bee.vy += (avgY - bee.y) * 0.01;
                }
                
                this.bees.forEach(other => {
                    if (other !== bee && other.alive) {
                        const dx = other.x - bee.x;
                        const dy = other.y - bee.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 30 && distance > 0) {
                            const cohesionForce = (30 - distance) / 30 * 0.05;
                            bee.vx += (dx / distance) * cohesionForce;
                            bee.vy += (dy / distance) * cohesionForce;
                        }
                    }
                });
            }
            
            updateBeeMovement(bee) {
                if (!bee.alive) return;
                
                bee.x += bee.vx;
                bee.y += bee.vy;
                
                bee.vx *= 0.9;
                bee.vy *= 0.9;
                
                const speed = Math.sqrt(bee.vx * bee.vx + bee.vy * bee.vy);
                const maxSpeed = bee.phase === 'fleeing' ? 4 : 2;
                if (speed > maxSpeed) {
                    bee.vx = (bee.vx / speed) * maxSpeed;
                    bee.vy = (bee.vy / speed) * maxSpeed;
                }
                
                if (bee.phase === 'foraging') {
                    bee.x = Math.max(10, Math.min(270, bee.x));
                    bee.y = Math.max(10, Math.min(190, bee.y));
                } else if (bee.phase === 'traveling' || bee.phase === 'fleeing') {
                    bee.x = Math.max(10, Math.min(840, bee.x));
                    bee.y = Math.max(10, Math.min(190, bee.y));
                } else if (bee.phase === 'hive_activity') {
                    bee.x = Math.max(560, Math.min(840, bee.x));
                    bee.y = Math.max(10, Math.min(190, bee.y));
                }
            }
            
            checkPhaseTransitions() {
                const aliveBees = this.bees.filter(b => b.alive);
                const beesInHive = aliveBees.filter(b => b.reachedHive);
                
                if (aliveBees.length === beesInHive.length && this.phaseTimer > 300) {
                    this.resetJourney();
                }
            }
            
            resetJourney() {
                this.phaseTimer = 0;
                
                this.bees.forEach(bee => {
                    bee.x = 50 + Math.random() * 50;
                    bee.y = 50 + Math.random() * 50;
                    bee.vx = 0;
                    bee.vy = 0;
                    bee.phase = 'foraging';
                    bee.nectar = 0;
                    bee.alive = true;
                    bee.coherenceLevel = 0.5;
                    bee.reachedHive = false;
                    bee.targetFlower = null;
                    bee.memoryTrace = [];
                });
                
                this.flowers.forEach(flower => {
                    flower.nectar = 0.8 + Math.random() * 0.2;
                });
                
                this.hive.honeyLevel = 0;
                this.hive.activity = 0;
            }
            
            render() {
                Object.values(this.contexts).forEach(ctx => {
                    ctx.clearRect(0, 0, 280, 200);
                });
                
                this.renderCoherenceStage();
                this.renderRuptureStage();
                this.renderRegenerationStage();
            }
            
            renderCoherenceStage() {
                const ctx = this.contexts.coherence;
                
                this.flowers.forEach(flower => {
                    ctx.save();
                    ctx.translate(flower.x, flower.y);
                    
                    const bloomPulse = Math.sin(flower.bloomPhase) * 0.3;
                    const currentSize = flower.size + bloomPulse;
                    
                    ctx.fillStyle = flower.color;
                    ctx.globalAlpha = 0.7 + flower.nectar * 0.3;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI;
                        ctx.save();
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.ellipse(0, -currentSize * 0.8, currentSize * 0.4, currentSize * 0.8, 0, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(0, 0, currentSize * 0.3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                });
                
                this.bees.forEach(bee => {
                    if (bee.alive && bee.x < 280) {
                        this.drawBee(ctx, bee, '#4a90e2');
                    }
                });
            }
            
            renderRuptureStage() {
                const ctx = this.contexts.rupture;
                
                const predatorCanvasX = this.predator.x - 280;
                const predatorCanvasY = this.predator.y;
                
                ctx.save();
                ctx.translate(predatorCanvasX, predatorCanvasY);
                
                ctx.fillStyle = '#2F2F2F';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.predator.size, this.predator.size * 0.6, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                const wingFlap = Math.sin(this.time * 0.3) * 0.5;
                ctx.fillStyle = '#1A1A1A';
                ctx.save();
                ctx.rotate(wingFlap);
                ctx.beginPath();
                ctx.ellipse(-this.predator.size * 0.3, -this.predator.size * 1.2, this.predator.size, this.predator.size * 0.4, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.rotate(-wingFlap);
                ctx.beginPath();
                ctx.ellipse(-this.predator.size * 0.3, this.predator.size * 1.2, this.predator.size, this.predator.size * 0.4, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                
                ctx.strokeStyle = 'rgba(220, 53, 69, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.predator.huntRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
                
                this.bees.forEach(bee => {
                    if (bee.alive && bee.x >= 280 && bee.x <= 560) {
                        const beeColor = bee.phase === 'fleeing' ? '#dc3545' : '#ffc107';
                        this.drawBee(ctx, { ...bee, x: bee.x - 280 }, beeColor);
                    }
                });
            }
            
            renderRegenerationStage() {
                const ctx = this.contexts.Regeneration;
                
                const hiveCanvasX = this.hive.x - 560;
                const hiveCanvasY = this.hive.y;
                
                ctx.save();
                ctx.translate(hiveCanvasX, hiveCanvasY);
                
                ctx.fillStyle = '#8B4513';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(0, 0, this.hive.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(0, this.hive.size * 0.7, 6, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.hive.honeyLevel > 0) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${Math.min(this.hive.honeyLevel * 10, 0.8)})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.hive.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                if (this.hive.activity > 0) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${this.hive.activity * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.hive.size + Math.sin(this.time * 0.1) * 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.font = '12px Georgia';
                ctx.textAlign = 'center';
                ctx.fillText(`Honey: ${(this.hive.honeyLevel * 100).toFixed(1)}%`, 140, 20);
                
                this.bees.forEach(bee => {
                    if (bee.alive && bee.x > 560) {
                        this.drawBee(ctx, { ...bee, x: bee.x - 560 }, '#28a745');
                    }
                });
            }
            
            drawBee(ctx, bee, color) {
                ctx.save();
                ctx.translate(bee.x, bee.y);
                
                const size = 2.5;
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 1.5, size, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.ellipse(-size * 0.3, 0, size * 0.3, size * 0.8, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(size * 0.3, 0, size * 0.3, size * 0.8, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                const wingFlap = Math.sin(this.time * 0.4) * 0.3;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.save();
                ctx.rotate(wingFlap);
                ctx.beginPath();
                ctx.ellipse(-size * 0.5, -size * 1.2, size * 0.8, size * 1.5, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.rotate(-wingFlap);
                ctx.beginPath();
                ctx.ellipse(-size * 0.5, size * 1.2, size * 0.8, size * 1.5, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                
                if (bee.phase === 'foraging' && bee.memoryTrace && bee.memoryTrace.length > 5) {
                    ctx.strokeStyle = `rgba(74, 144, 226, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    bee.memoryTrace.slice(-10).forEach((pos, i) => {
                        const trailX = pos.x - bee.x;
                        const trailY = pos.y - bee.y;
                        if (i === 0) {
                            ctx.moveTo(trailX, trailY);
                        } else {
                            ctx.lineTo(trailX, trailY);
                        }
                    });
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            startAnimation() {
                const animate = () => {
                    this.update();
                    this.render();
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        /**
         * Main Application
         */
        class CRRHomepage {
            constructor() {
                this.animationTime = 0;
                this.isAnimating = true;
                this.rafId = null;
                this.elements = this.cacheElements();
                this.ruptureActive = false;
                this.ruptureStartTime = 0;
                this.beeJourney = null;
                this.init();
            }

            cacheElements() {
                return {
                    logo: document.querySelector('.logo'),
                    logoHive: document.querySelector('.logo-hive'),
                    bees: document.querySelectorAll('.logo-bee'),
                    interiorBees: document.querySelectorAll('[class*="interior-bee"]'),
                    navLinks: document.querySelectorAll('.nav-link')
                };
            }

            init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.start());
                } else {
                    this.start();
                }
            }

            start() {
                try {
                    this.setupLogoInteractions();
                    this.setupNavigationInteractions();
                    this.setupBeeJourney();
                    
                    if (!this.respectsReducedMotion()) {
                        this.startAnimation();
                    }
                    
                    this.setupVisibilityChange();
                } catch (error) {
                    console.error('Initialisation error:', error);
                }
            }

            setupLogoInteractions() {
                if (!this.elements.logo) return;

                this.elements.logo.addEventListener('click', () => {
                    this.triggerDiracRupture();
                });
            }

            triggerDiracRupture() {
                if (this.ruptureActive) return;

                this.ruptureActive = true;
                this.ruptureStartTime = this.animationTime;
                
                this.elements.logoHive.classList.add('rupture');
                
                setTimeout(() => {
                    this.elements.logoHive.classList.remove('rupture');
                }, 3000);

                setTimeout(() => {
                    this.ruptureActive = false;
                }, 4000);
            }

            setupNavigationInteractions() {
                this.elements.navLinks.forEach((link) => {
                    link.addEventListener('mouseenter', () => {
                        if (!link.classList.contains('active')) {
                            link.style.transform = 'translateY(-2px)';
                        }
                    });
                    
                    link.addEventListener('mouseleave', () => {
                        link.style.transform = 'translateY(0)';
                    });
                });
            }

            setupBeeJourney() {
                this.beeJourney = new CRRBeeJourney();
            }

            startAnimation() {
                const animate = () => {
                    if (!this.isAnimating) return;
                    
                    this.animationTime += 0.025;
                    this.animateBees();
                    this.animateInteriorBees();
                    
                    this.rafId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            animateBees() {
                this.elements.bees.forEach((bee, index) => {
                    if (this.ruptureActive) {
                        this.animateRuptureBees(bee, index);
                    } else {
                        this.animateNormalBees(bee, index);
                    }
                });
            }

            animateNormalBees(bee, index) {
                const baseAngle = (index * Math.PI * 0.5) + this.animationTime * (0.4 + index * 0.15);
                const radius = 20 + Math.sin(this.animationTime * 0.7 + index) * 6;
                
                const figure8 = Math.sin(this.animationTime * 0.6 + index * 0.8) * 8;
                
                const x = 50 + Math.cos(baseAngle) * radius + figure8 * Math.cos(baseAngle * 2);
                const y = 50 + Math.sin(baseAngle) * radius * 0.8 + figure8 * 0.3 * Math.sin(baseAngle * 3);
                
                bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                
                const wingBeat = 0.6 + 0.4 * Math.sin(this.animationTime * 12 + index * 2.5);
                bee.style.opacity = wingBeat;
            }

            animateRuptureBees(bee, index) {
                const elapsedTime = this.animationTime - this.ruptureStartTime;
                
                if (elapsedTime < 60) {
                    const disperseProgress = elapsedTime / 60;
                    const disperseAngle = (index * Math.PI * 0.5) + this.animationTime * (2.5 + index * 0.6);
                    const disperseRadius = 20 + disperseProgress * (70 + index * 12);
                    
                    const x = 50 + Math.cos(disperseAngle) * disperseRadius;
                    const y = 50 + Math.sin(disperseAngle) * disperseRadius;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.2 + 0.8 * Math.sin(this.animationTime * 25 + index * 3.5);
                    
                } else if (elapsedTime < 140) {
                    const recohereProgress = (elapsedTime - 60) / 80;
                    const smoothProgress = 1 - Math.pow(1 - recohereProgress, 3);
                    
                    const currentRadius = 90 - smoothProgress * 70;
                    const angle = (index * Math.PI * 0.5) + this.animationTime * (1.8 - smoothProgress * 1.4);
                    
                    const x = 50 + Math.cos(angle) * currentRadius;
                    const y = 50 + Math.sin(angle) * currentRadius * 0.8;
                    
                    bee.setAttribute('transform', `translate(${x - 50}, ${y - 50})`);
                    bee.style.opacity = 0.6 + 0.4 * Math.sin(this.animationTime * (15 - smoothProgress * 5) + index * 2.5);
                }
            }

            animateInteriorBees() {
                this.elements.interiorBees.forEach((bee, index) => {
                    const movement = Math.sin(this.animationTime * 2.5 + index * 3.5) * 2;
                    const rotation = Math.sin(this.animationTime * 2 + index * 2.5) * 8;
                    
                    bee.setAttribute('transform', `translate(${movement}, ${movement * 0.6}) rotate(${rotation})`);
                });
            }

            setupVisibilityChange() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.isAnimating = false;
                        if (this.rafId) {
                            cancelAnimationFrame(this.rafId);
                        }
                    } else if (!this.respectsReducedMotion()) {
                        this.isAnimating = true;
                        this.startAnimation();
                    }
                });
            }

            respectsReducedMotion() {
                return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            }

            destroy() {
                this.isAnimating = false;
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                }
            }
        }

        // Initialize application
        const app = new CRRHomepage();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (app) app.destroy();
        });
    </script>
</body>
</html>
