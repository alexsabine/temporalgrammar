<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Learning: Dolphins with Sonar Detection</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f8f9fa;
      color: #212529;
      line-height: 1.6;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
      background: white;
    }
    
    .header {
      background: #1e3a8a;
      color: white;
      padding: 20px 30px;
      border-bottom: 3px solid #2563eb;
    }
    
    .header h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .header p {
      font-size: 14px;
      opacity: 0.9;
    }
    
    .math-explanation {
      background: #ecf0f1;
      border-bottom: 1px solid #bdc3c7;
    }
    
    .math-toggle {
      width: 100%;
      padding: 15px 30px;
      background: none;
      border: none;
      text-align: left;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #2c3e50;
      transition: background 0.2s;
    }
    
    .math-toggle:hover {
      background: #d5dbdb;
    }
    
    .math-toggle-icon {
      transition: transform 0.3s;
    }
    
    .math-toggle-icon.open {
      transform: rotate(180deg);
    }
    
    .math-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .math-content.open {
      max-height: 5000px;
    }
    
    .math-inner {
      padding: 20px 30px 30px;
      font-size: 14px;
    }
    
    .math-section {
      margin-bottom: 25px;
      padding: 20px;
      background: white;
      border-radius: 6px;
      border-left: 4px solid #3498db;
    }
    
    .math-section h3 {
      font-size: 17px;
      color: #2c3e50;
      margin-bottom: 12px;
      font-weight: 600;
    }
    
    .math-section h4 {
      font-size: 15px;
      color: #34495e;
      margin: 15px 0 10px 0;
      font-weight: 600;
    }
    
    .math-section p {
      margin-bottom: 10px;
      line-height: 1.7;
    }
    
    .math-equation {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #dee2e6;
      margin: 12px 0;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      overflow-x: auto;
    }
    
    .canvas-container {
      padding: 0;
      background: #0d1b2a;
      position: relative;
      width: 100%;
      height: 70vh;
      min-height: 500px;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    .overlay-controls {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10;
      max-height: calc(100% - 30px);
      overflow-y: auto;
      min-width: 220px;
      transition: background 0.3s ease;
      backdrop-filter: blur(5px);
    }
    
    .overlay-controls:hover {
      background: rgba(255, 255, 255, 0.85);
    }
    
    .overlay-controls h4 {
      font-size: 13px;
      margin-bottom: 12px;
      color: #2c3e50;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
      transition: color 0.3s ease;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
    }
    
    .overlay-controls:hover h4 {
      text-shadow: none;
    }
    
    .control-section {
      margin-bottom: 15px;
    }
    
    .control-section-title {
      font-size: 11px;
      color: #7f8c8d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
      font-weight: 600;
    }
    
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      padding: 4px 0;
    }
    
    .checkbox-item input[type="checkbox"] {
      cursor: pointer;
      width: 16px;
      height: 16px;
    }
    
    .checkbox-item label {
      cursor: pointer;
      user-select: none;
      flex: 1;
    }
    
    .learning-stats {
      margin-top: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .stat-label {
      color: #555;
      font-weight: 500;
    }
    
    .stat-value {
      color: #3498db;
      font-weight: 700;
      font-family: 'Courier New', monospace;
    }
    
    .progress-bar {
      height: 6px;
      background: rgba(52, 152, 219, 0.2);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .controls {
      padding: 20px 30px;
      background: white;
      border-top: 1px solid #ecf0f1;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .controls button {
      padding: 10px 20px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .controls button:hover {
      background: #2980b9;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .controls button:active {
      transform: translateY(0);
    }
    
    .metrics {
      padding: 20px 30px;
      background: #f8f9fa;
      border-top: 1px solid #ecf0f1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    
    .metric-box {
      background: white;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #3498db;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .metric-label {
      font-size: 12px;
      color: #7f8c8d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: 700;
      color: #2c3e50;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>CRR Learning: Dolphins with Sonar Detection</h1>
      <p>Click underwater to create bubble rings, or click in the air to create hula-hoops! Dolphins use CRR-based sonar to detect rings, learning optimal approach trajectories through memory-weighted regeneration.</p>
    </div>
    
    <div class="math-explanation">
      <button class="math-toggle" onclick="toggleMath()">
        <span>üìê CRR Mathematical Framework & Sonar Detection</span>
        <span class="math-toggle-icon" id="mathToggleIcon">‚ñº</span>
      </button>
      <div class="math-content" id="mathContent">
        <div class="math-inner">
          
          <div class="math-section">
            <h3>Core CRR Operators</h3>
            
            <h4>Coherence Integration C(x,t)</h4>
            <div class="math-equation">
C(x,t) = ‚à´‚ÇÄ·µó L(x,œÑ) dœÑ

Where:
- L(x,œÑ) = Memory density (accumulated state information)
- Non-Markovian: ALL past states influence future behavior
            </div>
            <p>Coherence accumulates continuously as dolphins practice ring passages. Higher coherence = stronger commitment to current behavioral patterns, but also increased rigidity.</p>
            
            <h4>Rupture Detection Œ¥(t-t‚ÇÄ)</h4>
            <div class="math-equation">
Œ¥(t-t‚ÇÄ) = Dirac delta at rupture threshold

Triggers when: C(x,t) > C‚Çú‚Çï·µ£‚Çë‚Çõ‚Çï‚Çí‚Çóùíπ
            </div>
            <p>When coherence exceeds threshold (100 in this simulation), the system becomes too rigid to absorb new information. Rupture is thermodynamically necessary, not a failure.</p>
            
            <h4>Regeneration Operator R[œá](x,t)</h4>
            <div class="math-equation">
R[œá](x,t) = ‚à´‚ÇÄ·µó œÜ(x,œÑ)¬∑exp(C(x)/Œ©)¬∑Œò(t-œÑ) dœÑ

Where:
- œÜ(x,œÑ) = Historical field signal (past successful trajectories)
- Œ© = System temperature parameter (15.0 for dolphins)
- exp(C/Œ©) = Exponential memory weighting
- Œò(t-œÑ) = Heaviside function (causality constraint)
            </div>
            <p>Past states gain exponentially increasing influence as coherence builds. Successful ring passages are weighted by accuracy √ó recency, creating adaptive learning.</p>
          </div>
          
          <div class="math-section">
            <h3>CRR Sonar Detection System</h3>
            
            <h4>Sonar Pulse Emission</h4>
            <div class="math-equation">
Sonar pulse emitted every N frames when:
- Dolphin coherence C > 20 (sufficient awareness)
- Active exploration or ring-seeking behavior

Pulse properties:
- Radius: r(t) = v_sound ¬∑ t
- Intensity: I(r) = I‚ÇÄ ¬∑ exp(-r/Œª)
- Œª = Coherence-dependent attenuation length
            </div>
            <p>Dolphins with higher coherence emit sonar more frequently and with greater range. The sonar itself is a CRR process - it accumulates information about the environment.</p>
            
            <h4>Coherence Field Interaction</h4>
            <div class="math-equation">
When sonar intersects bubble ring:
Detection_strength = C_dolphin ¬∑ exp(-distance/range) ¬∑ ring_opacity

Information gain: ŒîI = Detection_strength ¬∑ (1 + C_dolphin/Œ©)
            </div>
            <p>The dolphin's coherence field interacts with detected targets. Higher coherence = better target discrimination and memory-weighted target prioritization.</p>
            
            <h4>Memory-Weighted Target Selection</h4>
            <div class="math-equation">
Target priority = distance‚Åª¬π ¬∑ similarity(current, past_success) ¬∑ exp(C/Œ©)

Where similarity measured by:
- Angle relative to swimming direction
- Depth similarity to successful passages
- Ring size preference from memory
            </div>
            <p>Dolphins don't just detect rings - they weight them by similarity to past successful passages. This is pure CRR: coherence amplifies the influence of historical patterns.</p>
          </div>
          
          <div class="math-section">
            <h3>Learning Dynamics</h3>
            
            <h4>Exploitation-Rigidity Trap</h4>
            <p>As dolphins successfully pass through rings, coherence increases. This amplifies the weight of successful trajectories via exp(C/Œ©), creating increasingly precise approaches. However, excessive coherence makes the system brittle - unable to adapt to new ring positions or sizes. Rupture becomes thermodynamically necessary.</p>
            
            <h4>Regeneration After Rupture</h4>
            <div class="math-equation">
Post-rupture velocity regeneration:

v_new = (1 - Œ±) ¬∑ v_current + Œ± ¬∑ Œ£·µ¢ w·µ¢ ¬∑ v_memory_i

Where:
- Œ± = Regeneration strength (0.5)
- w·µ¢ = accuracy_i ¬∑ recency_i (normalized)
- Top 3 most successful memories selected
            </div>
            <p>After rupture, dolphins regenerate movement patterns from their most successful memories. This isn't random exploration - it's targeted sampling of the historical phase space weighted by past performance.</p>
            
            <h4>Collective Pod Intelligence</h4>
            <p>When multiple dolphins are present, their coherence fields overlap. This creates emergent coordination - dolphins tend to approach rings that other pod members have successfully passed. The collective memory exceeds individual capacity.</p>
          </div>
          
          <div class="math-section">
            <h3>Observable Predictions</h3>
            <p><strong>Early trials (C < 30):</strong> Erratic approaches, frequent misses, wide distribution of trajectories.</p>
            <p><strong>Learning phase (30 < C < 70):</strong> Increasing precision, exp(C/Œ©) rises from ~7 to ~90, accuracy improves from 40% to 75%.</p>
            <p><strong>Pre-rupture (C > 90):</strong> Near-perfect centering on familiar ring positions, but rigidity to novel configurations. Success rate peaks then plateaus.</p>
            <p><strong>Post-rupture regeneration:</strong> Brief performance drop as system explores, then rapid recovery weighted by successful memories.</p>
          </div>
          
        </div>
      </div>
    </div>
    
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      
      <div class="overlay-controls">
        <h4>Visualization</h4>
        
        <div class="control-section">
          <div class="control-section-title">Visual Elements</div>
          <div class="checkbox-group">
            <div class="checkbox-item">
              <input type="checkbox" id="showCoherence" checked>
              <label for="showCoherence">Coherence Fields</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="showSonar" checked>
              <label for="showSonar">Sonar Pulses</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="showTrails" checked>
              <label for="showTrails">Motion Trails</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="showConnections">
              <label for="showConnections">Pod Connections</label>
            </div>
            <div class="checkbox-item">
              <input type="checkbox" id="showTargeting" checked>
              <label for="showTargeting">Target Lines</label>
            </div>
          </div>
        </div>
        
        <div class="learning-stats">
          <div class="stat-row">
            <span class="stat-label">Avg Coherence</span>
            <span class="stat-value" id="avgCoherence">0.0</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="coherenceProgress"></div>
          </div>
          
          <div class="stat-row" style="margin-top: 12px;">
            <span class="stat-label">Memory Weight</span>
            <span class="stat-value" id="memoryWeight">1.0</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="memoryProgress"></div>
          </div>
          
          <div class="stat-row" style="margin-top: 12px;">
            <span class="stat-label">Learning Status</span>
            <span class="stat-value" id="learningStatus">Building</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="controls">
      <button onclick="addDolphin()">Add Dolphin üê¨</button>
      <button onclick="addFishSchool()">Add Fish School üêü</button>
      <button onclick="resetScene()">Reset Scene üîÑ</button>
    </div>
    
    <div class="metrics">
      <div class="metric-box">
        <div class="metric-label">Dolphins</div>
        <div class="metric-value" id="dolphinCount">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-label">Fish</div>
        <div class="metric-value" id="fishCount">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-label">Rings Passed</div>
        <div class="metric-value" id="ringsPassed">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-label">Success Rate</div>
        <div class="metric-value" id="successRate">0%</div>
      </div>
      <div class="metric-box">
        <div class="metric-label">Avg Accuracy</div>
        <div class="metric-value" id="avgAccuracy">0%</div>
      </div>
      <div class="metric-box">
        <div class="metric-label">Sonar Detections</div>
        <div class="metric-value" id="sonarDetections">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-label">Jumps Performed</div>
        <div class="metric-value" id="jumpCount">0</div>
      </div>
    </div>
  </div>

<script>
(function() {
  'use strict';
  
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  
  let width, height;
  let simulationTime = 0;
  
  // CRR Parameters
  const OMEGA_DOLPHIN = 15.0;
  const OMEGA_FISH = 10.0;
  const RUPTURE_THRESHOLD = 100;
  const SURFACE_Y = 0.25;
  
  // Process toggles
  const processToggles = {
    coherence: true,
    sonar: true,
    trails: true,
    connections: false,
    targeting: true
  };
  
  // Entities
  let dolphins = [];
  let fishSchools = [];
  let bubbleRings = [];
  let hulaHoops = [];
  let sonarPulses = [];
  
  // Learning metrics
  let totalRingsPassed = 0;
  let totalRingAttempts = 0;
  let totalSonarDetections = 0;
  let totalJumps = 0;
  let accuracyHistory = [];
  
  // Audio
  let audioCtx;
  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  
  function playSound(freq, duration, volume) {
    initAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = 'sine';
    gain.gain.setValueAtTime(volume, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }
  
  // Spatial hash
  class SpatialHash {
    constructor(cellSize) {
      this.cellSize = cellSize;
      this.cells = new Map();
    }
    
    clear() {
      this.cells.clear();
    }
    
    hash(x, y) {
      const cellX = Math.floor(x / this.cellSize);
      const cellY = Math.floor(y / this.cellSize);
      return `${cellX},${cellY}`;
    }
    
    insert(entity) {
      const key = this.hash(entity.x, entity.y);
      if (!this.cells.has(key)) {
        this.cells.set(key, []);
      }
      this.cells.get(key).push(entity);
    }
    
    queryRadius(x, y, radius) {
      const results = [];
      const minCellX = Math.floor((x - radius) / this.cellSize);
      const maxCellX = Math.floor((x + radius) / this.cellSize);
      const minCellY = Math.floor((y - radius) / this.cellSize);
      const maxCellY = Math.floor((y + radius) / this.cellSize);
      
      for (let cy = minCellY; cy <= maxCellY; cy++) {
        for (let cx = minCellX; cx <= maxCellX; cx++) {
          const key = `${cx},${cy}`;
          const cell = this.cells.get(key);
          if (cell) {
            for (let entity of cell) {
              const dx = entity.x - x;
              const dy = entity.y - y;
              if (dx * dx + dy * dy <= radius * radius) {
                results.push(entity);
              }
            }
          }
        }
      }
      return results;
    }
  }
  
  const spatialHash = new SpatialHash(80);
  
  // Sonar Pulse class
  class SonarPulse {
    constructor(x, y, dolphin) {
      this.x = x;
      this.y = y;
      this.dolphin = dolphin;
      this.radius = 0;
      this.maxRadius = 150 + (dolphin.coherence * 0.5);
      this.speed = 4;
      this.age = 0;
      this.detections = [];
    }
    
    update(rings) {
      this.radius += this.speed;
      this.age++;
      
      for (let ring of rings) {
        if (!this.detections.includes(ring)) {
          const dx = ring.x - this.x;
          const dy = ring.y - this.y;
          const dist = Math.hypot(dx, dy);
          
          if (Math.abs(dist - this.radius) < 10 && ring.opacity > 0.3) {
            this.detections.push(ring);
            const detectionStrength = this.dolphin.coherence * Math.exp(-dist / this.maxRadius) * ring.opacity;
            this.dolphin.onSonarDetection(ring, detectionStrength, dist);
            totalSonarDetections++;
            playSound(1200 + Math.random() * 300, 0.05, 0.08);
          }
        }
      }
      
      return this.radius < this.maxRadius;
    }
    
    draw(ctx) {
      if (!processToggles.sonar) return;
      
      const opacity = Math.max(0, 1 - (this.radius / this.maxRadius));
      
      ctx.strokeStyle = `rgba(100, 255, 200, ${opacity * 0.5})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.strokeStyle = `rgba(100, 255, 200, ${opacity * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius - 2, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
  
  // Bubble Ring class
  class BubbleRing {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.radius = 5;
      this.targetRadius = 40 + Math.random() * 20;
      this.thickness = 8;
      this.age = 0;
      this.maxAge = 600;
      this.opacity = 0;
      this.passed = false;
      this.attempted = false;
      this.passedBy = new Set();
      this.detectedBy = new Set();
      this.bubblesParticles = [];
      
      const numBubbles = 40;
      for (let i = 0; i < numBubbles; i++) {
        const angle = (i / numBubbles) * Math.PI * 2;
        this.bubblesParticles.push({
          angle: angle,
          offset: Math.random() * 5,
          size: 2 + Math.random() * 3,
          phase: Math.random() * Math.PI * 2
        });
      }
    }
    
    update() {
      this.age++;
      
      if (this.radius < this.targetRadius) {
        this.radius += (this.targetRadius - this.radius) * 0.1;
      }
      
      if (this.age < 30) {
        this.opacity = this.age / 30;
      } else if (this.age > this.maxAge - 60) {
        this.opacity = (this.maxAge - this.age) / 60;
      } else {
        this.opacity = 1;
      }
      
      this.y -= 0.3;
      
      for (let bubble of this.bubblesParticles) {
        bubble.phase += 0.05;
      }
      
      return this.age < this.maxAge && this.y > 0;
    }
    
    checkDolphinPassage(dolphin) {
      if (this.passedBy.has(dolphin)) return null;
      
      const dx = dolphin.x - this.x;
      const dy = dolphin.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      if (Math.abs(dist - this.radius) < 30) {
        if (!this.attempted) {
          this.attempted = true;
          totalRingAttempts++;
        }
        
        if (Math.abs(dist - this.radius) < this.thickness + 10) {
          this.passedBy.add(dolphin);
          const accuracy = 1 - Math.min(1, Math.abs(dist - this.radius) / this.thickness);
          
          return {
            success: true,
            accuracy: accuracy,
            x: this.x,
            y: this.y
          };
        }
      }
      
      return null;
    }
    
    draw(ctx) {
      ctx.save();
      ctx.globalAlpha = this.opacity;
      
      if (this.detectedBy.size > 0 && processToggles.sonar) {
        const glowGradient = ctx.createRadialGradient(this.x, this.y, this.radius - 20,
                                                        this.x, this.y, this.radius + 20);
        glowGradient.addColorStop(0, 'rgba(100, 255, 200, 0)');
        glowGradient.addColorStop(0.5, 'rgba(100, 255, 200, 0.3)');
        glowGradient.addColorStop(1, 'rgba(100, 255, 200, 0)');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius + 15, 0, Math.PI * 2);
        ctx.fill();
      }
      
      const gradient = ctx.createRadialGradient(this.x, this.y, this.radius - this.thickness,
                                                 this.x, this.y, this.radius + this.thickness);
      gradient.addColorStop(0, 'rgba(96, 165, 250, 0)');
      gradient.addColorStop(0.5, 'rgba(96, 165, 250, 0.6)');
      gradient.addColorStop(1, 'rgba(96, 165, 250, 0)');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = this.thickness * 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.strokeStyle = this.passed ? 'rgba(134, 239, 172, 0.9)' : 'rgba(147, 197, 253, 0.9)';
      ctx.lineWidth = this.thickness;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      for (let bubble of this.bubblesParticles) {
        const bx = this.x + Math.cos(bubble.angle) * (this.radius + bubble.offset + Math.sin(bubble.phase) * 3);
        const by = this.y + Math.sin(bubble.angle) * (this.radius + bubble.offset + Math.sin(bubble.phase) * 3);
        
        ctx.fillStyle = `rgba(191, 219, 254, ${this.opacity * 0.7})`;
        ctx.beginPath();
        ctx.arc(bx, by, bubble.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.5})`;
        ctx.beginPath();
        ctx.arc(bx - bubble.size * 0.3, by - bubble.size * 0.3, bubble.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
  }
  
  // Hula Hoop class
  class HulaHoop {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.radius = 45 + Math.random() * 15;
      this.thickness = 10;
      this.age = 0;
      this.maxAge = 800;
      this.opacity = 0;
      this.passed = false;
      this.passedBy = new Set();
      this.rotation = 0;
      this.rotationSpeed = 0.02 + Math.random() * 0.02;
      this.wobble = 0;
      this.color = Math.random();
    }
    
    update() {
      this.age++;
      this.rotation += this.rotationSpeed;
      this.wobble += 0.03;
      
      if (this.age < 40) {
        this.opacity = this.age / 40;
      } else if (this.age > this.maxAge - 80) {
        this.opacity = (this.maxAge - this.age) / 80;
      } else {
        this.opacity = 1;
      }
      
      this.y += Math.sin(this.wobble) * 0.3;
      
      return this.age < this.maxAge;
    }
    
    checkDolphinJump(dolphin) {
      if (this.passedBy.has(dolphin)) return null;
      
      const dx = dolphin.x - this.x;
      const dy = dolphin.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      if (Math.abs(dist - this.radius) < 35 && dolphin.isAboveWater) {
        this.passedBy.add(dolphin);
        const accuracy = 1 - Math.min(1, Math.abs(dist - this.radius) / this.thickness);
        
        return {
          success: true,
          accuracy: accuracy,
          x: this.x,
          y: this.y
        };
      }
      
      return null;
    }
    
    draw(ctx) {
      ctx.save();
      ctx.globalAlpha = this.opacity;
      
      ctx.translate(this.x, this.y);
      
      const glowGradient = ctx.createRadialGradient(0, 0, this.radius - 5, 0, 0, this.radius + 15);
      
      if (this.color < 0.33) {
        glowGradient.addColorStop(0, 'rgba(255, 100, 150, 0)');
        glowGradient.addColorStop(0.5, 'rgba(255, 100, 150, 0.4)');
        glowGradient.addColorStop(1, 'rgba(255, 100, 150, 0)');
      } else if (this.color < 0.66) {
        glowGradient.addColorStop(0, 'rgba(255, 200, 100, 0)');
        glowGradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.4)');
        glowGradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
      } else {
        glowGradient.addColorStop(0, 'rgba(150, 255, 100, 0)');
        glowGradient.addColorStop(0.5, 'rgba(150, 255, 100, 0.4)');
        glowGradient.addColorStop(1, 'rgba(150, 255, 100, 0)');
      }
      
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(0, 0, this.radius + 12, 0, Math.PI * 2);
      ctx.fill();
      
      const scaleY = 0.4 + Math.abs(Math.cos(this.rotation)) * 0.6;
      
      ctx.save();
      ctx.scale(1, scaleY);
      
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.lineWidth = this.thickness + 2;
      ctx.beginPath();
      ctx.arc(0, 3 / scaleY, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      if (this.color < 0.33) {
        ctx.strokeStyle = this.passed ? 'rgba(134, 239, 172, 0.9)' : 'rgba(255, 100, 150, 0.9)';
      } else if (this.color < 0.66) {
        ctx.strokeStyle = this.passed ? 'rgba(134, 239, 172, 0.9)' : 'rgba(255, 200, 100, 0.9)';
      } else {
        ctx.strokeStyle = this.passed ? 'rgba(134, 239, 172, 0.9)' : 'rgba(150, 255, 100, 0.9)';
      }
      
      ctx.lineWidth = this.thickness;
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, -this.thickness / 2 / scaleY, this.radius, Math.PI * 1.3, Math.PI * 1.7);
      ctx.stroke();
      
      ctx.restore();
      ctx.restore();
    }
  }
  
  // Fish class
  class Fish {
    constructor(x, y, schoolId) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 2;
      this.vy = (Math.random() - 0.5) * 2;
      this.schoolId = schoolId;
      this.size = 4 + Math.random() * 2;
      this.coherence = 0;
      this.memoryBuffer = [];
      this.maxMemory = 30;
      this.speed = 1.5 + Math.random() * 0.5;
      this.color = schoolId % 3 === 0 ? [255, 180, 100] : 
                   schoolId % 3 === 1 ? [100, 200, 255] : [255, 150, 200];
    }
    
    update(allFish) {
      this.memoryBuffer.push({
        x: this.x, y: this.y, vx: this.vx, vy: this.vy, t: simulationTime
      });
      if (this.memoryBuffer.length > this.maxMemory) {
        this.memoryBuffer.shift();
      }
      
      this.coherence += 0.3;
      
      let sepX = 0, sepY = 0, sepCount = 0;
      let aliX = 0, aliY = 0, aliCount = 0;
      let cohX = 0, cohY = 0, cohCount = 0;
      
      const nearby = spatialHash.queryRadius(this.x, this.y, 60);
      
      for (let other of nearby) {
        if (other instanceof Fish && other !== this && other.schoolId === this.schoolId) {
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist < 15 && dist > 0) {
            sepX += dx / dist;
            sepY += dy / dist;
            sepCount++;
          }
          
          if (dist < 40) {
            aliX += other.vx;
            aliY += other.vy;
            aliCount++;
          }
          
          if (dist < 50) {
            cohX += other.x;
            cohY += other.y;
            cohCount++;
          }
        }
      }
      
      if (sepCount > 0) {
        this.vx += (sepX / sepCount) * 0.5;
        this.vy += (sepY / sepCount) * 0.5;
      }
      
      if (aliCount > 0) {
        this.vx += (aliX / aliCount - this.vx) * 0.05;
        this.vy += (aliY / aliCount - this.vy) * 0.05;
      }
      
      if (cohCount > 0) {
        const cx = cohX / cohCount;
        const cy = cohY / cohCount;
        this.vx += (cx - this.x) * 0.01;
        this.vy += (cy - this.y) * 0.01;
      }
      
      const centerY = height * 0.5;
      this.vy += (centerY - this.y) * 0.0003;
      
      this.vx += (Math.random() - 0.5) * 0.1;
      this.vy += (Math.random() - 0.5) * 0.1;
      
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > this.speed) {
        this.vx = (this.vx / speed) * this.speed;
        this.vy = (this.vy / speed) * this.speed;
      }
      
      this.x += this.vx;
      this.y += this.vy;
      
      if (this.x < 0) this.x = width;
      if (this.x > width) this.x = 0;
      if (this.y < height * SURFACE_Y) this.y = height * SURFACE_Y;
      if (this.y > height) this.y = height * 0.95;
      
      if (this.coherence > RUPTURE_THRESHOLD) {
        this.coherence *= 0.3;
        
        if (this.memoryBuffer.length > 5) {
          const memory = this.memoryBuffer[Math.floor(Math.random() * this.memoryBuffer.length)];
          const weight = Math.exp(this.coherence / OMEGA_FISH);
          this.vx = this.vx * 0.7 + memory.vx * 0.3 * weight;
          this.vy = this.vy * 0.7 + memory.vy * 0.3 * weight;
        }
      }
    }
    
    draw(ctx) {
      const angle = Math.atan2(this.vy, this.vx);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(angle);
      
      ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.size * 1.5, this.size * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(-this.size * 1.2, 0);
      ctx.lineTo(-this.size * 2, -this.size * 0.5);
      ctx.lineTo(-this.size * 2, this.size * 0.5);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  // Dolphin class with full CRR
  class Dolphin {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 2;
      this.vy = (Math.random() - 0.5) * 2;
      
      this.size = 12;
      this.length = this.size * 3.5;
      this.speed = 1.8;
      
      this.coherence = 0;
      this.memoryBuffer = [];
      this.maxMemory = 100;
      this.ringPassageMemories = [];
      this.sonarMemory = [];
      this.jumpMemories = [];
      
      this.ringsPassed = 0;
      this.averageAccuracy = 0;
      
      this.state = 'explore';
      this.targetRing = null;
      this.targetHoop = null;
      this.sonarCooldown = 0;
      
      this.isAboveWater = false;
      this.jumpPhase = 0;
      this.jumpSpeed = 0;
      this.playfulness = 0.6 + Math.random() * 0.4;
      
      this.swimPhase = Math.random() * Math.PI * 2;
      this.swimFrequency = 0.15;
      this.swimAmplitude = 0.25;
      this.tailBeatPower = 0;
      
      this.numSegments = 12;
      this.bodySegments = [];
      for (let i = 0; i < this.numSegments; i++) {
        this.bodySegments.push({ x: this.x, y: this.y, angle: 0 });
      }
    }
    
    update(allDolphins, rings, hoops) {
      this.swimPhase += this.swimFrequency * this.speed;
      const speed = Math.hypot(this.vx, this.vy);
      this.tailBeatPower = Math.sin(this.swimPhase) * speed * 0.5;
      
      this.memoryBuffer.push({
        x: this.x, y: this.y, vx: this.vx, vy: this.vy,
        state: this.state, coherence: this.coherence, t: simulationTime
      });
      if (this.memoryBuffer.length > this.maxMemory) {
        this.memoryBuffer.shift();
      }
      
      this.coherence += 0.5;
      
      const surfaceY = height * SURFACE_Y + getWaveHeight(this.x, simulationTime);
      this.isAboveWater = this.y < surfaceY;
      
      this.sonarCooldown--;
      if (this.sonarCooldown <= 0 && this.coherence > 20) {
        const emitFrequency = Math.max(20, 60 - this.coherence * 0.3);
        this.sonarCooldown = emitFrequency;
        sonarPulses.push(new SonarPulse(this.x, this.y, this));
      }
      
      if (this.state === 'explore' && Math.random() < this.playfulness * 0.02) {
        const nearbyHoop = this.findNearestHoop(hoops);
        if (nearbyHoop) {
          this.state = 'approach_hoop';
          this.targetHoop = nearbyHoop;
        }
      }
      
      if (this.state !== 'jump' && this.state !== 'approach_hoop') {
        this.findTargetRing(rings);
      }
      
      if (this.state === 'jump') {
        this.updateJump(surfaceY, hoops);
      } else if (this.state === 'approach_hoop' && this.targetHoop) {
        this.approachHoop(this.targetHoop);
      } else if (this.state === 'swim_through' && this.targetRing) {
        this.swimThroughRing(this.targetRing);
      } else if (this.state === 'approach_ring' && this.targetRing) {
        this.approachRing(this.targetRing);
      } else {
        this.explore(allDolphins);
      }
      
      for (let ring of rings) {
        const result = ring.checkDolphinPassage(this);
        if (result && result.success) {
          this.onRingPassed(result, ring);
        }
      }
      
      if (this.isAboveWater) {
        for (let hoop of hoops) {
          const result = hoop.checkDolphinJump(this);
          if (result && result.success) {
            this.onHoopJumped(result, hoop);
          }
        }
      }
      
      this.x += this.vx;
      this.y += this.vy;
      
      if (this.x < 0) this.x = width;
      if (this.x > width) this.x = 0;
      if (this.y < 0) this.y = 0;
      if (this.y > height) this.y = height * 0.95;
      
      if (this.coherence > RUPTURE_THRESHOLD) {
        this.onRupture();
      }
      
      this.updateBodySegments();
    }
    
    explore(allDolphins) {
      const nearby = spatialHash.queryRadius(this.x, this.y, 150);
      
      let sepX = 0, sepY = 0, sepCount = 0;
      let aliX = 0, aliY = 0, aliCount = 0;
      let cohX = 0, cohY = 0, cohCount = 0;
      
      for (let other of nearby) {
        if (other instanceof Dolphin && other !== this) {
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist < 50 && dist > 0) {
            sepX += dx / dist;
            sepY += dy / dist;
            sepCount++;
          }
          
          if (dist < 100) {
            aliX += other.vx;
            aliY += other.vy;
            aliCount++;
          }
          
          if (dist < 150) {
            cohX += other.x;
            cohY += other.y;
            cohCount++;
          }
        }
      }
      
      if (sepCount > 0) {
        this.vx += (sepX / sepCount) * 0.3;
        this.vy += (sepY / sepCount) * 0.3;
      }
      
      if (aliCount > 0) {
        this.vx += (aliX / aliCount - this.vx) * 0.03;
        this.vy += (aliY / aliCount - this.vy) * 0.03;
      }
      
      if (cohCount > 0) {
        const cx = cohX / cohCount;
        const cy = cohY / cohCount;
        this.vx += (cx - this.x) * 0.002;
        this.vy += (cy - this.y) * 0.002;
      }
      
      this.vx += (Math.random() - 0.5) * 0.2;
      this.vy += (Math.random() - 0.5) * 0.2;
      
      const targetY = height * 0.5;
      this.vy += (targetY - this.y) * 0.0005;
      
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > this.speed * 1.5) {
        this.vx = (this.vx / speed) * this.speed * 1.5;
        this.vy = (this.vy / speed) * this.speed * 1.5;
      }
      
      this.vx *= 0.98;
      this.vy *= 0.98;
    }
    
    findTargetRing(rings) {
      let bestRing = null;
      let bestScore = -Infinity;
      
      const memoryWeight = Math.exp(this.coherence / OMEGA_DOLPHIN);
      
      for (let ring of rings) {
        if (ring.passedBy.has(this)) continue;
        
        const dx = ring.x - this.x;
        const dy = ring.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        let score = 1000 / (dist + 1);
        
        if (ring.detectedBy.has(this)) {
          score *= 2.0;
        }
        
        if (this.ringPassageMemories.length > 0) {
          const angle = Math.atan2(dy, dx);
          const avgSuccessAngle = this.ringPassageMemories.reduce((sum, mem) => {
            const memAngle = Math.atan2(mem.y - this.y, mem.x - this.x);
            return sum + memAngle;
          }, 0) / this.ringPassageMemories.length;
          
          const angleSimilarity = 1 - Math.abs(angle - avgSuccessAngle) / Math.PI;
          score *= (1 + angleSimilarity * memoryWeight * 0.1);
        }
        
        if (score > bestScore) {
          bestScore = score;
          bestRing = ring;
        }
      }
      
      if (bestRing) {
        const dist = Math.hypot(bestRing.x - this.x, bestRing.y - this.y);
        
        if (dist < 150) {
          this.state = 'approach_ring';
          this.targetRing = bestRing;
          
          if (dist < 80) {
            this.state = 'swim_through';
          }
        } else {
          this.state = 'explore';
          this.targetRing = null;
        }
      } else {
        this.state = 'explore';
        this.targetRing = null;
      }
    }
    
    approachRing(ring) {
      const memoryWeight = Math.exp(this.coherence / OMEGA_DOLPHIN);
      
      const dx = ring.x - this.x;
      const dy = ring.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      let approachVx = (dx / dist) * this.speed;
      let approachVy = (dy / dist) * this.speed;
      
      if (this.ringPassageMemories.length > 0) {
        const relevantMemories = this.ringPassageMemories.slice(-5);
        let memVx = 0, memVy = 0;
        
        for (let mem of relevantMemories) {
          memVx += mem.approachVx * mem.accuracy;
          memVy += mem.approachVy * mem.accuracy;
        }
        
        memVx /= relevantMemories.length;
        memVy /= relevantMemories.length;
        
        const memoryInfluence = Math.min(0.6, memoryWeight * 0.1);
        approachVx = approachVx * (1 - memoryInfluence) + memVx * memoryInfluence;
        approachVy = approachVy * (1 - memoryInfluence) + memVy * memoryInfluence;
      }
      
      this.vx += (approachVx - this.vx) * 0.08;
      this.vy += (approachVy - this.vy) * 0.08;
      
      this.coherence += 0.3;
      
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > this.speed * 2) {
        this.vx = (this.vx / speed) * this.speed * 2;
        this.vy = (this.vy / speed) * this.speed * 2;
      }
    }
    
    swimThroughRing(ring) {
      const memoryWeight = Math.exp(this.coherence / OMEGA_DOLPHIN);
      
      const dx = ring.x - this.x;
      const dy = ring.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      this.vx += (dx / dist) * 0.3;
      this.vy += (dy / dist) * 0.3;
      
      if (this.ringPassageMemories.length > 3) {
        const bestMemories = this.ringPassageMemories
          .sort((a, b) => b.accuracy - a.accuracy)
          .slice(0, 3);
        
        let optimalVx = 0, optimalVy = 0;
        for (let mem of bestMemories) {
          optimalVx += mem.throughVx * mem.accuracy;
          optimalVy += mem.throughVy * mem.accuracy;
        }
        optimalVx /= bestMemories.length;
        optimalVy /= bestMemories.length;
        
        const memoryInfluence = Math.min(0.7, memoryWeight * 0.12);
        this.vx = this.vx * (1 - memoryInfluence) + optimalVx * memoryInfluence;
        this.vy = this.vy * (1 - memoryInfluence) + optimalVy * memoryInfluence;
      }
      
      this.coherence += 1.0;
      
      const speed = Math.hypot(this.vx, this.vy);
      const targetSpeed = this.speed * 2.2;
      if (speed > targetSpeed) {
        this.vx = (this.vx / speed) * targetSpeed;
        this.vy = (this.vy / speed) * targetSpeed;
      }
    }
    
    findNearestHoop(hoops) {
      let nearest = null;
      let minDist = Infinity;
      
      for (let hoop of hoops) {
        if (hoop.passedBy.has(this)) continue;
        
        const dist = Math.hypot(hoop.x - this.x, hoop.y - this.y);
        if (dist < minDist && dist < 300) {
          minDist = dist;
          nearest = hoop;
        }
      }
      
      return nearest;
    }
    
    approachHoop(hoop) {
      const dx = hoop.x - this.x;
      const dy = hoop.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      const targetY = height * SURFACE_Y + 30;
      
      this.vx += (dx / dist) * 0.15;
      this.vy += (targetY - this.y) * 0.01;
      
      if (Math.abs(dx) < 80 && Math.abs(this.y - targetY) < 30) {
        this.state = 'jump';
        this.jumpPhase = 0;
        this.targetHoop = hoop;
        this.coherence += 5;
      }
      
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > this.speed * 2) {
        this.vx = (this.vx / speed) * this.speed * 2;
        this.vy = (this.vy / speed) * this.speed * 2;
      }
    }
    
    updateJump(surfaceY, hoops) {
      this.jumpPhase++;
      
      if (this.jumpPhase < 30) {
        this.vy -= 0.6;
        
        if (this.targetHoop) {
          const dx = this.targetHoop.x - this.x;
          this.vx += dx * 0.01;
        }
      } else if (this.isAboveWater) {
        this.vy += 0.18;
        
        if (this.targetHoop) {
          const dx = this.targetHoop.x - this.x;
          this.vx += dx * 0.005;
        }
        
        if (this.jumpMemories.length > 0) {
          const memoryWeight = Math.exp(this.coherence / OMEGA_DOLPHIN);
          const bestJump = this.jumpMemories.sort((a, b) => b.accuracy - a.accuracy)[0];
          
          const memoryInfluence = Math.min(0.3, memoryWeight * 0.05);
          this.vx = this.vx * (1 - memoryInfluence) + bestJump.vx * memoryInfluence;
        }
      }
      
      if (this.jumpPhase > 30 && this.y > surfaceY) {
        this.state = 'explore';
        this.jumpPhase = 0;
        this.targetHoop = null;
        this.vy *= 0.5;
        totalJumps++;
        playSound(300 + Math.random() * 200, 0.15, 0.2);
      }
      
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > 6) {
        this.vx = (this.vx / speed) * 6;
        this.vy = (this.vy / speed) * 6;
      }
    }
    
    onSonarDetection(ring, strength, distance) {
      ring.detectedBy.add(this);
      
      this.sonarMemory.push({
        ring: ring,
        strength: strength,
        distance: distance,
        t: simulationTime
      });
      
      if (this.sonarMemory.length > 20) {
        this.sonarMemory.shift();
      }
      
      this.coherence += 0.5;
    }
    
    onRingPassed(result, ring) {
      this.ringsPassed++;
      totalRingsPassed++;
      ring.passed = true;
      
      this.ringPassageMemories.push({
        x: result.x,
        y: result.y,
        vx: this.vx,
        vy: this.vy,
        approachVx: this.memoryBuffer.length > 5 ? this.memoryBuffer[this.memoryBuffer.length - 5].vx : this.vx,
        approachVy: this.memoryBuffer.length > 5 ? this.memoryBuffer[this.memoryBuffer.length - 5].vy : this.vy,
        throughVx: this.vx,
        throughVy: this.vy,
        accuracy: result.accuracy,
        coherence: this.coherence,
        t: simulationTime
      });
      
      if (this.ringPassageMemories.length > 20) {
        this.ringPassageMemories.shift();
      }
      
      accuracyHistory.push(result.accuracy);
      if (accuracyHistory.length > 50) {
        accuracyHistory.shift();
      }
      
      this.coherence += 10;
      
      const pitch = 800 + result.accuracy * 400;
      playSound(pitch, 0.15, 0.2);
    }
    
    onHoopJumped(result, hoop) {
      hoop.passed = true;
      totalRingsPassed++;
      
      this.jumpMemories.push({
        x: hoop.x,
        y: hoop.y,
        vx: this.vx,
        vy: this.vy,
        accuracy: result.accuracy,
        coherence: this.coherence,
        jumpPhase: this.jumpPhase,
        t: simulationTime
      });
      
      if (this.jumpMemories.length > 15) {
        this.jumpMemories.shift();
      }
      
      accuracyHistory.push(result.accuracy);
      if (accuracyHistory.length > 50) {
        accuracyHistory.shift();
      }
      
      this.coherence += 15;
      
      const pitch = 900 + result.accuracy * 500;
      playSound(pitch, 0.2, 0.25);
    }
    
    onRupture() {
      this.coherence *= 0.4;
      
      if (this.ringPassageMemories.length > 5) {
        const weightedMemories = this.ringPassageMemories.map((mem, idx) => ({
          ...mem,
          weight: mem.accuracy * (1 + idx / this.ringPassageMemories.length)
        }));
        
        weightedMemories.sort((a, b) => b.weight - a.weight);
        const bestMemory = weightedMemories[0];
        
        const regenerationStrength = 0.5;
        this.vx = this.vx * (1 - regenerationStrength) + bestMemory.vx * regenerationStrength;
        this.vy = this.vy * (1 - regenerationStrength) + bestMemory.vy * regenerationStrength;
      }
      
      this.state = 'explore';
      this.targetRing = null;
    }
    
    updateBodySegments() {
      const angle = Math.atan2(this.vy, this.vx);
      const segmentLength = this.length / this.numSegments;
      
      this.bodySegments[0].x = this.x;
      this.bodySegments[0].y = this.y;
      this.bodySegments[0].angle = angle;
      
      for (let i = 1; i < this.numSegments; i++) {
        const prev = this.bodySegments[i - 1];
        const waveOffset = Math.sin(this.swimPhase - i * 0.3) * this.swimAmplitude * this.size;
        
        const offsetX = Math.cos(angle + Math.PI / 2) * waveOffset;
        const offsetY = Math.sin(angle + Math.PI / 2) * waveOffset;
        
        const targetX = prev.x - Math.cos(angle) * segmentLength + offsetX;
        const targetY = prev.y - Math.sin(angle) * segmentLength + offsetY;
        
        this.bodySegments[i].x += (targetX - this.bodySegments[i].x) * 0.3;
        this.bodySegments[i].y += (targetY - this.bodySegments[i].y) * 0.3;
        
        this.bodySegments[i].angle = Math.atan2(
          this.bodySegments[i].y - prev.y,
          this.bodySegments[i].x - prev.x
        );
      }
    }
    
    draw(ctx) {
      if (processToggles.trails && this.memoryBuffer.length > 2) {
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.memoryBuffer[0].x, this.memoryBuffer[0].y);
        for (let i = 1; i < this.memoryBuffer.length; i += 2) {
          ctx.lineTo(this.memoryBuffer[i].x, this.memoryBuffer[i].y);
        }
        ctx.stroke();
      }
      
      const bodyColor = this.isAboveWater ? '#6b7280' : '#3b82f6';
      const bellyColor = this.isAboveWater ? '#9ca3af' : '#60a5fa';
      
      const widths = [];
      for (let i = 0; i < this.numSegments; i++) {
        const t = i / (this.numSegments - 1);
        let width;
        
        if (t < 0.15) {
          width = this.size * 0.4 + (t / 0.15) * this.size * 0.6;
        } else if (t < 0.4) {
          const localT = (t - 0.15) / 0.25;
          width = this.size + localT * this.size * 0.3;
        } else if (t < 0.7) {
          const localT = (t - 0.4) / 0.3;
          width = this.size * 1.3 - localT * this.size * 0.5;
        } else {
          const localT = (t - 0.7) / 0.3;
          width = this.size * 0.8 - localT * this.size * 0.6;
        }
        widths.push(width);
      }
      
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      for (let i = 0; i < this.numSegments; i++) {
        const seg = this.bodySegments[i];
        const width = widths[i];
        const perpAngle = seg.angle + Math.PI / 2;
        const px = seg.x + Math.cos(perpAngle) * width;
        const py = seg.y + Math.sin(perpAngle) * width;
        
        if (i === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
      
      for (let i = this.numSegments - 1; i >= 0; i--) {
        const seg = this.bodySegments[i];
        const width = widths[i];
        const perpAngle = seg.angle - Math.PI / 2;
        const px = seg.x + Math.cos(perpAngle) * width;
        const py = seg.y + Math.sin(perpAngle) * width;
        ctx.lineTo(px, py);
      }
      
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = bellyColor;
      ctx.beginPath();
      for (let i = 0; i < this.numSegments; i++) {
        const seg = this.bodySegments[i];
        const width = widths[i] * 0.7;
        const perpAngle = seg.angle - Math.PI / 2;
        const px = seg.x + Math.cos(perpAngle) * width;
        const py = seg.y + Math.sin(perpAngle) * width;
        
        if (i === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
      
      for (let i = this.numSegments - 1; i >= 0; i--) {
        const seg = this.bodySegments[i];
        const width = widths[i] * 0.5;
        const perpAngle = seg.angle - Math.PI / 2;
        const px = seg.x + Math.cos(perpAngle) * width;
        const py = seg.y + Math.sin(perpAngle) * width;
        ctx.lineTo(px, py);
      }
      
      ctx.closePath();
      ctx.fill();
      
      const headSeg = this.bodySegments[0];
      ctx.save();
      ctx.translate(headSeg.x, headSeg.y);
      ctx.rotate(headSeg.angle);
      
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.moveTo(this.size * 1.2, 0);
      ctx.lineTo(this.size * 2, -this.size * 0.3);
      ctx.lineTo(this.size * 2, this.size * 0.3);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(this.size * 0.8, -this.size * 0.4, this.size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(this.size * 0.85, -this.size * 0.45, this.size * 0.08, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      
      const dorsalIdx = Math.floor(this.numSegments * 0.4);
      const dorsalSeg = this.bodySegments[dorsalIdx];
      ctx.save();
      ctx.translate(dorsalSeg.x, dorsalSeg.y);
      ctx.rotate(dorsalSeg.angle);
      
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.moveTo(-this.size * 0.5, -widths[dorsalIdx]);
      ctx.quadraticCurveTo(
        this.size * 0.2, -widths[dorsalIdx] - this.size * 1.5,
        this.size * 0.8, -widths[dorsalIdx]
      );
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
      
      const pectoralIdx = Math.floor(this.numSegments * 0.25);
      const pectoralSeg = this.bodySegments[pectoralIdx];
      
      ctx.save();
      ctx.translate(pectoralSeg.x, pectoralSeg.y);
      ctx.rotate(pectoralSeg.angle);
      
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.ellipse(-this.size * 0.2, widths[pectoralIdx] * 0.8,
                  this.size * 1.2, this.size * 0.5, Math.PI / 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.ellipse(-this.size * 0.2, -widths[pectoralIdx] * 0.8,
                  this.size * 1.2, this.size * 0.5, -Math.PI / 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      
      const tailSeg = this.bodySegments[this.numSegments - 1];
      const tailAngle = tailSeg.angle + this.tailBeatPower * 0.3;
      
      ctx.save();
      ctx.translate(tailSeg.x, tailSeg.y);
      ctx.rotate(tailAngle);
      
      ctx.fillStyle = bodyColor;
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-this.size * 0.8, -this.size * 1.2, -this.size * 1.5, -this.size * 1.8);
      ctx.quadraticCurveTo(-this.size * 1.8, -this.size * 1.5, -this.size * 1.3, -this.size * 0.8);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(-this.size * 0.8, this.size * 1.2, -this.size * 1.5, this.size * 1.8);
      ctx.quadraticCurveTo(-this.size * 1.8, this.size * 1.5, -this.size * 1.3, this.size * 0.8);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
      
      if (processToggles.coherence && this.coherence > 30) {
        const radius = Math.min(60, this.coherence / 2);
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);
        const alpha = Math.min(0.4, this.coherence / 250);
        gradient.addColorStop(0, `rgba(99, 102, 241, ${alpha})`);
        gradient.addColorStop(1, 'rgba(99, 102, 241, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      if (processToggles.targeting && this.state === 'approach_ring' && this.targetRing) {
        ctx.strokeStyle = 'rgba(147, 197, 253, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.targetRing.x, this.targetRing.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }
  
  function getWaveHeight(x, time) {
    return Math.sin(x * 0.01 + time * 0.02) * 8 +
           Math.sin(x * 0.03 - time * 0.03) * 4 +
           Math.sin(x * 0.05 + time * 0.01) * 2;
  }
  
  function drawOceanSurface() {
    const surfaceY = height * SURFACE_Y;
    const points = [];
    
    for (let x = 0; x <= width; x += 5) {
      const waveHeight = getWaveHeight(x, simulationTime);
      points.push({ x, y: surfaceY + waveHeight });
    }
    
    ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    for (let p of points) {
      ctx.lineTo(p.x, p.y);
    }
    ctx.lineTo(width, 0);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(147, 197, 253, 0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.stroke();
    
    // Enhanced wave crests with foam and spray
    for (let i = 1; i < points.length - 1; i++) {
      // Detect peaks
      if (points[i].y < points[i-1].y && points[i].y < points[i+1].y) {
        const peakHeight = Math.min(points[i-1].y, points[i+1].y) - points[i].y;
        
        // Main foam blob
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(points[i].x, points[i].y - 2, 6 + peakHeight * 0.3, 3 + peakHeight * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.ellipse(points[i].x - 2, points[i].y - 3, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Spray particles
        for (let j = 0; j < 3; j++) {
          const offsetX = (Math.random() - 0.5) * 8;
          const offsetY = -Math.random() * 5;
          const size = 1 + Math.random() * 2;
          
          ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + Math.random() * 0.3})`;
          ctx.beginPath();
          ctx.arc(points[i].x + offsetX, points[i].y + offsetY, size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Trailing foam
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.ellipse(points[i].x + 5, points[i].y + 1, 4, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.ellipse(points[i].x - 5, points[i].y + 1, 4, 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  
  function updateMetrics() {
    document.getElementById('dolphinCount').textContent = dolphins.length;
    document.getElementById('fishCount').textContent = fishSchools.length;
    document.getElementById('ringsPassed').textContent = totalRingsPassed;
    document.getElementById('sonarDetections').textContent = totalSonarDetections;
    document.getElementById('jumpCount').textContent = totalJumps;
    
    const successRate = totalRingAttempts > 0
      ? ((totalRingsPassed / totalRingAttempts) * 100).toFixed(1)
      : 0;
    document.getElementById('successRate').textContent = successRate + '%';
    
    const avgAccuracy = accuracyHistory.length > 0
      ? (accuracyHistory.reduce((a, b) => a + b, 0) / accuracyHistory.length * 100).toFixed(1)
      : 0;
    document.getElementById('avgAccuracy').textContent = avgAccuracy + '%';
    
    const avgCoherence = dolphins.length > 0
      ? dolphins.reduce((sum, d) => sum + d.coherence, 0) / dolphins.length
      : 0;
    
    document.getElementById('avgCoherence').textContent = avgCoherence.toFixed(1);
    const coherencePct = Math.min(100, (avgCoherence / RUPTURE_THRESHOLD) * 100);
    document.getElementById('coherenceProgress').style.width = coherencePct + '%';
    
    const memoryWeight = Math.exp(avgCoherence / OMEGA_DOLPHIN);
    document.getElementById('memoryWeight').textContent = memoryWeight.toFixed(2);
    const memoryPct = Math.min(100, (memoryWeight / 50) * 100);
    document.getElementById('memoryProgress').style.width = memoryPct + '%';
    
    const status = avgCoherence < 30 ? 'Building' :
                   avgCoherence < 70 ? 'Learning' :
                   avgCoherence < 95 ? 'Pre-Rupture' : 'Critical!';
    document.getElementById('learningStatus').textContent = status;
  }
  
  function resizeCanvas() {
    const container = canvas.parentElement;
    width = container.clientWidth;
    height = container.clientHeight;
    canvas.width = width;
    canvas.height = height;
  }
  
  function toggleMath() {
    const content = document.getElementById('mathContent');
    const icon = document.getElementById('mathToggleIcon');
    content.classList.toggle('open');
    icon.classList.toggle('open');
  }
  
  window.addDolphin = function() {
    const x = width * 0.3 + Math.random() * (width * 0.4);
    const y = height * 0.5 + Math.random() * (height * 0.2);
    dolphins.push(new Dolphin(x, y));
    playSound(600, 0.15, 0.2);
  };
  
  window.addFishSchool = function() {
    const schoolSize = 15 + Math.floor(Math.random() * 15);
    const centerX = width * 0.2 + Math.random() * (width * 0.6);
    const centerY = height * 0.5 + Math.random() * (height * 0.3);
    const schoolId = Math.floor(Math.random() * 3);
    
    for (let i = 0; i < schoolSize; i++) {
      fishSchools.push(new Fish(
        centerX + (Math.random() - 0.5) * 60,
        centerY + (Math.random() - 0.5) * 60,
        schoolId
      ));
    }
    playSound(800, 0.1, 0.15);
  };
  
  window.resetScene = function() {
    dolphins = [];
    fishSchools = [];
    bubbleRings = [];
    hulaHoops = [];
    sonarPulses = [];
    simulationTime = 0;
    totalRingsPassed = 0;
    totalRingAttempts = 0;
    totalSonarDetections = 0;
    totalJumps = 0;
    accuracyHistory = [];
    
    for (let i = 0; i < 3; i++) addDolphin();
    for (let i = 0; i < 5; i++) addFishSchool();
  };
  
  function animate() {
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#87ceeb');
    gradient.addColorStop(SURFACE_Y, '#b0d4e3');
    gradient.addColorStop(SURFACE_Y, '#1e3a8a');
    gradient.addColorStop(0.6, '#1e40af');
    gradient.addColorStop(1, '#1e293b');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    const sunGradient = ctx.createRadialGradient(width * 0.85, height * 0.1, 0, width * 0.85, height * 0.1, 50);
    sunGradient.addColorStop(0, 'rgba(255, 255, 150, 0.9)');
    sunGradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
    ctx.fillStyle = sunGradient;
    ctx.beginPath();
    ctx.arc(width * 0.85, height * 0.1, 50, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(147, 197, 253, 0.05)';
    ctx.lineWidth = 40;
    for (let i = 0; i < 8; i++) {
      const x = (i + 1) * width / 9 + Math.sin(simulationTime * 0.01 + i) * 30;
      ctx.beginPath();
      ctx.moveTo(x, height * SURFACE_Y);
      ctx.lineTo(x + 50, height);
      ctx.stroke();
    }
    
    drawOceanSurface();
    
    spatialHash.clear();
    dolphins.forEach(d => spatialHash.insert(d));
    fishSchools.forEach(f => spatialHash.insert(f));
    
    fishSchools.forEach(fish => {
      fish.update(fishSchools);
      fish.draw(ctx);
    });
    
    bubbleRings = bubbleRings.filter(ring => ring.update());
    bubbleRings.forEach(ring => ring.draw(ctx));
    
    hulaHoops = hulaHoops.filter(hoop => hoop.update());
    hulaHoops.forEach(hoop => hoop.draw(ctx));
    
    sonarPulses = sonarPulses.filter(pulse => pulse.update(bubbleRings));
    sonarPulses.forEach(pulse => pulse.draw(ctx));
    
    dolphins.forEach(dolphin => {
      dolphin.update(dolphins, bubbleRings, hulaHoops);
      dolphin.draw(ctx);
    });
    
    if (processToggles.connections) {
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.15)';
      ctx.lineWidth = 1;
      for (let i = 0; i < dolphins.length; i++) {
        for (let j = i + 1; j < dolphins.length; j++) {
          const d1 = dolphins[i];
          const d2 = dolphins[j];
          const dist = Math.hypot(d2.x - d1.x, d2.y - d1.y);
          if (dist < 100) {
            ctx.beginPath();
            ctx.moveTo(d1.x, d1.y);
            ctx.lineTo(d2.x, d2.y);
            ctx.stroke();
          }
        }
      }
    }
    
    if (simulationTime % 30 === 0) {
      updateMetrics();
    }
    
    simulationTime++;
    requestAnimationFrame(animate);
  }
  
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (width / rect.width);
    const y = (e.clientY - rect.top) * (height / rect.height);
    
    const surfaceY = height * SURFACE_Y;
    
    if (y > surfaceY) {
      bubbleRings.push(new BubbleRing(x, y));
      playSound(400 + Math.random() * 200, 0.2, 0.15);
    } else {
      hulaHoops.push(new HulaHoop(x, y));
      playSound(600 + Math.random() * 300, 0.25, 0.18);
    }
  });
  
  document.getElementById('showCoherence').addEventListener('change', (e) => {
    processToggles.coherence = e.target.checked;
  });
  
  document.getElementById('showSonar').addEventListener('change', (e) => {
    processToggles.sonar = e.target.checked;
  });
  
  document.getElementById('showTrails').addEventListener('change', (e) => {
    processToggles.trails = e.target.checked;
  });
  
  document.getElementById('showConnections').addEventListener('change', (e) => {
    processToggles.connections = e.target.checked;
  });
  
  document.getElementById('showTargeting').addEventListener('change', (e) => {
    processToggles.targeting = e.target.checked;
  });
  
  window.toggleMath = toggleMath;
  
  resizeCanvas();
  resetScene();
  
  window.addEventListener('resize', resizeCanvas);
  
  animate();
})();
</script>
</body>
</html>
