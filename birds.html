<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced UCF Ecosystem with Eagle Predator and Multi-Scale Journeying</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 40%, #E0F6FF 70%, #F0F8FF 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
        }
        
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff88;
            border-radius: 10px;
            font-size: 12px;
            line-height: 1.6;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(5px);
            border: 1px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            min-width: 320px;
            max-height: 80vh;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .hud.collapsed {
            height: 45px;
            min-width: 200px;
        }
        
        .hud.collapsed .hud-content {
            display: none;
        }
        
        .hud-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
        }
        
        .hud-content {
            padding: 0 20px 20px;
            overflow-y: auto;
            max-height: calc(80vh - 45px);
        }
        
        .hud h2 {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            border-bottom: 1px solid #00ff88;
            padding-bottom: 8px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            padding-bottom: 4px;
        }
        
        .metric-value {
            color: #ffff00;
            font-weight: bold;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        .btn {
            padding: 12px 18px;
            border: 2px solid;
            border-radius: 8px;
            background: transparent;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px currentColor;
        }
        
        .btn.spawn { color: #00ff88; border-color: #00ff88; }
        .btn.enhance { color: #ffff00; border-color: #ffff00; }
        .btn.rupture { color: #ff6600; border-color: #ff6600; }
        .btn.sound { color: #ff00ff; border-color: #ff00ff; }
        .btn.reset { color: #ff0000; border-color: #ff0000; }
        .btn.starling { color: #8B4513; border-color: #8B4513; }
        .btn.swallow { color: #4169E1; border-color: #4169E1; }
        .btn.eagle { color: #B8860B; border-color: #B8860B; }
        .btn.journey { color: #FF1493; border-color: #FF1493; }
        
        .nature-mode-container {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            border: 1px solid #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00ff88;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .nature-mode-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #00ff88;
        }
        
        .nature-mode-container label {
            cursor: pointer;
            user-select: none;
        }
        
        .btn:hover.spawn { background: rgba(0, 255, 136, 0.1); }
        .btn:hover.enhance { background: rgba(255, 255, 0, 0.1); }
        .btn:hover.rupture { background: rgba(255, 102, 0, 0.1); }
        .btn:hover.sound { background: rgba(255, 0, 255, 0.1); }
        .btn:hover.reset { background: rgba(255, 0, 0, 0.1); }
        .btn:hover.starling { background: rgba(139, 69, 19, 0.1); }
        .btn:hover.swallow { background: rgba(65, 105, 225, 0.1); }
        .btn:hover.eagle { background: rgba(184, 134, 11, 0.1); }
        .btn:hover.journey { background: rgba(255, 20, 147, 0.1); }
        
        .equation {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ffff;
            border-radius: 10px;
            font-size: 11px;
            line-height: 1.8;
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            max-width: 300px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .equation.collapsed {
            height: 45px;
            min-width: 180px;
        }
        
        .equation.collapsed .equation-content {
            display: none;
        }
        
        .equation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
        }
        
        .equation-content {
            padding: 0 15px 15px;
        }

        .flocking-controls {
            position: fixed;
            left: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            border: 1px solid #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #00ff88;
            min-width: 200px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .flocking-controls.collapsed {
            height: 45px;
            min-width: 160px;
        }
        
        .flocking-controls.collapsed .controls-content {
            display: none;
        }
        
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
        }
        
        .controls-content {
            padding: 0 15px 15px;
        }
        
        .toggle-btn {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .toggle-btn:hover {
            opacity: 1;
        }

        .slider-group {
            margin-bottom: 10px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 4px;
            color: #88ffaa;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }

        .value-display {
            color: #ffff00;
            font-weight: bold;
            float: right;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="hud collapsed">
        <div class="hud-header" onclick="togglePanel('hud')">
            <h2>UCF MULTI-SCALE ECOSYSTEM</h2>
            <button class="toggle-btn">▼</button>
        </div>
        <div class="hud-content">
            <div class="metric">
                <span>Global Coherence C(x,t):</span>
                <span class="metric-value" id="coherence">0.500</span>
            </div>
            <div class="metric">
                <span>Memory Density ∫L(x,τ)dτ:</span>
                <span class="metric-value" id="memory">0.000</span>
            </div>
            <div class="metric">
                <span>Flocking Strength:</span>
                <span class="metric-value" id="flocking">0.000</span>
            </div>
            <div class="metric">
                <span>Rupture Events δ(t):</span>
                <span class="metric-value" id="ruptures">0</span>
            </div>
            <div class="metric">
                <span>Active Robins:</span>
                <span class="metric-value" id="robins">0</span>
            </div>
            <div class="metric">
                <span>Starling Swarm:</span>
                <span class="metric-value" id="starlings">0</span>
            </div>
            <div class="metric">
                <span>Swallow Territory:</span>
                <span class="metric-value" id="swallows">0</span>
            </div>
            <div class="metric">
                <span>Eagle Predators:</span>
                <span class="metric-value" id="eagles">0</span>
            </div>
            <div class="metric">
                <span>Active Journeys:</span>
                <span class="metric-value" id="journeys">0</span>
            </div>
            <div class="metric">
                <span>Established Nests:</span>
                <span class="metric-value" id="nests">0</span>
            </div>
            <div class="metric">
                <span>RNA Computation Rate:</span>
                <span class="metric-value" id="rna-rate">0.0</span>
            </div>
            <div class="metric">
                <span>Photosynthesis φ(x,τ):</span>
                <span class="metric-value" id="photosynthesis">0.000</span>
            </div>
            <div class="metric">
                <span>System Temperature Ω:</span>
                <span class="metric-value" id="temperature">1.000</span>
            </div>
            <div class="metric">
                <span>Avg Flight Speed:</span>
                <span class="metric-value" id="avg-speed">0.0</span>
            </div>
            <div class="metric">
                <span>Performance:</span>
                <span class="metric-value" id="fps">60 FPS</span>
            </div>
        </div>
    </div>
    
    <div class="equation collapsed">
        <div class="equation-header" onclick="togglePanel('equation')">
            <strong>UCF MULTI-SCALE EQUATIONS</strong>
            <button class="toggle-btn">▼</button>
        </div>
        <div class="equation-content">
            <strong>UCF Core Equations:</strong><br>
            C(x) = ∫ L(x,τ) dτ<br>
            δ(t-t₀) = Rupture Detection<br>
            R[χ](x,t) = ∫ φ(x,τ)·e^(C(x)/Ω)·Θ(t-τ) dτ<br><br>
            <strong>Multi-Scale Coherence:</strong><br>
            S(t) = scale transition function<br>
            C_interaction = C₁ · C₂ · δ(|S₁-S₂|)<br>
            Journey dynamics: s → s' via C-field<br><br>
            <strong>Predator Scaling:</strong><br>
            Eagle: S_min = 0.2 (starlings)<br>
            Eagle: S_max = 1.2 (robins)<br>
            Hunt success ∝ scale compatibility<br><br>
            <strong>RNA Locomotion:</strong><br>
            v(t) = Σ RNA_i(t) × motor_i<br>
            frequency = 20-35 Hz (Fast)<br>
            amplitude = f(coherence, RNA, scale)
        </div>
    </div>

    <div class="flocking-controls collapsed">
        <div class="controls-header" onclick="togglePanel('flocking-controls')">
            <span>PARAMETERS</span>
            <button class="toggle-btn">▼</button>
        </div>
        <div class="controls-content">
            <div class="slider-group">
                <label>Flock Size: <span class="value-display" id="flockSizeValue">6</span></label>
                <input type="range" id="flockSize" min="2" max="15" value="6">
            </div>
            <div class="slider-group">
                <label>Separation: <span class="value-display" id="separationValue">1.5</span></label>
                <input type="range" id="separation" min="0.5" max="3.0" step="0.1" value="1.5">
            </div>
            <div class="slider-group">
                <label>Cohesion: <span class="value-display" id="cohesionValue">1.0</span></label>
                <input type="range" id="cohesion" min="0.2" max="2.0" step="0.1" value="1.0">
            </div>
            <div class="slider-group">
                <label>RNA Strength: <span class="value-display" id="rnaValue">0.8</span></label>
                <input type="range" id="rnaStrength" min="0.1" max="2.0" step="0.1" value="0.8">
            </div>
            <div class="slider-group">
                <label>Journey Rate: <span class="value-display" id="journeyValue">0.3</span></label>
                <input type="range" id="journeyRate" min="0.1" max="1.0" step="0.1" value="0.3">
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn spawn" onclick="ecosystem.spawnRobinFlock()">Spawn Robins</button>
        <button class="btn starling" onclick="ecosystem.spawnStarlingSwarm()">Starling Swarm</button>
        <button class="btn swallow" onclick="ecosystem.spawnSwallowTerritory()">Swallow Territory</button>
        <button class="btn eagle" onclick="ecosystem.spawnEaglePredator()">Eagle Predator</button>
        <button class="btn journey" onclick="ecosystem.triggerJourneys()">Trigger Journeys</button>
        <button class="btn enhance" onclick="ecosystem.enhanceCoherence()">Boost C(x)</button>
        <button class="btn rupture" onclick="ecosystem.triggerRupture()">Force Rupture</button>
        <button class="btn sound" onclick="ecosystem.toggleAudio()" id="audioBtn">Enable RNA Audio</button>
        <button class="btn reset" onclick="ecosystem.reset()">Reset System</button>
    </div>

    <div class="nature-mode-container">
        <input type="checkbox" id="natureModeToggle" onchange="ecosystem.toggleNatureMode()">
        <label for="natureModeToggle">Nature Mode</label>
    </div>

    <script>
        // UCF Mathematical Framework - Complete Implementation with Multi-Scale Interactions
        class UCFMathematics {
            constructor() {
                this.Omega = 1.0; // System temperature parameter
                this.coherenceHistory = [];
                this.memoryDecayRate = 0.95;
                this.ruptureThreshold = 0.2;
                this.scaleCompatibilityThreshold = 0.3; // NEW: Scale interaction threshold
            }
            
            // Core UCF Coherence Integration: C(x) = ∫ L(x,τ) dτ
            coherenceIntegral(memoryDensityFunction, historyLength = 50) {
                let integral = 0;
                const dt = 1.0;
                
                for (let tau = 0; tau < historyLength; tau++) {
                    const L_tau = memoryDensityFunction(tau);
                    integral += L_tau * dt * Math.exp(-tau / (this.Omega * 10));
                }
                
                return Math.max(0, Math.min(1, integral / historyLength));
            }
            
            // Enhanced Memory Density Function L(x,τ) with Scale Integration
            memoryDensityFunction(entity, tau) {
                if (!entity || !entity.history || entity.history.length <= tau) return 0;
                
                const current = entity.history[entity.history.length - 1 - tau];
                const previous = entity.history[entity.history.length - 2 - tau];
                
                if (!current || !previous) return 0.1;
                
                // Spatial consistency
                const positionStability = 1 - Math.min(1, 
                    Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2)) / 50
                );
                
                // Velocity consistency  
                const velocityStability = 1 - Math.min(1,
                    Math.abs(current.vx - previous.vx) + Math.abs(current.vy - previous.vy)
                );
                
                // Behavioral consistency
                const behaviorStability = current.behavior === previous.behavior ? 1 : 0.2;
                
                // RNA computational consistency
                const rnaStability = current.rnaState && previous.rnaState ? 
                    1 - Math.abs(current.rnaState - previous.rnaState) : 0.5;

                // Scale consistency (NEW)
                const scaleStability = current.scale && previous.scale ?
                    1 - Math.abs(current.scale - previous.scale) : 0.5;
                
                return (positionStability + velocityStability + behaviorStability + rnaStability + scaleStability) / 5;
            }
            
            // NEW: Scale Compatibility Function
            scaleCompatibility(scale1, scale2) {
                const scaleDiff = Math.abs(scale1 - scale2);
                return scaleDiff < this.scaleCompatibilityThreshold ? 1 - (scaleDiff / this.scaleCompatibilityThreshold) : 0;
            }
            
            // Rupture Detection: δ(t-t₀)
            ruptureDetection(coherence) {
                return coherence < this.ruptureThreshold ? 1 : 0;
            }
            
            // Enhanced Regeneration Operator with Scale Modulation
            regenerationOperator(entity, historicalFieldSignal, coherence, tau, scaleModulation = 1) {
                const exponentialWeight = Math.exp(coherence / this.Omega);
                const causalityConstraint = tau >= 0 ? 1 : 0; // Heaviside function Θ(t-τ)
                
                return historicalFieldSignal * exponentialWeight * causalityConstraint * scaleModulation;
            }
            
            // Enhanced RNA Computational Model with Scale Integration
            computeRNALocomotion(rnaSequences, coherence, energy, behaviorState, scaleModulation = 1) {
                let totalMotorOutput = 0;
                let frequency = 20 + (coherence * 15); // 20-35 Hz range
                let amplitude = 0.5 + (energy * 0.5);
                
                // Scale affects RNA computation efficiency
                const scaleEfficiency = 0.5 + scaleModulation * 0.5;
                
                rnaSequences.forEach((sequence, i) => {
                    const motorPattern = this.rnaToMotorPattern(sequence, behaviorState, scaleModulation);
                    const temporalModulation = Math.sin((Date.now() / 1000) * frequency + i);
                    totalMotorOutput += motorPattern * temporalModulation * amplitude * scaleEfficiency;
                });
                
                return {
                    motorOutput: totalMotorOutput,
                    frequency: frequency,
                    amplitude: amplitude * scaleModulation
                };
            }
            
            rnaToMotorPattern(sequence, behaviorState, scaleModulation = 1) {
                const basePattern = sequence.pattern.reduce((sum, freq) => sum + freq, 0) / sequence.pattern.length;
                const behaviorModifier = {
                    'exploring': 1.0,
                    'flocking': 1.2,
                    'hunting': 1.5,
                    'nest_seeking': 1.3,
                    'nest_building': 1.4,
                    'territorial': 2.0,
                    'escaping': 3.0,
                    'journeying': 1.8, // NEW: Journey behavior
                    'murmurating': 1.1,
                    'swooping': 1.3,
                    'seeking': 1.1,
                    'landed': 0.3 // NEW: Landed behavior
                }[behaviorState] || 1.0;
                
                return (basePattern / 3000) * behaviorModifier * scaleModulation;
            }
        }

        // Enhanced L-System Tree with UCF Integration
        class UCFTree {
            constructor(x, y, scale = 1) {
                this.x = x;
                this.y = y;
                this.scale = scale;
                this.coherence = 0.5 + Math.random() * 0.3;
                this.photosynthesis = 0.3 + Math.random() * 0.2;
                
                // L-System parameters
                this.axiom = 'F';
                this.rules = ['F[+F]F[-F]F', 'FF[++F][--F]F', 'F[+F[-F]]F[--F[+F]]'];
                this.selectedRule = this.rules[Math.floor(Math.random() * this.rules.length)];
                this.angle = 22.5;
                this.iterations = 3;
                this.baseLength = 15 * scale;
                
                this.branches = [];
                this.leaves = [];
                this.nestSites = [];
                this.landingSites = []; // NEW: Landing sites for robins
                
                this.generate();
            }
            
            generate() {
                let current = this.axiom;
                
                for (let i = 0; i < this.iterations; i++) {
                    current = current.replace(/F/g, this.selectedRule);
                    if (current.length > 400) break;
                }
                
                this.parseLSystem(current);
                this.generateLeaves();
                this.createNestSites();
                this.createLandingSites(); // NEW: Create landing sites
            }
            
            parseLSystem(lstring) {
                const stack = [];
                let x = 0, y = 0, angle = -Math.PI/2;
                const angleRad = this.angle * Math.PI / 180;
                let generation = 0;
                
                for (const char of lstring) {
                    switch (char) {
                        case 'F':
                            const length = this.baseLength * Math.pow(0.75, generation);
                            const newX = x + Math.cos(angle) * length;
                            const newY = y + Math.sin(angle) * length;
                            
                            if (Math.abs(newX) < 200 * this.scale && Math.abs(newY) < 250 * this.scale) {
                                this.branches.push({
                                    x1: x, y1: y, x2: newX, y2: newY,
                                    thickness: Math.max(1, 4 - generation * 0.5) * this.scale,
                                    generation: generation,
                                    coherence: this.coherence + Math.random() * 0.1,
                                    angle: angle // NEW: Store branch angle
                                });
                                x = newX;
                                y = newY;
                            }
                            break;
                        case '+':
                            angle += angleRad * (0.7 + Math.random() * 0.6);
                            break;
                        case '-':
                            angle -= angleRad * (0.7 + Math.random() * 0.6);
                            break;
                        case '[':
                            stack.push({ x, y, angle, generation });
                            generation++;
                            break;
                        case ']':
                            if (stack.length > 0) {
                                const state = stack.pop();
                                x = state.x;
                                y = state.y;
                                angle = state.angle;
                                generation = state.generation;
                            }
                            break;
                    }
                }
            }
            
            generateLeaves() {
                this.branches.forEach(branch => {
                    if (branch.generation >= 1) {
                        const leafCount = 3 + Math.floor(Math.random() * 4);
                        
                        for (let i = 0; i < leafCount; i++) {
                            const t = 0.3 + Math.random() * 0.7;
                            const leafX = branch.x1 + (branch.x2 - branch.x1) * t;
                            const leafY = branch.y1 + (branch.y2 - branch.y1) * t;
                            
                            this.leaves.push({
                                x: this.x + leafX + (Math.random() - 0.5) * 12 * this.scale,
                                y: this.y + leafY + (Math.random() - 0.5) * 12 * this.scale,
                                size: (2.5 + Math.random() * 2.5) * this.scale,
                                photosynthesis: 0.3 + Math.random() * 0.4,
                                coherence: 0.4 + Math.random() * 0.3,
                                age: Math.random() * 100
                            });
                        }
                    }
                });
            }
            
            createNestSites() {
                this.branches.forEach((branch, index) => {
                    if (branch.generation >= 1 && branch.generation <= 3 && 
                        branch.thickness > 2.5 * this.scale && Math.random() < 0.4) {
                        
                        const midX = (branch.x1 + branch.x2) / 2;
                        const midY = (branch.y1 + branch.y2) / 2;
                        
                        const branchAngle = Math.atan2(branch.y2 - branch.y1, branch.x2 - branch.x1);
                        const isHorizontal = Math.abs(branchAngle) > Math.PI/6 && Math.abs(branchAngle) < 5*Math.PI/6;
                        
                        if (isHorizontal) {
                            this.nestSites.push({
                                x: this.x + midX,
                                y: this.y + midY - 40 * this.scale,
                                size: 12 * this.scale,
                                occupied: false,
                                nestId: null,
                                branchIndex: index,
                                stability: branch.thickness / (3 * this.scale)
                            });
                        }
                    }
                });
            }

            // NEW: Create landing sites for robins
            createLandingSites() {
                this.landingSites = [];
                this.branches.forEach((branch, index) => {
                    // Create landing sites on branches suitable for robins
                    if (branch.generation >= 0 && branch.generation <= 4 && 
                        branch.thickness > 1.5 * this.scale) {
                        
                        // Multiple landing positions along each suitable branch
                        const landingPositions = [0.3, 0.5, 0.7, 0.9];
                        
                        landingPositions.forEach(t => {
                            if (Math.random() < 0.6) { // Not every position becomes a landing site
                                const landingX = branch.x1 + (branch.x2 - branch.x1) * t;
                                const landingY = branch.y1 + (branch.y2 - branch.y1) * t;
                                
                                this.landingSites.push({
                                    x: this.x + landingX,
                                    y: this.y + landingY,
                                    branchIndex: index,
                                    occupied: false,
                                    robinId: null,
                                    stability: Math.min(1, branch.thickness / (2 * this.scale)),
                                    angle: branch.angle || 0, // Branch angle for proper robin orientation
                                    thickness: branch.thickness,
                                    generation: branch.generation
                                });
                            }
                        });
                    }
                });
            }
            
            updatePhotosynthesis(sunX, sunY, globalCoherence) {
                this.leaves.forEach(leaf => {
                    const distance = Math.sqrt(Math.pow(leaf.x - sunX, 2) + Math.pow(leaf.y - sunY, 2));
                    const sunFactor = Math.max(0.2, 1 - distance / 500);
                    const coherenceBoost = 1 + globalCoherence * 0.5;
                    
                    leaf.photosynthesis = Math.min(1, 
                        leaf.photosynthesis + 0.008 * sunFactor * coherenceBoost
                    );
                    leaf.age += 0.1;
                });
                
                const avgPhotosynthesis = this.leaves.reduce((sum, leaf) => sum + leaf.photosynthesis, 0) / this.leaves.length;
                this.photosynthesis = avgPhotosynthesis;
            }

            // NEW: Find available landing site for robin
            findLandingSite(robinX, robinY, maxDistance = 80) {
                const availableSites = this.landingSites.filter(site => 
                    !site.occupied && 
                    Math.sqrt((site.x - robinX) ** 2 + (site.y - robinY) ** 2) < maxDistance
                );
                
                if (availableSites.length === 0) return null;
                
                // Sort by distance and stability
                availableSites.sort((a, b) => {
                    const distA = Math.sqrt((a.x - robinX) ** 2 + (a.y - robinY) ** 2);
                    const distB = Math.sqrt((b.x - robinX) ** 2 + (b.y - robinY) ** 2);
                    const scoreA = a.stability * 2 - distA / 50;
                    const scoreB = b.stability * 2 - distB / 50;
                    return scoreB - scoreA;
                });
                
                return availableSites[0];
            }

            // NEW: Occupy landing site
            occupyLandingSite(site, robinId) {
                site.occupied = true;
                site.robinId = robinId;
            }

            // NEW: Release landing site
            releaseLandingSite(robinId) {
                const site = this.landingSites.find(site => site.robinId === robinId);
                if (site) {
                    site.occupied = false;
                    site.robinId = null;
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y - 40 * this.scale);
                
                // Draw trunk with texture
                const trunkWidth = 6 * this.scale;
                const trunkHeight = 40 * this.scale;
                
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(-trunkWidth/2, 0, trunkWidth, trunkHeight);
                
                // Trunk texture
                ctx.strokeStyle = '#2d1b17';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const y = trunkHeight * (0.2 + i * 0.2);
                    ctx.beginPath();
                    ctx.moveTo(-trunkWidth/3, y);
                    ctx.lineTo(trunkWidth/3, y);
                    ctx.stroke();
                }
                
                // Draw branches
                this.branches.forEach(branch => {
                    const coherenceAlpha = 0.7 + branch.coherence * 0.3;
                    ctx.strokeStyle = `rgba(101, 67, 33, ${coherenceAlpha})`;
                    ctx.lineWidth = branch.thickness;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(branch.x1, branch.y1);
                    ctx.lineTo(branch.x2, branch.y2);
                    ctx.stroke();
                });
                
                // Draw leaves
                this.leaves.forEach(leaf => {
                    const photosynthesisIntensity = 0.5 + leaf.photosynthesis * 0.5;
                    const red = Math.floor(40 * photosynthesisIntensity);
                    const green = Math.floor(140 * photosynthesisIntensity);
                    const blue = Math.floor(30 * photosynthesisIntensity);
                    
                    ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(leaf.x - this.x, leaf.y - this.y + 40 * this.scale, leaf.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (leaf.photosynthesis > 0.6) {
                        ctx.fillStyle = `rgba(255, 255, 100, ${(leaf.photosynthesis - 0.5) * 0.6})`;
                        ctx.beginPath();
                        ctx.arc(leaf.x - this.x, leaf.y - this.y + 40 * this.scale, leaf.size * 1.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                ctx.restore();
            }
            
            drawNests(ctx, nests) {
                this.nestSites.forEach(site => {
                    if (site.occupied && nests.has(site.nestId)) {
                        const nest = nests.get(site.nestId);
                        
                        ctx.save();
                        
                        // Nest shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(site.x + 2, site.y + 2, site.size, site.size * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Main nest bowl
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.ellipse(site.x, site.y, site.size, site.size * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Nest rim highlight
                        ctx.strokeStyle = '#A0522D';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(site.x, site.y, site.size, site.size * 0.7, 0, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Interior shading
                        ctx.fillStyle = '#654321';
                        ctx.beginPath();
                        ctx.ellipse(site.x, site.y, site.size * 0.7, site.size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Stick details
                        if (nest.materials && nest.materials.length > 0) {
                            nest.materials.slice(0, 8).forEach((material, i) => {
                                const angle = (i / 8) * Math.PI * 2;
                                const stickLength = 8 * this.scale;
                                
                                ctx.strokeStyle = '#A0522D';
                                ctx.lineWidth = 2;
                                ctx.lineCap = 'round';
                                
                                const startX = site.x + Math.cos(angle) * site.size * 0.8;
                                const startY = site.y + Math.sin(angle) * site.size * 0.5;
                                const endX = startX + Math.cos(angle + 0.3) * stickLength;
                                const endY = startY + Math.sin(angle + 0.3) * stickLength * 0.4;
                                
                                ctx.beginPath();
                                ctx.moveTo(startX, startY);
                                ctx.lineTo(endX, endY);
                                ctx.stroke();
                            });
                        }
                        
                        // Nest occupancy indicator
                        if (nest.robin) {
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                            ctx.beginPath();
                            ctx.arc(site.x, site.y - site.size * 0.5, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                });
            }

            // NEW: Draw landing site indicators (for debugging)
            drawLandingSites(ctx, showDebug = false) {
                if (!showDebug) return;
                
                this.landingSites.forEach(site => {
                    ctx.save();
                    
                    // Landing site indicator
                    const alpha = site.occupied ? 0.8 : 0.3;
                    const color = site.occupied ? '255, 0, 0' : '0, 255, 0';
                    
                    ctx.fillStyle = `rgba(${color}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(site.x, site.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Stability indicator
                    ctx.strokeStyle = `rgba(255, 255, 0, ${site.stability * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(site.x, site.y, 8 * site.stability, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                });
            }
        }

        // UCF Starling class
        class UCFStarling {
            constructor(x, y, UCFMath, ecosystem) {
                this.id = `starling_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.UCFMath = UCFMath;
                this.ecosystem = ecosystem;
                
                // Position and movement
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.heading = Math.atan2(this.vy, this.vx);
                
                // Starling properties
                this.bodySize = (1.0 + Math.random() * 0.5) * ecosystem.zoomScale;
                this.wingSpan = (2.2 + Math.random() * 0.7) * ecosystem.zoomScale;
                this.maxSpeed = (2.8 + Math.random() * 1.0) * ecosystem.zoomScale;
                this.color = { r: 20, g: 20, b: 20 };
                this.scale = 0.5; // Fixed small scale for starlings
                
                // Enhanced starling properties
                this.murmurationTendency = 0.85 + Math.random() * 0.1;
                this.collectiveBehavior = 0.8 + Math.random() * 0.15;
                this.swoopiNess = 0.75 + Math.random() * 0.2;
                this.separationDistance = 10 * ecosystem.zoomScale;
                
                // UCF properties
                this.coherenceTrace = 0.4 + Math.random() * 0.2;
                this.flightHistory = [];
                this.maxHistoryLength = 50;
                
                // Hunger system
                this.hunger = Math.random() * 0.3;
                this.hungerRate = 0.0008 + Math.random() * 0.0004;
                
                // Behavior state
                this.currentBehavior = 'murmurating';
                this.stress = 0;
                this.energy = 0.8 + Math.random() * 0.2;
                this.age = 0;
                
                // Landing system
                this.landed = false;
                this.landingCooldown = 0;
            }
            
            update(otherStarlings, time) {
                this.age++;
                
                // Update history for UCF calculations
                const historyEntry = {
                    x: this.x, y: this.y, vx: this.vx, vy: this.vy,
                    behavior: this.currentBehavior, 
                    energy: this.energy,
                    coherenceTrace: this.coherenceTrace,
                    scale: this.scale,
                    time: time
                };
                
                this.flightHistory.push(historyEntry);
                if (this.flightHistory.length > this.maxHistoryLength) {
                    this.flightHistory.shift();
                }
                
                // Calculate UCF coherence
                this.calculateCoherence();
                
                // Update hunger system
                this.updateHungerSystem();
                
                // Execute starling behavior
                this.enhancedStarlingBehavior(otherStarlings);
                
                // Apply movement
                this.applyMovement();
                
                // Update cooldowns
                if (this.landingCooldown > 0) this.landingCooldown--;
                
                // Stress decay
                this.stress = Math.max(0, this.stress - 0.015);
            }
            
            enhancedStarlingBehavior(starlings) {
                this.currentBehavior = 'murmurating';
                
                const activeStarlings = starlings.filter(s => 
                    s !== this && !s.landed && s.currentBehavior !== 'foraging'
                );
                
                if (activeStarlings.length > 0) {
                    let centerX = 0, centerY = 0;
                    activeStarlings.forEach(other => {
                        centerX += other.x;
                        centerY += other.y;
                    });
                    centerX /= activeStarlings.length;
                    centerY /= activeStarlings.length;
                    
                    // Enhanced boundary avoidance
                    const margin = 80;
                    const avoidanceForce = 0.3;
                    
                    if (centerX < margin) {
                        this.vx += avoidanceForce * (margin - centerX) / margin;
                    }
                    if (centerX > this.ecosystem.width - margin) {
                        this.vx -= avoidanceForce * (centerX - (this.ecosystem.width - margin)) / margin;
                    }
                    if (centerY < margin) {
                        this.vy += avoidanceForce * (margin - centerY) / margin;
                    }
                    if (centerY > this.ecosystem.height - margin) {
                        this.vy -= avoidanceForce * (centerY - (this.ecosystem.height - margin)) / margin;
                    }
                    
                    // Add exploration tendency
                    if (Math.random() < 0.005) {
                        const exploreX = this.ecosystem.width * (0.2 + Math.random() * 0.6);
                        const exploreY = this.ecosystem.height * (0.2 + Math.random() * 0.6);
                        const dx = exploreX - this.x;
                        const dy = exploreY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 100) {
                            this.vx += (dx / distance) * 0.02;
                            this.vy += (dy / distance) * 0.02;
                        }
                    }
                    
                    this.enhancedMurmuration(activeStarlings, centerX, centerY);
                    
                    // Swooping behavior
                    if (Math.random() < 0.035 * this.swoopiNess) {
                        this.currentBehavior = 'swooping';
                        
                        const swoopiNgAngle = Math.atan2(this.vy, this.vx) + 
                            Math.sin(this.ecosystem.time * 0.025 + this.x * 0.003) * Math.PI * 0.4;
                        
                        const swoopiNgForce = this.coherenceTrace * this.murmurationTendency * 0.5;
                        this.vx += Math.cos(swoopiNgAngle) * swoopiNgForce;
                        this.vy += Math.sin(swoopiNgAngle) * swoopiNgForce;
                    }
                    
                    // Wave propagation
                    if (Math.random() < 0.018 * this.collectiveBehavior) {
                        const wavePhase = this.ecosystem.time * 0.02 + this.x * 0.005 + this.y * 0.004;
                        const waveStrength = this.coherenceTrace * 0.4;
                        
                        this.vx += Math.sin(wavePhase) * waveStrength;
                        this.vy += Math.cos(wavePhase * 1.1) * waveStrength * 0.7;
                    }
                } else {
                    // Solo exploration
                    this.currentBehavior = 'seeking';
                    let targetX = this.ecosystem.width * 0.1 + Math.random() * this.ecosystem.width * 0.8;
                    let targetY = this.ecosystem.height * 0.2 + Math.random() * this.ecosystem.height * 0.6;
                    
                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);
                    
                    if (distance > 20) {
                        this.vx += (dx / distance) * 0.08;
                        this.vy += (dy / distance) * 0.08;
                    }
                }
            }
            
            enhancedMurmuration(starlings, centerX, centerY) {
                let separation = { x: 0, y: 0 };
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let count = 0;
                
                const range = 25;
                
                starlings.forEach(other => {
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);
                    
                    if (distance < range && distance > 0) {
                        if (distance < this.separationDistance) {
                            const repulsion = (this.separationDistance - distance) / this.separationDistance;
                            separation.x -= (dx / distance) * repulsion * 1.2;
                            separation.y -= (dy / distance) * repulsion * 1.2;
                        }
                        
                        const coherenceBonus = (this.coherenceTrace + other.coherenceTrace) * 0.5;
                        const alignmentWeight = coherenceBonus * this.murmurationTendency;
                        
                        alignment.x += other.vx * alignmentWeight;
                        alignment.y += other.vy * alignmentWeight;
                        
                        cohesion.x += other.x * alignmentWeight;
                        cohesion.y += other.y * alignmentWeight;
                        count++;
                    }
                });
                
                if (count > 0) {
                    this.vx += separation.x * 0.3;
                    this.vy += separation.y * 0.3;
                    
                    alignment.x /= count;
                    alignment.y /= count;
                    this.vx += (alignment.x - this.vx) * 0.11 * this.murmurationTendency;
                    this.vy += (alignment.y - this.vy) * 0.11 * this.murmurationTendency;
                    
                    cohesion.x /= count;
                    cohesion.y /= count;
                    this.vx += (cohesion.x - this.x) * 0.006;
                    this.vy += (cohesion.y - this.y) * 0.006;
                    
                    // Attraction to distributed center
                    const toCenterX = centerX - this.x;
                    const toCenterY = centerY - this.y;
                    this.vx += toCenterX * 0.0006;
                    this.vy += toCenterY * 0.0006;
                }
            }
            
            updateHungerSystem() {
                this.hunger = Math.min(1.0, this.hunger + this.hungerRate);
                if (Math.random() < 0.001) {
                    this.hunger = Math.max(0, this.hunger - 0.1);
                }
            }
            
            calculateCoherence() {
                if (this.flightHistory.length < 3) return;
                
                let coherenceSum = 0;
                let consistencySum = 0;
                
                for (let i = 1; i < this.flightHistory.length; i++) {
                    const prev = this.flightHistory[i-1];
                    const curr = this.flightHistory[i];
                    
                    const behaviorConsistency = prev.behavior === curr.behavior ? 1 : 0.25;
                    const velocityDiff = Math.abs(prev.vx - curr.vx) + Math.abs(prev.vy - curr.vy);
                    const velocityConsistency = Math.max(0, 1 - velocityDiff * 0.12);
                    
                    const frameCoherence = (behaviorConsistency + velocityConsistency) / 2;
                    const timeWeight = Math.pow(i / this.flightHistory.length, 1.2);
                    
                    coherenceSum += frameCoherence * timeWeight;
                    consistencySum += timeWeight;
                }
                
                if (consistencySum > 0) {
                    this.coherenceTrace = coherenceSum / consistencySum;
                }
            }
            
            applyMovement() {
                this.x += this.vx;
                this.y += this.vy;
                
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > this.maxSpeed) {
                    this.vx = (this.vx / currentSpeed) * this.maxSpeed;
                    this.vy = (this.vy / currentSpeed) * this.maxSpeed;
                }
                
                // Minimum speed maintenance
                const minSpeed = 0.6;
                if (currentSpeed < minSpeed && this.currentBehavior !== 'seeking') {
                    const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                    this.vx += Math.cos(angle) * 0.2;
                    this.vy += Math.sin(angle) * 0.2;
                }

                // Update heading smoothly
                const targetHeading = Math.atan2(this.vy, this.vx);
                let headingDiff = targetHeading - this.heading;
                
                // Normalize angle difference
                while (headingDiff > Math.PI) headingDiff -= 2 * Math.PI;
                while (headingDiff < -Math.PI) headingDiff += 2 * Math.PI;
                
                this.heading += headingDiff * 0.1;
                
                // Boundary handling
                const margin = 50;
                if (this.x < margin) this.vx += 0.8;
                if (this.x > this.ecosystem.width - margin) this.vx -= 0.8;
                if (this.y < margin) this.vy += 0.8;
                if (this.y > this.ecosystem.height - margin) this.vy -= 0.8;
                
                // Energy management
                const energyConsumption = currentSpeed / 1000;
                this.energy = Math.max(0.2, this.energy - energyConsumption);
                this.energy = Math.min(1.0, this.energy + 0.001);
            }
            
            triggerRupture() {
                const lossAmount = Math.floor(this.flightHistory.length * 0.6);
                this.flightHistory = this.flightHistory.slice(lossAmount);
                
                const newBehaviors = ['murmurating', 'seeking', 'swooping'];
                const currentIndex = newBehaviors.indexOf(this.currentBehavior);
                const availableBehaviors = newBehaviors.filter((_, i) => i !== currentIndex);
                this.currentBehavior = availableBehaviors[Math.floor(Math.random() * availableBehaviors.length)];
                
                this.vx *= 0.3;
                this.vy *= 0.3;
                this.coherenceTrace = 0.08;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                let starlingColor = 'rgba(20, 20, 20, 0.9)';
                
                if (this.hunger > 0.6) {
                    starlingColor = 'rgba(40, 30, 20, 0.95)';
                }
                
                ctx.fillStyle = starlingColor;
                ctx.beginPath();
                ctx.arc(0, 0, this.bodySize, 0, Math.PI * 2);
                ctx.fill();
                
                // Foraging indicator (hidden in nature mode)
                if ((this.foraging || this.currentBehavior === 'hungry') && !this.ecosystem.natureMode) {
                    ctx.strokeStyle = this.hunger > 0.7 ? 'rgba(255, 100, 0, 0.8)' : 'rgba(255, 165, 0, 0.6)';
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.bodySize * 1.8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enhanced stress indicator (hidden in nature mode)
                if (this.stress > 0.4 && !this.ecosystem.natureMode) {
                    ctx.strokeStyle = `rgba(255, 0, 0, ${this.stress * 0.35})`;
                    ctx.lineWidth = 0.6;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.bodySize * 1.6, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // NEW: UCF Swallow class for distant territories
        class UCFSwallow {
            constructor(x, y, UCFMath, ecosystem) {
                this.id = `swallow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.UCFMath = UCFMath;
                this.ecosystem = ecosystem;
                
                // Position and movement
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.heading = Math.atan2(this.vy, this.vx);
                
                // Swallow properties (smaller, faster)
                this.baseSize = 2.5;
                this.size = this.baseSize;
                this.wingSpan = 5;
                this.maxSpeed = 12;
                this.color = { r: 25, g: 35, b: 140 };
                this.scale = 0.3; // Small scale for distant perspective
                
                // Interaction properties
                this.interactionRange = 15;
                
                // UCF properties with scale history
                this.coherence = 0.4 + Math.random() * 0.3;
                this.energy = 0.7 + Math.random() * 0.3;
                this.stress = 0;
                this.age = 0;
                this.history = [];
                this.maxHistoryLength = 30;
                
                // Behavioral state
                this.currentBehavior = 'aerial_hunting';
                this.huntingTarget = null;
                this.agility = 0.75 + Math.random() * 0.2;
            }
            
            update(otherSwallows, visitingRobins, time) {
                this.age++;
                
                // Update history for UCF calculations
                const historyEntry = {
                    x: this.x, y: this.y, vx: this.vx, vy: this.vy,
                    behavior: this.currentBehavior,
                    energy: this.energy,
                    scale: this.scale,
                    coherence: this.coherence,
                    time: time
                };
                
                this.history.push(historyEntry);
                if (this.history.length > this.maxHistoryLength) {
                    this.history.shift();
                }
                
                // Fast aerial hunting behavior
                if (!this.huntingTarget && Math.random() < 0.04) {
                    this.huntingTarget = {
                        x: this.x + (Math.random() - 0.5) * 80,
                        y: this.y + (Math.random() - 0.5) * 60,
                        lifetime: 30 + Math.random() * 20
                    };
                }
                
                if (this.huntingTarget) {
                    const dx = this.huntingTarget.x - this.x;
                    const dy = this.huntingTarget.y - this.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);
                    
                    if (distance < 3 || this.huntingTarget.lifetime-- <= 0) {
                        this.huntingTarget = null;
                        this.energy = Math.min(1, this.energy + 0.05);
                    } else {
                        this.vx += (dx / distance) * 0.4 * this.agility;
                        this.vy += (dy / distance) * 0.4 * this.agility;
                    }
                }
                
                // NEW: Enhanced interaction with visiting robins based on scale compatibility
                visitingRobins.forEach(robin => {
                    const scaleCompatibility = this.UCFMath.scaleCompatibility(robin.scale || 1.0, this.scale);
                    
                    if (scaleCompatibility > 0.7) { // Only interact when scales are very similar
                        const dx = robin.x - this.x;
                        const dy = robin.y - this.y;
                        const distance = Math.sqrt(dx ** 2 + dy ** 2);
                        
                        if (distance < this.interactionRange) {
                            // Strong coherence exchange when scales match
                            const coherenceExchange = scaleCompatibility * 0.02;
                            this.coherence = Math.min(1, this.coherence + coherenceExchange);
                            robin.coherence = Math.min(1, robin.coherence + coherenceExchange);
                            
                            // Share agility enhancement
                            if (robin.maxSpeed) {
                                robin.maxSpeed = Math.min(robin.maxSpeed * 1.01, robin.maxSpeed * 1.1);
                            }
                            
                            // Learn from each other's behaviors
                            if (Math.random() < 0.05) {
                                this.agility = Math.min(1, this.agility + 0.01);
                                if (robin.energy !== undefined) {
                                    robin.energy = Math.min(1, robin.energy + 0.05);
                                }
                            }
                        }
                    }
                });
                
                // Apply movement
                this.applyMovement();
            }
            
            applyMovement() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Speed regulation
                const currentSpeed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (currentSpeed > this.maxSpeed) {
                    this.vx = (this.vx / currentSpeed) * this.maxSpeed;
                    this.vy = (this.vy / currentSpeed) * this.maxSpeed;
                }
                
                // Update heading
                this.heading = Math.atan2(this.vy, this.vx);
                
                // Boundary handling (stay in distant territory)
                const territory = this.ecosystem.distantSwallowTerritory;
                if (territory) {
                    if (this.x < territory.x) this.vx += 0.5;
                    if (this.x > territory.x + territory.width) this.vx -= 0.5;
                    if (this.y < territory.y) this.vy += 0.5;
                    if (this.y > territory.y + territory.height) this.vy -= 0.5;
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.heading);
                ctx.scale(this.scale, this.scale);
                
                // Draw swallow body
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.9)`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.2, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wing animation
                const wingBeat = Math.sin(this.age * 0.3) * 0.3;
                ctx.fillStyle = `rgba(${this.color.r * 0.8}, ${this.color.g * 0.8}, ${this.color.b * 0.8}, 0.8)`;
                
                // Wings
                ctx.save();
                ctx.rotate(wingBeat);
                ctx.fillRect(-this.size, -this.wingSpan * 0.5, this.size * 0.8, this.wingSpan);
                ctx.restore();
                
                ctx.save();
                ctx.rotate(-wingBeat);
                ctx.fillRect(-this.size, -this.wingSpan * 0.5, this.size * 0.8, this.wingSpan);
                ctx.restore();
                
                // Forked tail
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.9)`;
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.lineTo(-this.size * 1.5, -this.size * 0.7);
                ctx.lineTo(-this.size * 1.3, 0);
                ctx.lineTo(-this.size * 1.5, this.size * 0.7);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        // NEW: UCF Eagle predator with dynamic scaling
        class UCFEagle {
            constructor(x, y, UCFMath, ecosystem) {
                this.id = `eagle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.UCFMath = UCFMath;
                this.ecosystem = ecosystem;
                
                // Position and movement
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.heading = Math.atan2(this.vy, this.vx);
                
                // Eagle properties with dynamic scaling
                this.baseSize = 15;
                this.size = this.baseSize;
                this.scale = 1.0; // Current scale multiplier
                this.targetScale = 1.0; // Target scale for smooth transitions
                this.wingSpan = 25;
                this.maxSpeed = 8;
                this.color = { r: 101, g: 67, b: 33 };
                
                // Scale bounds for different prey types
                this.minScale = 0.1; // For hunting starlings (10% of original size)
                this.maxScale = 1.2; // For hunting robins
                this.scaleTransitionSpeed = 0.02;
                
                // Predator properties
                this.huntingTarget = null;
                this.huntingRange = 200;
                this.energy = 1.0;
                this.age = 0;
                this.aggressionLevel = 0.7;
                
                // UCF properties
                this.coherence = 0.6 + Math.random() * 0.2;
                this.history = [];
                this.maxHistoryLength = 40;
                
                // Hunting success tracking
                this.huntingSuccess = 0;
                this.totalHunts = 0;
            }
            
            update(robins, starlings, swallows, time) {
                this.age++;
                
                // Update history for UCF calculations
                const historyEntry = {
                    x: this.x, y: this.y, vx: this.vx, vy: this.vy,
                    behavior: 'hunting',
                    energy: this.energy,
                    scale: this.scale,
                    coherence: this.coherence,
                    aggressionLevel: this.aggressionLevel,
                    time: time
                };
                
                this.history.push(historyEntry);
                if (this.history.length > this.maxHistoryLength) {
                    this.history.shift();
                }
                
                // Determine target scale based on nearest prey
                this.calculateTargetScale(robins, starlings, swallows);
                
                // Smooth scale transition
                if (Math.abs(this.targetScale - this.scale) > 0.01) {
                    this.scale += (this.targetScale - this.scale) * this.scaleTransitionSpeed;
                    this.size = this.baseSize * this.scale;
                    this.huntingRange = 200 * this.scale;
                }
                
                // Hunt behavior based on current scale
                this.executeHuntingBehavior(robins, starlings, swallows);
                
                // Apply movement
                this.applyMovement();
                
                // Energy management
                this.energy -= 0.001;
                if (this.energy < 0.3) {
                    this.aggressionLevel = Math.min(1.0, this.aggressionLevel + 0.01);
                }
            }
            
            calculateTargetScale(robins, starlings, swallows) {
                let nearestPrey = null;
                let nearestDistance = Infinity;
                let targetScale = this.maxScale;
                
                // Check robins (large scale) - prefer when large
                robins.forEach(robin => {
                    const dist = Math.sqrt((robin.x - this.x) ** 2 + (robin.y - this.y) ** 2);
                    if (dist < nearestDistance) {
                        nearestDistance = dist;
                        nearestPrey = { type: 'robin', entity: robin };
                        targetScale = Math.max(0.8, (robin.scale || 1.0) * 1.2);
                    }
                });
                
                // Check starlings (small scale) - prefer when closer and hungrier
                const starlingPreference = this.energy < 0.5 ? 0.6 : 0.8; // Hungrier eagles prefer easier starling prey
                starlings.forEach(starling => {
                    const dist = Math.sqrt((starling.x - this.x) ** 2 + (starling.y - this.y) ** 2);
                    if (dist < nearestDistance * starlingPreference) {
                        nearestDistance = dist;
                        nearestPrey = { type: 'starling', entity: starling };
                        targetScale = Math.max(this.minScale, starling.scale * 1.5);
                    }
                });
                
                // Check swallows (very small scale) - highest preference when very hungry
                if (this.energy < 0.4) {
                    swallows.forEach(swallow => {
                        const dist = Math.sqrt((swallow.x - this.x) ** 2 + (swallow.y - this.y) ** 2);
                        if (dist < nearestDistance * 0.4) { // Very high preference for swallows when hungry
                            nearestDistance = dist;
                            nearestPrey = { type: 'swallow', entity: swallow };
                            targetScale = Math.max(0.25, swallow.scale * 1.3);
                        }
                    });
                }
                
                this.targetScale = Math.max(this.minScale, Math.min(this.maxScale, targetScale));
                
                // Set hunting target based on scale compatibility
                if (nearestPrey && nearestDistance < this.huntingRange) {
                    const scaleCompatibility = this.UCFMath.scaleCompatibility(this.scale, nearestPrey.entity.scale || 1.0);
                    if (scaleCompatibility > 0.5) {
                        this.huntingTarget = nearestPrey;
                    }
                }
            }
            
            executeHuntingBehavior(robins, starlings, swallows) {
                if (this.huntingTarget) {
                    const target = this.huntingTarget.entity;
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx ** 2 + dy ** 2);
                    
                    if (distance < this.size * 2) {
                        // Attempt to catch prey
                        this.totalHunts++;
                        const scaleCompatibility = this.UCFMath.scaleCompatibility(this.scale, target.scale || 1.0);
                        const catchProbability = this.aggressionLevel * scaleCompatibility * 0.4;
                        
                        if (Math.random() < catchProbability) {
                            this.catchPrey(target);
                            this.huntingSuccess++;
                        }
                    } else if (distance < this.huntingRange) {
                        // Chase prey with scale-modulated intensity
                        const scaleCompatibility = this.UCFMath.scaleCompatibility(this.scale, target.scale || 1.0);
                        const huntingForce = 0.3 * this.aggressionLevel * scaleCompatibility;
                        this.vx += (dx / distance) * huntingForce;
                        this.vy += (dy / distance) * huntingForce;
                        
                        // Trigger escape behavior in nearby birds
                        this.triggerEscapeResponse(robins, starlings, swallows);
                    } else {
                        this.huntingTarget = null;
                    }
                } else {
                    // Patrol behavior
                    this.patrol();
                }
            }
            
            catchPrey(prey) {
                // Remove prey from ecosystem
                const arrays = [this.ecosystem.robins, this.ecosystem.starlings, this.ecosystem.swallows];
                arrays.forEach(array => {
                    const index = array.indexOf(prey);
                    if (index > -1) {
                        array.splice(index, 1);
                        // Energy gain based on prey size/scale
                        const energyGain = 0.2 + ((prey.scale || 1.0) * 0.2);
                        this.energy = Math.min(1.0, this.energy + energyGain);
                        this.huntingTarget = null;
                        
                        // Coherence boost from successful hunt
                        this.coherence = Math.min(1.0, this.coherence + 0.1);
                    }
                });
            }
            
            triggerEscapeResponse(robins, starlings, swallows) {
                const escapeRange = this.huntingRange * 0.8;
                
                [...robins, ...starlings, ...swallows].forEach(bird => {
                    const dist = Math.sqrt((bird.x - this.x) ** 2 + (bird.y - this.y) ** 2);
                    const scaleCompatibility = this.UCFMath.scaleCompatibility(this.scale, bird.scale || 1.0);
                    
                    if (dist < escapeRange && scaleCompatibility > 0.3) {
                        // Trigger escape behavior
                        if (bird.triggerRupture) bird.triggerRupture();
                        
                        // Apply escape velocity
                        const escapeStrength = (escapeRange - dist) / escapeRange * scaleCompatibility;
                        const escapeX = bird.x - this.x;
                        const escapeY = bird.y - this.y;
                        const escapeDist = Math.sqrt(escapeX ** 2 + escapeY ** 2);
                        
                        if (escapeDist > 0) {
                            bird.vx += (escapeX / escapeDist) * escapeStrength * 2;
                            bird.vy += (escapeY / escapeDist) * escapeStrength * 2;
                            if (bird.stress !== undefined) bird.stress = 1.0;
                            
                            // Change behavior to escaping
                            if (bird.behavior !== undefined) {
                                bird.behavior = 'escaping';
                                bird.behaviorCooldown = 90;
                            }

                            // NEW: Force landed robins to take off when eagle approaches
                            if (bird.landed && bird.takeOff) {
                                bird.takeOff();
                            }
                        }
                    }
                });
            }
            
            patrol() {
                // Soaring patrol behavior with scale-based altitude preference
                if (Math.random() < 0.02) {
                    this.vx += (Math.random() - 0.5) * 0.3;
                    this.vy += (Math.random() - 0.5) * 0.3;
                }
                
                // Altitude preference based on scale - larger eagles fly higher
                const preferredAltitude = this.ecosystem.height * (0.3 - this.scale * 0.2);
                if (this.y > preferredAltitude) {
                    this.vy -= 0.05 * this.scale;
                }
            }
            
            applyMovement() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Speed regulation based on scale
                const effectiveMaxSpeed = this.maxSpeed * (0.5 + this.scale * 0.5);
                const currentSpeed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                
                if (currentSpeed > effectiveMaxSpeed) {
                    this.vx = (this.vx / currentSpeed) * effectiveMaxSpeed;
                    this.vy = (this.vy / currentSpeed) * effectiveMaxSpeed;
                }
                
                // Update heading
                this.heading = Math.atan2(this.vy, this.vx);
                
                // Boundary handling
                const margin = 100;
                if (this.x < margin) this.vx += 0.2;
                if (this.x > this.ecosystem.width - margin) this.vx -= 0.2;
                if (this.y < margin) this.vy += 0.2;
                if (this.y > this.ecosystem.height - margin) this.vy -= 0.2;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.heading);
                ctx.scale(this.scale, this.scale);
                
                // Draw eagle body
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.95)`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.baseSize * 1.2, this.baseSize * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings based on hunting state
                const wingSpread = this.huntingTarget ? 0.9 : 1.3;
                const wingBeat = Math.sin(this.age * 0.1) * 0.05;
                
                ctx.fillStyle = `rgba(${this.color.r * 0.9}, ${this.color.g * 0.9}, ${this.color.b * 0.9}, 0.9)`;
                
                // Left wing
                ctx.beginPath();
                ctx.ellipse(-this.baseSize * 0.3, (-this.wingSpan * wingSpread * 0.5) + wingBeat, 
                           this.wingSpan * 0.7, this.baseSize * 0.4, -0.1, 0, Math.PI * 2);
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.ellipse(-this.baseSize * 0.3, (this.wingSpan * wingSpread * 0.5) - wingBeat, 
                           this.wingSpan * 0.7, this.baseSize * 0.4, 0.1, 0, Math.PI * 2);
                ctx.fill();
                
                // Head and beak
                ctx.fillStyle = `rgba(${this.color.r * 1.1}, ${this.color.g * 1.1}, ${this.color.b * 1.1}, 0.95)`;
                ctx.beginPath();
                ctx.arc(this.baseSize * 0.6, 0, this.baseSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Beak
                ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
                ctx.beginPath();
                ctx.moveTo(this.baseSize * 0.9, 0);
                ctx.lineTo(this.baseSize * 1.1, -this.baseSize * 0.1);
                ctx.lineTo(this.baseSize * 1.1, this.baseSize * 0.1);
                ctx.closePath();
                ctx.fill();
                
                // Scale indicator for debugging (hidden in nature mode)
                if (this.ecosystem.showDebugInfo && !this.ecosystem.natureMode) {
                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + this.scale * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.baseSize * 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Draw hunting range indicator when hunting (hidden in nature mode)
                if (this.huntingTarget && !this.ecosystem.natureMode) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.1 + this.aggressionLevel * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 15]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.huntingRange, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
            }
        }

        // Enhanced UCF Robin with Multi-Scale Journeying Capabilities and Landing System
        class UCFRobin {
            constructor(x, y, UCFMath, ecosystem) {
                this.id = `robin_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.UCFMath = UCFMath;
                this.ecosystem = ecosystem;
                
                // Position and movement
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.heading = Math.atan2(this.vy, this.vx);
                
                // Enhanced flight characteristics
                this.size = 6;
                this.wingSpan = 14;
                this.maxSpeed = 18;
                this.maxForce = 0.4;
                this.energy = 0.8 + Math.random() * 0.2;
                
                // NEW: Multi-scale properties
                this.scale = 1.0; // Current scale
                this.targetScale = 1.0; // Target scale for transitions
                this.minScale = 0.3; // Minimum scale for swallow interactions
                this.maxScale = 1.2; // Maximum scale
                this.scaleTransitionSpeed = 0.03; // How fast scale changes
                
                // Flocking parameters
                this.separationRadius = 25;
                this.alignmentRadius = 50;
                this.cohesionRadius = 50;
                this.perceptionRadius = 80;
                this.flockingStrength = 0;
                
                // UCF properties
                this.coherence = 0.5 + Math.random() * 0.2;
                this.history = [];
                this.maxHistoryLength = 60;
                this.memoryDensity = 0;
                this.ruptureEvents = 0;
                
                // NEW: Journey system
                this.isJourneying = false;
                this.journeyTarget = null;
                this.journeyStartTime = 0;
                this.journeyDuration = 0;
                this.homePosition = { x: x, y: y };
                
                // NEW: Landing system
                this.landed = false;
                this.landingSite = null;
                this.landingCooldown = 0;
                this.landingDuration = 0;
                this.restTime = 0;
                this.landingEnergy = 0;
                
                // RNA sequences
                this.rnaSequences = [
                    { pattern: [2200, 2800, 2400, 3000], durations: [0.12, 0.08, 0.10, 0.09], amplitudes: [0.8, 0.9, 0.7, 1.0], motorPattern: 'flight' },
                    { pattern: [2600, 2200, 2600, 2200], durations: [0.06, 0.04, 0.06, 0.04], amplitudes: [0.9, 0.8, 0.9, 0.8], motorPattern: 'hover' },
                    { pattern: [2000, 2300, 2100, 2600], durations: [0.15, 0.12, 0.18, 0.10], amplitudes: [0.6, 0.7, 0.5, 0.8], motorPattern: 'maneuver' },
                    { pattern: [3000, 2400, 2800, 2200], durations: [0.08, 0.10, 0.12, 0.15], amplitudes: [1.0, 0.8, 0.9, 0.7], motorPattern: 'burst' },
                    { pattern: [2400, 2600, 2300, 2700], durations: [0.10, 0.08, 0.12, 0.09], amplitudes: [0.7, 0.8, 0.6, 0.9], motorPattern: 'flock' },
                    { pattern: [1800, 2000, 1900, 2100], durations: [0.20, 0.18, 0.22, 0.16], amplitudes: [0.5, 0.6, 0.4, 0.7], motorPattern: 'journey' }, // NEW
                    { pattern: [1500, 1600, 1400, 1700], durations: [0.30, 0.25, 0.35, 0.20], amplitudes: [0.3, 0.4, 0.2, 0.5], motorPattern: 'landed' } // NEW: Landing pattern
                ];
                
                this.currentRNAPattern = 0;
                this.rnaComputationRate = 0;
                
                // Behavioral state
                this.behavior = Math.random() < 0.7 ? 'flocking' : 'exploring';
                this.behaviorCooldown = 0;
                
                // Wing animation - much faster for realistic robin frequency
                this.wingPhase = Math.random() * Math.PI * 2;
                this.wingFrequency = 25; // 25 Hz base frequency
                this.wingAmplitude = 0.6;
                
                // Nesting system
                this.nestTarget = null;
                this.currentNest = null;
                this.carriedMaterials = [];
                this.territorialRadius = 80;
                this.mate = null;
                
                // Flocking weights
                this.separationWeight = 1.5;
                this.alignmentWeight = 1.0;
                this.cohesionWeight = 1.0;
                this.memoryWeight = 0.8;
                
                // Audio
                this.lastVocalization = 0;
                this.vocalizationCooldown = 0;
            }
            
            update(trees, otherRobins, materials, time) {
                // Update history with scale information
                const historyEntry = {
                    x: this.x, y: this.y, vx: this.vx, vy: this.vy,
                    behavior: this.behavior, 
                    energy: this.energy,
                    rnaState: this.currentRNAPattern,
                    flockingStrength: this.flockingStrength,
                    scale: this.scale, // NEW: Include scale in history
                    landed: this.landed, // NEW: Include landing state
                    time: time
                };
                
                this.history.push(historyEntry);
                if (this.history.length > this.maxHistoryLength) {
                    this.history.shift();
                }
                
                // Handle scale transitions
                this.updateScale();
                
                // NEW: Handle landing behavior
                if (this.landed) {
                    this.updateLandedBehavior(trees);
                } else {
                    // Calculate UCF metrics
                    this.memoryDensity = this.UCFMath.memoryDensityFunction(this, 0);
                    this.coherence = this.UCFMath.coherenceIntegral(
                        (tau) => this.UCFMath.memoryDensityFunction(this, tau),
                        this.history.length
                    );
                    
                    // Check for rupture events
                    const rupture = this.UCFMath.ruptureDetection(this.coherence);
                    if (rupture && Math.random() < 0.08) {
                        this.triggerRupture();
                    }
                    
                    // Enhanced RNA computational locomotion with scale modulation
                    this.computeRNALocomotion();
                    
                    // Apply flocking behaviors (only with similar-scale robins)
                    this.flock(otherRobins);
                    
                    // Execute higher-level behaviors
                    this.executeBehavior(trees, otherRobins, materials);
                    
                    // Apply movement
                    this.applyMovement();
                    
                    // Update wing animation
                    this.updateWingAnimation();
                    
                    // NEW: Check for landing opportunities
                    this.checkLandingOpportunities(trees);
                }
                
                // Handle vocalizations
                this.handleVocalizations(time);
                
                // Update cooldowns
                this.behaviorCooldown = Math.max(0, this.behaviorCooldown - 1);
                this.vocalizationCooldown = Math.max(0, this.vocalizationCooldown - 1);
                this.landingCooldown = Math.max(0, this.landingCooldown - 1);
            }

            // NEW: Scale transition management
            updateScale() {
                if (Math.abs(this.targetScale - this.scale) > 0.01) {
                    this.scale += (this.targetScale - this.scale) * this.scaleTransitionSpeed;
                    
                    // Adjust properties based on scale
                    this.size = 6 * this.scale;
                    this.separationRadius = 25 * this.scale;
                    this.alignmentRadius = 50 * this.scale;
                    this.cohesionRadius = 50 * this.scale;
                    this.perceptionRadius = 80 * this.scale;
                }
            }

            // NEW: Check for landing opportunities on tree branches
            checkLandingOpportunities(trees) {
                // Only check if not recently landed and not in certain behaviors
                if (this.landingCooldown > 0 || this.behavior === 'escaping' || 
                    this.isJourneying || this.behavior === 'territorial') {
                    return;
                }
                
                // Random chance to look for landing, higher when tired
                const landingChance = 0.003 + (1 - this.energy) * 0.007;
                if (Math.random() > landingChance) return;
                
                // Find nearby trees with available landing sites
                const nearbyTrees = trees.filter(tree => {
                    const dist = Math.sqrt((tree.x - this.x) ** 2 + (tree.y - this.y) ** 2);
                    return dist < 150;
                });
                
                for (const tree of nearbyTrees) {
                    const landingSite = tree.findLandingSite(this.x, this.y, 80);
                    if (landingSite) {
                        this.attemptLanding(tree, landingSite);
                        break;
                    }
                }
            }

            // NEW: Attempt to land on a tree branch
            attemptLanding(tree, landingSite) {
                // Set landing state
                this.landed = true;
                this.landingSite = landingSite;
                this.behavior = 'landed';
                this.currentRNAPattern = 6; // Use landed RNA pattern
                
                // Set position to landing site
                this.x = landingSite.x;
                this.y = landingSite.y;
                this.vx = 0;
                this.vy = 0;
                this.heading = landingSite.angle; // Orient along branch
                
                // Occupy the landing site
                tree.occupyLandingSite(landingSite, this.id);
                
                // Set landing duration based on energy and coherence
                this.landingDuration = 120 + Math.floor((1 - this.energy) * 180) + 
                                      Math.floor(this.coherence * 60);
                this.restTime = 0;
                this.landingEnergy = this.energy;
                
                // Set cooldown before next landing attempt
                this.landingCooldown = 300 + Math.floor(Math.random() * 300);
            }

            // NEW: Update behavior while landed
            updateLandedBehavior(trees) {
                this.restTime++;
                
                // Energy recovery while resting
                const energyRecovery = 0.004 + (this.landingSite.stability * 0.002);
                this.energy = Math.min(1.0, this.energy + energyRecovery);
                
                // Coherence improvement while stationary
                this.coherence = Math.min(1.0, this.coherence + 0.002);
                
                // Small movements while perched (head turning, slight adjustments)
                if (Math.random() < 0.05) {
                    this.heading += (Math.random() - 0.5) * 0.3;
                }
                
                // Check for takeoff conditions
                const shouldTakeOff = this.restTime >= this.landingDuration ||
                                    Math.random() < 0.001 || // Small random chance
                                    this.energy >= 0.95; // Full energy
                
                if (shouldTakeOff) {
                    this.takeOff(trees);
                }
            }

            // NEW: Take off from landing site
            takeOff(trees) {
                if (!this.landed || !this.landingSite) return;
                
                // Release the landing site
                if (trees) {
                    trees.forEach(tree => {
                        tree.releaseLandingSite(this.id);
                    });
                }
                
                // Reset landing state
                this.landed = false;
                this.landingSite = null;
                this.behavior = 'flocking';
                this.currentRNAPattern = 0; // Return to flight pattern
                this.behaviorCooldown = 30;
                
                // Initial takeoff velocity
                this.vx = Math.cos(this.heading) * 3 + (Math.random() - 0.5) * 2;
                this.vy = Math.sin(this.heading) * 3 - 2 - Math.random() * 2; // Upward bias
                
                // Energy cost for takeoff
                this.energy = Math.max(0.3, this.energy - 0.05);
            }
            
            // NEW: Initiate journey to distant territories
            startJourney() {
                if (this.isJourneying || this.landed) return;
                
                // Take off if landed
                if (this.landed) {
                    this.takeOff(this.ecosystem.trees);
                }
                
                // Select journey destination based on available territories
                const territories = [];
                
                // Add swallow territory if it exists
                if (this.ecosystem.distantSwallowTerritory) {
                    territories.push({
                        x: this.ecosystem.distantSwallowTerritory.x + this.ecosystem.distantSwallowTerritory.width / 2,
                        y: this.ecosystem.distantSwallowTerritory.y + this.ecosystem.distantSwallowTerritory.height / 2,
                        scale: 0.3,
                        type: 'swallow'
                    });
                }
                
                if (territories.length === 0) return;
                
                // Select random territory
                const selectedTerritory = territories[Math.floor(Math.random() * territories.length)];
                
                this.isJourneying = true;
                this.journeyTarget = selectedTerritory;
                this.targetScale = selectedTerritory.scale; // Begin scaling down
                this.behavior = 'journeying';
                this.behaviorCooldown = 600; // Long journey duration
                this.journeyStartTime = this.ecosystem.time;
                this.journeyDuration = 300 + Math.random() * 300; // 5-10 seconds at 60fps
                this.currentRNAPattern = 5; // Use journey RNA pattern
            }
            
            // Advanced Flocking System with Scale Compatibility
            flock(robins) {
                // Only flock with robins of similar scale and not landed
                const scaleCompatibleRobins = robins.filter(robin => {
                    if (robin === this || robin.landed) return false;
                    return this.UCFMath.scaleCompatibility(this.scale, robin.scale) > 0.7;
                });
                
                const neighbors = this.getNeighbors(scaleCompatibleRobins);
                this.flockingStrength = neighbors.length > 0 ? neighbors.length / scaleCompatibleRobins.length : 0;
                
                if (neighbors.length === 0) {
                    this.applyMemoryNavigation();
                    return;
                }
                
                // Core flocking behaviors
                const separation = this.separate(neighbors);
                const alignment = this.align(neighbors);
                const cohesion = this.cohere(neighbors);
                const memory = this.memoryAttraction();
                
                // Apply forces with scale-modulated weights
                this.applyForce(separation, this.separationWeight * this.ecosystem.params.separation * this.scale);
                this.applyForce(alignment, this.alignmentWeight * this.scale);
                this.applyForce(cohesion, this.cohesionWeight * this.ecosystem.params.cohesion * this.scale);
                this.applyForce(memory, this.memoryWeight * this.scale);
                
                // Behavioral modulation
                this.modulateForBehavior(neighbors);
            }
            
            getNeighbors(robins) {
                return robins.filter(other => {
                    if (other === this) return false;
                    const dist = Math.sqrt((other.x - this.x) ** 2 + (other.y - this.y) ** 2);
                    return dist < this.perceptionRadius;
                });
            }
            
            separate(neighbors) {
                const steer = { x: 0, y: 0 };
                let count = 0;
                
                neighbors.forEach(other => {
                    const dist = Math.sqrt((other.x - this.x) ** 2 + (other.y - this.y) ** 2);
                    if (dist < this.separationRadius && dist > 0) {
                        const diff = {
                            x: (this.x - other.x) / dist,
                            y: (this.y - other.y) / dist
                        };
                        diff.x /= dist;
                        diff.y /= dist;
                        
                        steer.x += diff.x;
                        steer.y += diff.y;
                        count++;
                    }
                });
                
                if (count > 0) {
                    steer.x /= count;
                    steer.y /= count;
                    
                    const magnitude = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                    if (magnitude > 0) {
                        steer.x = (steer.x / magnitude) * this.maxSpeed;
                        steer.y = (steer.y / magnitude) * this.maxSpeed;
                        
                        steer.x -= this.vx;
                        steer.y -= this.vy;
                        
                        const forceLevel = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                        if (forceLevel > this.maxForce) {
                            steer.x = (steer.x / forceLevel) * this.maxForce;
                            steer.y = (steer.y / forceLevel) * this.maxForce;
                        }
                    }
                }
                
                return steer;
            }
            
            align(neighbors) {
                const sum = { x: 0, y: 0 };
                let count = 0;
                
                neighbors.forEach(other => {
                    const dist = Math.sqrt((other.x - this.x) ** 2 + (other.y - this.y) ** 2);
                    if (dist < this.alignmentRadius) {
                        sum.x += other.vx;
                        sum.y += other.vy;
                        count++;
                    }
                });
                
                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    
                    const magnitude = Math.sqrt(sum.x ** 2 + sum.y ** 2);
                    if (magnitude > 0) {
                        sum.x = (sum.x / magnitude) * this.maxSpeed;
                        sum.y = (sum.y / magnitude) * this.maxSpeed;
                        
                        sum.x -= this.vx;
                        sum.y -= this.vy;
                        
                        const forceLevel = Math.sqrt(sum.x ** 2 + sum.y ** 2);
                        if (forceLevel > this.maxForce) {
                            sum.x = (sum.x / forceLevel) * this.maxForce;
                            sum.y = (sum.y / forceLevel) * this.maxForce;
                        }
                    }
                }
                
                return sum;
            }
            
            cohere(neighbors) {
                const sum = { x: 0, y: 0 };
                let count = 0;
                
                neighbors.forEach(other => {
                    const dist = Math.sqrt((other.x - this.x) ** 2 + (other.y - this.y) ** 2);
                    if (dist < this.cohesionRadius) {
                        sum.x += other.x;
                        sum.y += other.y;
                        count++;
                    }
                });
                
                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    
                    return this.seek(sum.x, sum.y);
                }
                
                return { x: 0, y: 0 };
            }
            
            seek(targetX, targetY) {
                const desired = {
                    x: targetX - this.x,
                    y: targetY - this.y
                };
                
                const magnitude = Math.sqrt(desired.x ** 2 + desired.y ** 2);
                if (magnitude === 0) return { x: 0, y: 0 };
                
                desired.x = (desired.x / magnitude) * this.maxSpeed;
                desired.y = (desired.y / magnitude) * this.maxSpeed;
                
                const steer = {
                    x: desired.x - this.vx,
                    y: desired.y - this.vy
                };
                
                const forceLevel = Math.sqrt(steer.x ** 2 + steer.y ** 2);
                if (forceLevel > this.maxForce) {
                    steer.x = (steer.x / forceLevel) * this.maxForce;
                    steer.y = (steer.y / forceLevel) * this.maxForce;
                }
                
                return steer;
            }
            
            memoryAttraction() {
                if (this.history.length < 5) return { x: 0, y: 0 };
                
                let sumX = 0, sumY = 0, totalWeight = 0;
                
                for (let i = this.history.length - 1; i >= Math.max(0, this.history.length - 10); i--) {
                    const entry = this.history[i];
                    const age = this.history.length - 1 - i;
                    const weight = Math.exp(-age / 5) * (entry.coherence || 0.5);
                    
                    sumX += entry.x * weight;
                    sumY += entry.y * weight;
                    totalWeight += weight;
                }
                
                if (totalWeight > 0) {
                    const centroidX = sumX / totalWeight;
                    const centroidY = sumY / totalWeight;
                    
                    const memoryForce = this.seek(centroidX, centroidY);
                    memoryForce.x *= 0.3;
                    memoryForce.y *= 0.3;
                    
                    return memoryForce;
                }
                
                return { x: 0, y: 0 };
            }
            
            applyMemoryNavigation() {
                const memoryForce = this.memoryAttraction();
                this.applyForce(memoryForce, 2.0);
                
                if (Math.random() < 0.02) {
                    const exploreForce = {
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2
                    };
                    this.applyForce(exploreForce, 1.0);
                }
            }
            
            applyForce(force, weight = 1.0) {
                this.vx += force.x * weight;
                this.vy += force.y * weight;
            }
            
            modulateForBehavior(neighbors) {
                if (this.behavior === 'territorial' && neighbors.length > 0) {
                    const extraSeparation = this.separate(neighbors);
                    this.applyForce(extraSeparation, 0.8);
                }
                
                if (this.behavior === 'nest_seeking' || this.behavior === 'nest_building') {
                    this.cohesionWeight *= 0.6;
                    this.alignmentWeight *= 0.8;
                }
            }
            
            computeRNALocomotion() {
                const rnaComputation = this.UCFMath.computeRNALocomotion(
                    this.rnaSequences, 
                    this.coherence, 
                    this.energy, 
                    this.behavior,
                    this.scale // NEW: Pass scale as modulation factor
                );
                
                this.rnaComputationRate = rnaComputation.motorOutput * this.ecosystem.params.rnaStrength;
                this.wingFrequency = rnaComputation.frequency;
                this.wingAmplitude = rnaComputation.amplitude;
                
                // Select optimal RNA pattern
                const optimalPattern = this.selectOptimalRNAPattern();
                if (optimalPattern !== this.currentRNAPattern) {
                    this.currentRNAPattern = optimalPattern;
                }
                
                // Apply RNA-enhanced locomotion boost with scale consideration
                const locomotionBoost = 1 + (this.rnaComputationRate * 0.8 * this.scale);
                this.maxSpeed = 18 * locomotionBoost;

                // Modulate flocking weights based on RNA and scale
                this.separationWeight = 1.5 + this.rnaComputationRate * 0.5 * this.scale;
                this.alignmentWeight = 1.0 + this.rnaComputationRate * 0.3 * this.scale;
                this.cohesionWeight = 1.0 + this.rnaComputationRate * 0.2 * this.scale;
                this.memoryWeight = 0.8 + this.coherence * 0.4 * this.scale;
            }
            
            selectOptimalRNAPattern() {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                if (this.behavior === 'landed') return 6; // Landed pattern
                if (this.behavior === 'journeying') return 5; // Journey pattern
                if (this.behavior === 'flocking' && this.flockingStrength > 0.3) return 4; // Flock pattern
                if (this.behavior === 'escaping' || speed > 12) return 3; // Burst pattern
                if (this.behavior === 'hunting' || this.behavior === 'territorial') return 2; // Maneuver pattern
                if (speed < 3 || this.coherence > 0.6) return 1; // Hover pattern
                return 0; // Flight pattern
            }
            
            // Enhanced behavior system with journeying
            executeBehavior(trees, otherRobins, materials) {
                // Journey behavior has highest priority
                if (this.behavior === 'journeying') {
                    this.executeJourneyBehavior();
                    return;
                }
                
                // Behavior transition logic
                if (this.behaviorCooldown === 0) {
                    if (this.behavior === 'exploring' && Math.random() < 0.02) {
                        this.behavior = 'flocking';
                        this.behaviorCooldown = 60;
                    } else if (this.behavior === 'flocking' && Math.random() < 0.004) {
                        const behaviors = ['nest_seeking', 'hunting', 'exploring'];
                        this.behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
                        this.behaviorCooldown = 120;
                    }
                    
                    // NEW: Random chance to start journey
                    if (Math.random() < this.ecosystem.params.journeyRate * 0.001) {
                        this.startJourney();
                        return;
                    }
                }

                switch (this.behavior) {
                    case 'flocking':
                        // Primary flocking behavior
                        break;
                    case 'exploring':
                        this.exploreArea(trees);
                        break;
                    case 'nest_seeking':
                        this.seekNestSite(trees);
                        break;
                    case 'nest_building':
                        this.buildNest(trees, materials);
                        break;
                    case 'territorial':
                        this.defendTerritory(otherRobins);
                        break;
                    case 'hunting':
                        this.huntForFood(materials);
                        break;
                    case 'escaping':
                        this.escape(otherRobins);
                        if (this.behaviorCooldown === 0) {
                            this.behavior = 'flocking';
                        }
                        break;
                }
            }
            
            // NEW: Journey behavior execution
            executeJourneyBehavior() {
                if (!this.journeyTarget) return;
                
                const dx = this.journeyTarget.x - this.x;
                const dy = this.journeyTarget.y - this.y;
                const distance = Math.sqrt(dx ** 2 + dy ** 2);
                
                if (distance > 30) {
                    // Navigate towards journey target
                    const journeyForce = this.seek(this.journeyTarget.x, this.journeyTarget.y);
                    this.applyForce(journeyForce, 1.5);
                } else {
                    // Arrived at destination
                    this.interactWithLocalEcosystem();
                }
                
                // Check if journey duration is complete
                if (this.ecosystem.time - this.journeyStartTime > this.journeyDuration) {
                    this.returnFromJourney();
                }
            }
            
            // NEW: Interact with local ecosystem at destination
            interactWithLocalEcosystem() {
                // When at swallow territory, interact with swallows
                if (this.journeyTarget.type === 'swallow' && Math.abs(this.scale - this.journeyTarget.scale) < 0.1) {
                    const nearbySwallows = this.ecosystem.swallows.filter(swallow => {
                        const dist = Math.sqrt((swallow.x - this.x) ** 2 + (swallow.y - this.y) ** 2);
                        const scaleCompatibility = this.UCFMath.scaleCompatibility(swallow.scale, this.scale);
                        return dist < 20 && scaleCompatibility > 0.7;
                    });
                    
                    if (nearbySwallows.length > 0) {
                        // Coherence exchange with swallows
                        nearbySwallows.forEach(swallow => {
                            const coherenceExchange = 0.02;
                            this.coherence = Math.min(1, this.coherence + coherenceExchange);
                            swallow.coherence = Math.min(1, swallow.coherence + coherenceExchange);
                        });
                        
                        // Learn from swallow behaviors - enhance agility
                        this.maxSpeed = Math.min(this.maxSpeed * 1.02, this.maxSpeed * 1.1);
                        this.energy = Math.min(1.0, this.energy + 0.05);
                        
                        // Enhance RNA computation through interaction
                        this.rnaComputationRate = Math.min(1.0, this.rnaComputationRate + 0.1);
                    }
                }
            }
            
            // NEW: Return from journey
            returnFromJourney() {
                this.isJourneying = false;
                this.journeyTarget = null;
                this.behavior = 'flocking';
                this.targetScale = this.maxScale; // Return to normal size
                this.behaviorCooldown = 60;
                this.currentRNAPattern = 0; // Return to normal flight pattern
            }
            
            exploreArea(trees) {
                const nearestTree = trees.reduce((closest, tree) => {
                    const dist = Math.sqrt((tree.x - this.x) ** 2 + (tree.y - this.y) ** 2);
                    return dist < closest.dist ? { tree, dist } : closest;
                }, { dist: Infinity });
                
                if (nearestTree.tree && nearestTree.dist > 120) {
                    const dx = nearestTree.tree.x - this.x;
                    const dy = nearestTree.tree.y - 80 - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        const force = 0.15 * this.rnaComputationRate;
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }
                
                if (Math.random() < 0.03) {
                    const rnaModulation = 1 + this.rnaComputationRate * 0.5;
                    this.vx += (Math.random() - 0.5) * 2 * rnaModulation;
                    this.vy += (Math.random() - 0.5) * 1.5 * rnaModulation;
                }
            }
            
            seekNestSite(trees) {
                const availableSites = [];
                
                trees.forEach(tree => {
                    tree.nestSites.forEach(site => {
                        if (!site.occupied) {
                            const dist = Math.sqrt((site.x - this.x) ** 2 + (site.y - this.y) ** 2);
                            if (dist < 300) {
                                availableSites.push({ site, tree, dist });
                            }
                        }
                    });
                });
                
                if (availableSites.length > 0) {
                    availableSites.sort((a, b) => {
                        const scoreA = a.site.stability * (1 + this.coherence) - a.dist / 100;
                        const scoreB = b.site.stability * (1 + this.coherence) - b.dist / 100;
                        return scoreB - scoreA;
                    });
                    
                    const selected = availableSites[0];
                    
                    const nestForce = this.seek(selected.site.x, selected.site.y);
                    this.applyForce(nestForce, 1.5);
                    
                    if (selected.dist < 25) {
                        selected.site.occupied = true;
                        selected.site.nestId = this.id;
                        this.nestTarget = selected.site;
                        this.behavior = 'nest_building';
                        this.behaviorCooldown = 60;
                    }
                }
            }
            
            buildNest(trees, materials) {
                if (!this.nestTarget) {
                    this.behavior = 'nest_seeking';
                    return;
                }
                
                if (this.carriedMaterials.length < 6) {
                    const nearbyMaterial = materials.find(material => {
                        const dist = Math.sqrt((material.x - this.x) ** 2 + (material.y - this.y) ** 2);
                        return dist < 25 && !material.collected;
                    });
                    
                    if (nearbyMaterial) {
                        nearbyMaterial.collected = true;
                        this.carriedMaterials.push(nearbyMaterial);
                    }
                }
                
                const dx = this.nestTarget.x - this.x;
                const dy = this.nestTarget.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 25) {
                    const navigationForce = this.seek(this.nestTarget.x, this.nestTarget.y);
                    this.applyForce(navigationForce, 2.0);
                } else if (this.carriedMaterials.length >= 4) {
                    this.completeNest();
                }
            }
            
            completeNest() {
                const nestData = {
                    id: this.nestTarget.nestId,
                    x: this.nestTarget.x,
                    y: this.nestTarget.y,
                    robin: this.id,
                    materials: [...this.carriedMaterials],
                    completed: true,
                    stability: this.nestTarget.stability
                };
                
                this.ecosystem.nests.set(this.nestTarget.nestId, nestData);
                this.currentNest = this.nestTarget.nestId;
                this.carriedMaterials = [];
                this.behavior = 'territorial';
                this.behaviorCooldown = 180;
            }
            
            defendTerritory(otherRobins) {
                if (!this.currentNest) return;
                
                const nest = this.ecosystem.nests.get(this.currentNest);
                if (!nest) return;
                
                const patrolRadius = this.territorialRadius * (1 + this.rnaComputationRate * 0.3);
                const targetX = nest.x + Math.sin((Date.now() / 1000) * 0.5) * patrolRadius * 0.7;
                const targetY = nest.y + Math.cos((Date.now() / 1000) * 0.4) * patrolRadius * 0.5;
                
                const patrolForce = this.seek(targetX, targetY);
                this.applyForce(patrolForce, 0.8);
                
                otherRobins.forEach(other => {
                    if (other !== this && !other.mate && !other.landed) {
                        const intruderDist = Math.sqrt((other.x - nest.x) ** 2 + (other.y - nest.y) ** 2);
                        if (intruderDist < this.territorialRadius) {
                            const chaseForce = this.seek(other.x, other.y);
                            this.applyForce(chaseForce, 1.5);
                            
                            if (other.behavior !== 'escaping') {
                                other.behavior = 'escaping';
                                other.behaviorCooldown = 90;
                                
                                // Force landed robin to take off when chased
                                if (other.landed) {
                                    other.takeOff(this.ecosystem.trees);
                                }
                            }
                        }
                    }
                });
            }
            
            escape(otherRobins) {
                const threats = otherRobins.filter(other => 
                    other.behavior === 'territorial' && 
                    Math.sqrt((other.x - this.x) ** 2 + (other.y - this.y) ** 2) < 100
                );
                
                if (threats.length > 0) {
                    const nearestThreat = threats.reduce((closest, threat) => {
                        const dist = Math.sqrt((threat.x - this.x) ** 2 + (threat.y - this.y) ** 2);
                        return dist < closest.dist ? { threat, dist } : closest;
                    }, { dist: Infinity });
                    
                    if (nearestThreat.threat) {
                        const escapeX = this.x - nearestThreat.threat.x;
                        const escapeY = this.y - nearestThreat.threat.y;
                        const dist = Math.sqrt(escapeX ** 2 + escapeY ** 2);
                        
                        if (dist > 0) {
                            const escapeForce = {
                                x: (escapeX / dist) * this.maxForce,
                                y: (escapeY / dist) * this.maxForce
                            };
                            this.applyForce(escapeForce, 2.0);
                        }
                    }
                }
            }
            
            huntForFood(materials) {
                const nearbyFood = materials.filter(material => {
                    if (material.collected || material.type !== 'grass') return false;
                    const dist = Math.sqrt((material.x - this.x) ** 2 + (material.y - this.y) ** 2);
                    return dist < 40;
                });
                
                if (nearbyFood.length > 0) {
                    const target = nearbyFood.reduce((closest, food) => {
                        const dist = Math.sqrt((food.x - this.x) ** 2 + (food.y - this.y) ** 2);
                        return dist < closest.dist ? { food, dist } : closest;
                    }, { dist: Infinity });
                    
                    if (target.food) {
                        const huntingForce = this.seek(target.food.x, target.food.y);
                        this.applyForce(huntingForce, 1.8);
                        
                        if (target.dist < 15) {
                            target.food.collected = true;
                            this.energy = Math.min(1.0, this.energy + 0.15);
                            this.behavior = 'flocking';
                            this.behaviorCooldown = 60;
                        }
                    }
                } else {
                    this.behavior = 'flocking';
                    this.behaviorCooldown = 30;
                }
            }
            
            applyMovement() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Speed regulation with RNA and scale enhancement
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const effectiveMaxSpeed = this.maxSpeed * (1 + this.rnaComputationRate * 0.3) * this.scale;
                
                if (currentSpeed > effectiveMaxSpeed) {
                    this.vx = (this.vx / currentSpeed) * effectiveMaxSpeed;
                    this.vy = (this.vy / currentSpeed) * effectiveMaxSpeed;
                }
                
                // Minimum speed maintenance
                if (currentSpeed < 3 && this.behavior !== 'territorial') {
                    const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                    this.vx += Math.cos(angle) * 0.5;
                    this.vy += Math.sin(angle) * 0.5;
                }

                // Update heading smoothly
                const targetHeading = Math.atan2(this.vy, this.vx);
                let headingDiff = targetHeading - this.heading;
                
                while (headingDiff > Math.PI) headingDiff -= 2 * Math.PI;
                while (headingDiff < -Math.PI) headingDiff += 2 * Math.PI;
                
                this.heading += headingDiff * 0.1;
                
                // Boundary handling
                const margin = 50;
                if (this.x < margin) this.vx += 0.8;
                if (this.x > this.ecosystem.width - margin) this.vx -= 0.8;
                if (this.y < margin) this.vy += 0.8;
                if (this.y > this.ecosystem.height - margin) this.vy -= 0.8;
                
                // Energy management
                const energyConsumption = currentSpeed / 1000;
                this.energy = Math.max(0.2, this.energy - energyConsumption);
                this.energy = Math.min(1.0, this.energy + 0.001);
            }
            
            updateWingAnimation() {
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const speedFactor = Math.min(1, currentSpeed / 8);
                
                // Scale affects wing frequency
                this.wingPhase += this.wingFrequency * 0.15 * (0.5 + speedFactor) * this.scale;
                this.wingAmplitude = 0.3 + (this.energy * 0.4) + (this.rnaComputationRate * 0.3);
            }
            
            triggerRupture() {
                this.ruptureEvents++;
                
                const regeneration = this.UCFMath.regenerationOperator(
                    this, 
                    this.coherence,
                    this.coherence,
                    1,
                    this.scale // NEW: Include scale in regeneration
                );
                
                const lossAmount = Math.floor(this.history.length * 0.6);
                this.history = this.history.slice(lossAmount);
                
                const newBehaviors = ['flocking', 'exploring', 'hunting', 'escaping'];
                const currentIndex = newBehaviors.indexOf(this.behavior);
                const availableBehaviors = newBehaviors.filter((_, i) => i !== currentIndex);
                this.behavior = availableBehaviors[Math.floor(Math.random() * availableBehaviors.length)];
                
                this.vx *= (0.3 + regeneration * 0.7);
                this.vy *= (0.3 + regeneration * 0.7);
                
                this.currentRNAPattern = (this.currentRNAPattern + 1) % this.rnaSequences.length;
                this.behaviorCooldown = 60;

                // NEW: Force takeoff if landed during rupture
                if (this.landed) {
                    this.takeOff(this.ecosystem.trees);
                }
            }
            
            handleVocalizations(time) {
                const vocalizationRate = {
                    'territorial': 0.025,
                    'nest_building': 0.015,
                    'escaping': 0.035,
                    'hunting': 0.012,
                    'exploring': 0.008,
                    'flocking': 0.010,
                    'nest_seeking': 0.012,
                    'journeying': 0.020, // NEW: Enhanced vocalization during journey
                    'landed': 0.005 // NEW: Reduced vocalization when landed
                }[this.behavior] || 0.008;
                
                const rnaModulatedRate = vocalizationRate * (1 + this.rnaComputationRate * 0.4);
                
                if (Math.random() < rnaModulatedRate && this.vocalizationCooldown === 0) {
                    this.vocalize();
                    this.vocalizationCooldown = 30 + Math.floor(Math.random() * 60);
                }
            }
            
            vocalize() {
                if (!this.ecosystem.audioEnabled || !this.ecosystem.audioContext) return;
                
                try {
                    const sequence = this.rnaSequences[this.currentRNAPattern];
                    const coherenceModulation = 0.8 + this.coherence * 0.4;
                    const scaleModulation = 0.7 + this.scale * 0.6; // NEW: Scale affects vocalization
                    let timeOffset = 0;
                    
                    sequence.pattern.forEach((freq, i) => {
                        const startTime = this.ecosystem.audioContext.currentTime + timeOffset;
                        const duration = sequence.durations[i] * coherenceModulation * scaleModulation;
                        const amplitude = sequence.amplitudes[i] * 0.06 * (1 + this.rnaComputationRate * 0.3) * this.scale;
                        
                        const osc = this.ecosystem.audioContext.createOscillator();
                        const gain = this.ecosystem.audioContext.createGain();
                        
                        // Scale affects frequency
                        osc.frequency.setValueAtTime(freq * coherenceModulation * (0.5 + this.scale * 0.5), startTime);
                        
                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(amplitude, startTime + duration * 0.1);
                        gain.gain.setValueAtTime(amplitude * 0.9, startTime + duration * 0.9);
                        gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                        
                        osc.connect(gain);
                        gain.connect(this.ecosystem.audioContext.destination);
                        
                        osc.start(startTime);
                        osc.stop(startTime + duration);
                        
                        timeOffset += duration + 0.015;
                    });
                } catch (e) {
                    console.warn('Vocalization synthesis failed:', e);
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // NEW: Different drawing behavior when landed
                if (this.landed) {
                    ctx.rotate(this.heading);
                    ctx.scale(this.scale, this.scale);
                    
                    // Draw landed robin (no wing animation)
                    ctx.fillStyle = `rgba(139, 69, 19, ${0.9 + this.coherence * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Red breast with energy modulation
                    const breastIntensity = 0.8 + this.energy * 0.2;
                    ctx.fillStyle = `rgba(220, 20, 60, ${breastIntensity})`;
                    ctx.beginPath();
                    ctx.arc(1, 0, 6 * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Small tail
                    ctx.fillStyle = `rgba(101, 67, 33, 0.8)`;
                    ctx.beginPath();
                    ctx.ellipse(-4, 0, 3, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Head
                    ctx.fillStyle = `rgba(139, 69, 19, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(3, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(4.5, -1, 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Beak
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
                    ctx.beginPath();
                    ctx.moveTo(6, 0);
                    ctx.lineTo(8, -0.5);
                    ctx.lineTo(8, 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Landing indicator (hidden in nature mode)
                    if (!this.ecosystem.natureMode) {
                        ctx.strokeStyle = `rgba(0, 255, 0, 0.6)`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(0, 0, 10, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else {
                    // Normal flying robin drawing
                    ctx.rotate(this.heading);
                    ctx.scale(this.scale, this.scale);
                    
                    // Draw flocking trail if in flocking behavior and not in nature mode
                    if (this.behavior === 'flocking' && this.history.length > 1 && !this.ecosystem.natureMode) {
                        ctx.save();
                        ctx.resetTransform();
                        ctx.strokeStyle = `rgba(100, 200, 100, 0.3)`;
                        ctx.lineWidth = 1 * this.scale;
                        ctx.beginPath();
                        
                        const trailLength = Math.min(6, this.history.length);
                        for (let i = this.history.length - trailLength; i < this.history.length; i++) {
                            const entry = this.history[i];
                            if (i === this.history.length - trailLength) {
                                ctx.moveTo(entry.x, entry.y);
                            } else {
                                ctx.lineTo(entry.x, entry.y);
                            }
                        }
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    
                    // Wing animation
                    if (currentSpeed > 0.5) {
                        const wingBeat = Math.sin(this.wingPhase) * this.wingAmplitude;
                        const wingColor = `rgba(101, 67, 33, ${0.7 + this.energy * 0.3})`;
                        
                        ctx.fillStyle = wingColor;
                        
                        // Left wing
                        ctx.save();
                        ctx.rotate(wingBeat);
                        ctx.beginPath();
                        ctx.ellipse(-3, -1, this.wingSpan * 0.6, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        
                        // Right wing
                        ctx.save();
                        ctx.rotate(-wingBeat);
                        ctx.beginPath();
                        ctx.ellipse(-3, 1, this.wingSpan * 0.6, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // Body with coherence-influenced coloring
                    const bodyAlpha = 0.9 + this.coherence * 0.1;
                    ctx.fillStyle = `rgba(139, 69, 19, ${bodyAlpha})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2); // Use fixed size 6, scale applied via transform
                    ctx.fill();
                    
                    // Red breast with energy modulation
                    const breastIntensity = 0.8 + this.energy * 0.2;
                    ctx.fillStyle = `rgba(220, 20, 60, ${breastIntensity})`;
                    ctx.beginPath();
                    ctx.arc(2, 0, 6 * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // RNA computation rate visualization (hidden in nature mode)
                    if (this.rnaComputationRate > 0.5 && !this.ecosystem.natureMode) {
                        ctx.strokeStyle = `rgba(0, 255, 255, ${this.rnaComputationRate * 0.8})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6 * 1.8, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Behavior indicator with scale-based intensity (hidden in nature mode)
                    if (!this.ecosystem.natureMode) {
                        const behaviorColors = {
                            'flocking': 'rgba(100, 255, 100, 0.6)',
                            'territorial': 'rgba(255, 0, 0, 0.7)',
                            'nest_building': 'rgba(255, 165, 0, 0.7)',
                            'nest_seeking': 'rgba(255, 200, 0, 0.6)',
                            'escaping': 'rgba(255, 255, 0, 0.8)',
                            'hunting': 'rgba(0, 255, 0, 0.6)',
                            'journeying': 'rgba(255, 20, 147, 0.8)' // NEW: Journey indicator
                        };
                        
                        if (behaviorColors[this.behavior]) {
                            ctx.strokeStyle = behaviorColors[this.behavior];
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, 6 * 1.4, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    
                    // Show carried materials
                    if (this.carriedMaterials.length > 0) {
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        
                        this.carriedMaterials.slice(0, 3).forEach((material, i) => {
                            const angle = (i / 3) * Math.PI * 0.4 - Math.PI * 0.2;
                            const length = 6;
                            
                            ctx.beginPath();
                            ctx.moveTo(6 * 0.8, 0);
                            ctx.lineTo(
                                6 * 0.8 + Math.cos(angle) * length,
                                Math.sin(angle) * length
                            );
                            ctx.stroke();
                        });
                    }
                }
                
                ctx.restore();
                
                // Scale transition indicator (hidden in nature mode)
                if (Math.abs(this.targetScale - this.scale) > 0.05 && !this.ecosystem.natureMode) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 20, 147, ${0.6 + Math.sin(this.ecosystem.time * 0.1) * 0.4})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 12]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 30 * this.scale, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
            }
        }

        // Main Enhanced Multi-Scale UCF Ecosystem
        class EnhancedUCFEcosystem {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.UCFMath = new UCFMathematics();
                
                // Initialize all arrays first
                this.trees = [];
                this.robins = [];
                this.starlings = [];
                this.swallows = []; // NEW: Swallow array
                this.eagles = []; // NEW: Eagle array
                this.nestingMaterials = [];
                this.nests = new Map();
                this.terrain = [];
                
                // System state
                this.time = 0;
                this.globalCoherence = 0.5;
                this.totalMemoryDensity = 0;
                this.totalRuptureEvents = 0;
                this.photosynthesisRate = 0.3;
                this.systemTemperature = 1.0;
                this.avgFlockingStrength = 0;
                this.zoomScale = 0.8;
                
                // NEW: Journey tracking
                this.activeJourneys = 0;
                
                // Starling spawn rotation
                this.starlingSpawnQuadrant = 0;
                
                // NEW: Define distant swallow territory
                this.distantSwallowTerritory = {
                    x: this.width * 0.05,
                    y: this.height * 0.05,
                    width: this.width * 0.25,
                    height: this.height * 0.25
                };
                
                // Enhanced parameters
                this.params = {
                    flockSize: 6,
                    separation: 1.5,
                    cohesion: 1.0,
                    rnaStrength: 0.8,
                    journeyRate: 0.3 // NEW: Journey probability parameter
                };
                
                // Performance tracking
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsTime = Date.now();
                
                // Environment
                this.sunX = 0;
                this.sunY = 80;
                this.groundHeight = 0;
                
                // Debug mode
                this.showDebugInfo = false;
                
                // NEW: Nature mode for clean visualization
                this.natureMode = false;
                
                // Audio system
                this.audioEnabled = false;
                this.audioContext = null;
                this.initAudio();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.initialize();
                this.setupControls();
                this.animate();
            }
            
            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.groundHeight = this.height * 0.82;
                this.sunX = this.width - 100;
                
                // Update distant territory definition
                this.distantSwallowTerritory = {
                    x: this.width * 0.05,
                    y: this.height * 0.05,
                    width: this.width * 0.25,
                    height: this.height * 0.25
                };
                
                if (!this.terrain || this.terrain.length === 0) {
                    this.generateTerrain();
                }
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Audio context not supported');
                }
            }
            
            initialize() {
                this.generateTerrain();
                this.generateTrees();
                this.generateNestingMaterials();
                this.spawnRobinFlock();
                this.spawnStarlingSwarm();
            }
            
            generateTerrain() {
                this.terrain = [];
                const segments = 100;
                
                for (let i = 0; i <= segments; i++) {
                    const x = (i / segments) * this.width;
                    const noise1 = Math.sin(i * 0.1) * 25;
                    const noise2 = Math.sin(i * 0.05) * 40;
                    const y = this.groundHeight + noise1 + noise2;
                    this.terrain.push({ x, y });
                }
            }
            
            generateTrees() {
                this.trees = [];
                const treeCount = 12;
                
                for (let i = 0; i < treeCount; i++) {
                    const x = (i + 1) * (this.width / (treeCount + 1));
                    const y = this.getGroundHeight(x);
                    const scale = 0.8 + Math.random() * 0.6;
                    this.trees.push(new UCFTree(x, y, scale));
                }
            }
            
            generateNestingMaterials() {
                this.nestingMaterials = [];
                
                for (let i = 0; i < 40; i++) {
                    const x = Math.random() * this.width;
                    const y = this.getGroundHeight(x) - 10;
                    
                    this.nestingMaterials.push({
                        x: x,
                        y: y,
                        length: 5 + Math.random() * 12,
                        thickness: 0.5 + Math.random() * 1.5,
                        angle: Math.random() * Math.PI * 2,
                        type: Math.random() < 0.6 ? 'twig' : 'grass',
                        collected: false,
                        age: 0
                    });
                }
            }
            
            getGroundHeight(x) {
                if (!this.terrain || this.terrain.length === 0) return this.groundHeight;
                
                const index = Math.floor((x / this.width) * this.terrain.length);
                const clampedIndex = Math.max(0, Math.min(this.terrain.length - 1, index));
                return this.terrain[clampedIndex].y;
            }
            
            spawnRobinFlock() {
                const centerX = this.width * (0.3 + Math.random() * 0.4);
                const centerY = this.height * (0.2 + Math.random() * 0.3);
                const flockRadius = 60;
                
                for (let i = 0; i < this.params.flockSize; i++) {
                    const angle = (i / this.params.flockSize) * Math.PI * 2;
                    const radius = flockRadius * Math.random();
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    const robin = new UCFRobin(x, y, this.UCFMath, this);
                    this.robins.push(robin);
                }
            }
            
            spawnStarlingSwarm() {
                const count = 200; // Smaller swarm for performance
                
                let centerX, centerY;
                const margin = 130;
                
                switch (this.starlingSpawnQuadrant) {
                    case 0: // Top-left
                        centerX = margin + Math.random() * (this.width * 0.25);
                        centerY = margin + Math.random() * (this.height * 0.25);
                        break;
                    case 1: // Top-right
                        centerX = this.width * 0.75 + Math.random() * (this.width * 0.25 - margin);
                        centerY = margin + Math.random() * (this.height * 0.25);
                        break;
                    case 2: // Bottom-left
                        centerX = margin + Math.random() * (this.width * 0.25);
                        centerY = this.height * 0.55 + Math.random() * (this.height * 0.45 - margin);
                        break;
                    case 3: // Bottom-right
                        centerX = this.width * 0.75 + Math.random() * (this.width * 0.25 - margin);
                        centerY = this.height * 0.55 + Math.random() * (this.height * 0.45 - margin);
                        break;
                }
                
                this.starlingSpawnQuadrant = (this.starlingSpawnQuadrant + 1) % 4;
                
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 45;
                    
                    const starling = new UCFStarling(
                        centerX + Math.cos(angle) * distance,
                        centerY + Math.sin(angle) * distance,
                        this.UCFMath,
                        this
                    );
                    this.starlings.push(starling);
                }
            }
            
            // NEW: Spawn swallow territory
            spawnSwallowTerritory() {
                const count = 30;
                const territory = this.distantSwallowTerritory;
                
                for (let i = 0; i < count; i++) {
                    const x = territory.x + Math.random() * territory.width;
                    const y = territory.y + Math.random() * territory.height;
                    
                    const swallow = new UCFSwallow(x, y, this.UCFMath, this);
                    this.swallows.push(swallow);
                }
            }
            
            // NEW: Spawn eagle predator
            spawnEaglePredator() {
                const x = this.width * (0.2 + Math.random() * 0.6);
                const y = this.height * (0.1 + Math.random() * 0.3); // High altitude spawn
                
                const eagle = new UCFEagle(x, y, this.UCFMath, this);
                this.eagles.push(eagle);
            }
            
            // NEW: Trigger journeys for random robins
            triggerJourneys() {
                const eligibleRobins = this.robins.filter(robin => 
                    !robin.isJourneying && robin.behavior !== 'nest_building' && 
                    robin.behavior !== 'territorial' && !robin.landed
                );
                
                const journeyCount = Math.min(3, Math.floor(eligibleRobins.length * 0.3));
                
                for (let i = 0; i < journeyCount; i++) {
                    if (eligibleRobins.length > 0) {
                        const randomIndex = Math.floor(Math.random() * eligibleRobins.length);
                        const robin = eligibleRobins.splice(randomIndex, 1)[0];
                        robin.startJourney();
                    }
                }
            }
            
            setupControls() {
                const controls = [
                    { id: 'flockSize', param: 'flockSize', callback: () => this.adjustFlockSize() },
                    { id: 'separation', param: 'separation' },
                    { id: 'cohesion', param: 'cohesion' },
                    { id: 'rnaStrength', param: 'rnaStrength' },
                    { id: 'journeyRate', param: 'journeyRate' }
                ];
                
                controls.forEach(({ id, param, callback }) => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(id + 'Value');
                    
                    if (slider && valueDisplay) {
                        slider.addEventListener('input', () => {
                            this.params[param] = parseFloat(slider.value);
                            valueDisplay.textContent = slider.value;
                            
                            if (callback) callback();
                        });
                    }
                });
            }
            
            adjustFlockSize() {
                const targetSize = this.params.flockSize;
                const currentSize = this.robins.length;
                
                if (targetSize > currentSize) {
                    for (let i = 0; i < targetSize - currentSize; i++) {
                        const x = this.width * (0.3 + Math.random() * 0.4);
                        const y = this.height * (0.3 + Math.random() * 0.4);
                        const robin = new UCFRobin(x, y, this.UCFMath, this);
                        this.robins.push(robin);
                    }
                } else if (targetSize < currentSize) {
                    this.robins = this.robins.slice(0, targetSize);
                }
            }
            
            enhanceCoherence() {
                this.robins.forEach(robin => {
                    robin.coherence = Math.min(1, robin.coherence + 0.25);
                    robin.energy = Math.min(1, robin.energy + 0.2);
                });
                
                this.starlings.forEach(starling => {
                    starling.coherenceTrace = Math.min(1, starling.coherenceTrace + 0.25);
                    starling.energy = Math.min(1, starling.energy + 0.2);
                });
                
                this.swallows.forEach(swallow => {
                    swallow.coherence = Math.min(1, swallow.coherence + 0.25);
                    swallow.energy = Math.min(1, swallow.energy + 0.2);
                });
                
                this.eagles.forEach(eagle => {
                    eagle.coherence = Math.min(1, eagle.coherence + 0.15);
                    eagle.energy = Math.min(1, eagle.energy + 0.3);
                });
                
                this.trees.forEach(tree => {
                    tree.coherence = Math.min(1, tree.coherence + 0.15);
                });
                
                this.UCFMath.Omega = Math.min(2, this.UCFMath.Omega + 0.2);
            }
            
            triggerRupture() {
                this.robins.forEach(robin => {
                    if (Math.random() < 0.7) {
                        robin.triggerRupture();
                    }
                });
                
                this.starlings.forEach(starling => {
                    if (Math.random() < 0.5) {
                        starling.triggerRupture();
                    }
                });
                
                this.totalRuptureEvents += this.robins.length + this.starlings.length;
            }
            
            toggleAudio() {
                this.audioEnabled = !this.audioEnabled;
                const btn = document.getElementById('audioBtn');
                
                if (this.audioEnabled) {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    btn.textContent = 'Disable RNA Audio';
                    btn.style.background = 'rgba(255, 0, 255, 0.2)';
                } else {
                    btn.textContent = 'Enable RNA Audio';
                    btn.style.background = 'transparent';
                }
            }
            
            // NEW: Toggle nature mode for clean visualization
            toggleNatureMode() {
                this.natureMode = !this.natureMode;
                const checkbox = document.getElementById('natureModeToggle');
                if (checkbox) {
                    checkbox.checked = this.natureMode;
                }
            }
            
            reset() {
                this.robins = [];
                this.starlings = [];
                this.swallows = []; // NEW
                this.eagles = []; // NEW
                this.nests.clear();
                this.trees = [];
                this.nestingMaterials = [];
                this.time = 0;
                this.globalCoherence = 0.5;
                this.totalMemoryDensity = 0;
                this.totalRuptureEvents = 0;
                this.activeJourneys = 0;
                this.starlingSpawnQuadrant = 0;
                this.UCFMath = new UCFMathematics();
                
                this.initialize();
            }
            
            update() {
                this.time++;
                
                // Safety checks
                if (!this.robins) this.robins = [];
                if (!this.starlings) this.starlings = [];
                if (!this.swallows) this.swallows = [];
                if (!this.eagles) this.eagles = [];
                if (!this.trees) this.trees = [];
                if (!this.nestingMaterials) this.nestingMaterials = [];
                if (!this.nests) this.nests = new Map();
                
                // Update robins with multi-scale interactions
                this.robins.forEach(robin => {
                    if (robin && typeof robin.update === 'function') {
                        robin.update(this.trees, this.robins, this.nestingMaterials, this.time);
                    }
                });
                
                // Update starlings
                this.starlings.forEach(starling => {
                    if (starling && typeof starling.update === 'function') {
                        starling.update(this.starlings, this.time);
                    }
                });
                
                // NEW: Update swallows with visiting robin interactions
                this.swallows.forEach(swallow => {
                    if (swallow && typeof swallow.update === 'function') {
                        const visitingRobins = this.robins.filter(robin => 
                            robin.isJourneying && robin.behavior === 'journeying'
                        );
                        swallow.update(this.swallows, visitingRobins, this.time);
                    }
                });
                
                // NEW: Update eagles with multi-scale hunting
                this.eagles.forEach(eagle => {
                    if (eagle && typeof eagle.update === 'function') {
                        eagle.update(this.robins, this.starlings, this.swallows, this.time);
                    }
                });
                
                // Update trees
                this.trees.forEach(tree => {
                    if (tree && typeof tree.updatePhotosynthesis === 'function') {
                        tree.updatePhotosynthesis(this.sunX, this.sunY, this.globalCoherence);
                    }
                });
                
                // Calculate global UCF metrics across all scales
                let totalCoherence = 0;
                let totalMemory = 0;
                let totalFlocking = 0;
                let totalEntities = 0;
                
                if (this.robins.length > 0) {
                    const robinCoherence = this.robins.reduce((sum, robin) => sum + (robin.coherence || 0), 0);
                    const robinMemory = this.robins.reduce((sum, robin) => sum + (robin.memoryDensity || 0), 0);
                    const robinFlocking = this.robins.reduce((sum, robin) => sum + (robin.flockingStrength || 0), 0);
                    
                    totalCoherence += robinCoherence;
                    totalMemory += robinMemory;
                    totalFlocking += robinFlocking;
                    totalEntities += this.robins.length;
                }
                
                if (this.starlings.length > 0) {
                    const starlingCoherence = this.starlings.reduce((sum, starling) => sum + (starling.coherenceTrace || 0), 0);
                    totalCoherence += starlingCoherence;
                    totalMemory += this.starlings.length * 0.5;
                    totalEntities += this.starlings.length;
                }
                
                // NEW: Include swallows in global metrics
                if (this.swallows.length > 0) {
                    const swallowCoherence = this.swallows.reduce((sum, swallow) => sum + (swallow.coherence || 0), 0);
                    totalCoherence += swallowCoherence;
                    totalMemory += this.swallows.length * 0.4;
                    totalEntities += this.swallows.length;
                }
                
                // NEW: Include eagles in global metrics
                if (this.eagles.length > 0) {
                    const eagleCoherence = this.eagles.reduce((sum, eagle) => sum + (eagle.coherence || 0), 0);
                    totalCoherence += eagleCoherence;
                    totalMemory += this.eagles.length * 0.8;
                    totalEntities += this.eagles.length;
                }
                
                if (totalEntities > 0) {
                    this.globalCoherence = totalCoherence / totalEntities;
                    this.totalMemoryDensity = totalMemory / totalEntities;
                    this.avgFlockingStrength = totalFlocking / Math.max(1, this.robins.length);
                    
                    this.totalRuptureEvents = this.robins.reduce((sum, robin) => sum + (robin.ruptureEvents || 0), 0);
                }
                
                // NEW: Count active journeys
                this.activeJourneys = this.robins.filter(robin => robin.isJourneying).length;
                
                // Calculate photosynthesis rate
                if (this.trees.length > 0) {
                    this.photosynthesisRate = this.trees.reduce((sum, tree) => sum + (tree.photosynthesis || 0), 0) / this.trees.length;
                }
                
                this.systemTemperature = this.UCFMath.Omega;
                
                // Regenerate materials periodically
                if (this.time % 180 === 0) {
                    this.regenerateMaterials();
                }
                
                // Update UI
                if (this.time % 30 === 0) {
                    this.updateUI();
                }
                
                this.trackPerformance();
            }
            
            regenerateMaterials() {
                const availableMaterials = this.nestingMaterials.filter(m => !m.collected).length;
                
                if (availableMaterials < 25) {
                    for (let i = 0; i < 5; i++) {
                        const x = Math.random() * this.width;
                        const y = this.getGroundHeight(x) - 10;
                        
                        this.nestingMaterials.push({
                            x: x,
                            y: y,
                            length: 5 + Math.random() * 12,
                            thickness: 0.5 + Math.random() * 1.5,
                            angle: Math.random() * Math.PI * 2,
                            type: Math.random() < 0.6 ? 'twig' : 'grass',
                            collected: false,
                            age: 0
                        });
                    }
                }
            }
            
            trackPerformance() {
                this.frameCount++;
                const now = Date.now();
                
                if (now - this.lastFpsTime > 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsTime));
                    this.frameCount = 0;
                    this.lastFpsTime = now;
                }
            }
            
            updateUI() {
                const avgRNARate = this.robins.length > 0 ? 
                    this.robins.reduce((sum, robin) => sum + (robin.rnaComputationRate || 0), 0) / this.robins.length : 0;
                
                const avgSpeed = this.robins.length > 0 ? 
                    this.robins.reduce((sum, robin) => sum + Math.sqrt((robin.vx || 0) ** 2 + (robin.vy || 0) ** 2), 0) / this.robins.length : 0;
                
                document.getElementById('coherence').textContent = this.globalCoherence.toFixed(3);
                document.getElementById('memory').textContent = this.totalMemoryDensity.toFixed(3);
                document.getElementById('flocking').textContent = this.avgFlockingStrength.toFixed(3);
                document.getElementById('ruptures').textContent = this.totalRuptureEvents.toString();
                document.getElementById('robins').textContent = this.robins.length.toString();
                document.getElementById('starlings').textContent = this.starlings.length.toString();
                document.getElementById('swallows').textContent = this.swallows.length.toString(); // NEW
                document.getElementById('eagles').textContent = this.eagles.length.toString(); // NEW
                document.getElementById('journeys').textContent = this.activeJourneys.toString(); // NEW
                document.getElementById('nests').textContent = this.nests.size.toString();
                document.getElementById('rna-rate').textContent = avgRNARate.toFixed(3);
                document.getElementById('photosynthesis').textContent = this.photosynthesisRate.toFixed(3);
                document.getElementById('temperature').textContent = this.systemTemperature.toFixed(3);
                document.getElementById('avg-speed').textContent = avgSpeed.toFixed(1);
                document.getElementById('fps').textContent = `${this.fps} FPS`;
            }
            
            draw() {
                // Clear with atmospheric gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.4, '#B0E0E6');
                gradient.addColorStop(0.7, '#E0F6FF');
                gradient.addColorStop(1, '#F0F8FF');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw enhanced sun
                this.drawSun();
                
                // Draw terrain
                this.drawTerrain();
                
                // Draw distant swallow territory indicator (hidden in nature mode)
                if (!this.natureMode) {
                    this.drawSwallowTerritory();
                }
                
                // Draw trees
                this.trees.forEach(tree => {
                    tree.draw(this.ctx);
                });
                
                // NEW: Draw landing sites (for debugging)
                if (this.showDebugInfo && !this.natureMode) {
                    this.trees.forEach(tree => {
                        tree.drawLandingSites(this.ctx, true);
                    });
                }
                
                // Draw nests
                this.trees.forEach(tree => {
                    tree.drawNests(this.ctx, this.nests);
                });
                
                // Draw nesting materials
                this.drawNestingMaterials();
                
                // Draw all birds in order: swallows (background), starlings, robins, eagles (foreground)
                this.swallows.forEach(swallow => {
                    swallow.draw(this.ctx);
                });
                
                this.starlings.forEach(starling => {
                    starling.draw(this.ctx);
                });
                
                this.robins.forEach(robin => {
                    robin.draw(this.ctx);
                });
                
                // NEW: Draw eagles last (top predator layer)
                this.eagles.forEach(eagle => {
                    eagle.draw(this.ctx);
                });
                
                // Draw UCF field visualization (hidden in nature mode)
                if (!this.natureMode) {
                    this.drawUCFFields();
                }
                
                // Draw journey paths (hidden in nature mode)
                if (!this.natureMode) {
                    this.drawJourneyPaths();
                }
            }
            
            // NEW: Draw swallow territory boundary
            drawSwallowTerritory() {
                if (this.swallows.length === 0) return;
                
                const territory = this.distantSwallowTerritory;
                
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(65, 105, 225, 0.4)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([15, 20]);
                this.ctx.strokeRect(territory.x, territory.y, territory.width, territory.height);
                this.ctx.setLineDash([]);
                
                // Territory label
                this.ctx.fillStyle = 'rgba(65, 105, 225, 0.8)';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText('Swallow Territory', territory.x + 10, territory.y + 25);
                
                this.ctx.restore();
            }
            
            // NEW: Draw journey paths
            drawJourneyPaths() {
                this.robins.forEach(robin => {
                    if (robin.isJourneying && robin.journeyTarget) {
                        this.ctx.save();
                        this.ctx.strokeStyle = `rgba(255, 20, 147, 0.5)`;
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([10, 15]);
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(robin.x, robin.y);
                        this.ctx.lineTo(robin.journeyTarget.x, robin.journeyTarget.y);
                        this.ctx.stroke();
                        
                        // Journey destination marker
                        this.ctx.fillStyle = 'rgba(255, 20, 147, 0.7)';
                        this.ctx.beginPath();
                        const pulseRadius = 8 + Math.sin(this.time * 0.1) * 3;
                        this.ctx.arc(robin.journeyTarget.x, robin.journeyTarget.y, pulseRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.setLineDash([]);
                        this.ctx.restore();
                    }
                });
            }
            
            drawSun() {
                const coherenceBoost = this.globalCoherence;
                const photosynthesisBoost = this.photosynthesisRate;
                const intensity = 0.8 + coherenceBoost * 0.15 + photosynthesisBoost * 0.05;
                const radius = 35;
                
                const pulse = Math.sin(this.time * 0.02) * 0.1 + 0.9;
                const coreGradient = this.ctx.createRadialGradient(
                    this.sunX, this.sunY, 0,
                    this.sunX, this.sunY, radius
                );
                
                coreGradient.addColorStop(0, `rgba(255, 255, 220, ${intensity * pulse})`);
                coreGradient.addColorStop(0.6, `rgba(255, 220, 120, ${intensity * 0.8})`);
                coreGradient.addColorStop(1, `rgba(255, 180, 80, ${intensity * 0.6})`);
                
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(this.sunX, this.sunY, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced rays for multi-scale ecosystem
                const avgRNARate = this.robins.length > 0 ? 
                    this.robins.reduce((sum, robin) => sum + (robin.rnaComputationRate || 0), 0) / this.robins.length : 0;
                
                const totalBirds = this.robins.length + this.starlings.length + this.swallows.length + this.eagles.length;
                const ecosystemComplexity = Math.min(1, totalBirds / 100);
                const journeyFactor = this.activeJourneys / Math.max(1, this.robins.length);
                
                const rayCount = 8 + Math.floor(avgRNARate * 6) + Math.floor(this.avgFlockingStrength * 4) + 
                               Math.floor(ecosystemComplexity * 8) + Math.floor(journeyFactor * 6);
                
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2 + this.time * 0.008;
                    const rayLength = radius * (1.5 + Math.sin(this.time * 0.01 + i) * 0.3);
                    const rayIntensity = intensity * (0.4 + avgRNARate * 0.3 + this.avgFlockingStrength * 0.2 + 
                                                     ecosystemComplexity * 0.2 + journeyFactor * 0.3);
                    
                    this.ctx.strokeStyle = `rgba(255, 220, 120, ${rayIntensity})`;
                    this.ctx.lineWidth = 2 + avgRNARate * 2 + ecosystemComplexity * 2;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        this.sunX + Math.cos(angle) * radius,
                        this.sunY + Math.sin(angle) * radius
                    );
                    this.ctx.lineTo(
                        this.sunX + Math.cos(angle) * rayLength,
                        this.sunY + Math.sin(angle) * rayLength
                    );
                    this.ctx.stroke();
                }
                
                if (coherenceBoost > 0.6) {
                    this.ctx.strokeStyle = `rgba(255, 255, 150, ${(coherenceBoost - 0.5) * 0.6})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([6, 12]);
                    this.ctx.beginPath();
                    this.ctx.arc(this.sunX, this.sunY, radius * 1.8, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
            
            drawTerrain() {
                this.ctx.fillStyle = '#4a7c59';
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height);
                
                this.terrain.forEach(point => {
                    this.ctx.lineTo(point.x, point.y);
                });
                
                this.ctx.lineTo(this.width, this.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#2d5016';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.terrain.forEach((point, i) => {
                    if (i === 0) this.ctx.moveTo(point.x, point.y);
                    else this.ctx.lineTo(point.x, point.y);
                });
                this.ctx.stroke();
            }
            
            drawNestingMaterials() {
                this.nestingMaterials.forEach(material => {
                    if (material.collected) return;
                    
                    this.ctx.save();
                    this.ctx.translate(material.x, material.y);
                    this.ctx.rotate(material.angle);
                    
                    const color = material.type === 'twig' ? '#8B4513' : '#9ACD32';
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = material.thickness;
                    this.ctx.lineCap = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(-material.length / 2, 0);
                    this.ctx.lineTo(material.length / 2, 0);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                });
            }
            
            drawUCFFields() {
                if (this.globalCoherence > 0.7) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.15;
                    
                    const fieldSpacing = 80;
                    const fieldRadius = 20;
                    
                    for (let x = fieldSpacing; x < this.width; x += fieldSpacing) {
                        for (let y = fieldSpacing; y < this.height - 100; y += fieldSpacing) {
                            const localCoherence = this.calculateLocalCoherence(x, y);
                            
                            if (localCoherence > 0.5) {
                                this.ctx.strokeStyle = `rgba(0, 255, 255, ${localCoherence})`;
                                this.ctx.lineWidth = 1;
                                this.ctx.beginPath();
                                this.ctx.arc(x, y, fieldRadius * localCoherence, 0, Math.PI * 2);
                                this.ctx.stroke();
                            }
                        }
                    }
                    
                    this.ctx.restore();
                }
            }
            
            calculateLocalCoherence(x, y) {
                let totalCoherence = 0;
                let count = 0;
                
                [...this.robins, ...this.starlings, ...this.swallows, ...this.eagles].forEach(bird => {
                    const dist = Math.sqrt((bird.x - x) ** 2 + (bird.y - y) ** 2);
                    if (dist < 100) {
                        const birdCoherence = bird.coherence || bird.coherenceTrace || 0;
                        totalCoherence += birdCoherence * (1 - dist / 100);
                        count++;
                    }
                });
                
                return count > 0 ? totalCoherence / count : 0;
            }
            
            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize the enhanced multi-scale ecosystem
        let ecosystem;
        
        function togglePanel(panelId) {
            const panel = document.querySelector(`.${panelId}`);
            const toggleBtn = panel.querySelector('.toggle-btn');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggleBtn.textContent = '▲';
            } else {
                panel.classList.add('collapsed');
                toggleBtn.textContent = '▼';
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing Enhanced Multi-Scale UCF Ecosystem with Eagle Predators and Robin Journeying...');
            ecosystem = new EnhancedUCFEcosystem();
            window.ecosystem = ecosystem;
            
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.textContent = '▼';
            });
        });
    </script>
</body>
</html>