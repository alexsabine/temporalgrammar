<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Fish Learning - Biological Intelligence Emergence</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Georgia, serif;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 50%, #f5f6f8 100%);
      color: #2c2c2c;
      min-height: 100vh;
      padding: 30px;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #2c3e50;
    }
    
    .header h1 {
      font-size: 32px;
      font-weight: 400;
      color: #2c3e50;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }
    
    .header p {
      color: #546e7a;
      font-size: 15px;
      font-style: italic;
    }
    
    .explainer-section {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      margin-bottom: 25px;
      overflow: hidden;
    }
    
    .explainer-header {
      background: #e9ecef;
      padding: 15px 20px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }
    
    .explainer-header:hover {
      background: #dee2e6;
    }
    
    .explainer-header h2 {
      font-size: 18px;
      font-weight: 400;
      color: #2c3e50;
    }
    
    .explainer-toggle {
      font-size: 20px;
      color: #546e7a;
      transition: transform 0.3s;
    }
    
    .explainer-toggle.open {
      transform: rotate(180deg);
    }
    
    .explainer-content {
      padding: 25px;
      display: none;
    }
    
    .explainer-content.open {
      display: block;
    }
    
    .explainer-content h3 {
      font-size: 16px;
      font-weight: 600;
      color: #2c3e50;
      margin: 20px 0 12px 0;
      border-bottom: 1px solid #dee2e6;
      padding-bottom: 5px;
    }
    
    .explainer-content h3:first-child {
      margin-top: 0;
    }
    
    .explainer-content p {
      margin-bottom: 12px;
      font-size: 14px;
      color: #495057;
      text-align: justify;
    }
    
    .explainer-content ul {
      margin: 10px 0 15px 25px;
      font-size: 14px;
      color: #495057;
    }
    
    .explainer-content li {
      margin-bottom: 8px;
    }
    
    .equation {
      background: #ffffff;
      border-left: 3px solid #2c3e50;
      padding: 12px 15px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #2c3e50;
      overflow-x: auto;
    }
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 20px;
    }
    
    .panel {
      background: #ffffff;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 10px 20px;
      background: #2c3e50;
      border: 1px solid #2c3e50;
      border-radius: 3px;
      color: white;
      font-family: Georgia, serif;
      font-weight: 400;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
    }
    
    .btn:hover {
      background: #34495e;
      border-color: #34495e;
    }
    
    .btn.success {
      background: #10b981;
      border-color: #10b981;
    }
    
    .btn.success:hover {
      background: #059669;
      border-color: #059669;
    }
    
    .btn.danger {
      background: #ef4444;
      border-color: #ef4444;
    }
    
    .btn.danger:hover {
      background: #dc2626;
      border-color: #dc2626;
    }
    
    canvas {
      display: block;
      background: #0a0a15;
      border-radius: 8px;
      margin-bottom: 15px;
      width: 100%;
    }
    
    .phase-indicator {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(16, 185, 129, 0.5);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      font-weight: 600;
      color: #10b981;
      text-align: center;
      margin-bottom: 20px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
    }
    
    .stat-card {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 3px;
      padding: 15px;
    }
    
    .stat-card h3 {
      font-size: 14px;
      color: #2c3e50;
      margin-bottom: 12px;
      font-weight: 600;
      border-bottom: 1px solid #dee2e6;
      padding-bottom: 6px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 13px;
    }
    
    .stat-label {
      color: #6c757d;
    }
    
    .stat-value {
      font-weight: 600;
      color: #2c3e50;
    }
    
    .stat-value.good {
      color: #10b981;
    }
    
    .stat-value.excellent {
      color: #f59e0b;
    }
    
    .legend {
      font-size: 12px;
      color: #6c757d;
      margin-top: 12px;
      line-height: 1.8;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 3px;
    }
    
    .legend strong {
      color: #2c3e50;
    }
    
    .active-component {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      padding: 12px;
      border-radius: 3px;
      margin-bottom: 15px;
      font-size: 12px;
    }
    
    .component-label {
      color: #10b981;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .component-value {
      font-family: 'Courier New', monospace;
      color: #2c3e50;
    }
    
    @media (max-width: 1024px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 768px) {
      .header h1 {
        font-size: 24px;
      }
      
      .panel {
        padding: 15px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Coherence-Rupture-Regeneration: Biological Intelligence Emergence</h1>
      <p>Observing the transition from Markovian (memoryless) to Non-Markovian (history-aware) behaviour</p>
    </div>
    
    <div class="explainer-section">
      <div class="explainer-header" onclick="toggleExplainer()">
        <h2>Mathematical Framework & Biological Motivation</h2>
        <span class="explainer-toggle" id="explainerToggle">▼</span>
      </div>
      <div class="explainer-content" id="explainerContent">
        <h3>Core Mathematical Framework</h3>
        <p>This demonstration models biological learning through the Coherence-Rupture-Regeneration (CRR) framework. Unlike the spatial navigation demonstration, this focuses on how organisms accumulate experience, undergo learning breakthroughs, and reconstruct behaviour based on weighted historical memory.</p>
        
        <div class="equation">
C(x,t) = ∫ L(x,τ) dτ
(Coherence: Accumulated learning through experience density)
        </div>
        
        <p>Coherence C represents the fish's total accumulated learning. Each experience contributes a learning density L(x,τ) that integrates over time. High-stakes events (predator encounters) contribute more to L than routine exploration, creating differential memory weighting.</p>
        
        <div class="equation">
L(x,τ) = φ₊ - φ₋
(Memory density: Positive learning events minus stressful penalties)
        </div>
        
        <p>The memory density captures the net learning rate at each moment. Predator proximity generates strong positive learning signals (φ₊ > 2.5), while energy depletion creates mild stress penalties (φ₋). Food discoveries provide moderate positive reinforcement.</p>
        
        <div class="equation">
δ(t-t₀) when C(x) > C_threshold
(Rupture: Discontinuous reorganisation at critical coherence)
        </div>
        
        <p>When accumulated coherence exceeds threshold (~115 in this implementation, approximately Ω·ln(10)), the system undergoes rupture—a learning breakthrough. Coherence resets to 35% of its previous value, but critically, the fish's behaviour has reorganised. This models phenomena like insight learning or phase transitions in skill acquisition.</p>
        
        <div class="equation">
R[χ](x,t) = ∫ φ(x,τ)·e^(C(x,τ)/Ω)·Θ(t-τ) dτ
(Regeneration: Exponentially-weighted memory reconstruction)
        </div>
        
        <p>Behaviour is continuously reconstructed through the regeneration operator R. Past experiences φ(x,τ) are weighted by accumulated coherence through the exponential term e^(C/Ω), where Ω = 50 acts as a temperature parameter. The Heaviside function Θ(t-τ) enforces causality—only the past influences the present, creating temporal asymmetry characteristic of biological systems.</p>
        
        <h3>From Markovian to Non-Markovian Behaviour</h3>
        <p>The fish begins with purely Markovian behaviour—current actions depend only on immediate sensory input. However, as coherence accumulates, the system becomes increasingly non-Markovian:</p>
        
        <ul>
          <li><strong>C ≈ 0 (Early behaviour):</strong> Random exploration, e^(C/Ω) ≈ 1, minimal memory influence</li>
          <li><strong>C ≈ 50 (Intermediate):</strong> e^(C/Ω) ≈ 2.7, past experiences begin shaping decisions</li>
          <li><strong>C > 100 (Advanced):</strong> e^(C/Ω) > 7.4, strong memory weighting guides sophisticated avoidance and approach behaviours</li>
        </ul>
        
        <p>The intelligence parameter I = tanh(C/Ω) captures this transition, approaching 1 as the fish becomes fully history-aware. This creates a smooth continuum from reactive (Markovian) to anticipatory (non-Markovian) behaviour.</p>
        
        <h3>Biological Plausibility</h3>
        <p>This mathematical structure captures several phenomena observed in biological learning:</p>
        
        <ul>
          <li><strong>Differential encoding:</strong> High-stakes events (predation risk) create stronger memories than neutral experiences</li>
          <li><strong>Consolidation:</strong> The exponential weighting e^(C/Ω) mirrors how neural representations strengthen with repeated activation</li>
          <li><strong>Insight learning:</strong> Rupture events model sudden behavioural reorganisations documented in animal cognition</li>
          <li><strong>Temporal decay:</strong> The regeneration operator includes temporal decay (not shown explicitly but implemented as exp(-α·Δt)) matching synaptic weakening</li>
          <li><strong>Non-stationarity:</strong> Unlike fixed reward functions in RL, learning rate and behavioural policy evolve continuously</li>
        </ul>
        
        <h3>Comparison with Reinforcement Learning</h3>
        <p>Traditional RL approaches differ fundamentally from CRR dynamics:</p>
        
        <ul>
          <li><strong>CRR has no reward function:</strong> Behaviour emerges from coherence accumulation rather than reward maximisation</li>
          <li><strong>No value function:</strong> The fish doesn't estimate future returns; decisions arise from memory-weighted gradients</li>
          <li><strong>No policy optimisation:</strong> There is no fixed policy being improved—behaviour continuously reconstructs through R[χ]</li>
          <li><strong>Non-stationary learning:</strong> The effective "learning rate" scales with I = tanh(C/Ω), creating adaptive temporal structure</li>
          <li><strong>Rupture as feature:</strong> Discontinuous reorganisations are essential, not pathological</li>
        </ul>
        
        <h3>Observable Phenomena</h3>
        <p>Watch for these emergent behaviours as coherence accumulates:</p>
        
        <ul>
          <li><strong>Improved avoidance:</strong> Initially, the fish may swim towards predators. As C increases, avoidance becomes more reliable and occurs at greater distances</li>
          <li><strong>Directed foraging:</strong> Early food discoveries are accidental. With higher C, the fish begins seeking food more deliberately</li>
          <li><strong>Post-rupture refinement:</strong> After rupture, behaviour often becomes more efficient—the fish has "learnt how to learn"</li>
          <li><strong>Coherence field radius:</strong> The purple glow visualises accumulated coherence spatially, showing how learning becomes embedded in the environment</li>
          <li><strong>Memory vectors:</strong> Pink arrows show regeneration influences—past high-value locations pull current behaviour</li>
        </ul>
        
        <h3>Parameter Values</h3>
        <p>This implementation uses the following constants:</p>
        
        <ul>
          <li>Ω = 50 (Temperature parameter controlling memory weighting sensitivity)</li>
          <li>C_threshold = Ω·ln(10) ≈ 115 (Rupture trigger)</li>
          <li>Rupture retention = 0.35 (35% of coherence preserved after rupture)</li>
          <li>Temporal decay α = 0.05 (Memory weakening rate)</li>
          <li>Spatial memory range = 150 units (Maximum influence distance for regeneration)</li>
          <li>Memory trace capacity = 500 events (Sliding window of historical states)</li>
        </ul>
        
        <h3>Interpretation Guide</h3>
        <p>The demonstration visualises several key components:</p>
        
        <ul>
          <li><strong>Purple coherence field:</strong> Radius scales with C, showing total accumulated learning</li>
          <li><strong>Pink trail:</strong> Memory trace showing recent trajectory</li>
          <li><strong>Yellow/green particles:</strong> Learning events (food discoveries, successful avoidance)</li>
          <li><strong>Pink explosion:</strong> Rupture event—behavioural reorganisation</li>
          <li><strong>Real-time metrics:</strong> Track C(x), L(x,τ), R[χ], and rupture count as learning progresses</li>
        </ul>
        
        <p style="margin-top: 20px; font-style: italic; color: #6c757d;">This demonstration shows that sophisticated adaptive behaviour can emerge from simple mathematical principles governing coherence accumulation, critical transitions, and exponentially-weighted memory regeneration—without explicit programming of survival strategies or reward-based optimisation.</p>
      </div>
    </div>
    
    <div class="main-grid">
      <div class="panel">
        <div class="controls">
          <button class="btn danger" onclick="simulation.addPredator()">Add Predator (High Learning)</button>
          <button class="btn success" onclick="simulation.addFood()">Add Food (Moderate Learning)</button>
          <button class="btn" onclick="simulation.reset()">Reset Simulation</button>
        </div>
        
        <div class="phase-indicator">
          Learning Phase: <span id="phaseLabel">Early Exploration</span>
        </div>
        
        <canvas id="oceanCanvas" width="900" height="600"></canvas>
        
        <div class="legend">
          <strong style="color: #667eea;">Purple field:</strong> Coherence C(x) &nbsp;•&nbsp;
          <strong style="color: #f093fb;">Pink trail:</strong> Memory trace φ(x,τ) &nbsp;•&nbsp;
          <strong style="color: #ff6b6b;">Red sharks:</strong> Predators (danger learning) &nbsp;•&nbsp;
          <strong style="color: #4ecdc4;">Cyan dots:</strong> Food (reward learning)
        </div>
      </div>
      
      <div class="panel">
        <div class="stats-grid">
          <div class="active-component" id="activeComponent">
            <div class="component-label">Active Operator</div>
            <div class="component-value" id="activeOperator">Observing...</div>
          </div>
          
          <div class="stat-card">
            <h3>CRR Metrics</h3>
            <div class="stat-row">
              <span class="stat-label">Coherence C(x):</span>
              <span class="stat-value excellent" id="coherenceValue">0.0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Learning Rate L(x,τ):</span>
              <span class="stat-value" id="memoryValue">0.00</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Regeneration R[χ]:</span>
              <span class="stat-value" id="regenValue">0.00</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Intelligence I:</span>
              <span class="stat-value" id="intelligenceValue">0.00</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Ruptures δ(t):</span>
              <span class="stat-value good" id="ruptureValue">0</span>
            </div>
          </div>
          
          <div class="stat-card">
            <h3>Learning Events</h3>
            <div class="stat-row">
              <span class="stat-label">Total Events:</span>
              <span class="stat-value" id="totalEvents">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Predator Encounters:</span>
              <span class="stat-value" id="predatorEvents">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Food Discoveries:</span>
              <span class="stat-value" id="foodEvents">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Breakthroughs:</span>
              <span class="stat-value good" id="breakthroughs">0</span>
            </div>
          </div>
          
          <div class="stat-card">
            <h3>Behaviour Analysis</h3>
            <div class="stat-row">
              <span class="stat-label">Behaviour Type:</span>
              <span class="stat-value" id="behaviourType">Markovian</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Memory Depth:</span>
              <span class="stat-value" id="memoryDepth">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Avoidance Quality:</span>
              <span class="stat-value" id="avoidanceQuality">Learning</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    'use strict';
    
    function toggleExplainer() {
      const content = document.getElementById('explainerContent');
      const toggle = document.getElementById('explainerToggle');
      content.classList.toggle('open');
      toggle.classList.toggle('open');
    }
    
    class CRRFishSimulation {
      constructor() {
        this.canvas = document.getElementById('oceanCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        
        this.OMEGA = 50;
        this.RUPTURE_THRESHOLD = this.OMEGA * Math.log(10);
        
        this.fish = {
          x: this.width / 2,
          y: this.height / 2,
          vx: 0,
          vy: 0,
          coherence: 0,
          memoryTrace: [],
          ruptureCount: 0,
          currentL: 0,
          regeneration: 0,
          direction: 0
        };
        
        this.predators = [];
        this.food = [];
        this.particles = [];
        
        this.metrics = {
          totalEvents: 0,
          predatorEvents: 0,
          foodEvents: 0,
          breakthroughs: 0
        };
        
        this.activeComponent = 'coherence';
        this.componentTimer = 0;
        this.time = 0;
        
        this.animate();
      }
      
      reset() {
        this.fish.x = this.width / 2;
        this.fish.y = this.height / 2;
        this.fish.vx = 0;
        this.fish.vy = 0;
        this.fish.coherence = 0;
        this.fish.memoryTrace = [];
        this.fish.ruptureCount = 0;
        this.fish.currentL = 0;
        this.fish.regeneration = 0;
        
        this.predators = [];
        this.food = [];
        this.particles = [];
        
        this.metrics = {
          totalEvents: 0,
          predatorEvents: 0,
          foodEvents: 0,
          breakthroughs: 0
        };
        
        this.time = 0;
        this.updateMetrics();
      }
      
      addPredator() {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.max(this.width, this.height) * 0.4;
        this.predators.push({
          x: this.fish.x + Math.cos(angle) * distance,
          y: this.fish.y + Math.sin(angle) * distance,
          vx: 0,
          vy: 0,
          size: 25,
          age: 0
        });
      }
      
      addFood() {
        this.food.push({
          x: Math.random() * this.width,
          y: Math.random() * this.height,
          size: 8
        });
      }
      
      calculateMemoryDensity() {
        let L = 0.1;
        
        for (let predator of this.predators) {
          const dist = Math.hypot(this.fish.x - predator.x, this.fish.y - predator.y);
          if (dist < 150) {
            const danger = (150 - dist) / 150;
            L += danger * 2.5;
            
            if (danger > 0.5 && Math.random() < 0.01) {
              this.metrics.predatorEvents++;
              this.metrics.totalEvents++;
              this.highlightComponent('memory', 1000);
            }
          }
        }
        
        for (let i = this.food.length - 1; i >= 0; i--) {
          const item = this.food[i];
          const dist = Math.hypot(this.fish.x - item.x, this.fish.y - item.y);
          if (dist < 30) {
            L += 1.2;
            
            if (dist < 15) {
              this.food.splice(i, 1);
              this.metrics.foodEvents++;
              this.metrics.totalEvents++;
              this.highlightComponent('memory', 800);
              this.createParticles(item.x, item.y, '#4ecdc4');
            }
          }
        }
        
        return L;
      }
      
      calculateRegeneration() {
        let R = 0;
        const currentTime = this.time;
        
        for (let memory of this.fish.memoryTrace) {
          if (memory.t >= currentTime) break;
          
          const phi = memory.L;
          const timeDecay = Math.exp(-0.05 * (currentTime - memory.t));
          const coherenceWeight = Math.exp(this.fish.coherence / this.OMEGA);
          
          R += phi * coherenceWeight * timeDecay * 0.1;
        }
        
        return R;
      }
      
      updateFish() {
        this.fish.currentL = this.calculateMemoryDensity();
        
        this.fish.coherence += this.fish.currentL;
        this.highlightComponent('coherence', 100);
        
        this.fish.memoryTrace.push({
          t: this.time,
          L: this.fish.currentL,
          C: this.fish.coherence,
          x: this.fish.x,
          y: this.fish.y
        });
        
        if (this.fish.memoryTrace.length > 500) {
          this.fish.memoryTrace.shift();
        }
        
        if (this.fish.coherence > this.RUPTURE_THRESHOLD) {
          this.fish.ruptureCount++;
          this.metrics.breakthroughs++;
          this.highlightComponent('rupture', 2000);
          this.fish.coherence *= 0.35;
          this.createParticles(this.fish.x, this.fish.y, '#f093fb', 30);
        }
        
        this.fish.regeneration = this.calculateRegeneration();
        this.highlightComponent('regeneration', 100);
        
        const coherenceInfluence = Math.tanh(this.fish.coherence / this.OMEGA);
        const regenInfluence = this.fish.regeneration * 0.1;
        
        for (let predator of this.predators) {
          const dx = this.fish.x - predator.x;
          const dy = this.fish.y - predator.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist < 200) {
            const avoidStrength = (200 - dist) / 200;
            const learningBoost = 1 + coherenceInfluence;
            this.fish.vx += (dx / dist) * avoidStrength * 0.5 * learningBoost;
            this.fish.vy += (dy / dist) * avoidStrength * 0.5 * learningBoost;
          }
        }
        
        for (let item of this.food) {
          const dx = item.x - this.fish.x;
          const dy = item.y - this.fish.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist < 150) {
            const seekStrength = coherenceInfluence * 0.3;
            this.fish.vx += (dx / dist) * seekStrength;
            this.fish.vy += (dy / dist) * seekStrength;
          }
        }
        
        const exploration = 1 - coherenceInfluence * 0.5;
        this.fish.vx += (Math.random() - 0.5) * 0.3 * exploration;
        this.fish.vy += (Math.random() - 0.5) * 0.3 * exploration;
        
        this.fish.vx += regenInfluence * Math.cos(this.time * 0.1);
        this.fish.vy += regenInfluence * Math.sin(this.time * 0.1);
        
        this.fish.x += this.fish.vx;
        this.fish.y += this.fish.vy;
        
        const margin = 50;
        if (this.fish.x < margin) {
          this.fish.x = margin;
          this.fish.vx = Math.abs(this.fish.vx);
        }
        if (this.fish.x > this.width - margin) {
          this.fish.x = this.width - margin;
          this.fish.vx = -Math.abs(this.fish.vx);
        }
        if (this.fish.y < margin) {
          this.fish.y = margin;
          this.fish.vy = Math.abs(this.fish.vy);
        }
        if (this.fish.y > this.height - margin) {
          this.fish.y = this.height - margin;
          this.fish.vy = -Math.abs(this.fish.vy);
        }
        
        this.fish.vx *= 0.95;
        this.fish.vy *= 0.95;
        
        if (Math.abs(this.fish.vx) > 0.1 || Math.abs(this.fish.vy) > 0.1) {
          this.fish.direction = Math.atan2(this.fish.vy, this.fish.vx);
        }
      }
      
      updatePredators() {
        for (let predator of this.predators) {
          predator.age++;
          
          const dx = this.fish.x - predator.x;
          const dy = this.fish.y - predator.y;
          const dist = Math.hypot(dx, dy);
          
          const chaseStrength = 0.15;
          predator.vx += (dx / dist) * chaseStrength;
          predator.vy += (dy / dist) * chaseStrength;
          
          predator.x += predator.vx;
          predator.y += predator.vy;
          
          predator.vx *= 0.96;
          predator.vy *= 0.96;
          
          if (predator.age > 1000) {
            const index = this.predators.indexOf(predator);
            if (index > -1) this.predators.splice(index, 1);
          }
        }
      }
      
      updateParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];
          p.age++;
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1;
          p.opacity -= 0.02;
          
          if (p.opacity <= 0 || p.age > 100) {
            this.particles.splice(i, 1);
          }
        }
      }
      
      highlightComponent(component, duration) {
        this.activeComponent = component;
        this.componentTimer = duration;
        
        const labels = {
          'coherence': 'C(x,t) = ∫L(x,τ)dτ',
          'memory': 'L(x,τ) = φ₊ - φ₋',
          'rupture': 'δ(t-t₀) — Breakthrough!',
          'regeneration': 'R[χ] = ∫φ·e^(C/Ω)·Θ(t-τ)dτ'
        };
        
        document.getElementById('activeOperator').textContent = labels[component] || 'Observing...';
      }
      
      createParticles(x, y, color, count = 15) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 3;
          this.particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 2,
            color,
            opacity: 1,
            age: 0
          });
        }
      }
      
      updateMetrics() {
        document.getElementById('coherenceValue').textContent = this.fish.coherence.toFixed(1);
        document.getElementById('memoryValue').textContent = this.fish.currentL.toFixed(2);
        document.getElementById('regenValue').textContent = this.fish.regeneration.toFixed(2);
        
        const intelligence = Math.tanh(this.fish.coherence / this.OMEGA);
        document.getElementById('intelligenceValue').textContent = intelligence.toFixed(2);
        document.getElementById('ruptureValue').textContent = this.fish.ruptureCount;
        
        document.getElementById('totalEvents').textContent = this.metrics.totalEvents;
        document.getElementById('predatorEvents').textContent = this.metrics.predatorEvents;
        document.getElementById('foodEvents').textContent = this.metrics.foodEvents;
        document.getElementById('breakthroughs').textContent = this.metrics.breakthroughs;
        
        let phaseLabel = 'Early Exploration';
        let behaviourType = 'Markovian';
        
        if (this.fish.coherence > 80) {
          phaseLabel = 'Advanced Learning';
          behaviourType = 'Non-Markovian';
        } else if (this.fish.coherence > 40) {
          phaseLabel = 'Intermediate Learning';
          behaviourType = 'Transitional';
        }
        
        document.getElementById('phaseLabel').textContent = phaseLabel;
        document.getElementById('behaviourType').textContent = behaviourType;
        document.getElementById('memoryDepth').textContent = this.fish.memoryTrace.length;
        
        const avoidQuality = intelligence > 0.7 ? 'Sophisticated' : intelligence > 0.4 ? 'Developing' : 'Learning';
        document.getElementById('avoidanceQuality').textContent = avoidQuality;
      }
      
      draw() {
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
        gradient.addColorStop(0, '#1a3a52');
        gradient.addColorStop(1, '#0d1b2a');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        if (this.fish.coherence > 10) {
          const radius = this.fish.coherence * 1.5;
          const fieldGradient = this.ctx.createRadialGradient(
            this.fish.x, this.fish.y, 0,
            this.fish.x, this.fish.y, radius
          );
          fieldGradient.addColorStop(0, 'rgba(102, 126, 234, 0.2)');
          fieldGradient.addColorStop(1, 'rgba(102, 126, 234, 0)');
          this.ctx.fillStyle = fieldGradient;
          this.ctx.beginPath();
          this.ctx.arc(this.fish.x, this.fish.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
        }
        
        if (this.fish.memoryTrace.length > 2) {
          this.ctx.strokeStyle = 'rgba(240, 147, 251, 0.2)';
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(this.fish.memoryTrace[0].x, this.fish.memoryTrace[0].y);
          for (let memory of this.fish.memoryTrace) {
            this.ctx.lineTo(memory.x, memory.y);
          }
          this.ctx.stroke();
        }
        
        for (let p of this.particles) {
          this.ctx.fillStyle = p.color;
          this.ctx.globalAlpha = p.opacity;
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          this.ctx.fill();
        }
        this.ctx.globalAlpha = 1;
        
        for (let item of this.food) {
          this.ctx.fillStyle = '#4ecdc4';
          this.ctx.beginPath();
          this.ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.strokeStyle = 'rgba(78, 205, 196, 0.3)';
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.arc(item.x, item.y, item.size + Math.sin(this.time * 0.1) * 3, 0, Math.PI * 2);
          this.ctx.stroke();
        }
        
        for (let predator of this.predators) {
          this.ctx.save();
          this.ctx.translate(predator.x, predator.y);
          const angle = Math.atan2(predator.vy, predator.vx);
          this.ctx.rotate(angle);
          
          this.ctx.fillStyle = 'rgba(255, 107, 107, 0.1)';
          this.ctx.beginPath();
          this.ctx.arc(0, 0, 150, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.fillStyle = '#ff6b6b';
          this.ctx.beginPath();
          this.ctx.ellipse(0, 0, predator.size, predator.size * 0.4, 0, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.fillStyle = '#fff';
          this.ctx.beginPath();
          this.ctx.arc(predator.size * 0.4, -predator.size * 0.1, 4, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.restore();
        }
        
        this.ctx.save();
        this.ctx.translate(this.fish.x, this.fish.y);
        this.ctx.rotate(this.fish.direction);
        
        const glowIntensity = Math.min(1, this.fish.coherence / this.RUPTURE_THRESHOLD);
        this.ctx.shadowColor = `rgba(102, 126, 234, ${glowIntensity})`;
        this.ctx.shadowBlur = 20 * glowIntensity;
        
        const bodyGradient = this.ctx.createLinearGradient(-15, 0, 15, 0);
        bodyGradient.addColorStop(0, '#667eea');
        bodyGradient.addColorStop(1, '#764ba2');
        this.ctx.fillStyle = bodyGradient;
        this.ctx.beginPath();
        this.ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.beginPath();
        this.ctx.moveTo(-15, 0);
        this.ctx.lineTo(-22, -8);
        this.ctx.lineTo(-22, 8);
        this.ctx.closePath();
        this.ctx.fill();
        
        this.ctx.shadowBlur = 0;
        this.ctx.fillStyle = '#fff';
        this.ctx.beginPath();
        this.ctx.arc(8, -3, 3, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.fillStyle = '#000';
        this.ctx.beginPath();
        this.ctx.arc(9, -3, 1.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.restore();
      }
      
      animate() {
        this.time++;
        
        this.updateFish();
        this.updatePredators();
        this.updateParticles();
        
        if (this.componentTimer > 0) {
          this.componentTimer--;
        }
        
        this.draw();
        
        if (this.time % 10 === 0) {
          this.updateMetrics();
        }
        
        if (this.time % 200 === 0 && this.food.length < 5) {
          this.addFood();
        }
        
        requestAnimationFrame(() => this.animate());
      }
    }
    
    const simulation = new CRRFishSimulation();
    window.simulation = simulation;
  </script>
</body>
</html>