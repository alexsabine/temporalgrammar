<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplet ‚Äî CRR Framework Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a1a;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 1000;
        }
        
        .ctrl-btn {
            padding: 10px 18px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.7);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            font-size: 11px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            letter-spacing: 0.3px;
        }
        
        .ctrl-btn:hover {
            background: rgba(30, 30, 30, 0.95);
            border-color: rgba(255, 255, 255, 0.25);
            color: #fff;
        }
        
        .ctrl-btn.active {
            background: rgba(60, 130, 180, 0.3);
            border-color: rgba(100, 180, 255, 0.5);
            color: #fff;
        }
        
        .info-overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            line-height: 1.6;
            z-index: 1000;
            display: none;
        }
        
        .info-overlay.visible {
            display: block;
        }
        
        .info-overlay .label {
            color: rgba(100, 180, 255, 0.6);
        }
        
        /* Math overlay styles */
        .math-overlay {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 320px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(100, 180, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1000;
            display: none;
            line-height: 1.5;
        }
        
        .math-overlay.visible {
            display: block;
        }
        
        .math-overlay h3 {
            color: rgba(100, 180, 255, 0.9);
            font-size: 11px;
            margin: 12px 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(100, 180, 255, 0.2);
        }
        
        .math-overlay h3:first-child {
            margin-top: 0;
        }
        
        .math-overlay .equation {
            background: rgba(100, 180, 255, 0.1);
            padding: 8px 10px;
            border-radius: 4px;
            margin: 6px 0;
            font-family: 'Times New Roman', serif;
            font-size: 13px;
            font-style: italic;
            color: #fff;
        }
        
        .math-overlay .code {
            background: rgba(50, 50, 50, 0.8);
            padding: 6px 8px;
            border-radius: 3px;
            margin: 4px 0;
            font-family: 'SF Mono', monospace;
            font-size: 9px;
            color: rgba(150, 255, 150, 0.9);
        }
        
        .math-overlay .note {
            color: rgba(255, 200, 100, 0.8);
            font-size: 9px;
            margin: 4px 0;
        }
        
        .math-overlay .param {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .math-overlay .param-name {
            color: rgba(100, 180, 255, 0.8);
        }
        
        .math-overlay .param-value {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .math-overlay::-webkit-scrollbar {
            width: 6px;
        }
        
        .math-overlay::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
        }
        
        .math-overlay::-webkit-scrollbar-thumb {
            background: rgba(100, 180, 255, 0.3);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="info-overlay" id="infoOverlay">
        <span class="label">OPTICAL PIPELINE</span><br>
        Photon ‚Üí Fresnel ‚Üí Screen ‚Üí Retina ‚Üí V1<br><br>
        <span class="label">n(water)</span> = 1.333 @ 589nm<br>
        <span class="label">Display</span> = <span id="refreshRate">60</span>Hz<br><br>
        <span class="label">INTERNAL DYNAMICS</span><br>
        H‚ÇÇO clusters ‚Ä¢ Convection ‚Ä¢ H-bonds
    </div>
    
    <!-- Mathematical Documentation Overlay -->
    <div class="math-overlay" id="mathOverlay">
        <h3>CRR FRAMEWORK</h3>
        <div style="color: rgba(255,255,255,0.6); margin-bottom: 8px;">
            Coherence-Rupture-Regeneration dynamics governing<br>
            multi-scale temporal processes in this simulation.
        </div>
        
        <h3>¬ß1 COHERENCE INTEGRAL</h3>
        <div class="equation">C(x,t) = ‚à´ L(x,œÑ) dœÑ</div>
        <div style="color: rgba(255,255,255,0.6);">
            Coherence accumulates as the integral of local<br>
            activity L over time. Discrete implementation:
        </div>
        <div class="code">CRR.scale.C += CRR.scale.L</div>
        
        <h3>¬ß2 RUPTURE DYNAMICS</h3>
        <div class="equation">Œ¥(now) when C ‚â• Œ©</div>
        <div style="color: rgba(255,255,255,0.6);">
            Scale-invariant "choice-moments" occur when<br>
            accumulated coherence reaches threshold Œ©.<br>
            The Dirac delta marks ontological present.
        </div>
        <div class="code">if (CRR.scale.C >= CRR.scale.omega) {<br>
            &nbsp;&nbsp;CRR.scale.C = 0;  // Reset<br>
            &nbsp;&nbsp;CRR.scale.rupture = 1;  // Event<br>
        }</div>
        
        <h3>¬ß3 REGENERATION</h3>
        <div class="equation">R = ‚à´ œÜ(x,œÑ) ¬∑ exp(C/Œ©) ¬∑ Œò(...) dœÑ</div>
        <div style="color: rgba(255,255,255,0.6);">
            Post-rupture regeneration with exponential<br>
            memory weighting. exp(C/Œ©) determines<br>
            historical coherence accessibility.
        </div>
        <div class="note">
            ‚Üí Large Œ©: all history weighted equally<br>
            ‚Üí Small Œ©: peaked at highest coherence
        </div>
        
        <h3>¬ß4 CROSS-SCALE CASCADE</h3>
        <div style="color: rgba(255,255,255,0.6);">
            Rupture at scale n drives coherence input<br>
            L at scale n+1 (regeneration coupling):
        </div>
        <div class="code">
            photon.rupture ‚Üí molecular.L += 0.15<br>
            molecular.rupture ‚Üí cluster.L += 0.25<br>
            cluster.rupture ‚Üí surface.L += 0.35<br>
            surface.rupture ‚Üí neural.L += 0.50
        </div>
        
        <h3>¬ß5 Œ© HIERARCHY</h3>
        <div style="color: rgba(255,255,255,0.6); margin-bottom: 6px;">
            Threshold values increase with scale<br>
            (faster rupture at micro-scales):
        </div>
        <div class="param"><span class="param-name">Œ©_photon</span><span class="param-value">0.8</span></div>
        <div class="param"><span class="param-name">Œ©_molecular</span><span class="param-value">2.0</span></div>
        <div class="param"><span class="param-name">Œ©_cluster</span><span class="param-value">5.0</span></div>
        <div class="param"><span class="param-name">Œ©_surface</span><span class="param-value">12.0</span></div>
        <div class="param"><span class="param-name">Œ©_neural</span><span class="param-value">30.0</span></div>
        <div class="note" style="margin-top: 6px;">
            Inter-scale ratio ‚âà 2.5√ó (close to e ‚âà 2.718)
        </div>
        
        <h3>¬ß6 PHYSICAL OPTICS</h3>
        <div class="equation">n(Œª) = A + B/Œª¬≤</div>
        <div style="color: rgba(255,255,255,0.6);">Cauchy dispersion equation:</div>
        <div class="param"><span class="param-name">A</span><span class="param-value">1.3199</span></div>
        <div class="param"><span class="param-name">B</span><span class="param-value">0.00653 Œºm¬≤</span></div>
        <div class="param"><span class="param-name">n_D (589nm)</span><span class="param-value">1.333</span></div>
        
        <div class="equation" style="margin-top: 10px;">
            R = (R_s + R_p) / 2
        </div>
        <div style="color: rgba(255,255,255,0.6);">
            Fresnel reflectance (unpolarized):<br>
        </div>
        <div class="code" style="font-size: 8px;">
            R_s = ((n‚ÇÅcosŒ∏·µ¢ - n‚ÇÇcosŒ∏‚Çú)/(n‚ÇÅcosŒ∏·µ¢ + n‚ÇÇcosŒ∏‚Çú))¬≤<br>
            R_p = ((n‚ÇÅcosŒ∏‚Çú - n‚ÇÇcosŒ∏·µ¢)/(n‚ÇÅcosŒ∏‚Çú + n‚ÇÇcosŒ∏·µ¢))¬≤
        </div>
        
        <h3>¬ß7 MOLECULAR H‚ÇÇO</h3>
        <div class="param"><span class="param-name">H-O-H angle</span><span class="param-value">104.45¬∞</span></div>
        <div class="param"><span class="param-name">H-bond cutoff</span><span class="param-value">0.35 (norm)</span></div>
        <div class="param"><span class="param-name">Coordination</span><span class="param-value">Tetrahedral</span></div>
        <div style="color: rgba(255,255,255,0.6); margin-top: 6px;">
            Clusters exhibit dynamic H-bond network<br>
            with Brownian motion + toroidal convection.
        </div>
        
        <h3>¬ß8 COGNITIVE MAPPING</h3>
        <div style="color: rgba(255,255,255,0.6);">
            Optical ‚Üí Neural pipeline:
        </div>
        <div class="code">Photon ‚Üí Fresnel ‚Üí Screen ‚Üí Retina ‚Üí V1</div>
        <div class="param"><span class="param-name">Neural/Photon Œ©</span><span class="param-value">37.5√ó</span></div>
        <div class="param"><span class="param-name">Hierarchical depth</span><span class="param-value">~3.2 levels</span></div>
        <div class="note" style="margin-top: 6px;">
            log_œÄ(Œ©_neural/Œ©_photon) ‚âà 3.2
        </div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(100,180,255,0.2); color: rgba(255,255,255,0.4); font-size: 8px;">
            CRR Framework ‚Äî A. Sabine (2024-2025)<br>
            cohere.org.uk
        </div>
    </div>
    
    <div class="controls">
        <button class="ctrl-btn" id="infoBtn">‚Ñπ Info</button>
        <button class="ctrl-btn" id="mathBtn">‚à´ Math</button>
        <button class="ctrl-btn" id="physicsBtn">‚öõ Physics</button>
        <button class="ctrl-btn active" id="pureBtn">üíß Pure</button>
    </div>
    
    <script>
        /*
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         * WATER DROPLET SIMULATION ‚Äî CRR Framework Implementation
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         * 
         * This simulation implements the Coherence-Rupture-Regeneration (CRR)
         * mathematical framework across multiple scales, from photon interactions
         * through molecular dynamics to neural/cognitive processing.
         * 
         * CRR CORE EQUATIONS:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * 1. COHERENCE:     C(x,t) = ‚à´ L(x,œÑ) dœÑ
         *    Coherence accumulates as the temporal integral of local activity L.
         *    Discrete: C_new = C_old + L
         * 
         * 2. RUPTURE:       Œ¥(now) when C ‚â• Œ©
         *    Scale-invariant "choice-moments" occur when accumulated coherence
         *    reaches threshold Œ©. The Dirac delta marks ontological present
         *    where agents metabolize past into future.
         * 
         * 3. REGENERATION:  R = ‚à´ œÜ(x,œÑ) ¬∑ exp(C(x,œÑ)/Œ©) ¬∑ Œò(...) dœÑ
         *    Post-rupture reconstruction with exponential memory weighting.
         *    exp(C/Œ©) creates differential historical access:
         *      - Large Œ© ‚Üí exp ‚âà 1 (all history weighted equally)
         *      - Small Œ© ‚Üí peaked (only highest coherence accessible)
         * 
         * MULTI-SCALE HIERARCHY:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Scale        Œ©       Description
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Photon       0.8     Electromagnetic coherence
         * Molecular    2.0     H‚ÇÇO vibration/rotation
         * Cluster      5.0     H-bond network dynamics
         * Surface      12.0    Droplet interface tension
         * Neural       30.0    Perceptual integration
         * 
         * The ~2.5√ó ratio between scales approximates e ‚âà 2.718,
         * suggesting natural exponential temporal scaling.
         * 
         * CROSS-SCALE CASCADE (Regeneration):
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * When scale n ruptures, it drives coherence input L at scale n+1:
         *   photon    ‚Üí molecular  (coupling: 0.15)
         *   molecular ‚Üí cluster    (coupling: 0.25)
         *   cluster   ‚Üí surface    (coupling: 0.35)
         *   surface   ‚Üí neural     (coupling: 0.50)
         * 
         * Increasing coupling strength toward macro-scales models how
         * micro-ruptures feed energy into larger coherence windows.
         * 
         * PHYSICAL OPTICS:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Refractive Index: n(Œª) = A + B/Œª¬≤  (Cauchy dispersion)
         *   A = 1.3199, B = 0.00653 Œºm¬≤
         *   n_D = 1.333 @ 589nm (sodium D-line, 20¬∞C)
         * 
         * Fresnel Reflectance (unpolarized): R = (R_s + R_p) / 2
         *   R_s = ((n‚ÇÅcosŒ∏·µ¢ - n‚ÇÇcosŒ∏‚Çú)/(n‚ÇÅcosŒ∏·µ¢ + n‚ÇÇcosŒ∏‚Çú))¬≤
         *   R_p = ((n‚ÇÅcosŒ∏‚Çú - n‚ÇÇcosŒ∏·µ¢)/(n‚ÇÅcosŒ∏‚Çú + n‚ÇÇcosŒ∏·µ¢))¬≤
         * 
         * Total Internal Reflection: when sinŒ∏‚Çú > 1, R = 1
         * 
         * MOLECULAR H‚ÇÇO:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * H-O-H bond angle: 104.45¬∞ (experimental value)
         * H-bond network: Dynamic tetrahedral coordination
         * Brownian motion: Stochastic molecular diffusion
         * Convection: Toroidal flow pattern in droplet interior
         * 
         * COGNITIVE SCIENCE MAPPING:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * The simulation traces the optical-cognitive pipeline:
         *   Photon ‚Üí Fresnel ‚Üí Screen ‚Üí Retina ‚Üí V1
         * 
         * Neural/Photon Œ© ratio: 37.5√ó (neural coherence windows much longer)
         * Hierarchical depth: ~3.2 levels (log_œÄ of total Œ© span)
         * 
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         * REFERENCES:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * - Sabine, A. (2024-2025). Coherence-Rupture-Regeneration Framework.
         * - Whitehead, A.N. (1929). Process and Reality.
         * - Friston, K. (2010). The Free-Energy Principle.
         * 
         * Framework website: cohere.org.uk
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         */
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // =====================================================
        // PHYSICAL CONSTANTS
        // =====================================================
        /*
         * OPTICAL PHYSICS
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Water refractive index follows Cauchy dispersion:
         *   n(Œª) = A + B/Œª¬≤
         * 
         * These coefficients yield n_D = 1.333 at the sodium
         * D-line (589nm), matching experimental measurements
         * for pure water at 20¬∞C.
         */
        
        const WATER = {
            A: 1.3199,      // Cauchy coefficient A (dimensionless)
            B: 0.00653,     // Cauchy coefficient B (Œºm¬≤)
            n_D: 1.333      // Refractive index at 589nm (sodium D-line)
        };
        
        /*
         * Cauchy Dispersion Equation
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Returns wavelength-dependent refractive index.
         * This simplified Sellmeier form captures chromatic
         * dispersion responsible for rainbow caustics.
         * 
         * @param lambda_nm - Wavelength in nanometers
         * @returns n(Œª) - Refractive index at that wavelength
         */
        function refractiveIndex(lambda_nm) {
            const lambda_um = lambda_nm / 1000;  // Convert nm ‚Üí Œºm
            return WATER.A + WATER.B / (lambda_um * lambda_um);
        }
        
        /*
         * Fresnel Reflectance (Unpolarized Light)
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Computes reflection coefficient at dielectric interface
         * using full Fresnel equations for s and p polarization.
         * 
         * For unpolarized light: R = (R_s + R_p) / 2
         * 
         * R_s (s-polarization, TE):
         *   R_s = ((n‚ÇÅcosŒ∏·µ¢ - n‚ÇÇcosŒ∏‚Çú) / (n‚ÇÅcosŒ∏·µ¢ + n‚ÇÇcosŒ∏‚Çú))¬≤
         * 
         * R_p (p-polarization, TM):
         *   R_p = ((n‚ÇÅcosŒ∏‚Çú - n‚ÇÇcosŒ∏·µ¢) / (n‚ÇÅcosŒ∏‚Çú + n‚ÇÇcosŒ∏·µ¢))¬≤
         * 
         * Total Internal Reflection occurs when sinŒ∏‚Çú > 1,
         * i.e., when the refracted ray would exceed 90¬∞.
         * 
         * @param n1 - Refractive index of incident medium
         * @param n2 - Refractive index of transmitted medium
         * @param cosTheta_i - Cosine of incident angle
         * @returns R - Reflectance (0 to 1)
         */
        function fresnelReflectance(n1, n2, cosTheta_i) {
            // Snell's law: n‚ÇÅsinŒ∏·µ¢ = n‚ÇÇsinŒ∏‚Çú
            const sinTheta_i = Math.sqrt(Math.max(0, 1 - cosTheta_i * cosTheta_i));
            const sinTheta_t = (n1 / n2) * sinTheta_i;
            
            // Total Internal Reflection check
            if (sinTheta_t > 1) return 1;  // TIR: all light reflected
            
            const cosTheta_t = Math.sqrt(Math.max(0, 1 - sinTheta_t * sinTheta_t));
            
            // Fresnel equations (with epsilon to prevent division by zero)
            const Rs = Math.pow((n1 * cosTheta_i - n2 * cosTheta_t) / (n1 * cosTheta_i + n2 * cosTheta_t + 0.0001), 2);
            const Rp = Math.pow((n1 * cosTheta_t - n2 * cosTheta_i) / (n1 * cosTheta_t + n2 * cosTheta_i + 0.0001), 2);
            
            // Unpolarized: average of s and p
            return Math.min(1, (Rs + Rp) / 2);
        }
        
        // =====================================================
        // CRR STATE
        // =====================================================
        /*
         * CRR MULTI-SCALE STATE VARIABLES
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Each scale maintains:
         *   C       - Accumulated coherence (‚à´L dœÑ)
         *   omega   - Rupture threshold (Œ©)
         *   L       - Current coherence input rate
         *   rupture - Rupture event intensity (decays after Œ¥)
         * 
         * SCALE HIERARCHY:
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * photon    (Œ©=0.8)   Electromagnetic field coherence
         * molecular (Œ©=2.0)   H‚ÇÇO molecular vibration/rotation
         * cluster   (Œ©=5.0)   Hydrogen bond network dynamics
         * surface   (Œ©=12.0)  Droplet surface tension waves
         * neural    (Œ©=30.0)  Perceptual/cognitive integration
         * 
         * The hierarchy embodies CRR's scale-invariant structure:
         * same C‚ÜíŒ¥‚ÜíR dynamics operate at each level, with
         * Œ© determining the characteristic timescale.
         * 
         * Inter-scale Œ© ratio ‚âà 2.5 (close to e ‚âà 2.718)
         */
        
        const CRR = {
            photon:    { C: 0, omega: 0.8,  L: 0, rupture: 0 },
            molecular: { C: 0, omega: 2.0,  L: 0, rupture: 0 },
            cluster:   { C: 0, omega: 5.0,  L: 0, rupture: 0 },
            surface:   { C: 0, omega: 12.0, L: 0, rupture: 0 },
            neural:    { C: 0, omega: 30.0, L: 0, rupture: 0 }
        };
        
        // =====================================================
        // DROPLET STATE
        // =====================================================
        
        const droplet = {
            cx: 0,
            cy: 0,
            baseRadius: 0,
            wobblePhase: 0,
            wobbleAmp: 0,
            causticPhase: 0,
            flowPhase: 0
        };
        
        // =====================================================
        // INTERNAL DYNAMICS - Water molecule clusters
        // =====================================================
        /*
         * MOLECULAR DYNAMICS
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * The simulation models three populations:
         * 
         * 1. CLUSTERS (NUM_CLUSTERS = 25)
         *    H‚ÇÇO molecule aggregates with tetrahedral coordination.
         *    Each cluster has coherence that recovers over time
         *    (regeneration) and can be disrupted by rupture events.
         * 
         * 2. MOLECULES (NUM_MOLECULES = 60)
         *    Individual H‚ÇÇO with correct 104.45¬∞ bond angle.
         *    Exhibit Brownian motion and rotational dynamics.
         * 
         * 3. FLOW PARTICLES (NUM_FLOW_PARTICLES = 40)
         *    Tracer particles showing toroidal convection
         *    pattern within the droplet interior.
         * 
         * 4. H-BONDS (dynamic)
         *    Hydrogen bonds form between nearby clusters,
         *    creating the characteristic network structure
         *    of liquid water.
         */
        
        const NUM_CLUSTERS = 25;
        const NUM_MOLECULES = 60;
        const NUM_FLOW_PARTICLES = 40;
        
        let clusters = [];
        let molecules = [];
        let flowParticles = [];
        let hBonds = [];
        
        function initInternals() {
            clusters = [];
            molecules = [];
            flowParticles = [];
            hBonds = [];
            
            // H‚ÇÇO clusters (tetrahedral coordination)
            for (let i = 0; i < NUM_CLUSTERS; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.85;
                clusters.push({
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: (Math.random() - 0.5) * 1.6,
                    size: 0.02 + Math.random() * 0.025,
                    phase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.02 + Math.random() * 0.02,
                    coherence: Math.random(),  // CRR coherence state
                    vx: (Math.random() - 0.5) * 0.001,
                    vy: (Math.random() - 0.5) * 0.001
                });
            }
            
            // Individual water molecules (smaller, faster)
            for (let i = 0; i < NUM_MOLECULES; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.9;
                molecules.push({
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: (Math.random() - 0.5) * 1.8,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.08,
                    vibration: Math.random() * 0.5 + 0.5,
                    vx: (Math.random() - 0.5) * 0.003,
                    vy: (Math.random() - 0.5) * 0.003
                });
            }
            
            // Flow/convection particles
            for (let i = 0; i < NUM_FLOW_PARTICLES; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.8;
                flowParticles.push({
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: (Math.random() - 0.5) * 1.5,
                    age: Math.random(),
                    speed: 0.002 + Math.random() * 0.003
                });
            }
            
            // Generate hydrogen bonds between nearby clusters
            updateHBonds();
        }
        
        /*
         * HYDROGEN BOND NETWORK
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * H-bonds form between clusters within cutoff distance.
         * Bond strength inversely proportional to distance.
         * 
         * In liquid water, each molecule participates in
         * ~3.5 H-bonds on average (tetrahedral network).
         */
        function updateHBonds() {
            hBonds = [];
            for (let i = 0; i < clusters.length; i++) {
                for (let j = i + 1; j < clusters.length; j++) {
                    const dx = clusters[j].x - clusters[i].x;
                    const dy = clusters[j].y - clusters[i].y;
                    const dz = clusters[j].z - clusters[i].z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // H-bond forms within cutoff (0.35 normalized units)
                    if (dist < 0.35 && dist > 0.08) {
                        hBonds.push({
                            from: i,
                            to: j,
                            strength: 1 - dist / 0.35,
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
        }
        
        // =====================================================
        // RESIZE
        // =====================================================
        
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
            
            droplet.cx = window.innerWidth / 2;
            droplet.cy = window.innerHeight / 2;
            droplet.baseRadius = Math.min(window.innerWidth, window.innerHeight) * 0.28;
            
            initInternals();
        }
        resize();
        window.addEventListener('resize', resize);
        
        // =====================================================
        // UI STATE
        // =====================================================
        
        let showInfo = false;
        let showPhysics = false;
        let showMath = false;
        let actualRefreshRate = 60;
        let frameCount = 0;
        let lastSecond = performance.now();
        
        document.getElementById('infoBtn').addEventListener('click', () => {
            showInfo = !showInfo;
            document.getElementById('infoOverlay').classList.toggle('visible', showInfo);
            document.getElementById('infoBtn').classList.toggle('active', showInfo);
        });
        
        document.getElementById('mathBtn').addEventListener('click', () => {
            showMath = !showMath;
            document.getElementById('mathOverlay').classList.toggle('visible', showMath);
            document.getElementById('mathBtn').classList.toggle('active', showMath);
        });
        
        document.getElementById('physicsBtn').addEventListener('click', () => {
            showPhysics = !showPhysics;
            document.getElementById('physicsBtn').classList.toggle('active', showPhysics);
            document.getElementById('pureBtn').classList.toggle('active', !showPhysics);
        });
        
        document.getElementById('pureBtn').addEventListener('click', () => {
            showPhysics = false;
            showInfo = false;
            showMath = false;
            document.getElementById('physicsBtn').classList.remove('active');
            document.getElementById('infoBtn').classList.remove('active');
            document.getElementById('mathBtn').classList.remove('active');
            document.getElementById('infoOverlay').classList.remove('visible');
            document.getElementById('mathOverlay').classList.remove('visible');
            document.getElementById('pureBtn').classList.add('active');
        });
        
        // =====================================================
        // CRR DYNAMICS
        // =====================================================
        /*
         * CRR UPDATE FUNCTION
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Implements the three CRR equations at each scale:
         * 
         * 1. COHERENCE ACCUMULATION: C += L
         *    Discrete form of C(x,t) = ‚à´L(x,œÑ)dœÑ
         * 
         * 2. RUPTURE CHECK: if (C >= Œ©) ‚Üí Œ¥ event
         *    When coherence reaches threshold, rupture occurs.
         *    C resets to 0, rupture flag set to 1.
         * 
         * 3. REGENERATION CASCADE: rupture drives next scale
         *    Each rupture adds to L of the next higher scale,
         *    implementing cross-scale energy flow.
         * 
         * CASCADE COUPLING STRENGTHS:
         *   photon ‚Üí molecular:   0.15
         *   molecular ‚Üí cluster:  0.25
         *   cluster ‚Üí surface:    0.35
         *   surface ‚Üí neural:     0.50
         * 
         * Increasing coupling toward macro-scales reflects
         * how micro-ruptures aggregate into larger events.
         * 
         * RUPTURE DECAY RATES:
         *   photon:    0.85 (fast decay, t¬Ω ‚âà 4.3 frames)
         *   molecular: 0.90 (t¬Ω ‚âà 6.6 frames)
         *   cluster:   0.92 (t¬Ω ‚âà 8.3 frames)
         *   surface:   0.95 (t¬Ω ‚âà 13.5 frames)
         *   neural:    0.97 (slow decay, t¬Ω ‚âà 22.8 frames)
         */
        
        function updateCRR(dt) {
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // PHOTON SCALE (Œ© = 0.8)
            // Electromagnetic field coherence
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            CRR.photon.L = 0.05 + Math.random() * 0.06;  // Stochastic photon input
            CRR.photon.C += CRR.photon.L;                 // C(t) = ‚à´L dœÑ
            
            if (CRR.photon.C >= CRR.photon.omega) {       // Œ¥(now) when C ‚â• Œ©
                CRR.photon.C = 0;                          // Reset coherence
                CRR.photon.rupture = 1;                    // Rupture event
                CRR.molecular.L += 0.15;                   // Cascade ‚Üí molecular
            }
            CRR.photon.rupture *= 0.85;                   // Exponential decay
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // MOLECULAR SCALE (Œ© = 2.0)
            // H‚ÇÇO vibration and rotation
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            CRR.molecular.L += 0.01 + Math.random() * 0.02;
            CRR.molecular.C += CRR.molecular.L;           // C(t) = ‚à´L dœÑ
            CRR.molecular.L *= 0.9;                        // L decay (damping)
            
            if (CRR.molecular.C >= CRR.molecular.omega) { // Œ¥(now) when C ‚â• Œ©
                CRR.molecular.C = 0;
                CRR.molecular.rupture = 1;
                CRR.cluster.L += 0.25;                     // Cascade ‚Üí cluster
                
                // Molecular rupture excites individual H‚ÇÇO molecules
                for (let i = 0; i < 5; i++) {
                    const mol = molecules[Math.floor(Math.random() * molecules.length)];
                    mol.vibration = 1.5;
                    mol.rotSpeed *= 1.5;
                }
            }
            CRR.molecular.rupture *= 0.9;
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // CLUSTER SCALE (Œ© = 5.0)
            // Hydrogen bond network dynamics
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            CRR.cluster.L += 0.008 + Math.random() * 0.012;
            CRR.cluster.C += CRR.cluster.L;               // C(t) = ‚à´L dœÑ
            CRR.cluster.L *= 0.92;
            
            if (CRR.cluster.C >= CRR.cluster.omega) {     // Œ¥(now) when C ‚â• Œ©
                CRR.cluster.C = 0;
                CRR.cluster.rupture = 1;
                CRR.surface.L += 0.35;                     // Cascade ‚Üí surface
                
                // Cluster rupture disrupts a random cluster's coherence
                const cluster = clusters[Math.floor(Math.random() * clusters.length)];
                cluster.coherence = 0;                     // Reset cluster coherence
                cluster.vx += (Math.random() - 0.5) * 0.005;
                cluster.vy += (Math.random() - 0.5) * 0.005;
            }
            CRR.cluster.rupture *= 0.92;
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // SURFACE SCALE (Œ© = 12.0)
            // Droplet interface tension dynamics
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            CRR.surface.L += 0.005 + Math.random() * 0.008;
            CRR.surface.C += CRR.surface.L;               // C(t) = ‚à´L dœÑ
            CRR.surface.L *= 0.94;
            
            if (CRR.surface.C >= CRR.surface.omega) {     // Œ¥(now) when C ‚â• Œ©
                CRR.surface.C = 0;
                CRR.surface.rupture = 1;
                CRR.neural.L += 0.5;                       // Cascade ‚Üí neural
                
                // Surface rupture creates visible wobble
                droplet.wobbleAmp = Math.min(0.008, droplet.wobbleAmp + 0.003);
            }
            CRR.surface.rupture *= 0.95;
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // NEURAL SCALE (Œ© = 30.0)
            // Perceptual/cognitive integration
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            CRR.neural.L += 0.003 + Math.random() * 0.004;
            CRR.neural.C += CRR.neural.L;                 // C(t) = ‚à´L dœÑ
            CRR.neural.L *= 0.96;
            
            if (CRR.neural.C >= CRR.neural.omega) {       // Œ¥(now) when C ‚â• Œ©
                CRR.neural.C = 0;
                CRR.neural.rupture = 1;
                // Neural rupture: perceptual "moment" completes
                // (No higher scale to cascade to in this simulation)
            }
            CRR.neural.rupture *= 0.97;
        }
        
        // =====================================================
        // PHYSICS UPDATE
        // =====================================================
        /*
         * PHYSICS UPDATE
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Updates all physical dynamics:
         * - Droplet wobble (surface tension)
         * - Caustic animation (internal refraction)
         * - Flow phase (convection)
         * - Cluster Brownian motion + coherence recovery
         * - Molecule Brownian motion + rotation
         * - Convection particle advection
         * - Hydrogen bond network update
         * 
         * COHERENCE RECOVERY (Regeneration):
         * Each cluster's coherence recovers at rate 0.01/frame,
         * implementing the regeneration phase of CRR where
         * systems rebuild coherence after rupture.
         */
        
        function updatePhysics(dt) {
            droplet.wobblePhase += 0.015;
            droplet.wobbleAmp *= 0.995;
            droplet.wobbleAmp = Math.min(0.01, droplet.wobbleAmp);
            
            droplet.causticPhase += 0.006;
            droplet.flowPhase += 0.004;
            
            // Update clusters (Brownian motion + coherence recovery)
            clusters.forEach(cluster => {
                cluster.x += cluster.vx;
                cluster.y += cluster.vy;
                
                // Brownian kicks (thermal fluctuation)
                cluster.vx += (Math.random() - 0.5) * 0.0003;
                cluster.vy += (Math.random() - 0.5) * 0.0003;
                
                // Damping
                cluster.vx *= 0.98;
                cluster.vy *= 0.98;
                
                // Boundary constraint (keep inside droplet)
                const r = Math.sqrt(cluster.x * cluster.x + cluster.y * cluster.y);
                if (r > 0.85) {
                    cluster.x *= 0.85 / r;
                    cluster.y *= 0.85 / r;
                    cluster.vx *= -0.5;
                    cluster.vy *= -0.5;
                }
                
                // Phase and coherence recovery (REGENERATION)
                cluster.phase += cluster.pulseSpeed;
                cluster.coherence += 0.01;                 // R: coherence rebuilds
                cluster.coherence = Math.min(1, cluster.coherence);
            });
            
            // Update molecules (Brownian + rotation)
            molecules.forEach(mol => {
                mol.x += mol.vx;
                mol.y += mol.vy;
                
                // Brownian motion
                mol.vx += (Math.random() - 0.5) * 0.0008;
                mol.vy += (Math.random() - 0.5) * 0.0008;
                mol.vx *= 0.97;
                mol.vy *= 0.97;
                
                // Boundary
                const r = Math.sqrt(mol.x * mol.x + mol.y * mol.y);
                if (r > 0.9) {
                    mol.x *= 0.9 / r;
                    mol.y *= 0.9 / r;
                    mol.vx *= -0.3;
                    mol.vy *= -0.3;
                }
                
                mol.rotation += mol.rotSpeed;
                mol.rotSpeed *= 0.995;
                mol.rotSpeed = Math.max(0.01, Math.abs(mol.rotSpeed)) * Math.sign(mol.rotSpeed || 1);
                mol.vibration *= 0.98;
                mol.vibration = Math.max(0.3, mol.vibration);
            });
            
            // Update flow particles (convection simulation)
            flowParticles.forEach(p => {
                // Circular convection pattern (toroidal flow)
                const angle = Math.atan2(p.y, p.x);
                const r = Math.sqrt(p.x * p.x + p.y * p.y);
                
                // Toroidal flow
                const flowAngle = angle + droplet.flowPhase;
                p.x += Math.cos(flowAngle + Math.PI/2) * p.speed * (1 - r);
                p.y += Math.sin(flowAngle + Math.PI/2) * p.speed * (1 - r);
                
                // Vertical component
                p.z += Math.sin(droplet.flowPhase * 2 + angle) * 0.002;
                p.z = Math.max(-0.8, Math.min(0.8, p.z));
                
                // Reset if outside
                const newR = Math.sqrt(p.x * p.x + p.y * p.y);
                if (newR > 0.85) {
                    const newTheta = Math.random() * Math.PI * 2;
                    const newRad = Math.random() * 0.3;
                    p.x = Math.cos(newTheta) * newRad;
                    p.y = Math.sin(newTheta) * newRad;
                }
                
                p.age += 0.005;
                if (p.age > 1) p.age = 0;
            });
            
            // Periodically update H-bonds
            if (Math.random() < 0.02) {
                updateHBonds();
            }
            
            // Update H-bond phases
            hBonds.forEach(bond => {
                bond.phase += 0.03;
            });
        }
        
        // =====================================================
        // GET DROPLET RADIUS
        // =====================================================
        
        function getRadius(theta) {
            let r = droplet.baseRadius;
            const wobble = droplet.wobbleAmp * droplet.baseRadius;
            r += wobble * Math.cos(2 * theta + droplet.wobblePhase);
            r += droplet.baseRadius * 0.004 * Math.cos(theta - Math.PI/2);
            return r;
        }
        
        // =====================================================
        // 3D PROJECTION
        // =====================================================
        
        function project3D(x, y, z, cx, cy, radius) {
            const fov = 600;
            const scale = fov / (fov + z * radius * 0.5);
            return {
                x: cx + x * radius * scale,
                y: cy + y * radius * scale,
                scale: scale,
                depth: z
            };
        }
        
        // =====================================================
        // RENDERING
        // =====================================================
        
        function render() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cx = droplet.cx;
            const cy = droplet.cy;
            
            renderEnvironment(w, h);
            renderContactShadow(cx, cy);
            
            // Main droplet
            ctx.save();
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.clip();
            
            // VERY translucent water body
            renderWaterBody(cx, cy);
            
            // Internal dynamics (always visible, enhanced in physics mode)
            renderInternalDynamics(cx, cy, showPhysics);
            
            // Caustics
            renderCaustics(cx, cy);
            
            // Subsurface
            renderSubsurface(cx, cy);
            
            ctx.restore();
            
            // Surface effects
            renderFresnelRim(cx, cy);
            renderEnvironmentReflection(cx, cy);
            renderSpecularHighlights(cx, cy);
            renderEdge(cx, cy);
            
            // CRR overlay
            if (showPhysics) {
                renderCRROverlay(cx, cy);
            }
        }
        
        function renderEnvironment(w, h) {
            const bgGrad = ctx.createLinearGradient(0, 0, 0, h);
            bgGrad.addColorStop(0, '#404040');
            bgGrad.addColorStop(0.35, '#333333');
            bgGrad.addColorStop(0.65, '#2a2a2a');
            bgGrad.addColorStop(1, '#1f1f1f');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Texture
            ctx.globalAlpha = 0.015;
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = 25 + Math.random() * 45;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, '#666');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function renderContactShadow(cx, cy) {
            const r = droplet.baseRadius;
            const shadowY = cy + r * 0.96;
            
            const outer = ctx.createRadialGradient(cx, shadowY + 15, 0, cx, shadowY + 15, r * 1.2);
            outer.addColorStop(0, 'rgba(0, 0, 0, 0.35)');
            outer.addColorStop(0.4, 'rgba(0, 0, 0, 0.15)');
            outer.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = outer;
            ctx.beginPath();
            ctx.ellipse(cx, shadowY + 15, r * 1.0, r * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            
            const inner = ctx.createRadialGradient(cx, shadowY + 3, 0, cx, shadowY + 3, r * 0.4);
            inner.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            inner.addColorStop(0.6, 'rgba(0, 0, 0, 0.2)');
            inner.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = inner;
            ctx.beginPath();
            ctx.ellipse(cx, shadowY + 3, r * 0.35, r * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderWaterBody(cx, cy) {
            const r = droplet.baseRadius;
            
            // MUCH more translucent - like glass
            const water = ctx.createRadialGradient(
                cx - r * 0.1, cy - r * 0.15, 0,
                cx, cy, r * 1.1
            );
            
            // Very low opacity - you can see through it
            water.addColorStop(0, 'rgba(255, 255, 255, 0.12)');
            water.addColorStop(0.2, 'rgba(248, 252, 255, 0.10)');
            water.addColorStop(0.4, 'rgba(240, 248, 255, 0.08)');
            water.addColorStop(0.6, 'rgba(230, 242, 252, 0.06)');
            water.addColorStop(0.8, 'rgba(220, 235, 250, 0.05)');
            water.addColorStop(1, 'rgba(210, 228, 245, 0.04)');
            
            ctx.fillStyle = water;
            ctx.fillRect(cx - r * 1.5, cy - r * 1.5, r * 3, r * 3);
            
            // Very subtle blue tint
            const tint = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            tint.addColorStop(0, 'rgba(200, 225, 255, 0.04)');
            tint.addColorStop(0.5, 'rgba(190, 220, 250, 0.025)');
            tint.addColorStop(1, 'rgba(180, 215, 245, 0.015)');
            ctx.fillStyle = tint;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderInternalDynamics(cx, cy, enhanced) {
            const r = droplet.baseRadius;
            const baseAlpha = enhanced ? 1 : 0.4;
            
            // Sort everything by depth for proper rendering
            const allItems = [];
            
            // Add clusters
            clusters.forEach((cluster, i) => {
                allItems.push({ type: 'cluster', data: cluster, index: i, z: cluster.z });
            });
            
            // Add molecules
            molecules.forEach((mol, i) => {
                allItems.push({ type: 'molecule', data: mol, index: i, z: mol.z });
            });
            
            // Add flow particles
            flowParticles.forEach((p, i) => {
                allItems.push({ type: 'flow', data: p, index: i, z: p.z });
            });
            
            // Sort back to front
            allItems.sort((a, b) => a.z - b.z);
            
            // Draw H-bonds first (behind everything)
            if (enhanced) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                
                hBonds.forEach(bond => {
                    const c1 = clusters[bond.from];
                    const c2 = clusters[bond.to];
                    
                    const p1 = project3D(c1.x, c1.y, c1.z, cx, cy, r);
                    const p2 = project3D(c2.x, c2.y, c2.z, cx, cy, r);
                    
                    const pulse = 0.5 + Math.sin(bond.phase) * 0.5;
                    
                    ctx.strokeStyle = `rgba(100, 180, 255, ${bond.strength * pulse * 0.5})`;
                    ctx.lineWidth = 1 + bond.strength;
                    ctx.setLineDash([3, 3]);
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
                ctx.restore();
            }
            
            // Draw items
            allItems.forEach(item => {
                if (item.type === 'cluster') {
                    drawCluster(item.data, cx, cy, r, baseAlpha, enhanced);
                } else if (item.type === 'molecule') {
                    drawMolecule(item.data, cx, cy, r, baseAlpha, enhanced);
                } else if (item.type === 'flow') {
                    drawFlowParticle(item.data, cx, cy, r, baseAlpha, enhanced);
                }
            });
        }
        
        /*
         * CLUSTER RENDERING
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Clusters are rendered with alpha modulated by their
         * coherence value. This implements the exp(C/Œ©) memory
         * weighting visually: high coherence = more visible.
         */
        function drawCluster(cluster, cx, cy, r, baseAlpha, enhanced) {
            const p = project3D(cluster.x, cluster.y, cluster.z, cx, cy, r);
            const size = cluster.size * r * p.scale;
            
            const pulse = 0.7 + Math.sin(cluster.phase) * 0.3;
            // COHERENCE MODULATES ALPHA (implicit exp(C/Œ©))
            const alpha = baseAlpha * (0.3 + cluster.coherence * 0.7) * pulse;
            const depthFade = 0.5 + (cluster.z + 1) * 0.25;
            
            if (enhanced) {
                // Outer glow
                const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2.5);
                glow.addColorStop(0, `rgba(150, 200, 255, ${alpha * depthFade * 0.3})`);
                glow.addColorStop(0.5, `rgba(130, 190, 255, ${alpha * depthFade * 0.15})`);
                glow.addColorStop(1, 'rgba(120, 180, 255, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Core
            const core = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
            core.addColorStop(0, `rgba(200, 230, 255, ${alpha * depthFade * 0.6})`);
            core.addColorStop(0.5, `rgba(170, 210, 250, ${alpha * depthFade * 0.3})`);
            core.addColorStop(1, `rgba(150, 200, 245, 0)`);
            ctx.fillStyle = core;
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Tetrahedral hint (in enhanced mode)
            if (enhanced && cluster.coherence > 0.5) {
                ctx.strokeStyle = `rgba(180, 220, 255, ${alpha * depthFade * 0.2})`;
                ctx.lineWidth = 0.5;
                for (let i = 0; i < 4; i++) {
                    const angle = cluster.phase + (i / 4) * Math.PI * 2;
                    const len = size * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(angle) * len, p.y + Math.sin(angle) * len * 0.6);
                    ctx.stroke();
                }
            }
        }
        
        /*
         * MOLECULE RENDERING (H‚ÇÇO)
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Individual water molecules with correct geometry:
         * - O-H bond angle: 104.45¬∞ (experimental value)
         * - Oxygen shown as larger red sphere
         * - Hydrogens as smaller white spheres
         */
        function drawMolecule(mol, cx, cy, r, baseAlpha, enhanced) {
            const p = project3D(mol.x, mol.y, mol.z, cx, cy, r);
            const size = 3 * p.scale;
            const alpha = baseAlpha * mol.vibration * 0.5;
            const depthFade = 0.4 + (mol.z + 1) * 0.3;
            
            if (!enhanced) {
                // Simple dot in pure mode
                ctx.fillStyle = `rgba(220, 240, 255, ${alpha * depthFade * 0.4})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            
            // H‚ÇÇO structure in enhanced mode
            const bondLen = size * 2;
            const bondAngle = 104.45 * Math.PI / 180;  // Exact H-O-H angle
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(mol.rotation);
            
            // Oxygen (center) - red
            const oGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            oGrad.addColorStop(0, `rgba(255, 120, 120, ${alpha * depthFade * 0.7})`);
            oGrad.addColorStop(0.5, `rgba(255, 100, 100, ${alpha * depthFade * 0.4})`);
            oGrad.addColorStop(1, 'rgba(255, 80, 80, 0)');
            ctx.fillStyle = oGrad;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Hydrogen positions (104.45¬∞ apart)
            const h1x = Math.cos(-bondAngle/2) * bondLen;
            const h1y = Math.sin(-bondAngle/2) * bondLen;
            const h2x = Math.cos(bondAngle/2) * bondLen;
            const h2y = Math.sin(bondAngle/2) * bondLen;
            
            // O-H bonds
            ctx.strokeStyle = `rgba(200, 220, 240, ${alpha * depthFade * 0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(h1x, h1y);
            ctx.moveTo(0, 0);
            ctx.lineTo(h2x, h2y);
            ctx.stroke();
            
            // H atoms - white
            const hSize = size * 0.5;
            [{ x: h1x, y: h1y }, { x: h2x, y: h2y }].forEach(h => {
                const hGrad = ctx.createRadialGradient(h.x, h.y, 0, h.x, h.y, hSize);
                hGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha * depthFade * 0.8})`);
                hGrad.addColorStop(0.5, `rgba(240, 250, 255, ${alpha * depthFade * 0.4})`);
                hGrad.addColorStop(1, 'rgba(230, 245, 255, 0)');
                ctx.fillStyle = hGrad;
                ctx.beginPath();
                ctx.arc(h.x, h.y, hSize, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }
        
        function drawFlowParticle(p, cx, cy, r, baseAlpha, enhanced) {
            const proj = project3D(p.x, p.y, p.z, cx, cy, r);
            const size = 2 * proj.scale;
            const alpha = baseAlpha * (1 - p.age) * 0.3;
            const depthFade = 0.3 + (p.z + 1) * 0.35;
            
            if (!enhanced) return;  // Only show in physics mode
            
            // Flow line (shows direction)
            const angle = Math.atan2(p.y, p.x) + Math.PI/2;
            const tailLen = 8 * proj.scale;
            
            const grad = ctx.createLinearGradient(
                proj.x - Math.cos(angle) * tailLen,
                proj.y - Math.sin(angle) * tailLen,
                proj.x, proj.y
            );
            grad.addColorStop(0, 'rgba(100, 255, 200, 0)');
            grad.addColorStop(1, `rgba(100, 255, 200, ${alpha * depthFade})`);
            
            ctx.strokeStyle = grad;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(proj.x - Math.cos(angle) * tailLen, proj.y - Math.sin(angle) * tailLen);
            ctx.lineTo(proj.x, proj.y);
            ctx.stroke();
            
            // Head
            ctx.fillStyle = `rgba(150, 255, 220, ${alpha * depthFade * 1.5})`;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderCaustics(cx, cy) {
            const r = droplet.baseRadius;
            const t = droplet.causticPhase;
            
            for (let i = 0; i < 18; i++) {
                const baseAngle = (i / 18) * Math.PI * 2;
                const angle = baseAngle + Math.sin(t * 0.35 + i * 0.6) * 0.18;
                const dist = r * (0.25 + (i % 4) * 0.12);
                const rDist = dist + Math.sin(t * 0.7 + i * 0.45) * 10;
                
                const x = cx + Math.cos(angle) * rDist;
                const y = cy + Math.sin(angle) * rDist * 0.8;
                
                const size = 6 + Math.sin(t * 0.5 + i * 0.9) * 4;
                const alpha = 0.018 + Math.sin(t * 0.6 + i) * 0.008;
                
                const caustic = ctx.createRadialGradient(x, y, 0, x, y, size);
                caustic.addColorStop(0, `rgba(255, 255, 255, ${alpha * 1.4})`);
                caustic.addColorStop(0.4, `rgba(255, 255, 255, ${alpha * 0.7})`);
                caustic.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(1.2, 0.5);
                ctx.fillStyle = caustic;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        function renderSubsurface(cx, cy) {
            const r = droplet.baseRadius;
            
            const sss = ctx.createRadialGradient(cx, cy - r * 0.35, r * 0.06, cx, cy, r);
            sss.addColorStop(0, 'rgba(255, 255, 255, 0.06)');
            sss.addColorStop(0.4, 'rgba(255, 255, 255, 0.025)');
            sss.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = sss;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        /*
         * FRESNEL RIM LIGHTING
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Uses the fresnelReflectance() function to compute
         * physically-correct rim lighting intensity based on
         * viewing angle and water's refractive index.
         */
        function renderFresnelRim(cx, cy) {
            const r = droplet.baseRadius;
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            for (let i = 0; i <= 360; i += 1) {
                const theta = (i / 360) * Math.PI * 2;
                const radius = getRadius(theta);
                const x = cx + Math.cos(theta) * radius;
                const y = cy + Math.sin(theta) * radius;
                
                // Compute Fresnel reflectance at grazing angle
                const R = fresnelReflectance(1.0, WATER.n_D, 0.1);
                const lightAngle = -Math.PI * 0.65;
                const angleDiff = Math.abs(theta - lightAngle);
                const lightFactor = Math.pow(Math.cos(angleDiff * 0.5), 2);
                const heightFactor = 0.3 + 0.7 * (1 - (Math.sin(theta) + 1) * 0.5);
                const intensity = R * lightFactor * heightFactor;
                
                if (intensity > 0.03) {
                    const rimGrad = ctx.createRadialGradient(x, y, 0, x, y, 4);
                    rimGrad.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.6})`);
                    rimGrad.addColorStop(0.4, `rgba(255, 255, 255, ${intensity * 0.3})`);
                    rimGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = rimGrad;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function renderEnvironmentReflection(cx, cy) {
            const r = droplet.baseRadius;
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            const reflect = ctx.createLinearGradient(
                cx - r * 0.45, cy - r * 0.35,
                cx + r * 0.45, cy - r * 0.1
            );
            reflect.addColorStop(0, 'rgba(220, 230, 240, 0)');
            reflect.addColorStop(0.25, 'rgba(235, 245, 255, 0.035)');
            reflect.addColorStop(0.5, 'rgba(250, 255, 255, 0.06)');
            reflect.addColorStop(0.75, 'rgba(235, 245, 255, 0.035)');
            reflect.addColorStop(1, 'rgba(220, 230, 240, 0)');
            ctx.fillStyle = reflect;
            ctx.beginPath();
            ctx.ellipse(cx, cy - r * 0.24, r * 0.5, r * 0.14, -0.05, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function renderSpecularHighlights(cx, cy) {
            const r = droplet.baseRadius;
            const hlX = cx - r * 0.24;
            const hlY = cy - r * 0.26;
            
            // Outer glow
            const glow = ctx.createRadialGradient(hlX, hlY, 0, hlX, hlY, r * 0.35);
            glow.addColorStop(0, 'rgba(255, 255, 255, 0.25)');
            glow.addColorStop(0.35, 'rgba(255, 255, 255, 0.12)');
            glow.addColorStop(0.7, 'rgba(255, 255, 255, 0.03)');
            glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(hlX, hlY, r * 0.35, 0, Math.PI * 2);
            ctx.fill();
            
            // Main highlight
            ctx.save();
            ctx.translate(hlX, hlY);
            ctx.rotate(-0.15);
            ctx.scale(1.05, 0.75);
            
            const main = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.14);
            main.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
            main.addColorStop(0.2, 'rgba(255, 255, 255, 0.85)');
            main.addColorStop(0.5, 'rgba(255, 255, 255, 0.38)');
            main.addColorStop(0.8, 'rgba(255, 255, 255, 0.08)');
            main.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.14, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Sharp spark
            const sparkX = hlX - r * 0.05;
            const sparkY = hlY - r * 0.03;
            const spark = ctx.createRadialGradient(sparkX, sparkY, 0, sparkX, sparkY, 6);
            spark.addColorStop(0, 'rgba(255, 255, 255, 1)');
            spark.addColorStop(0.4, 'rgba(255, 255, 255, 0.85)');
            spark.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = spark;
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary spark
            const spark2 = ctx.createRadialGradient(sparkX + 9, sparkY + 4, 0, sparkX + 9, sparkY + 4, 3);
            spark2.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            spark2.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = spark2;
            ctx.beginPath();
            ctx.arc(sparkX + 9, sparkY + 4, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary highlights
            const secondaries = [
                { x: 0.16, y: -0.44, r: 0.045, a: 0.28 },
                { x: 0.34, y: -0.18, r: 0.03, a: 0.2 },
                { x: -0.36, y: 0.24, r: 0.05, a: 0.08 },
                { x: 0.26, y: 0.31, r: 0.035, a: 0.06 },
                { x: 0.41, y: 0.03, r: 0.02, a: 0.1 },
            ];
            
            secondaries.forEach(hl => {
                const x = cx + r * hl.x;
                const y = cy + r * hl.y;
                const size = r * hl.r;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                grad.addColorStop(0, `rgba(255, 255, 255, ${hl.a})`);
                grad.addColorStop(0.45, `rgba(255, 255, 255, ${hl.a * 0.35})`);
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function renderEdge(cx, cy) {
            ctx.save();
            
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const radius = getRadius(theta) + 1;
                const x = cx + Math.cos(theta) * radius;
                const y = cy + Math.sin(theta) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(200, 225, 255, 0.05)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const radius = getRadius(theta);
                const x = cx + Math.cos(theta) * radius;
                const y = cy + Math.sin(theta) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(80, 100, 120, 0.1)';
            ctx.lineWidth = 0.8;
            ctx.stroke();
            
            ctx.restore();
        }
        
        /*
         * CRR DYNAMICS OVERLAY
         * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
         * Visual representation of CRR state at each scale.
         * Bar shows C/Œ© ratio (coherence progress toward rupture).
         * Flash indicates recent rupture event.
         */
        function renderCRROverlay(cx, cy) {
            const r = droplet.baseRadius;
            
            ctx.save();
            
            // CRR panel
            const panelW = 180;
            const panelH = 140;
            const panelX = cx + r + 25;
            const panelY = cy - panelH / 2;
            
            // Panel background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.roundRect(panelX, panelY, panelW, panelH, 6);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Title
            ctx.font = '10px -apple-system, sans-serif';
            ctx.fillStyle = 'rgba(100, 180, 255, 0.8)';
            ctx.textAlign = 'left';
            ctx.fillText('CRR DYNAMICS', panelX + 10, panelY + 18);
            
            // CRR bars - each shows C/Œ© progress
            const scales = [
                { name: 'Photon', data: CRR.photon, color: '#ff6b6b' },
                { name: 'Molecular', data: CRR.molecular, color: '#ffeaa7' },
                { name: 'Cluster', data: CRR.cluster, color: '#74b9ff' },
                { name: 'Surface', data: CRR.surface, color: '#55efc4' },
                { name: 'Neural', data: CRR.neural, color: '#a29bfe' }
            ];
            
            scales.forEach((scale, i) => {
                const y = panelY + 35 + i * 20;
                const barW = 80;
                const barH = 6;
                const barX = panelX + 70;
                
                // Label
                ctx.font = '9px SF Mono, Monaco, monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'right';
                ctx.fillText(scale.name, barX - 8, y + 5);
                
                // Bar background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.roundRect(barX, y, barW, barH, 2);
                ctx.fill();
                
                // Bar fill (C/Œ© ratio)
                const ratio = Math.min(scale.data.C / scale.data.omega, 1);
                ctx.fillStyle = scale.color;
                ctx.beginPath();
                ctx.roundRect(barX, y, barW * ratio, barH, 2);
                ctx.fill();
                
                // Rupture flash (Œ¥ event indicator)
                if (scale.data.rupture > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${scale.data.rupture * 0.4})`;
                    ctx.beginPath();
                    ctx.roundRect(barX, y, barW, barH, 2);
                    ctx.fill();
                }
            });
            
            // Physics info
            const infoY = panelY + panelH + 15;
            ctx.font = '9px SF Mono, Monaco, monospace';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.textAlign = 'left';
            ctx.fillText(`n = ${WATER.n_D.toFixed(4)}`, panelX, infoY);
            ctx.fillText(`Clusters: ${clusters.length}`, panelX, infoY + 14);
            ctx.fillText(`H-bonds: ${hBonds.length}`, panelX, infoY + 28);
            ctx.fillText(`Molecules: ${molecules.length}`, panelX, infoY + 42);
            
            ctx.restore();
        }
        
        // =====================================================
        // ANIMATION LOOP
        // =====================================================
        
        let lastTime = 0;
        
        function animate(timestamp) {
            frameCount++;
            if (timestamp - lastSecond >= 1000) {
                actualRefreshRate = frameCount;
                frameCount = 0;
                lastSecond = timestamp;
                document.getElementById('refreshRate').textContent = actualRefreshRate;
            }
            
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            
            updateCRR(dt);
            updatePhysics(dt);
            render();
            
            requestAnimationFrame(animate);
        }
        
        requestAnimationFrame(animate);
        
    </script>
</body>
</html>
