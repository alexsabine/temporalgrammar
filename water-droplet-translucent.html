<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplet ‚Äî Translucent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a1a;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 1000;
        }
        
        .ctrl-btn {
            padding: 10px 18px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.7);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            font-size: 11px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            letter-spacing: 0.3px;
        }
        
        .ctrl-btn:hover {
            background: rgba(30, 30, 30, 0.95);
            border-color: rgba(255, 255, 255, 0.25);
            color: #fff;
        }
        
        .ctrl-btn.active {
            background: rgba(60, 130, 180, 0.3);
            border-color: rgba(100, 180, 255, 0.5);
            color: #fff;
        }
        
        .info-overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            line-height: 1.6;
            z-index: 1000;
            display: none;
        }
        
        .info-overlay.visible {
            display: block;
        }
        
        .info-overlay .label {
            color: rgba(100, 180, 255, 0.6);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="info-overlay" id="infoOverlay">
        <span class="label">OPTICAL PIPELINE</span><br>
        Photon ‚Üí Fresnel ‚Üí Screen ‚Üí Retina ‚Üí V1<br><br>
        <span class="label">n(water)</span> = 1.333 @ 589nm<br>
        <span class="label">Display</span> = <span id="refreshRate">60</span>Hz<br><br>
        <span class="label">INTERNAL DYNAMICS</span><br>
        H‚ÇÇO clusters ‚Ä¢ Convection ‚Ä¢ H-bonds
    </div>
    
    <div class="controls">
        <button class="ctrl-btn" id="infoBtn">‚Ñπ Info</button>
        <button class="ctrl-btn" id="physicsBtn">‚öõ Physics</button>
        <button class="ctrl-btn active" id="pureBtn">üíß Pure</button>
        <button class="ctrl-btn" id="soundBtn">üîä Sound</button>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // =====================================================
        // WATER SOUNDSCAPE ENGINE
        // =====================================================
        
        class WaterSoundscape {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.enabled = false;
                this.masterGain = null;
            }
            
            async init() {
                if (this.initialized) return;
                
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master output with compression for smooth dynamics
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                this.compressor.connect(this.ctx.destination);
                
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0;
                this.masterGain.connect(this.compressor);
                
                // === MOLECULAR LAYER: High crystalline shimmer ===
                // Represents H‚ÇÇO bond vibrations (O-H stretch ~3400 cm‚Åª¬π)
                this.molecularOsc1 = this.ctx.createOscillator();
                this.molecularOsc1.type = 'sine';
                this.molecularOsc1.frequency.value = 2200;
                
                this.molecularOsc2 = this.ctx.createOscillator();
                this.molecularOsc2.type = 'sine';
                this.molecularOsc2.frequency.value = 2450;
                
                this.molecularOsc3 = this.ctx.createOscillator();
                this.molecularOsc3.type = 'sine';
                this.molecularOsc3.frequency.value = 2680;
                
                // Shimmer LFO
                this.molecularLFO = this.ctx.createOscillator();
                this.molecularLFO.type = 'sine';
                this.molecularLFO.frequency.value = 6;
                this.molecularLFOGain = this.ctx.createGain();
                this.molecularLFOGain.gain.value = 60;
                this.molecularLFO.connect(this.molecularLFOGain);
                this.molecularLFOGain.connect(this.molecularOsc1.frequency);
                this.molecularLFOGain.connect(this.molecularOsc2.frequency);
                
                this.molecularFilter = this.ctx.createBiquadFilter();
                this.molecularFilter.type = 'bandpass';
                this.molecularFilter.frequency.value = 2400;
                this.molecularFilter.Q.value = 8;
                
                this.molecularGain = this.ctx.createGain();
                this.molecularGain.gain.value = 0;
                
                this.molecularOsc1.connect(this.molecularFilter);
                this.molecularOsc2.connect(this.molecularFilter);
                this.molecularOsc3.connect(this.molecularFilter);
                this.molecularFilter.connect(this.molecularGain);
                this.molecularGain.connect(this.masterGain);
                
                this.molecularOsc1.start();
                this.molecularOsc2.start();
                this.molecularOsc3.start();
                this.molecularLFO.start();
                
                // === CLUSTER LAYER: Mid-range liquid resonance ===
                // H-bond network collective modes
                this.clusterOsc1 = this.ctx.createOscillator();
                this.clusterOsc1.type = 'triangle';
                this.clusterOsc1.frequency.value = 380;
                
                this.clusterOsc2 = this.ctx.createOscillator();
                this.clusterOsc2.type = 'triangle';
                this.clusterOsc2.frequency.value = 480;
                
                this.clusterOsc3 = this.ctx.createOscillator();
                this.clusterOsc3.type = 'sine';
                this.clusterOsc3.frequency.value = 285;
                
                this.clusterFilter = this.ctx.createBiquadFilter();
                this.clusterFilter.type = 'lowpass';
                this.clusterFilter.frequency.value = 600;
                this.clusterFilter.Q.value = 2;
                
                this.clusterGain = this.ctx.createGain();
                this.clusterGain.gain.value = 0;
                
                this.clusterOsc1.connect(this.clusterFilter);
                this.clusterOsc2.connect(this.clusterFilter);
                this.clusterOsc3.connect(this.clusterFilter);
                this.clusterFilter.connect(this.clusterGain);
                this.clusterGain.connect(this.masterGain);
                
                this.clusterOsc1.start();
                this.clusterOsc2.start();
                this.clusterOsc3.start();
                
                // === SURFACE LAYER: Deep droplet resonance ===
                // Capillary wave modes
                this.surfaceOsc1 = this.ctx.createOscillator();
                this.surfaceOsc1.type = 'sine';
                this.surfaceOsc1.frequency.value = 65;
                
                this.surfaceOsc2 = this.ctx.createOscillator();
                this.surfaceOsc2.type = 'sine';
                this.surfaceOsc2.frequency.value = 98;
                
                this.surfaceOsc3 = this.ctx.createOscillator();
                this.surfaceOsc3.type = 'sine';
                this.surfaceOsc3.frequency.value = 130;
                
                this.surfaceGain = this.ctx.createGain();
                this.surfaceGain.gain.value = 0;
                
                this.surfaceOsc1.connect(this.surfaceGain);
                this.surfaceOsc2.connect(this.surfaceGain);
                this.surfaceOsc3.connect(this.surfaceGain);
                this.surfaceGain.connect(this.masterGain);
                
                this.surfaceOsc1.start();
                this.surfaceOsc2.start();
                this.surfaceOsc3.start();
                
                // === FLOW LAYER: Whooshy convection ===
                this.flowNoise = this.createFilteredNoise('pink');
                this.flowFilter = this.ctx.createBiquadFilter();
                this.flowFilter.type = 'bandpass';
                this.flowFilter.frequency.value = 800;
                this.flowFilter.Q.value = 0.8;
                
                this.flowGain = this.ctx.createGain();
                this.flowGain.gain.value = 0;
                
                this.flowNoise.connect(this.flowFilter);
                this.flowFilter.connect(this.flowGain);
                this.flowGain.connect(this.masterGain);
                
                // === AMBIENT WATER TEXTURE ===
                this.ambientNoise = this.createFilteredNoise('brown');
                this.ambientFilter = this.ctx.createBiquadFilter();
                this.ambientFilter.type = 'lowpass';
                this.ambientFilter.frequency.value = 300;
                this.ambientFilter.Q.value = 1;
                
                this.ambientGain = this.ctx.createGain();
                this.ambientGain.gain.value = 0;
                
                this.ambientNoise.connect(this.ambientFilter);
                this.ambientFilter.connect(this.ambientGain);
                this.ambientGain.connect(this.masterGain);
                
                // === COHERENCE TONE: Rising tension before rupture ===
                this.coherenceOsc = this.ctx.createOscillator();
                this.coherenceOsc.type = 'sine';
                this.coherenceOsc.frequency.value = 180;
                
                this.coherenceFilter = this.ctx.createBiquadFilter();
                this.coherenceFilter.type = 'bandpass';
                this.coherenceFilter.frequency.value = 180;
                this.coherenceFilter.Q.value = 15;
                
                this.coherenceGain = this.ctx.createGain();
                this.coherenceGain.gain.value = 0;
                
                this.coherenceOsc.connect(this.coherenceFilter);
                this.coherenceFilter.connect(this.coherenceGain);
                this.coherenceGain.connect(this.masterGain);
                this.coherenceOsc.start();
                
                this.initialized = true;
                console.log('üíß Water soundscape initialized');
            }
            
            createFilteredNoise(type) {
                const bufferSize = 2 * this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);
                
                if (type === 'pink') {
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                        b6 = white * 0.115926;
                    }
                } else if (type === 'brown') {
                    let lastOut = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        output[i] = (lastOut + 0.02 * white) / 1.02;
                        lastOut = output[i];
                        output[i] *= 3.5;
                    }
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                noise.start();
                return noise;
            }
            
            update(crrState, flowIntensity) {
                if (!this.initialized || !this.enabled) return;
                
                const t = this.ctx.currentTime;
                const ramp = 0.1;
                
                // Molecular layer - responds to molecular CRR
                const molRatio = crrState.molecular.C / crrState.molecular.omega;
                const molVol = 0.015 + molRatio * 0.025;
                const molFreq = 2200 + molRatio * 400;
                this.molecularGain.gain.linearRampToValueAtTime(molVol, t + ramp);
                this.molecularFilter.frequency.linearRampToValueAtTime(molFreq, t + ramp);
                this.molecularLFO.frequency.linearRampToValueAtTime(4 + molRatio * 8, t + ramp);
                
                // Cluster layer - responds to cluster CRR
                const clustRatio = crrState.cluster.C / crrState.cluster.omega;
                const clustVol = 0.02 + clustRatio * 0.03;
                const clustFreq = 320 + clustRatio * 150;
                this.clusterGain.gain.linearRampToValueAtTime(clustVol, t + ramp);
                this.clusterOsc1.frequency.linearRampToValueAtTime(clustFreq, t + ramp);
                this.clusterOsc2.frequency.linearRampToValueAtTime(clustFreq * 1.26, t + ramp);
                this.clusterOsc3.frequency.linearRampToValueAtTime(clustFreq * 0.75, t + ramp);
                
                // Surface layer - responds to surface CRR
                const surfRatio = crrState.surface.C / crrState.surface.omega;
                const surfVol = 0.03 + surfRatio * 0.04;
                const surfFreq = 55 + surfRatio * 30;
                this.surfaceGain.gain.linearRampToValueAtTime(surfVol, t + ramp);
                this.surfaceOsc1.frequency.linearRampToValueAtTime(surfFreq, t + ramp);
                this.surfaceOsc2.frequency.linearRampToValueAtTime(surfFreq * 1.5, t + ramp);
                this.surfaceOsc3.frequency.linearRampToValueAtTime(surfFreq * 2, t + ramp);
                
                // Flow layer
                const flowVol = 0.008 + flowIntensity * 0.012;
                this.flowGain.gain.linearRampToValueAtTime(flowVol, t + ramp);
                this.flowFilter.frequency.linearRampToValueAtTime(600 + flowIntensity * 400, t + ramp);
                
                // Ambient texture
                this.ambientGain.gain.linearRampToValueAtTime(0.012, t + ramp);
                
                // Coherence tone - average of all scales
                const avgRatio = (molRatio + clustRatio + surfRatio) / 3;
                const cohVol = avgRatio * 0.025;
                const cohFreq = 150 + avgRatio * 180;
                this.coherenceGain.gain.linearRampToValueAtTime(cohVol, t + ramp);
                this.coherenceOsc.frequency.linearRampToValueAtTime(cohFreq, t + ramp);
                this.coherenceFilter.frequency.linearRampToValueAtTime(cohFreq, t + ramp);
            }
            
            triggerPhotonRupture() {
                if (!this.initialized || !this.enabled) return;
                const t = this.ctx.currentTime;
                
                // Tiny crystalline tick
                const tick = this.ctx.createOscillator();
                tick.type = 'sine';
                tick.frequency.value = 4000 + Math.random() * 2000;
                tick.frequency.exponentialRampToValueAtTime(2000, t + 0.05);
                
                const tickGain = this.ctx.createGain();
                tickGain.gain.value = 0.03;
                tickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                
                tick.connect(tickGain);
                tickGain.connect(this.masterGain);
                tick.start();
                tick.stop(t + 0.05);
            }
            
            triggerMolecularRupture() {
                if (!this.initialized || !this.enabled) return;
                const t = this.ctx.currentTime;
                
                // High-pitched crystalline ping
                const ping = this.ctx.createOscillator();
                ping.type = 'sine';
                ping.frequency.value = 2800 + Math.random() * 800;
                ping.frequency.exponentialRampToValueAtTime(1400, t + 0.18);
                
                const pingGain = this.ctx.createGain();
                pingGain.gain.value = 0.06;
                pingGain.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
                
                // Add slight reverb feel with delay
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.03;
                const delayGain = this.ctx.createGain();
                delayGain.gain.value = 0.3;
                
                ping.connect(pingGain);
                ping.connect(delay);
                delay.connect(delayGain);
                delayGain.connect(pingGain);
                pingGain.connect(this.masterGain);
                ping.start();
                ping.stop(t + 0.2);
            }
            
            triggerClusterRupture() {
                if (!this.initialized || !this.enabled) return;
                const t = this.ctx.currentTime;
                
                // Liquid "glub" - H-bond network reorganization
                const glub = this.ctx.createOscillator();
                glub.type = 'sine';
                glub.frequency.value = 500 + Math.random() * 150;
                glub.frequency.exponentialRampToValueAtTime(180, t + 0.22);
                
                const glubGain = this.ctx.createGain();
                glubGain.gain.value = 0.08;
                glubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
                
                // Second harmonic
                const glub2 = this.ctx.createOscillator();
                glub2.type = 'triangle';
                glub2.frequency.value = 350;
                glub2.frequency.exponentialRampToValueAtTime(120, t + 0.2);
                
                const glub2Gain = this.ctx.createGain();
                glub2Gain.gain.value = 0.04;
                glub2Gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                
                glub.connect(glubGain);
                glub2.connect(glub2Gain);
                glubGain.connect(this.masterGain);
                glub2Gain.connect(this.masterGain);
                glub.start();
                glub2.start();
                glub.stop(t + 0.25);
                glub2.stop(t + 0.2);
            }
            
            triggerSurfaceRupture() {
                if (!this.initialized || !this.enabled) return;
                const t = this.ctx.currentTime;
                
                // Deep resonant "bloop" - capillary wave excitation
                const bloop = this.ctx.createOscillator();
                bloop.type = 'sine';
                bloop.frequency.value = 140;
                bloop.frequency.exponentialRampToValueAtTime(50, t + 0.4);
                
                const bloopGain = this.ctx.createGain();
                bloopGain.gain.value = 0.12;
                bloopGain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                
                // Harmonics
                const bloop2 = this.ctx.createOscillator();
                bloop2.type = 'sine';
                bloop2.frequency.value = 280;
                bloop2.frequency.exponentialRampToValueAtTime(100, t + 0.35);
                
                const bloop2Gain = this.ctx.createGain();
                bloop2Gain.gain.value = 0.05;
                bloop2Gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
                
                const bloop3 = this.ctx.createOscillator();
                bloop3.type = 'sine';
                bloop3.frequency.value = 420;
                bloop3.frequency.exponentialRampToValueAtTime(150, t + 0.25);
                
                const bloop3Gain = this.ctx.createGain();
                bloop3Gain.gain.value = 0.025;
                bloop3Gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
                
                bloop.connect(bloopGain);
                bloop2.connect(bloop2Gain);
                bloop3.connect(bloop3Gain);
                bloopGain.connect(this.masterGain);
                bloop2Gain.connect(this.masterGain);
                bloop3Gain.connect(this.masterGain);
                
                bloop.start();
                bloop2.start();
                bloop3.start();
                bloop.stop(t + 0.5);
                bloop2.stop(t + 0.35);
                bloop3.stop(t + 0.25);
                
                // Splash texture
                this.triggerSplash(0.06);
            }
            
            triggerSplash(volume) {
                if (!this.initialized || !this.enabled) return;
                const t = this.ctx.currentTime;
                
                const bufferSize = this.ctx.sampleRate * 0.3;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    const env = Math.exp(-i / (this.ctx.sampleRate * 0.04));
                    output[i] = (Math.random() * 2 - 1) * env;
                }
                
                const splash = this.ctx.createBufferSource();
                splash.buffer = buffer;
                
                const splashFilter = this.ctx.createBiquadFilter();
                splashFilter.type = 'bandpass';
                splashFilter.frequency.value = 2500;
                splashFilter.Q.value = 1.5;
                
                const splashGain = this.ctx.createGain();
                splashGain.gain.value = volume;
                
                splash.connect(splashFilter);
                splashFilter.connect(splashGain);
                splashGain.connect(this.masterGain);
                splash.start();
            }
            
            triggerNeuralRupture() {
                if (!this.initialized || !this.enabled) return;
                const t = this.ctx.currentTime;
                
                // Subtle "recognition" chime - your V1 firing
                const chime = this.ctx.createOscillator();
                chime.type = 'sine';
                chime.frequency.value = 800;
                
                const chimeGain = this.ctx.createGain();
                chimeGain.gain.value = 0.03;
                chimeGain.gain.setValueAtTime(0.03, t);
                chimeGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                
                chime.connect(chimeGain);
                chimeGain.connect(this.masterGain);
                chime.start();
                chime.stop(t + 0.3);
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                if (this.masterGain) {
                    const t = this.ctx.currentTime;
                    this.masterGain.gain.linearRampToValueAtTime(
                        enabled ? 0.5 : 0,
                        t + 0.3
                    );
                }
            }
            
            toggle() {
                this.setEnabled(!this.enabled);
                return this.enabled;
            }
        }
        
        const soundscape = new WaterSoundscape();
        
        // =====================================================
        // PHYSICAL CONSTANTS
        // =====================================================
        
        const WATER = {
            A: 1.3199,
            B: 0.00653,
            n_D: 1.333
        };
        
        function refractiveIndex(lambda_nm) {
            const lambda_um = lambda_nm / 1000;
            return WATER.A + WATER.B / (lambda_um * lambda_um);
        }
        
        function fresnelReflectance(n1, n2, cosTheta_i) {
            const sinTheta_i = Math.sqrt(Math.max(0, 1 - cosTheta_i * cosTheta_i));
            const sinTheta_t = (n1 / n2) * sinTheta_i;
            if (sinTheta_t > 1) return 1;
            const cosTheta_t = Math.sqrt(Math.max(0, 1 - sinTheta_t * sinTheta_t));
            const Rs = Math.pow((n1 * cosTheta_i - n2 * cosTheta_t) / (n1 * cosTheta_i + n2 * cosTheta_t + 0.0001), 2);
            const Rp = Math.pow((n1 * cosTheta_t - n2 * cosTheta_i) / (n1 * cosTheta_t + n2 * cosTheta_i + 0.0001), 2);
            return Math.min(1, (Rs + Rp) / 2);
        }
        
        // =====================================================
        // CRR STATE
        // =====================================================
        
        const CRR = {
            photon: { C: 0, omega: 0.8, L: 0, rupture: 0 },
            molecular: { C: 0, omega: 2.0, L: 0, rupture: 0 },
            cluster: { C: 0, omega: 5.0, L: 0, rupture: 0 },
            surface: { C: 0, omega: 12.0, L: 0, rupture: 0 },
            neural: { C: 0, omega: 30.0, L: 0, rupture: 0 }
        };
        
        // =====================================================
        // DROPLET STATE
        // =====================================================
        
        const droplet = {
            cx: 0,
            cy: 0,
            baseRadius: 0,
            wobblePhase: 0,
            wobbleAmp: 0,
            causticPhase: 0,
            flowPhase: 0
        };
        
        // =====================================================
        // INTERNAL DYNAMICS - Water molecule clusters
        // =====================================================
        
        const NUM_CLUSTERS = 25;
        const NUM_MOLECULES = 60;
        const NUM_FLOW_PARTICLES = 40;
        
        let clusters = [];
        let molecules = [];
        let flowParticles = [];
        let hBonds = [];
        
        function initInternals() {
            clusters = [];
            molecules = [];
            flowParticles = [];
            hBonds = [];
            
            // H‚ÇÇO clusters (tetrahedral coordination)
            for (let i = 0; i < NUM_CLUSTERS; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.85;
                clusters.push({
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: (Math.random() - 0.5) * 1.6,
                    size: 0.02 + Math.random() * 0.025,
                    phase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.02 + Math.random() * 0.02,
                    coherence: Math.random(),
                    vx: (Math.random() - 0.5) * 0.001,
                    vy: (Math.random() - 0.5) * 0.001
                });
            }
            
            // Individual water molecules (smaller, faster)
            for (let i = 0; i < NUM_MOLECULES; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.9;
                molecules.push({
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: (Math.random() - 0.5) * 1.8,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.08,
                    vibration: Math.random() * 0.5 + 0.5,
                    vx: (Math.random() - 0.5) * 0.003,
                    vy: (Math.random() - 0.5) * 0.003
                });
            }
            
            // Flow/convection particles
            for (let i = 0; i < NUM_FLOW_PARTICLES; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.8;
                flowParticles.push({
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: (Math.random() - 0.5) * 1.5,
                    age: Math.random(),
                    speed: 0.002 + Math.random() * 0.003
                });
            }
            
            // Generate hydrogen bonds between nearby clusters
            updateHBonds();
        }
        
        function updateHBonds() {
            hBonds = [];
            for (let i = 0; i < clusters.length; i++) {
                for (let j = i + 1; j < clusters.length; j++) {
                    const dx = clusters[j].x - clusters[i].x;
                    const dy = clusters[j].y - clusters[i].y;
                    const dz = clusters[j].z - clusters[i].z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < 0.35 && dist > 0.08) {
                        hBonds.push({
                            from: i,
                            to: j,
                            strength: 1 - dist / 0.35,
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
        }
        
        // =====================================================
        // RESIZE
        // =====================================================
        
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
            
            droplet.cx = window.innerWidth / 2;
            droplet.cy = window.innerHeight / 2;
            droplet.baseRadius = Math.min(window.innerWidth, window.innerHeight) * 0.28;
            
            initInternals();
        }
        resize();
        window.addEventListener('resize', resize);
        
        // =====================================================
        // UI STATE
        // =====================================================
        
        let showInfo = false;
        let showPhysics = false;
        let actualRefreshRate = 60;
        let frameCount = 0;
        let lastSecond = performance.now();
        
        document.getElementById('infoBtn').addEventListener('click', () => {
            showInfo = !showInfo;
            document.getElementById('infoOverlay').classList.toggle('visible', showInfo);
            document.getElementById('infoBtn').classList.toggle('active', showInfo);
        });
        
        document.getElementById('physicsBtn').addEventListener('click', () => {
            showPhysics = !showPhysics;
            document.getElementById('physicsBtn').classList.toggle('active', showPhysics);
            document.getElementById('pureBtn').classList.toggle('active', !showPhysics);
        });
        
        document.getElementById('pureBtn').addEventListener('click', () => {
            showPhysics = false;
            showInfo = false;
            document.getElementById('physicsBtn').classList.remove('active');
            document.getElementById('infoBtn').classList.remove('active');
            document.getElementById('infoOverlay').classList.remove('visible');
            document.getElementById('pureBtn').classList.add('active');
        });
        
        document.getElementById('soundBtn').addEventListener('click', async () => {
            if (!soundscape.initialized) {
                await soundscape.init();
            }
            const isOn = soundscape.toggle();
            const btn = document.getElementById('soundBtn');
            btn.textContent = isOn ? 'üîä Sound On' : 'üîá Sound Off';
            btn.classList.toggle('active', isOn);
        });
        
        // =====================================================
        // CRR DYNAMICS
        // =====================================================
        
        let flowIntensity = 0;
        
        function updateCRR(dt) {
            // Photon scale
            CRR.photon.L = 0.05 + Math.random() * 0.06;
            CRR.photon.C += CRR.photon.L;
            if (CRR.photon.C >= CRR.photon.omega) {
                CRR.photon.C = 0;
                CRR.photon.rupture = 1;
                CRR.molecular.L += 0.15;
                soundscape.triggerPhotonRupture();
            }
            CRR.photon.rupture *= 0.85;
            
            // Molecular scale
            CRR.molecular.L += 0.01 + Math.random() * 0.02;
            CRR.molecular.C += CRR.molecular.L;
            CRR.molecular.L *= 0.9;
            if (CRR.molecular.C >= CRR.molecular.omega) {
                CRR.molecular.C = 0;
                CRR.molecular.rupture = 1;
                CRR.cluster.L += 0.25;
                soundscape.triggerMolecularRupture();
                
                // Excite some molecules
                for (let i = 0; i < 5; i++) {
                    const mol = molecules[Math.floor(Math.random() * molecules.length)];
                    mol.vibration = 1.5;
                    mol.rotSpeed *= 1.5;
                }
            }
            CRR.molecular.rupture *= 0.9;
            
            // Cluster scale (H-bond network dynamics)
            CRR.cluster.L += 0.008 + Math.random() * 0.012;
            CRR.cluster.C += CRR.cluster.L;
            CRR.cluster.L *= 0.92;
            if (CRR.cluster.C >= CRR.cluster.omega) {
                CRR.cluster.C = 0;
                CRR.cluster.rupture = 1;
                CRR.surface.L += 0.35;
                soundscape.triggerClusterRupture();
                
                // Reorganize clusters
                const cluster = clusters[Math.floor(Math.random() * clusters.length)];
                cluster.coherence = 0;
                cluster.vx += (Math.random() - 0.5) * 0.005;
                cluster.vy += (Math.random() - 0.5) * 0.005;
                
                // Boost flow
                flowIntensity = Math.min(1, flowIntensity + 0.3);
            }
            CRR.cluster.rupture *= 0.92;
            
            // Surface scale
            CRR.surface.L += 0.005 + Math.random() * 0.008;
            CRR.surface.C += CRR.surface.L;
            CRR.surface.L *= 0.94;
            if (CRR.surface.C >= CRR.surface.omega) {
                CRR.surface.C = 0;
                CRR.surface.rupture = 1;
                CRR.neural.L += 0.5;
                droplet.wobbleAmp = Math.min(0.008, droplet.wobbleAmp + 0.003);
                soundscape.triggerSurfaceRupture();
            }
            CRR.surface.rupture *= 0.95;
            
            // Neural scale
            CRR.neural.L += 0.003 + Math.random() * 0.004;
            CRR.neural.C += CRR.neural.L;
            CRR.neural.L *= 0.96;
            if (CRR.neural.C >= CRR.neural.omega) {
                CRR.neural.C = 0;
                CRR.neural.rupture = 1;
                soundscape.triggerNeuralRupture();
            }
            CRR.neural.rupture *= 0.97;
            
            // Decay flow intensity
            flowIntensity *= 0.995;
            
            // Update continuous soundscape
            soundscape.update(CRR, flowIntensity);
        }
        
        // =====================================================
        // PHYSICS UPDATE
        // =====================================================
        
        function updatePhysics(dt) {
            droplet.wobblePhase += 0.015;
            droplet.wobbleAmp *= 0.995;
            droplet.wobbleAmp = Math.min(0.01, droplet.wobbleAmp);
            
            droplet.causticPhase += 0.006;
            droplet.flowPhase += 0.004;
            
            // Update clusters (Brownian motion + coherence recovery)
            clusters.forEach(cluster => {
                cluster.x += cluster.vx;
                cluster.y += cluster.vy;
                
                // Brownian kicks
                cluster.vx += (Math.random() - 0.5) * 0.0003;
                cluster.vy += (Math.random() - 0.5) * 0.0003;
                
                // Damping
                cluster.vx *= 0.98;
                cluster.vy *= 0.98;
                
                // Boundary
                const r = Math.sqrt(cluster.x * cluster.x + cluster.y * cluster.y);
                if (r > 0.85) {
                    cluster.x *= 0.85 / r;
                    cluster.y *= 0.85 / r;
                    cluster.vx *= -0.5;
                    cluster.vy *= -0.5;
                }
                
                // Phase and coherence
                cluster.phase += cluster.pulseSpeed;
                cluster.coherence += 0.01;
                cluster.coherence = Math.min(1, cluster.coherence);
            });
            
            // Update molecules
            molecules.forEach(mol => {
                mol.x += mol.vx;
                mol.y += mol.vy;
                
                // Brownian
                mol.vx += (Math.random() - 0.5) * 0.0008;
                mol.vy += (Math.random() - 0.5) * 0.0008;
                mol.vx *= 0.97;
                mol.vy *= 0.97;
                
                // Boundary
                const r = Math.sqrt(mol.x * mol.x + mol.y * mol.y);
                if (r > 0.9) {
                    mol.x *= 0.9 / r;
                    mol.y *= 0.9 / r;
                    mol.vx *= -0.3;
                    mol.vy *= -0.3;
                }
                
                mol.rotation += mol.rotSpeed;
                mol.rotSpeed *= 0.995;
                mol.rotSpeed = Math.max(0.01, Math.abs(mol.rotSpeed)) * Math.sign(mol.rotSpeed || 1);
                mol.vibration *= 0.98;
                mol.vibration = Math.max(0.3, mol.vibration);
            });
            
            // Update flow particles (convection simulation)
            flowParticles.forEach(p => {
                // Circular convection pattern
                const angle = Math.atan2(p.y, p.x);
                const r = Math.sqrt(p.x * p.x + p.y * p.y);
                
                // Toroidal flow
                const flowAngle = angle + droplet.flowPhase;
                p.x += Math.cos(flowAngle + Math.PI/2) * p.speed * (1 - r);
                p.y += Math.sin(flowAngle + Math.PI/2) * p.speed * (1 - r);
                
                // Vertical component
                p.z += Math.sin(droplet.flowPhase * 2 + angle) * 0.002;
                p.z = Math.max(-0.8, Math.min(0.8, p.z));
                
                // Reset if outside
                const newR = Math.sqrt(p.x * p.x + p.y * p.y);
                if (newR > 0.85) {
                    const newTheta = Math.random() * Math.PI * 2;
                    const newRad = Math.random() * 0.3;
                    p.x = Math.cos(newTheta) * newRad;
                    p.y = Math.sin(newTheta) * newRad;
                }
                
                p.age += 0.005;
                if (p.age > 1) p.age = 0;
            });
            
            // Periodically update H-bonds
            if (Math.random() < 0.02) {
                updateHBonds();
            }
            
            // Update H-bond phases
            hBonds.forEach(bond => {
                bond.phase += 0.03;
            });
        }
        
        // =====================================================
        // GET DROPLET RADIUS
        // =====================================================
        
        function getRadius(theta) {
            let r = droplet.baseRadius;
            const wobble = droplet.wobbleAmp * droplet.baseRadius;
            r += wobble * Math.cos(2 * theta + droplet.wobblePhase);
            r += droplet.baseRadius * 0.004 * Math.cos(theta - Math.PI/2);
            return r;
        }
        
        // =====================================================
        // 3D PROJECTION
        // =====================================================
        
        function project3D(x, y, z, cx, cy, radius) {
            const fov = 600;
            const scale = fov / (fov + z * radius * 0.5);
            return {
                x: cx + x * radius * scale,
                y: cy + y * radius * scale,
                scale: scale,
                depth: z
            };
        }
        
        // =====================================================
        // RENDERING
        // =====================================================
        
        function render() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cx = droplet.cx;
            const cy = droplet.cy;
            
            renderEnvironment(w, h);
            renderContactShadow(cx, cy);
            
            // Main droplet
            ctx.save();
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.clip();
            
            // VERY translucent water body
            renderWaterBody(cx, cy);
            
            // Internal dynamics (always visible, enhanced in physics mode)
            renderInternalDynamics(cx, cy, showPhysics);
            
            // Caustics
            renderCaustics(cx, cy);
            
            // Subsurface
            renderSubsurface(cx, cy);
            
            ctx.restore();
            
            // Surface effects
            renderFresnelRim(cx, cy);
            renderEnvironmentReflection(cx, cy);
            renderSpecularHighlights(cx, cy);
            renderEdge(cx, cy);
            
            // CRR overlay
            if (showPhysics) {
                renderCRROverlay(cx, cy);
            }
        }
        
        function renderEnvironment(w, h) {
            const bgGrad = ctx.createLinearGradient(0, 0, 0, h);
            bgGrad.addColorStop(0, '#404040');
            bgGrad.addColorStop(0.35, '#333333');
            bgGrad.addColorStop(0.65, '#2a2a2a');
            bgGrad.addColorStop(1, '#1f1f1f');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Texture
            ctx.globalAlpha = 0.015;
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = 25 + Math.random() * 45;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, '#666');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function renderContactShadow(cx, cy) {
            const r = droplet.baseRadius;
            const shadowY = cy + r * 0.96;
            
            const outer = ctx.createRadialGradient(cx, shadowY + 15, 0, cx, shadowY + 15, r * 1.2);
            outer.addColorStop(0, 'rgba(0, 0, 0, 0.35)');
            outer.addColorStop(0.4, 'rgba(0, 0, 0, 0.15)');
            outer.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = outer;
            ctx.beginPath();
            ctx.ellipse(cx, shadowY + 15, r * 1.0, r * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            
            const inner = ctx.createRadialGradient(cx, shadowY + 3, 0, cx, shadowY + 3, r * 0.4);
            inner.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            inner.addColorStop(0.6, 'rgba(0, 0, 0, 0.2)');
            inner.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = inner;
            ctx.beginPath();
            ctx.ellipse(cx, shadowY + 3, r * 0.35, r * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderWaterBody(cx, cy) {
            const r = droplet.baseRadius;
            
            // MUCH more translucent - like glass
            const water = ctx.createRadialGradient(
                cx - r * 0.1, cy - r * 0.15, 0,
                cx, cy, r * 1.1
            );
            
            // Very low opacity - you can see through it
            water.addColorStop(0, 'rgba(255, 255, 255, 0.12)');
            water.addColorStop(0.2, 'rgba(248, 252, 255, 0.10)');
            water.addColorStop(0.4, 'rgba(240, 248, 255, 0.08)');
            water.addColorStop(0.6, 'rgba(230, 242, 252, 0.06)');
            water.addColorStop(0.8, 'rgba(220, 235, 250, 0.05)');
            water.addColorStop(1, 'rgba(210, 228, 245, 0.04)');
            
            ctx.fillStyle = water;
            ctx.fillRect(cx - r * 1.5, cy - r * 1.5, r * 3, r * 3);
            
            // Very subtle blue tint
            const tint = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            tint.addColorStop(0, 'rgba(200, 225, 255, 0.04)');
            tint.addColorStop(0.5, 'rgba(190, 220, 250, 0.025)');
            tint.addColorStop(1, 'rgba(180, 215, 245, 0.015)');
            ctx.fillStyle = tint;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderInternalDynamics(cx, cy, enhanced) {
            const r = droplet.baseRadius;
            const baseAlpha = enhanced ? 1 : 0.4;
            
            // Sort everything by depth for proper rendering
            const allItems = [];
            
            // Add clusters
            clusters.forEach((cluster, i) => {
                allItems.push({ type: 'cluster', data: cluster, index: i, z: cluster.z });
            });
            
            // Add molecules
            molecules.forEach((mol, i) => {
                allItems.push({ type: 'molecule', data: mol, index: i, z: mol.z });
            });
            
            // Add flow particles
            flowParticles.forEach((p, i) => {
                allItems.push({ type: 'flow', data: p, index: i, z: p.z });
            });
            
            // Sort back to front
            allItems.sort((a, b) => a.z - b.z);
            
            // Draw H-bonds first (behind everything)
            if (enhanced) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                
                hBonds.forEach(bond => {
                    const c1 = clusters[bond.from];
                    const c2 = clusters[bond.to];
                    
                    const p1 = project3D(c1.x, c1.y, c1.z, cx, cy, r);
                    const p2 = project3D(c2.x, c2.y, c2.z, cx, cy, r);
                    
                    const pulse = 0.5 + Math.sin(bond.phase) * 0.5;
                    
                    ctx.strokeStyle = `rgba(100, 180, 255, ${bond.strength * pulse * 0.5})`;
                    ctx.lineWidth = 1 + bond.strength;
                    ctx.setLineDash([3, 3]);
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
                ctx.restore();
            }
            
            // Draw items
            allItems.forEach(item => {
                if (item.type === 'cluster') {
                    drawCluster(item.data, cx, cy, r, baseAlpha, enhanced);
                } else if (item.type === 'molecule') {
                    drawMolecule(item.data, cx, cy, r, baseAlpha, enhanced);
                } else if (item.type === 'flow') {
                    drawFlowParticle(item.data, cx, cy, r, baseAlpha, enhanced);
                }
            });
        }
        
        function drawCluster(cluster, cx, cy, r, baseAlpha, enhanced) {
            const p = project3D(cluster.x, cluster.y, cluster.z, cx, cy, r);
            const size = cluster.size * r * p.scale;
            
            const pulse = 0.7 + Math.sin(cluster.phase) * 0.3;
            const alpha = baseAlpha * (0.3 + cluster.coherence * 0.7) * pulse;
            const depthFade = 0.5 + (cluster.z + 1) * 0.25;
            
            if (enhanced) {
                // Outer glow
                const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2.5);
                glow.addColorStop(0, `rgba(150, 200, 255, ${alpha * depthFade * 0.3})`);
                glow.addColorStop(0.5, `rgba(130, 190, 255, ${alpha * depthFade * 0.15})`);
                glow.addColorStop(1, 'rgba(120, 180, 255, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Core
            const core = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
            core.addColorStop(0, `rgba(200, 230, 255, ${alpha * depthFade * 0.6})`);
            core.addColorStop(0.5, `rgba(170, 210, 250, ${alpha * depthFade * 0.3})`);
            core.addColorStop(1, `rgba(150, 200, 245, 0)`);
            ctx.fillStyle = core;
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Tetrahedral hint (in enhanced mode)
            if (enhanced && cluster.coherence > 0.5) {
                ctx.strokeStyle = `rgba(180, 220, 255, ${alpha * depthFade * 0.2})`;
                ctx.lineWidth = 0.5;
                for (let i = 0; i < 4; i++) {
                    const angle = cluster.phase + (i / 4) * Math.PI * 2;
                    const len = size * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + Math.cos(angle) * len, p.y + Math.sin(angle) * len * 0.6);
                    ctx.stroke();
                }
            }
        }
        
        function drawMolecule(mol, cx, cy, r, baseAlpha, enhanced) {
            const p = project3D(mol.x, mol.y, mol.z, cx, cy, r);
            const size = 3 * p.scale;
            const alpha = baseAlpha * mol.vibration * 0.5;
            const depthFade = 0.4 + (mol.z + 1) * 0.3;
            
            if (!enhanced) {
                // Simple dot in pure mode
                ctx.fillStyle = `rgba(220, 240, 255, ${alpha * depthFade * 0.4})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            
            // H‚ÇÇO structure in enhanced mode
            const bondLen = size * 2;
            const bondAngle = 104.45 * Math.PI / 180;
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(mol.rotation);
            
            // Oxygen (center)
            const oGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            oGrad.addColorStop(0, `rgba(255, 120, 120, ${alpha * depthFade * 0.7})`);
            oGrad.addColorStop(0.5, `rgba(255, 100, 100, ${alpha * depthFade * 0.4})`);
            oGrad.addColorStop(1, 'rgba(255, 80, 80, 0)');
            ctx.fillStyle = oGrad;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Hydrogens
            const h1x = Math.cos(-bondAngle/2) * bondLen;
            const h1y = Math.sin(-bondAngle/2) * bondLen;
            const h2x = Math.cos(bondAngle/2) * bondLen;
            const h2y = Math.sin(bondAngle/2) * bondLen;
            
            // Bonds
            ctx.strokeStyle = `rgba(200, 220, 240, ${alpha * depthFade * 0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(h1x, h1y);
            ctx.moveTo(0, 0);
            ctx.lineTo(h2x, h2y);
            ctx.stroke();
            
            // H atoms
            const hSize = size * 0.5;
            [{ x: h1x, y: h1y }, { x: h2x, y: h2y }].forEach(h => {
                const hGrad = ctx.createRadialGradient(h.x, h.y, 0, h.x, h.y, hSize);
                hGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha * depthFade * 0.8})`);
                hGrad.addColorStop(0.5, `rgba(240, 250, 255, ${alpha * depthFade * 0.4})`);
                hGrad.addColorStop(1, 'rgba(230, 245, 255, 0)');
                ctx.fillStyle = hGrad;
                ctx.beginPath();
                ctx.arc(h.x, h.y, hSize, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }
        
        function drawFlowParticle(p, cx, cy, r, baseAlpha, enhanced) {
            const proj = project3D(p.x, p.y, p.z, cx, cy, r);
            const size = 2 * proj.scale;
            const alpha = baseAlpha * (1 - p.age) * 0.3;
            const depthFade = 0.3 + (p.z + 1) * 0.35;
            
            if (!enhanced) return;  // Only show in physics mode
            
            // Flow line (shows direction)
            const angle = Math.atan2(p.y, p.x) + Math.PI/2;
            const tailLen = 8 * proj.scale;
            
            const grad = ctx.createLinearGradient(
                proj.x - Math.cos(angle) * tailLen,
                proj.y - Math.sin(angle) * tailLen,
                proj.x, proj.y
            );
            grad.addColorStop(0, 'rgba(100, 255, 200, 0)');
            grad.addColorStop(1, `rgba(100, 255, 200, ${alpha * depthFade})`);
            
            ctx.strokeStyle = grad;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(proj.x - Math.cos(angle) * tailLen, proj.y - Math.sin(angle) * tailLen);
            ctx.lineTo(proj.x, proj.y);
            ctx.stroke();
            
            // Head
            ctx.fillStyle = `rgba(150, 255, 220, ${alpha * depthFade * 1.5})`;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderCaustics(cx, cy) {
            const r = droplet.baseRadius;
            const t = droplet.causticPhase;
            
            for (let i = 0; i < 18; i++) {
                const baseAngle = (i / 18) * Math.PI * 2;
                const angle = baseAngle + Math.sin(t * 0.35 + i * 0.6) * 0.18;
                const dist = r * (0.25 + (i % 4) * 0.12);
                const rDist = dist + Math.sin(t * 0.7 + i * 0.45) * 10;
                
                const x = cx + Math.cos(angle) * rDist;
                const y = cy + Math.sin(angle) * rDist * 0.8;
                
                const size = 6 + Math.sin(t * 0.5 + i * 0.9) * 4;
                const alpha = 0.018 + Math.sin(t * 0.6 + i) * 0.008;
                
                const caustic = ctx.createRadialGradient(x, y, 0, x, y, size);
                caustic.addColorStop(0, `rgba(255, 255, 255, ${alpha * 1.4})`);
                caustic.addColorStop(0.4, `rgba(255, 255, 255, ${alpha * 0.7})`);
                caustic.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(1.2, 0.5);
                ctx.fillStyle = caustic;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        function renderSubsurface(cx, cy) {
            const r = droplet.baseRadius;
            
            const sss = ctx.createRadialGradient(cx, cy - r * 0.35, r * 0.06, cx, cy, r);
            sss.addColorStop(0, 'rgba(255, 255, 255, 0.06)');
            sss.addColorStop(0.4, 'rgba(255, 255, 255, 0.025)');
            sss.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = sss;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function renderFresnelRim(cx, cy) {
            const r = droplet.baseRadius;
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            for (let i = 0; i <= 360; i += 1) {
                const theta = (i / 360) * Math.PI * 2;
                const radius = getRadius(theta);
                const x = cx + Math.cos(theta) * radius;
                const y = cy + Math.sin(theta) * radius;
                
                const R = fresnelReflectance(1.0, WATER.n_D, 0.1);
                const lightAngle = -Math.PI * 0.65;
                const angleDiff = Math.abs(theta - lightAngle);
                const lightFactor = Math.pow(Math.cos(angleDiff * 0.5), 2);
                const heightFactor = 0.3 + 0.7 * (1 - (Math.sin(theta) + 1) * 0.5);
                const intensity = R * lightFactor * heightFactor;
                
                if (intensity > 0.03) {
                    const rimGrad = ctx.createRadialGradient(x, y, 0, x, y, 4);
                    rimGrad.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.6})`);
                    rimGrad.addColorStop(0.4, `rgba(255, 255, 255, ${intensity * 0.3})`);
                    rimGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = rimGrad;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function renderEnvironmentReflection(cx, cy) {
            const r = droplet.baseRadius;
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            const reflect = ctx.createLinearGradient(
                cx - r * 0.45, cy - r * 0.35,
                cx + r * 0.45, cy - r * 0.1
            );
            reflect.addColorStop(0, 'rgba(220, 230, 240, 0)');
            reflect.addColorStop(0.25, 'rgba(235, 245, 255, 0.035)');
            reflect.addColorStop(0.5, 'rgba(250, 255, 255, 0.06)');
            reflect.addColorStop(0.75, 'rgba(235, 245, 255, 0.035)');
            reflect.addColorStop(1, 'rgba(220, 230, 240, 0)');
            ctx.fillStyle = reflect;
            ctx.beginPath();
            ctx.ellipse(cx, cy - r * 0.24, r * 0.5, r * 0.14, -0.05, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function renderSpecularHighlights(cx, cy) {
            const r = droplet.baseRadius;
            const hlX = cx - r * 0.24;
            const hlY = cy - r * 0.26;
            
            // Outer glow
            const glow = ctx.createRadialGradient(hlX, hlY, 0, hlX, hlY, r * 0.35);
            glow.addColorStop(0, 'rgba(255, 255, 255, 0.25)');
            glow.addColorStop(0.35, 'rgba(255, 255, 255, 0.12)');
            glow.addColorStop(0.7, 'rgba(255, 255, 255, 0.03)');
            glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(hlX, hlY, r * 0.35, 0, Math.PI * 2);
            ctx.fill();
            
            // Main highlight
            ctx.save();
            ctx.translate(hlX, hlY);
            ctx.rotate(-0.15);
            ctx.scale(1.05, 0.75);
            
            const main = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.14);
            main.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
            main.addColorStop(0.2, 'rgba(255, 255, 255, 0.85)');
            main.addColorStop(0.5, 'rgba(255, 255, 255, 0.38)');
            main.addColorStop(0.8, 'rgba(255, 255, 255, 0.08)');
            main.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.14, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Sharp spark
            const sparkX = hlX - r * 0.05;
            const sparkY = hlY - r * 0.03;
            const spark = ctx.createRadialGradient(sparkX, sparkY, 0, sparkX, sparkY, 6);
            spark.addColorStop(0, 'rgba(255, 255, 255, 1)');
            spark.addColorStop(0.4, 'rgba(255, 255, 255, 0.85)');
            spark.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = spark;
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary spark
            const spark2 = ctx.createRadialGradient(sparkX + 9, sparkY + 4, 0, sparkX + 9, sparkY + 4, 3);
            spark2.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            spark2.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = spark2;
            ctx.beginPath();
            ctx.arc(sparkX + 9, sparkY + 4, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary highlights
            const secondaries = [
                { x: 0.16, y: -0.44, r: 0.045, a: 0.28 },
                { x: 0.34, y: -0.18, r: 0.03, a: 0.2 },
                { x: -0.36, y: 0.24, r: 0.05, a: 0.08 },
                { x: 0.26, y: 0.31, r: 0.035, a: 0.06 },
                { x: 0.41, y: 0.03, r: 0.02, a: 0.1 },
            ];
            
            secondaries.forEach(hl => {
                const x = cx + r * hl.x;
                const y = cy + r * hl.y;
                const size = r * hl.r;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                grad.addColorStop(0, `rgba(255, 255, 255, ${hl.a})`);
                grad.addColorStop(0.45, `rgba(255, 255, 255, ${hl.a * 0.35})`);
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function renderEdge(cx, cy) {
            ctx.save();
            
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const radius = getRadius(theta) + 1;
                const x = cx + Math.cos(theta) * radius;
                const y = cy + Math.sin(theta) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(200, 225, 255, 0.05)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const radius = getRadius(theta);
                const x = cx + Math.cos(theta) * radius;
                const y = cy + Math.sin(theta) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(80, 100, 120, 0.1)';
            ctx.lineWidth = 0.8;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function renderCRROverlay(cx, cy) {
            const r = droplet.baseRadius;
            
            ctx.save();
            
            // CRR panel
            const panelW = 180;
            const panelH = 140;
            const panelX = cx + r + 25;
            const panelY = cy - panelH / 2;
            
            // Panel background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.roundRect(panelX, panelY, panelW, panelH, 6);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Title
            ctx.font = '10px -apple-system, sans-serif';
            ctx.fillStyle = 'rgba(100, 180, 255, 0.8)';
            ctx.textAlign = 'left';
            ctx.fillText('CRR DYNAMICS', panelX + 10, panelY + 18);
            
            // CRR bars
            const scales = [
                { name: 'Photon', data: CRR.photon, color: '#ff6b6b' },
                { name: 'Molecular', data: CRR.molecular, color: '#ffeaa7' },
                { name: 'Cluster', data: CRR.cluster, color: '#74b9ff' },
                { name: 'Surface', data: CRR.surface, color: '#55efc4' },
                { name: 'Neural', data: CRR.neural, color: '#a29bfe' }
            ];
            
            scales.forEach((scale, i) => {
                const y = panelY + 35 + i * 20;
                const barW = 80;
                const barH = 6;
                const barX = panelX + 70;
                
                // Label
                ctx.font = '9px SF Mono, Monaco, monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'right';
                ctx.fillText(scale.name, barX - 8, y + 5);
                
                // Bar background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.roundRect(barX, y, barW, barH, 2);
                ctx.fill();
                
                // Bar fill
                const ratio = Math.min(scale.data.C / scale.data.omega, 1);
                ctx.fillStyle = scale.color;
                ctx.beginPath();
                ctx.roundRect(barX, y, barW * ratio, barH, 2);
                ctx.fill();
                
                // Rupture flash
                if (scale.data.rupture > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${scale.data.rupture * 0.4})`;
                    ctx.beginPath();
                    ctx.roundRect(barX, y, barW, barH, 2);
                    ctx.fill();
                }
            });
            
            // Physics info
            const infoY = panelY + panelH + 15;
            ctx.font = '9px SF Mono, Monaco, monospace';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.textAlign = 'left';
            ctx.fillText(`n = ${WATER.n_D.toFixed(4)}`, panelX, infoY);
            ctx.fillText(`Clusters: ${clusters.length}`, panelX, infoY + 14);
            ctx.fillText(`H-bonds: ${hBonds.length}`, panelX, infoY + 28);
            ctx.fillText(`Molecules: ${molecules.length}`, panelX, infoY + 42);
            
            ctx.restore();
        }
        
        // =====================================================
        // ANIMATION LOOP
        // =====================================================
        
        let lastTime = 0;
        
        function animate(timestamp) {
            frameCount++;
            if (timestamp - lastSecond >= 1000) {
                actualRefreshRate = frameCount;
                frameCount = 0;
                lastSecond = timestamp;
                document.getElementById('refreshRate').textContent = actualRefreshRate;
            }
            
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            
            updateCRR(dt);
            updatePhysics(dt);
            render();
            
            requestAnimationFrame(animate);
        }
        
        requestAnimationFrame(animate);
        
    </script>
</body>
</html>
