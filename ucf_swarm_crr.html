<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Non-Markovian Swarm - Coherence Rupture Rebirth</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #ffffff;
            color: #1a1a1a;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }

        .main-container {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.06);
            max-width: 1600px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .header .subtitle {
            color: #666666;
            font-size: 1rem;
            font-weight: 400;
            margin-bottom: 20px;
        }

        .equation-banner {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            font-family: 'Georgia', monospace;
            font-size: 0.95rem;
            color: #495057;
            margin-bottom: 20px;
        }

        .active-equation-display {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #007bff;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .current-equation {
            font-family: 'Courier New', monospace;
            font-size: 1.6rem;
            color: #2563eb;
            margin-bottom: 12px;
            font-weight: 600;
            text-align: center;
        }

        .equation-description {
            font-size: 0.9rem;
            color: #495057;
            line-height: 1.4;
            text-align: center;
            margin-bottom: 15px;
        }

        .code-snippet {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #495057;
            white-space: pre-wrap;
            margin-top: 10px;
        }

        .phase-coherence { border-color: #28a745; }
        .phase-coherence .current-equation { color: #28a745; }
        
        .phase-rupture { border-color: #dc3545; }
        .phase-rupture .current-equation { color: #dc3545; }
        
        .phase-regeneration { border-color: #6f42c1; }
        .phase-regeneration .current-equation { color: #6f42c1; }

        .simulation-area {
            position: relative;
            width: 100%;
            height: 600px;
            background: #000000;
            border: 2px solid #e0e0e0;
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
            cursor: crosshair;
        }

        #swarmCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .swarm-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .phase-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: bold;
        }

        .controls-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .controls, .metrics, .crr-parameters {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
        }

        .controls h3, .metrics h3, .crr-parameters h3 {
            color: #495057;
            font-size: 1rem;
            margin-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 5px;
        }

        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }

        .control-group label {
            min-width: 100px;
            font-size: 0.85rem;
            color: #495057;
        }

        .control-group input[type="range"] {
            flex: 1;
            height: 6px;
            background: #dee2e6;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-group .value {
            min-width: 50px;
            font-size: 0.8rem;
            color: #6c757d;
            text-align: right;
            font-family: monospace;
        }

        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #007bff;
            background: #fff;
            color: #007bff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #007bff;
            color: #fff;
        }

        .btn.active {
            background: #007bff;
            color: #fff;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .metric-label {
            color: #6c757d;
        }

        .metric-value {
            font-weight: bold;
            color: #495057;
            font-family: monospace;
        }

        .explanation-section {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 30px;
            margin-top: 20px;
        }

        .explanation-section h3 {
            color: #2c3e50;
            font-size: 1.3rem;
            margin-bottom: 20px;
            border-bottom: 3px solid #007bff;
            padding-bottom: 8px;
        }

        .explanation-section h4 {
            color: #495057;
            font-size: 1.1rem;
            margin: 20px 0 12px 0;
        }

        .explanation-section p {
            font-size: 0.95rem;
            color: #6c757d;
            margin-bottom: 12px;
            text-align: justify;
            line-height: 1.6;
        }

        .explanation-section ul {
            font-size: 0.95rem;
            color: #6c757d;
            margin-left: 20px;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .explanation-section li {
            margin-bottom: 6px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            background: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
        }

        .comparison-card h5 {
            color: #495057;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .comparison-card.markovian {
            border-left: 4px solid #dc3545;
        }

        .comparison-card.non-markovian {
            border-left: 4px solid #28a745;
        }

        @media (max-width: 1024px) {
            .controls-metrics {
                grid-template-columns: 1fr;
            }
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>CRR Non-Markovian Swarm</h1>
            <div class="subtitle">Coherence • Rupture • Rebirth Framework</div>
        </div>

        <div class="equation-banner">
            CRR Swarm Dynamics: C(x,t) = ∫ L(x,τ) dτ • δ(t-t₀) • R[χ](x,t) = ∫ Fφ(x,τ)·e^(C(x)/Ω)dτ
        </div>

        <div class="active-equation-display phase-coherence" id="activeEquation">
            <div class="current-equation" id="currentEquation">C(x,t) = ∫₀ᵗ L(x,τ) dτ</div>
            <div class="equation-description" id="equationDescription">
                Swarm coherence through accumulated positional memory integration
            </div>
            <div class="code-snippet" id="codeSnippet">
// Coherence Phase - Historical Memory Integration
p.history.push([p.x, p.y]);
if (p.history.length > memoryDepth) p.history.shift();

// Memory-weighted centroid calculation
let hx = p.history.reduce((a,b) => a + b[0], 0) / p.history.length;
let hy = p.history.reduce((a,b) => a + b[1], 0) / p.history.length;

// Non-Markovian force based on entire trajectory
p.vx += (hx - p.x) * coherenceStrength;
p.vy += (hy - p.y) * coherenceStrength;
            </div>
        </div>

        <div class="simulation-area">
            <canvas id="swarmCanvas"></canvas>
            <div class="swarm-overlay">
                Click anywhere to trigger rupture<br>
                Particles remember their trajectories<br>
                Non-Markovian memory dynamics
            </div>
            <div class="phase-indicator phase-coherence" id="phaseIndicator">
                Phase: Coherence Building
            </div>
        </div>

        <div class="controls-metrics">
            <div class="controls">
                <h3>Simulation Controls</h3>
                
                <div class="control-group">
                    <label>Particle Count:</label>
                    <input type="range" id="particleCount" min="50" max="500" value="300">
                    <span class="value" id="particleCountValue">300</span>
                </div>
                
                <div class="control-group">
                    <label>Memory Depth:</label>
                    <input type="range" id="memoryDepth" min="10" max="100" value="50">
                    <span class="value" id="memoryDepthValue">50</span>
                </div>
                
                <div class="control-group">
                    <label>Random Motion:</label>
                    <input type="range" id="randomMotion" min="0.01" max="0.5" step="0.01" value="0.2">
                    <span class="value" id="randomMotionValue">0.20</span>
                </div>
                
                <div class="control-group">
                    <label>Damping:</label>
                    <input type="range" id="damping" min="0.90" max="0.99" step="0.01" value="0.99">
                    <span class="value" id="dampingValue">0.99</span>
                </div>
                
                <div class="button-group">
                    <button class="btn" onclick="triggerGlobalRupture()">Global Rupture</button>
                    <button class="btn" onclick="resetSwarm()">Reset Swarm</button>
                    <button class="btn" onclick="toggleTrails()" id="trailsBtn">Trails: ON</button>
                    <button class="btn" onclick="togglePause()" id="pauseBtn">Pause</button>
                </div>
            </div>
            
            <div class="metrics">
                <h3>System Metrics</h3>
                
                <div class="metric-row">
                    <span class="metric-label">Active Particles:</span>
                    <span class="metric-value" id="activeParticles">300</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">Avg Memory Length:</span>
                    <span class="metric-value" id="avgMemoryLength">0</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">System Energy:</span>
                    <span class="metric-value" id="systemEnergy">0.000</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">Coherence Index:</span>
                    <span class="metric-value" id="coherenceIndex">0.000</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">Time Since Rupture:</span>
                    <span class="metric-value" id="timeSinceRupture">0s</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">Total Ruptures:</span>
                    <span class="metric-value" id="totalRuptures">0</span>
                </div>
            </div>

            <div class="crr-parameters">
                <h3>CRR Framework</h3>
                
                <div class="control-group">
                    <label>Coherence Strength:</label>
                    <input type="range" id="coherenceStrength" min="0.001" max="0.01" step="0.001" value="0.002">
                    <span class="value" id="coherenceStrengthValue">0.002</span>
                </div>
                
                <div class="control-group">
                    <label>Rupture Radius:</label>
                    <input type="range" id="ruptureRadius" min="50" max="200" value="100">
                    <span class="value" id="ruptureRadiusValue">100</span>
                </div>
                
                <div class="control-group">
                    <label>Rupture Intensity:</label>
                    <input type="range" id="ruptureIntensity" min="1" max="10" value="5">
                    <span class="value" id="ruptureIntensityValue">5</span>
                </div>
                
                <div class="control-group">
                    <label>Field Ω:</label>
                    <input type="range" id="fieldOmega" min="0.01" max="0.1" step="0.01" value="0.05">
                    <span class="value" id="fieldOmegaValue">0.05</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">∫ L(x,τ) dτ:</span>
                    <span class="metric-value" id="mnemonicIntegral">0.000</span>
                </div>
                
                <div class="metric-row">
                    <span class="metric-label">δ(t-t₀):</span>
                    <span class="metric-value" id="diracOperator">0.000</span>
                </div>
            </div>
        </div>

        <div class="explanation-section">
            <h3>Non-Markovian vs Traditional Swarm Systems</h3>
            
            <div class="comparison-grid">
                <div class="comparison-card markovian">
                    <h5>Traditional Markovian Swarm</h5>
                    <ul>
                        <li>Current state only determines future behavior</li>
                        <li>No memory of trajectory or past experiences</li>
                        <li>Purely reactive to immediate environment</li>
                        <li>Predictable, deterministic dynamics</li>
                        <li>Limited emergent complexity</li>
                    </ul>
                </div>
                
                <div class="comparison-card non-markovian">
                    <h5>CRR Non-Markovian Swarm</h5>
                    <ul>
                        <li>Entire history influences current behavior</li>
                        <li>Accumulated memory creates attractor dynamics</li>
                        <li>Exhibits learning and adaptation over time</li>
                        <li>Rich emergent patterns from memory integration</li>
                        <li>Rupture events enable system reorganization</li>
                    </ul>
                </div>
            </div>

            <h4>The CRR Framework Applied</h4>
            <p><strong>Coherence Phase:</strong> Particles accumulate positional history and are drawn back toward their personal trajectory centroids. This creates stable, memory-dependent motion patterns that evolve over time.</p>
            
            <p><strong>Rupture Events:</strong> Click interactions trigger localised δ(t-t₀) disruptions that clear memory and inject impulses. This breaks established patterns and enables system reorganisation.</p>
            
            <p><strong>Regeneration Phase:</strong> After rupture, particles rebuild their behavioral patterns through the rebirth operator R[χ], integrating new experiences with residual memory traces weighted by the field parameter Ω.</p>

            <h4>Key Mathematical Innovations</h4>
            <ul>
                <li><strong>Memory Integration C(x,t) = ∫ L(x,τ) dτ:</strong> Each particle maintains a weighted integral of its positional history, creating non-local temporal correlations</li>
                <li><strong>Mnemonic Force Fields:</strong> Particles experience forces based not just on current position, but on their entire accumulated trajectory</li>
                <li><strong>Rupture Dynamics:</strong> Discrete memory-clearing events that enable rapid behavioral transitions and learning</li>
                <li><strong>Historical Attractors:</strong> Emergent patterns arise from the interplay between memory, randomness, and rupture events</li>
            </ul>

            <h4>Biological and Computational Parallels</h4>
            <p>This framework models aspects of:</p>
            <ul>
                <li><strong>Neural Plasticity:</strong> How memories influence current behavior while remaining updatable through experience</li>
                <li><strong>Collective Memory:</strong> Group behaviors that depend on shared historical experiences</li>
                <li><strong>Adaptive Systems:</strong> Learning algorithms that balance stability with adaptability</li>
                <li><strong>Swarm Intelligence:</strong> Emergent coordination through memory-mediated interactions</li>
            </ul>

            <h4>Emergent Properties</h4>
            <p>Unlike Markovian systems, this swarm exhibits:</p>
            <ul>
                <li><strong>Path Dependence:</strong> Different histories lead to different current states even with identical conditions</li>
                <li><strong>Temporal Coherence:</strong> Particles develop consistent movement patterns based on accumulated experience</li>
                <li><strong>Memory-Mediated Clustering:</strong> Spatial organisation emerges from historical trajectory preferences</li>
                <li><strong>Adaptive Resilience:</strong> System can maintain organisation while adapting to disruptions</li>
            </ul>

            <h4>Research Applications</h4>
            <p>This approach enables modeling of:</p>
            <ul>
                <li>Animal migration patterns with memory of previous routes</li>
                <li>Social dynamics where past interactions influence current behavior</li>
                <li>Distributed computing systems with historical optimisation</li>
                <li>Economic markets where trader behavior depends on past experiences</li>
                <li>Evolutionary processes where fitness depends on historical adaptation</li>
            </ul>
        </div>
    </div>

    <script>
        class UCFSwarmSimulation {
            constructor() {
                this.canvas = document.getElementById('swarmCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Simulation state
                this.particles = [];
                this.time = 0;
                this.phase = 'coherence'; // coherence, rupture, regeneration
                this.lastRuptureTime = 0;
                this.totalRuptures = 0;
                this.paused = false;
                this.showTrails = true;
                this.ruptureActive = false;
                this.ruptureDecayTime = 0;
                
                // Parameters
                this.params = {
                    particleCount: 300,
                    memoryDepth: 50,
                    randomMotion: 0.2,
                    damping: 0.99,
                    coherenceStrength: 0.002,
                    ruptureRadius: 100,
                    ruptureIntensity: 5,
                    fieldOmega: 0.05
                };
                
                this.resizeCanvas();
                this.initializeParticles();
                this.setupEventListeners();
                this.animate();
            }
            
            resizeCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
            }
            
            initializeParticles() {
                this.particles = [];
                for (let i = 0; i < this.params.particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        history: [],
                        coherenceValue: 0,
                        timeSinceLastRupture: 0
                    });
                }
                this.updateEquationDisplay();
            }
            
            updateParticles() {
                if (this.paused) return;
                
                this.time++;
                
                // Update phase based on rupture state
                if (this.ruptureActive) {
                    this.ruptureDecayTime--;
                    if (this.ruptureDecayTime <= 0) {
                        this.ruptureActive = false;
                        this.phase = 'regeneration';
                        setTimeout(() => {
                            if (!this.ruptureActive) {
                                this.phase = 'coherence';
                                this.updateEquationDisplay();
                            }
                        }, 2000);
                        this.updateEquationDisplay();
                    }
                }
                
                this.particles.forEach(p => {
                    p.timeSinceLastRupture++;
                    
                    // UCF Coherence Integration: C(x,t) = ∫ L(x,τ) dτ
                    p.history.push([p.x, p.y, this.time]);
                    if (p.history.length > this.params.memoryDepth) {
                        p.history.shift();
                    }
                    
                    // Calculate mnemonic density L(x,τ) and coherence
                    if (p.history.length > 0) {
                        let totalWeight = 0;
                        let weightedX = 0;
                        let weightedY = 0;
                        
                        // Memory-weighted centroid calculation
                        for (let i = 0; i < p.history.length; i++) {
                            const memory = p.history[i];
                            const age = this.time - memory[2];
                            const weight = Math.exp(-age / (this.params.memoryDepth * 0.3));
                            
                            weightedX += memory[0] * weight;
                            weightedY += memory[1] * weight;
                            totalWeight += weight;
                        }
                        
                        const hx = weightedX / totalWeight;
                        const hy = weightedY / totalWeight;
                        
                        // Coherence value based on trajectory stability
                        const displacement = Math.sqrt((hx - p.x) ** 2 + (hy - p.y) ** 2);
                        p.coherenceValue = Math.exp(-displacement / 50);
                        
                        // Non-Markovian memory force
                        const memoryForce = this.params.coherenceStrength * p.coherenceValue;
                        p.vx += (hx - p.x) * memoryForce;
                        p.vy += (hy - p.y) * memoryForce;
                    }
                    
                    // Random motion (exploration vs exploitation balance)
                    p.vx += (Math.random() - 0.5) * this.params.randomMotion;
                    p.vy += (Math.random() - 0.5) * this.params.randomMotion;
                    
                    // Damping
                    p.vx *= this.params.damping;
                    p.vy *= this.params.damping;
                    
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Boundary handling with soft reflection
                    if (p.x < 0 || p.x > this.canvas.width) {
                        p.vx *= -0.8;
                        p.x = Math.max(0, Math.min(this.canvas.width, p.x));
                    }
                    if (p.y < 0 || p.y > this.canvas.height) {
                        p.vy *= -0.8;
                        p.y = Math.max(0, Math.min(this.canvas.height, p.y));
                    }
                });
            }
            
            triggerRupture(clickX, clickY) {
                this.phase = 'rupture';
                this.ruptureActive = true;
                this.ruptureDecayTime = 30;
                this.lastRuptureTime = this.time;
                this.totalRuptures++;
                
                // UCF Rupture Event: δ(t-t₀)
                this.particles.forEach(p => {
                    const dx = p.x - clickX;
                    const dy = p.y - clickY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const influence = Math.exp(-dist / this.params.ruptureRadius);
                    
                    if (influence > 0.01) {
                        // Clear memory proportional to rupture influence
                        const memoryLoss = Math.floor(p.history.length * influence * 0.8);
                        p.history = p.history.slice(memoryLoss);
                        
                        // Add impulse away from rupture point
                        const normalizedDx = dist > 0 ? dx / dist : Math.random() - 0.5;
                        const normalizedDy = dist > 0 ? dy / dist : Math.random() - 0.5;
                        
                        p.vx += normalizedDx * influence * this.params.ruptureIntensity;
                        p.vy += normalizedDy * influence * this.params.ruptureIntensity;
                        
                        p.timeSinceLastRupture = 0;
                        p.coherenceValue = 0.1;
                    }
                });
                
                this.updateEquationDisplay();
                
                // Visual feedback
                this.ctx.fillStyle = "rgba(255,0,0,0.3)";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            updateEquationDisplay() {
                const activeEquation = document.getElementById('activeEquation');
                const currentEquation = document.getElementById('currentEquation');
                const equationDescription = document.getElementById('equationDescription');
                const codeSnippet = document.getElementById('codeSnippet');
                const phaseIndicator = document.getElementById('phaseIndicator');
                
                // Remove all phase classes
                activeEquation.classList.remove('phase-coherence', 'phase-rupture', 'phase-regeneration');
                phaseIndicator.classList.remove('phase-coherence', 'phase-rupture', 'phase-regeneration');
                
                if (this.phase === 'coherence') {
                    activeEquation.classList.add('phase-coherence');
                    phaseIndicator.classList.add('phase-coherence');
                    currentEquation.textContent = 'C(x,t) = ∫₀ᵗ L(x,τ) dτ';
                    equationDescription.textContent = 'Swarm coherence through accumulated positional memory integration';
                    phaseIndicator.textContent = 'Phase: Coherence Building';
                    codeSnippet.textContent = `// Coherence Phase - Historical Memory Integration
p.history.push([p.x, p.y, this.time]);
if (p.history.length > memoryDepth) p.history.shift();

// Memory-weighted centroid calculation
let hx = p.history.reduce((a,b) => a + b[0], 0) / p.history.length;
let hy = p.history.reduce((a,b) => a + b[1], 0) / p.history.length;

// Non-Markovian force based on entire trajectory
p.vx += (hx - p.x) * coherenceStrength;
p.vy += (hy - p.y) * coherenceStrength;`;
                } else if (this.phase === 'rupture') {
                    activeEquation.classList.add('phase-rupture');
                    phaseIndicator.classList.add('phase-rupture');
                    currentEquation.textContent = 'δ(t-t₀)';
                    equationDescription.textContent = 'Discrete rupture event - localized memory disruption';
                    phaseIndicator.textContent = 'Phase: Rupture Active';
                    codeSnippet.textContent = `// Rupture Phase - Memory Disruption
const influence = Math.exp(-dist / ruptureRadius);
if (influence > 0.01) {
    // Clear memory proportional to rupture influence
    const memoryLoss = Math.floor(p.history.length * influence * 0.8);
    p.history = p.history.slice(memoryLoss);
    
    // Add impulse away from rupture point
    p.vx += normalizedDx * influence * ruptureIntensity;
    p.vy += normalizedDy * influence * ruptureIntensity;
}`;
                } else if (this.phase === 'regeneration') {
                    activeEquation.classList.add('phase-regeneration');
                    phaseIndicator.classList.add('phase-regeneration');
                    currentEquation.textContent = 'R[χ](x,t) = ∫ Fφ(x,τ)·e^(C(x)/Ω)dτ';
                    equationDescription.textContent = 'Rebirth reconstruction integrating new experiences with memory traces';
                    phaseIndicator.textContent = 'Phase: Regenerating';
                    codeSnippet.textContent = `// Regeneration Phase - Pattern Rebuilding
for (let memory of p.history) {
    const age = this.time - memory[2];
    const weight = Math.exp(-age / (memoryDepth * 0.3));
    const coherenceWeight = Math.exp(p.coherenceValue / fieldOmega);
    
    totalWeight += weight * coherenceWeight;
    weightedX += memory[0] * weight * coherenceWeight;
    weightedY += memory[1] * weight * coherenceWeight;
}
// Causal constraint: Θ(t-τ) ensures only past influences present`;
                }
            }
            
            render() {
                // Semi-transparent background for trail effect
                this.ctx.fillStyle = this.showTrails ? "rgba(0,0,0,0.1)" : "rgba(0,0,0,1)";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw particles
                this.particles.forEach(p => {
                    // Particle color based on coherence and phase
                    let red, green, blue, alpha;
                    
                    if (this.phase === 'rupture') {
                        red = 255;
                        green = Math.floor(100 + p.coherenceValue * 155);
                        blue = Math.floor(100 + p.coherenceValue * 155);
                        alpha = 0.8;
                    } else if (this.phase === 'regeneration') {
                        red = Math.floor(100 + p.coherenceValue * 155);
                        green = Math.floor(100 + p.coherenceValue * 155);
                        blue = 255;
                        alpha = 0.7 + p.coherenceValue * 0.3;
                    } else {
                        red = Math.floor(255 * (1 - p.coherenceValue));
                        green = 255;
                        blue = Math.floor(255 * p.coherenceValue);
                        alpha = 0.6 + p.coherenceValue * 0.4;
                    }
                    
                    // Draw particle
                    this.ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 2 + p.coherenceValue * 2, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Draw memory trail
                    if (this.showTrails && p.history.length > 1) {
                        this.ctx.strokeStyle = `rgba(${red}, ${green}, ${blue}, ${alpha * 0.3})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        
                        const trailLength = Math.min(10, p.history.length);
                        for (let i = p.history.length - trailLength; i < p.history.length; i++) {
                            const memory = p.history[i];
                            if (i === p.history.length - trailLength) {
                                this.ctx.moveTo(memory[0], memory[1]);
                            } else {
                                this.ctx.lineTo(memory[0], memory[1]);
                            }
                        }
                        this.ctx.stroke();
                    }
                });
                
                this.updateMetrics();
            }
            
            updateMetrics() {
                const avgMemoryLength = this.particles.reduce((sum, p) => sum + p.history.length, 0) / this.particles.length;
                const avgCoherence = this.particles.reduce((sum, p) => sum + p.coherenceValue, 0) / this.particles.length;
                const systemEnergy = this.particles.reduce((sum, p) => sum + (p.vx * p.vx + p.vy * p.vy), 0) / this.particles.length;
                const timeSinceRupture = Math.floor((this.time - this.lastRuptureTime) / 60);
                
                document.getElementById('activeParticles').textContent = this.particles.length;
                document.getElementById('avgMemoryLength').textContent = avgMemoryLength.toFixed(1);
                document.getElementById('systemEnergy').textContent = systemEnergy.toFixed(3);
                document.getElementById('coherenceIndex').textContent = avgCoherence.toFixed(3);
                document.getElementById('timeSinceRupture').textContent = `${timeSinceRupture}s`;
                document.getElementById('totalRuptures').textContent = this.totalRuptures;
                document.getElementById('mnemonicIntegral').textContent = avgCoherence.toFixed(3);
                document.getElementById('diracOperator').textContent = this.ruptureActive ? '1.000' : '0.000';
            }
            
            setupEventListeners() {
                // Canvas click for rupture
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    this.triggerRupture(clickX, clickY);
                });
                
                // Parameter controls
                const controls = [
                    'particleCount', 'memoryDepth', 'randomMotion', 'damping',
                    'coherenceStrength', 'ruptureRadius', 'ruptureIntensity', 'fieldOmega'
                ];
                
                controls.forEach(id => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(id + 'Value');
                    
                    slider.addEventListener('input', () => {
                        this.params[id] = parseFloat(slider.value);
                        valueDisplay.textContent = slider.value;
                        
                        if (id === 'particleCount') {
                            this.initializeParticles();
                        }
                    });
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }
            
            animate() {
                this.updateParticles();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
            
            // Public methods for buttons
            triggerGlobalRupturePublic() {
                this.triggerRupture(this.canvas.width / 2, this.canvas.height / 2);
            }
            
            resetSwarmPublic() {
                this.time = 0;
                this.lastRuptureTime = 0;
                this.totalRuptures = 0;
                this.phase = 'coherence';
                this.ruptureActive = false;
                this.initializeParticles();
            }
            
            toggleTrailsPublic() {
                this.showTrails = !this.showTrails;
                document.getElementById('trailsBtn').textContent = `Trails: ${this.showTrails ? 'ON' : 'OFF'}`;
            }
            
            togglePausePublic() {
                this.paused = !this.paused;
                document.getElementById('pauseBtn').textContent = this.paused ? 'Resume' : 'Pause';
            }
        }
        
        // Initialize simulation
        let simulation;
        window.addEventListener('DOMContentLoaded', () => {
            simulation = new UCFSwarmSimulation();
        });
        
        // Global functions for buttons
        function triggerGlobalRupture() { simulation.triggerGlobalRupturePublic(); }
        function resetSwarm() { simulation.resetSwarmPublic(); }
        function toggleTrails() { simulation.toggleTrailsPublic(); }
        function togglePause() { simulation.togglePausePublic(); }
    </script>
</body>
</html>