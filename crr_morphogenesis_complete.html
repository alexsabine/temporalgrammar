<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Morphogenesis: From DNA to Human Form</title>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-deep: #060a08;
      --bg-mid: #0c1610;
      --bg-surface: rgba(20, 45, 35, 0.5);
      --border: rgba(74, 154, 138, 0.2);
      --border-bright: rgba(74, 154, 138, 0.4);
      --text-primary: #c8e8d8;
      --text-secondary: #8ab8a8;
      --text-muted: rgba(168, 200, 184, 0.5);
      --accent: #7ac4a8;
      --accent-bright: #9ae4c8;
      --gene-axis: #8b5cf6;
      --gene-hox: #f59e0b;
      --gene-organ: #10b981;
      --gene-limb: #3b82f6;
      --gene-late: #ef4444;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      background: linear-gradient(165deg, var(--bg-deep) 0%, var(--bg-mid) 50%, var(--bg-deep) 100%);
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      line-height: 1.6;
      min-height: 100vh;
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-deep); }
    ::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 3px; }
    
    /* Typography */
    h1, h2, h3 { font-family: 'Cormorant Garamond', serif; font-weight: 400; color: var(--accent); }
    h1 { font-size: 2.8rem; letter-spacing: 0.08em; }
    h2 { font-size: 1.6rem; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.2rem; margin-bottom: 0.75rem; }
    
    p { margin-bottom: 1rem; color: var(--text-secondary); }
    strong { color: var(--accent); font-weight: 500; }
    em { color: var(--accent-bright); font-style: italic; }
    code { background: var(--bg-surface); padding: 0.15em 0.4em; border-radius: 3px; font-size: 0.9em; }
    
    /* Layout */
    .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
    
    header {
      text-align: center;
      padding: 3rem 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 2rem;
    }
    
    header p { font-size: 1rem; opacity: 0.7; margin-top: 0.5rem; }
    
    .main-grid {
      display: grid;
      grid-template-columns: 320px 1fr 320px;
      gap: 1.5rem;
      margin-bottom: 3rem;
    }
    
    .panel {
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.25rem;
    }
    
    /* Simulation Area */
    .sim-container { display: flex; flex-direction: column; align-items: center; }
    
    #simulation {
      width: 100%;
      aspect-ratio: 1;
      background: radial-gradient(ellipse at center, #14251e 0%, var(--bg-deep) 100%);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    
    .controls {
      display: flex;
      gap: 0.75rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    button {
      padding: 0.6rem 1.5rem;
      background: var(--bg-surface);
      border: 1px solid var(--border-bright);
      border-radius: 4px;
      color: var(--accent-bright);
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:hover { background: rgba(74, 154, 138, 0.2); }
    button.primary { background: rgba(74, 154, 138, 0.3); }
    button.danger { border-color: rgba(239, 68, 68, 0.4); color: #fca5a5; }
    
    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
    }
    
    .slider-group label { color: var(--text-muted); }
    .slider-group span { min-width: 2.5rem; }
    
    input[type="range"] {
      width: 80px;
      accent-color: var(--accent);
    }
    
    /* Genome Visualizer */
    .genome-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 1rem;
    }
    
    .gene {
      width: 22px;
      height: 22px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
      transition: all 0.3s;
      cursor: default;
      position: relative;
    }
    
    .gene.inactive { opacity: 0.3; background: #2a3a32; }
    .gene.axis { background: var(--gene-axis); }
    .gene.hox { background: var(--gene-hox); }
    .gene.organ { background: var(--gene-organ); }
    .gene.limb { background: var(--gene-limb); }
    .gene.late { background: var(--gene-late); }
    
    .gene-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-size: 0.7rem;
      margin-top: 0.75rem;
    }
    
    .gene-legend span {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .gene-legend .dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }
    
    /* Timeline */
    .timeline {
      max-height: 180px;
      overflow-y: auto;
      font-size: 0.75rem;
    }
    
    .timeline-event {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.3rem 0;
      border-bottom: 1px solid rgba(74, 154, 138, 0.1);
    }
    
    .timeline-event .time { width: 40px; color: var(--text-muted); }
    .timeline-event .bar {
      flex: 1;
      height: 10px;
      background: rgba(30, 60, 50, 0.5);
      border-radius: 2px;
      overflow: hidden;
    }
    .timeline-event .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-bright));
      border-radius: 2px;
    }
    .timeline-event .name { width: 90px; color: var(--accent); font-size: 0.7rem; }
    
    /* Stats */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }
    
    .stat {
      padding: 0.5rem;
      background: rgba(30, 60, 50, 0.3);
      border-radius: 4px;
    }
    
    .stat-label { font-size: 0.65rem; color: var(--text-muted); }
    .stat-value { font-size: 1.1rem; color: var(--accent-bright); }
    
    /* Exposition Section */
    .exposition {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }
    
    .expo-card {
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .expo-card ul {
      margin-left: 1.25rem;
      color: var(--text-secondary);
    }
    
    .expo-card li { margin-bottom: 0.5rem; }
    
    .equation {
      background: rgba(30, 60, 50, 0.4);
      padding: 1rem;
      border-radius: 4px;
      font-family: 'Cormorant Garamond', serif;
      font-size: 1.3rem;
      text-align: center;
      margin: 1rem 0;
      color: var(--accent-bright);
    }
    
    .highlight-box {
      background: rgba(74, 154, 138, 0.15);
      border-left: 3px solid var(--accent);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 4px 4px 0;
    }
    
    /* Body state panel */
    .body-state {
      margin-top: 1rem;
      padding: 0.75rem;
      background: rgba(30, 60, 50, 0.3);
      border-radius: 4px;
      font-size: 0.75rem;
    }
    
    .body-state div { margin-bottom: 0.25rem; }
    
    /* Footer */
    footer {
      text-align: center;
      padding: 2rem;
      border-top: 1px solid var(--border);
      margin-top: 2rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }
    
    @media (max-width: 1100px) {
      .main-grid { grid-template-columns: 1fr; }
      .exposition { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>CRR MORPHOGENESIS</h1>
      <p>Coherence–Rupture–Regeneration dynamics governing the emergence of human form from DNA</p>
    </header>
    
    <div class="main-grid">
      <!-- Left Panel: Genome -->
      <div class="panel">
        <h3>Genome (<span id="expressed-count">0</span>/<span id="total-genes">0</span> expressed)</h3>
        
        <div id="genome-grid" class="genome-grid"></div>
        
        <div class="gene-legend">
          <span><div class="dot" style="background: var(--gene-axis)"></div> Axis</span>
          <span><div class="dot" style="background: var(--gene-hox)"></div> Hox</span>
          <span><div class="dot" style="background: var(--gene-organ)"></div> Organ</span>
          <span><div class="dot" style="background: var(--gene-limb)"></div> Limb</span>
          <span><div class="dot" style="background: var(--gene-late)"></div> Late</span>
        </div>
        
        <div class="body-state">
          <strong style="color: var(--accent);">Body State</strong>
          <div>Elongation: <span id="body-elongation">0</span>%</div>
          <div>Uprightness: <span id="body-uprightness">0</span>%</div>
          <div>Head size: <span id="body-head">0</span>%</div>
          <div>Limb pairs: <span id="body-limbs">0</span></div>
        </div>
        
        <h3 style="margin-top: 1.25rem;">Expression Timeline</h3>
        <div id="timeline" class="timeline">
          <div style="color: var(--text-muted); font-size: 0.75rem;">Awaiting development...</div>
        </div>
      </div>
      
      <!-- Center: Simulation -->
      <div class="sim-container">
        <svg id="simulation" viewBox="0 0 400 400">
          <defs>
            <radialGradient id="bodyGrad" cx="40%" cy="30%">
              <stop offset="0%" stop-color="#5aa888" />
              <stop offset="100%" stop-color="#2d6a5a" />
            </radialGradient>
            <radialGradient id="bodyGrad2" cx="40%" cy="30%">
              <stop offset="0%" stop-color="#4a9878" />
              <stop offset="100%" stop-color="#2a5a4a" />
            </radialGradient>
            <radialGradient id="headGrad" cx="35%" cy="30%">
              <stop offset="0%" stop-color="#7ac4a8" />
              <stop offset="100%" stop-color="#4a9a8a" />
            </radialGradient>
          </defs>
          <g id="body-group"></g>
          <text id="stage-label" x="200" y="385" text-anchor="middle" fill="#5a9a8a" font-size="13" font-family="'Cormorant Garamond', serif"></text>
        </svg>
        
        <div class="controls">
          <button id="btn-play" class="primary">▶ Develop</button>
          <button id="btn-reset" class="danger">↺ Reset</button>
        </div>
        
        <div class="controls" style="margin-top: 0.75rem;">
          <div class="slider-group">
            <label>Speed:</label>
            <input type="range" id="speed" min="0.5" max="3" step="0.5" value="1">
            <span id="speed-val">1×</span>
          </div>
          <div class="slider-group">
            <label>Selection Pressure:</label>
            <input type="range" id="pressure" min="0.1" max="0.8" step="0.1" value="0.4">
            <span id="pressure-val">0.4</span>
          </div>
        </div>
      </div>
      
      <!-- Right Panel: CRR Dynamics -->
      <div class="panel">
        <h3>CRR Dynamics</h3>
        
        <div class="stats-grid">
          <div class="stat">
            <div class="stat-label">Developmental Age</div>
            <div class="stat-value" id="dev-age">0.0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Ω (effective)</div>
            <div class="stat-value" id="omega">0.300</div>
          </div>
          <div class="stat">
            <div class="stat-label">Gene Coherence (C)</div>
            <div class="stat-value" id="coherence">0.0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Stability (C/Ω)</div>
            <div class="stat-value" id="stability">0.0</div>
          </div>
        </div>
        
        <div class="highlight-box" style="margin-top: 1.25rem;">
          <strong>The CRR Mechanism</strong><br><br>
          <strong>DNA</strong> = Accumulated evolutionary coherence<br><br>
          <strong>Rupture (δ)</strong> = Gene expression event<br><br>
          <strong>exp(C/Ω)</strong> = High-coherence genes express first<br><br>
          <strong>Body</strong> = Phenotype from expression history
        </div>
        
        <div style="margin-top: 1rem; font-size: 0.75rem; color: var(--text-secondary);">
          <strong style="color: var(--accent);">Why Hox genes are conserved:</strong><br>
          High coherence → high exp(C/Ω) → always expressed early and reliably → 
          any mutation disrupts downstream cascade → strongly selected against.
        </div>
      </div>
    </div>
    
    <!-- Exposition Section -->
    <div class="exposition">
      <div class="expo-card">
        <h2>What Has Been Achieved</h2>
        <p>
          This simulation demonstrates <strong>CRR (Coherence–Rupture–Regeneration)</strong> as the 
          governing dynamics for morphogenesis—the emergence of body form from genetic information.
        </p>
        <p>
          The human figure that emerges is <em>not pre-drawn</em>. It is generated through a sequence 
          of developmental events whose <strong>timing is determined by CRR mathematics</strong>:
        </p>
        <ul>
          <li><strong>Coherence accumulates</strong> from expressed genes</li>
          <li><strong>Rupture occurs</strong> when the C/Ω threshold is crossed</li>
          <li><strong>Gene selection</strong> is weighted by exp(C/Ω)—favouring high-coherence genes</li>
          <li><strong>Body structure changes</strong> based on which gene expressed</li>
        </ul>
      </div>
      
      <div class="expo-card">
        <h2>The Core Equations</h2>
        
        <p><strong>1. Coherence Accumulation</strong></p>
        <div class="equation">C(t) = Σ C<sub>gene</sub> for all expressed genes</div>
        <p>Coherence is the sum of all expressed gene coherence values—representing accumulated developmental stability.</p>
        
        <p><strong>2. Rupture Probability</strong></p>
        <div class="equation">P(δ) ∝ pressure / (1 + C/Ω)</div>
        <p>Higher selection pressure increases rupture rate; higher stability (C/Ω) decreases it.</p>
        
        <p><strong>3. Gene Selection Weighting</strong></p>
        <div class="equation">w<sub>gene</sub> = exp(C<sub>gene</sub> / Ω)</div>
        <p>Genes with higher coherence are exponentially more likely to be selected for expression.</p>
      </div>
      
      <div class="expo-card">
        <h2>The Genome as Coherence Reservoir</h2>
        <p>
          Each gene carries a <strong>coherence value</strong> representing millions of years of 
          evolutionary selection. This is why the model treats <strong>DNA as accumulated coherence</strong>.
        </p>
        
        <table style="width: 100%; font-size: 0.8rem; margin-top: 1rem;">
          <tr style="border-bottom: 1px solid var(--border);">
            <th style="text-align: left; padding: 0.5rem;">Gene Category</th>
            <th style="text-align: left; padding: 0.5rem;">Coherence</th>
            <th style="text-align: left; padding: 0.5rem;">Role</th>
          </tr>
          <tr><td style="padding: 0.4rem; color: var(--gene-axis);">Axis genes</td><td>9–10</td><td>Body axes (most ancient)</td></tr>
          <tr><td style="padding: 0.4rem; color: var(--gene-hox);">Hox genes</td><td>6.5–8</td><td>Segment identity</td></tr>
          <tr><td style="padding: 0.4rem; color: var(--gene-organ);">Organ genes</td><td>5–7</td><td>Organ specification</td></tr>
          <tr><td style="padding: 0.4rem; color: var(--gene-limb);">Limb genes</td><td>3–5</td><td>Appendage patterning</td></tr>
          <tr><td style="padding: 0.4rem; color: var(--gene-late);">Late genes</td><td>2–2.5</td><td>Recent adaptations</td></tr>
        </table>
        
        <p style="margin-top: 1rem;">
          High-coherence genes (like Hox) are <strong>95%+ conserved across 500 million years</strong> 
          precisely because the exp(C/Ω) weighting ensures they always express reliably.
        </p>
      </div>
      
      <div class="expo-card">
        <h2>Developmental Sequence</h2>
        <p>The simulation produces a stereotyped developmental sequence, driven by gene prerequisites and CRR selection:</p>
        
        <ol style="margin-left: 1.25rem; color: var(--text-secondary);">
          <li><strong>Axis establishment</strong> — Anterior-Posterior, Dorsal-Ventral, Left-Right</li>
          <li><strong>Hox patterning</strong> — Head, Thorax, Abdomen regional identity</li>
          <li><strong>Organogenesis</strong> — Neural tube, eye field, somite clock</li>
          <li><strong>Limb formation</strong> — Bud → Proximal → Medial → Distal → Digits</li>
          <li><strong>Late modifications</strong> — Uprightness, encephalisation</li>
        </ol>
        
        <p style="margin-top: 1rem;">
          This sequence emerges from two constraints: <strong>gene prerequisites</strong> (biological logic) 
          and <strong>exp(C/Ω) weighting</strong> (high-coherence genes express first within each tier).
        </p>
      </div>
      
      <div class="expo-card">
        <h2>CRR's Explanatory Power</h2>
        <p>The CRR framework explains several key phenomena in evolutionary developmental biology:</p>
        
        <div class="highlight-box">
          <strong>Why are body plans conserved?</strong><br>
          High-coherence axis and Hox genes have such strong exp(C/Ω) weighting that they 
          always dominate early development, creating the same basic body plan.
        </div>
        
        <div class="highlight-box">
          <strong>Why does evolution repeat solutions?</strong><br>
          Eyes evolved 40+ times independently because the same high-coherence developmental 
          programs are consistently accessed via exp(C/Ω) weighting.
        </div>
        
        <div class="highlight-box">
          <strong>Why are late features more variable?</strong><br>
          Low-coherence genes (like UPRIGHT_POSTURE) have lower exp(C/Ω) weights, making 
          their expression more stochastic and thus more evolutionarily labile.
        </div>
      </div>
      
      <div class="expo-card">
        <h2>Connection to Broader CRR Theory</h2>
        <p>
          This morphogenesis model is one application of the broader <strong>CRR framework</strong>, 
          which describes how systems accumulate coherence, undergo rupture transitions, and 
          regenerate with memory-weighted access to prior states.
        </p>
        <p>The core CRR equations are:</p>
        <div class="equation">C(x,t) = ∫ L(x,τ) dτ</div>
        <p style="text-align: center; font-size: 0.85rem;">Coherence accumulates over time</p>
        
        <div class="equation">δ(now)</div>
        <p style="text-align: center; font-size: 0.85rem;">Rupture as scale-invariant transition moment</p>
        
        <div class="equation">R = ∫ φ(x,τ) exp(C/Ω) dτ</div>
        <p style="text-align: center; font-size: 0.85rem;">Regeneration weighted by coherence history</p>
        
        <p style="margin-top: 1rem;">
          The key insight: <strong>Ω = 1/φ</strong> where φ is the phase to rupture, determined by 
          the symmetry class of the system. For morphogenesis, we use Ω ≈ 0.3, allowing frequent 
          developmental transitions while maintaining coherence-weighted selection.
        </p>
      </div>
    </div>
    
    <footer>
      <p>CRR Morphogenesis Simulation · Alexander Sabine · Active Inference Institute · January 2026</p>
      <p style="margin-top: 0.5rem;">
        Framework: Coherence–Rupture–Regeneration (CRR) · 
        <a href="https://www.temporalgrammar.ai" style="color: var(--accent);">www.temporalgrammar.ai</a>
      </p>
    </footer>
  </div>
  
  <script>
    // ==========================================================================
    // GENE DEFINITIONS
    // ==========================================================================
    
    const GENES = [
      // Axis genes (highest coherence - most ancient)
      { id: 'AP', name: 'Anterior-Posterior', coherence: 10, category: 'axis', prereqs: [] },
      { id: 'DV', name: 'Dorsal-Ventral', coherence: 9, category: 'axis', prereqs: ['AP'] },
      { id: 'LR', name: 'Left-Right', coherence: 9.5, category: 'axis', prereqs: ['AP'] },
      
      // Hox genes (high coherence - fundamental patterning)
      { id: 'HOX_HEAD', name: 'Hox-Head', coherence: 8, category: 'hox', prereqs: ['AP'] },
      { id: 'HOX_THORAX', name: 'Hox-Thorax', coherence: 7.5, category: 'hox', prereqs: ['AP'] },
      { id: 'HOX_ABDOMEN', name: 'Hox-Abdomen', coherence: 7, category: 'hox', prereqs: ['HOX_THORAX'] },
      { id: 'HOX_LIMB', name: 'Hox-Limb', coherence: 6.5, category: 'hox', prereqs: ['HOX_THORAX'] },
      
      // Organ genes (medium coherence)
      { id: 'NEURAL', name: 'Neural Tube', coherence: 7, category: 'organ', prereqs: ['DV'] },
      { id: 'EYE', name: 'Eye Field', coherence: 6, category: 'organ', prereqs: ['HOX_HEAD'] },
      { id: 'SOMITE', name: 'Somite Clock', coherence: 5, category: 'organ', prereqs: ['AP'] },
      { id: 'FACE', name: 'Facial Features', coherence: 4.5, category: 'organ', prereqs: ['HOX_HEAD', 'EYE'] },
      
      // Limb genes (medium coherence, cascade)
      { id: 'LIMB_BUD', name: 'Limb Bud', coherence: 5, category: 'limb', prereqs: ['HOX_LIMB'] },
      { id: 'LIMB_PROX', name: 'Limb Proximal', coherence: 4.5, category: 'limb', prereqs: ['LIMB_BUD'] },
      { id: 'LIMB_MED', name: 'Limb Medial', coherence: 4, category: 'limb', prereqs: ['LIMB_PROX'] },
      { id: 'LIMB_DIST', name: 'Limb Distal', coherence: 3.5, category: 'limb', prereqs: ['LIMB_MED'] },
      { id: 'DIGITS', name: 'Digit Pattern', coherence: 3, category: 'limb', prereqs: ['LIMB_DIST'] },
      
      // Late genes (low coherence - recent adaptations)
      { id: 'UPRIGHT', name: 'Upright Posture', coherence: 2, category: 'late', prereqs: ['LIMB_DIST'] },
      { id: 'ENCEPH', name: 'Encephalisation', coherence: 2.5, category: 'late', prereqs: ['NEURAL', 'HOX_HEAD'] },
    ];
    
    // ==========================================================================
    // STATE
    // ==========================================================================
    
    let state = {
      genome: {},
      body: null,
      playing: false,
      time: 0,
      speed: 1,
      pressure: 0.4,
      omega: 0.3,
      expressionHistory: [],
    };
    
    function createInitialBody() {
      return {
        elongation: 0,
        segments: 1,
        hasHead: false,
        headSize: 0,
        hasEyes: false,
        hasMouth: false,
        limbBuds: [],
        uprightness: 0,
        developmentalAge: 0,
        hasDigits: false,
      };
    }
    
    function createGenome() {
      const genome = {};
      GENES.forEach(gene => {
        genome[gene.id] = {
          ...gene,
          expressed: false,
          expressionTime: null,
        };
      });
      return genome;
    }
    
    // ==========================================================================
    // CRR ENGINE
    // ==========================================================================
    
    function getExpressedCoherence() {
      return Object.values(state.genome)
        .filter(g => g.expressed)
        .reduce((sum, g) => sum + g.coherence, 0);
    }
    
    function getExpressibleGenes() {
      return Object.values(state.genome).filter(gene => {
        if (gene.expressed) return false;
        return gene.prereqs.every(prereq => state.genome[prereq]?.expressed);
      });
    }
    
    function checkRupture() {
      const C = getExpressedCoherence();
      const numExpressed = Object.values(state.genome).filter(g => g.expressed).length;
      const effectiveOmega = state.omega * (1 + numExpressed * 0.02);
      const stability = C / effectiveOmega;
      
      const pRupture = Math.min(0.2 * (1 + state.pressure * 3) / (1 + stability * 0.01), 0.5);
      
      // Update display
      document.getElementById('omega').textContent = effectiveOmega.toFixed(3);
      document.getElementById('coherence').textContent = C.toFixed(1);
      document.getElementById('stability').textContent = stability.toFixed(1);
      
      return Math.random() < pRupture;
    }
    
    function selectGene(expressible) {
      if (expressible.length === 0) return null;
      
      const numExpressed = Object.values(state.genome).filter(g => g.expressed).length;
      const effectiveOmega = state.omega * (1 + numExpressed * 0.02);
      const maxC = Math.max(...expressible.map(g => g.coherence));
      
      const weights = expressible.map(gene => {
        const logWeight = (gene.coherence - maxC) / effectiveOmega;
        return { gene, weight: Math.exp(Math.max(logWeight, -20)) };
      });
      
      const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
      let r = Math.random() * totalWeight;
      
      for (const { gene, weight } of weights) {
        r -= weight;
        if (r <= 0) return gene;
      }
      return weights[0].gene;
    }
    
    function applyGeneExpression(gene) {
      state.genome[gene.id].expressed = true;
      state.genome[gene.id].expressionTime = state.body.developmentalAge;
      
      state.expressionHistory.push({
        gene: gene.id,
        name: gene.name,
        time: state.body.developmentalAge,
        coherence: gene.coherence,
      });
      
      // Apply phenotypic effect
      switch (gene.id) {
        case 'AP':
          state.body.elongation = Math.max(state.body.elongation, 0.2);
          break;
        case 'DV':
          state.body.elongation = Math.min(state.body.elongation + 0.1, 1);
          break;
        case 'HOX_HEAD':
          state.body.hasHead = true;
          state.body.headSize = 0.35;
          break;
        case 'HOX_THORAX':
          state.body.elongation = Math.min(state.body.elongation + 0.2, 1);
          break;
        case 'HOX_ABDOMEN':
          state.body.elongation = Math.min(state.body.elongation + 0.15, 1);
          break;
        case 'EYE':
          state.body.hasEyes = true;
          break;
        case 'FACE':
          state.body.hasMouth = true;
          state.body.headSize = Math.min(state.body.headSize + 0.2, 1);
          break;
        case 'SOMITE':
          state.body.segments = Math.min(state.body.segments + 2, 4);
          break;
        case 'LIMB_BUD':
          state.body.limbBuds = [
            { position: 0.25, size: 0.15, type: 'bud' },
            { position: 0.75, size: 0.15, type: 'bud' },
          ];
          break;
        case 'LIMB_PROX':
          state.body.limbBuds.forEach(l => { l.size = 0.4; l.type = 'proximal'; });
          break;
        case 'LIMB_MED':
          state.body.limbBuds.forEach(l => { l.size = 0.65; l.type = 'medial'; });
          break;
        case 'LIMB_DIST':
          state.body.limbBuds.forEach(l => {
            l.size = 1;
            l.type = l.position < 0.5 ? 'arm' : 'leg';
          });
          break;
        case 'DIGITS':
          state.body.hasDigits = true;
          break;
        case 'UPRIGHT':
          state.body.uprightness = 1;
          break;
        case 'ENCEPH':
          state.body.headSize = Math.min(state.body.headSize + 0.3, 1);
          break;
      }
    }
    
    function step() {
      const dt = 0.1 * state.speed;
      state.body.developmentalAge += dt;
      state.time++;
      
      document.getElementById('dev-age').textContent = state.body.developmentalAge.toFixed(1);
      
      if (checkRupture()) {
        const expressible = getExpressibleGenes();
        const gene = selectGene(expressible);
        if (gene) {
          applyGeneExpression(gene);
        }
      }
      
      updateUI();
      renderBody();
    }
    
    // ==========================================================================
    // RENDERING
    // ==========================================================================
    
    function renderBody() {
      const svg = document.getElementById('body-group');
      svg.innerHTML = '';
      
      const body = state.body;
      const cx = 200, cy = 200;
      const pulse = 1 + Math.sin(state.time * 0.08) * 0.015;
      
      const baseSize = 35;
      const bodyLength = baseSize + body.elongation * 90;
      const bodyWidth = baseSize * (1.05 - body.elongation * 0.25);
      const isUpright = body.uprightness > 0.5;
      
      let elements = '';
      
      if (isUpright) {
        // UPRIGHT RENDERING
        const torsoH = bodyLength * 0.55;
        const torsoW = bodyWidth * 0.75;
        
        // Torso
        elements += `<ellipse cx="${cx}" cy="${cy + 5}" rx="${torsoW * pulse / 2}" ry="${torsoH * pulse / 2}" fill="url(#bodyGrad)" stroke="#2d5a4a" stroke-width="2"/>`;
        
        // Head
        if (body.hasHead) {
          const headY = cy - torsoH / 2 - body.headSize * 18;
          const headSize = 16 + body.headSize * 20;
          
          // Neck
          elements += `<line x1="${cx}" y1="${cy - torsoH / 2 + 8}" x2="${cx}" y2="${headY + headSize * 0.7}" stroke="#4a8a7a" stroke-width="${torsoW * 0.22}" stroke-linecap="round"/>`;
          
          // Head
          elements += `<ellipse cx="${cx}" cy="${headY}" rx="${headSize * 0.82 * pulse}" ry="${headSize * pulse}" fill="url(#headGrad)" stroke="#2d5a4a" stroke-width="2"/>`;
          
          // Eyes
          if (body.hasEyes) {
            const eyeSpacing = headSize * 0.32;
            const eyeSize = headSize * 0.14;
            const eyeY = headY - headSize * 0.12;
            elements += `<ellipse cx="${cx - eyeSpacing}" cy="${eyeY}" rx="${eyeSize}" ry="${eyeSize * 0.7}" fill="#1a3a2a"/>`;
            elements += `<ellipse cx="${cx + eyeSpacing}" cy="${eyeY}" rx="${eyeSize}" ry="${eyeSize * 0.7}" fill="#1a3a2a"/>`;
          }
          
          // Mouth
          if (body.hasMouth) {
            const mouthY = headY + headSize * 0.32;
            elements += `<path d="M ${cx - headSize * 0.18} ${mouthY} Q ${cx} ${mouthY + 4} ${cx + headSize * 0.18} ${mouthY}" stroke="#2d4a3a" stroke-width="2" fill="none"/>`;
          }
        }
        
        // Limbs
        body.limbBuds.forEach((limb, i) => {
          const limbLen = 12 + limb.size * 48;
          const limbW = 4 + limb.size * 6;
          const isArm = limb.position < 0.5;
          
          if (isArm) {
            const shoulderY = cy - torsoH * 0.32;
            const shoulderW = torsoW * 0.48;
            const armAngle = Math.PI * 0.38;
            
            const lx2 = cx - shoulderW - limbLen * Math.sin(armAngle);
            const ly2 = shoulderY + limbLen * Math.cos(armAngle);
            const rx2 = cx + shoulderW + limbLen * Math.sin(armAngle);
            
            elements += `<line x1="${cx - shoulderW}" y1="${shoulderY}" x2="${lx2}" y2="${ly2}" stroke="#4a9a8a" stroke-width="${limbW}" stroke-linecap="round"/>`;
            elements += `<line x1="${cx + shoulderW}" y1="${shoulderY}" x2="${rx2}" y2="${ly2}" stroke="#4a9a8a" stroke-width="${limbW}" stroke-linecap="round"/>`;
            
            if (limb.size > 0.5) {
              const handSize = body.hasDigits ? 7 + limb.size * 5 : 4 + limb.size * 4;
              elements += `<circle cx="${lx2}" cy="${ly2}" r="${handSize}" fill="url(#headGrad)" stroke="#2d5a4a" stroke-width="1"/>`;
              elements += `<circle cx="${rx2}" cy="${ly2}" r="${handSize}" fill="url(#headGrad)" stroke="#2d5a4a" stroke-width="1"/>`;
            }
          } else {
            const hipY = cy + torsoH * 0.28;
            const hipW = torsoW * 0.32;
            const legAngle = Math.PI * 0.06;
            
            const lx2 = cx - hipW - limbLen * Math.sin(legAngle);
            const ly2 = hipY + limbLen * Math.cos(legAngle);
            const rx2 = cx + hipW + limbLen * Math.sin(legAngle);
            
            elements += `<line x1="${cx - hipW}" y1="${hipY}" x2="${lx2}" y2="${ly2}" stroke="#4a9a8a" stroke-width="${limbW + 2}" stroke-linecap="round"/>`;
            elements += `<line x1="${cx + hipW}" y1="${hipY}" x2="${rx2}" y2="${ly2}" stroke="#4a9a8a" stroke-width="${limbW + 2}" stroke-linecap="round"/>`;
            
            if (limb.size > 0.5) {
              const footW = body.hasDigits ? 10 + limb.size * 5 : 6 + limb.size * 4;
              const footH = 3 + limb.size * 2;
              elements += `<ellipse cx="${lx2}" cy="${ly2 + 2}" rx="${footW}" ry="${footH}" fill="url(#headGrad)" stroke="#2d5a4a" stroke-width="1"/>`;
              elements += `<ellipse cx="${rx2}" cy="${ly2 + 2}" rx="${footW}" ry="${footH}" fill="url(#headGrad)" stroke="#2d5a4a" stroke-width="1"/>`;
            }
          }
        });
        
      } else {
        // HORIZONTAL RENDERING
        const bodyLeft = cx - bodyLength / 2;
        
        if (body.segments <= 1) {
          elements += `<ellipse cx="${cx}" cy="${cy}" rx="${bodyLength * pulse / 2}" ry="${bodyWidth * pulse / 2}" fill="url(#bodyGrad)" stroke="#2d5a4a" stroke-width="2"/>`;
        } else {
          const segW = bodyLength / body.segments;
          for (let i = 0; i < body.segments; i++) {
            const segX = bodyLeft + i * segW + segW / 2;
            const taper = 1 - Math.abs(i - body.segments / 2) / body.segments * 0.25;
            const fill = i % 2 === 0 ? 'url(#bodyGrad)' : 'url(#bodyGrad2)';
            elements += `<ellipse cx="${segX}" cy="${cy}" rx="${segW * 0.52 * pulse}" ry="${bodyWidth * taper * pulse / 2}" fill="${fill}" stroke="#2d5a4a" stroke-width="1"/>`;
          }
        }
        
        // Head
        if (body.hasHead) {
          const headX = bodyLeft - body.headSize * 10;
          const headSize = 10 + body.headSize * 18;
          
          elements += `<ellipse cx="${headX}" cy="${cy}" rx="${headSize * pulse}" ry="${headSize * 0.8 * pulse}" fill="url(#headGrad)" stroke="#2d5a4a" stroke-width="2"/>`;
          
          if (body.hasEyes) {
            const eyeSize = headSize * 0.12;
            elements += `<ellipse cx="${headX - headSize * 0.35}" cy="${cy - headSize * 0.25}" rx="${eyeSize * 0.7}" ry="${eyeSize}" fill="#1a3a2a"/>`;
            elements += `<ellipse cx="${headX - headSize * 0.35}" cy="${cy + headSize * 0.25}" rx="${eyeSize * 0.7}" ry="${eyeSize}" fill="#1a3a2a"/>`;
          }
          
          if (body.hasMouth) {
            elements += `<ellipse cx="${headX - headSize * 0.55}" cy="${cy}" rx="${headSize * 0.08}" ry="${headSize * 0.12}" fill="#2d4a3a"/>`;
          }
        }
        
        // Limbs (horizontal)
        body.limbBuds.forEach((limb, i) => {
          const limbLen = 10 + limb.size * 40;
          const limbW = 4 + limb.size * 5;
          const limbX = bodyLeft + limb.position * bodyLength;
          const attachOff = bodyWidth * 0.32;
          
          elements += `<line x1="${limbX}" y1="${cy - attachOff}" x2="${limbX - limbLen * 0.25}" y2="${cy - attachOff - limbLen * 0.85}" stroke="#4a9a8a" stroke-width="${limbW}" stroke-linecap="round"/>`;
          elements += `<line x1="${limbX}" y1="${cy + attachOff}" x2="${limbX - limbLen * 0.25}" y2="${cy + attachOff + limbLen * 0.85}" stroke="#4a9a8a" stroke-width="${limbW}" stroke-linecap="round"/>`;
        });
        
        // Tail
        if (body.elongation > 0.3 && body.uprightness < 0.5) {
          const tailStart = bodyLeft + bodyLength;
          const tailLen = 20 + body.elongation * 15;
          elements += `<path d="M ${tailStart} ${cy} Q ${tailStart + tailLen * 0.6} ${cy - 8} ${tailStart + tailLen} ${cy}" stroke="#4a8a7a" stroke-width="${bodyWidth * 0.18}" stroke-linecap="round" fill="none"/>`;
        }
      }
      
      svg.innerHTML = elements;
      
      // Update stage label
      const stageLabel = document.getElementById('stage-label');
      if (body.uprightness > 0.5) {
        stageLabel.textContent = 'Upright Biped';
      } else if (body.limbBuds.length > 0 && body.limbBuds[0].size > 0.5) {
        stageLabel.textContent = 'Quadruped';
      } else if (body.limbBuds.length > 0) {
        stageLabel.textContent = 'Limb Formation';
      } else if (body.hasHead) {
        stageLabel.textContent = 'Cephalised Embryo';
      } else if (body.elongation > 0.3) {
        stageLabel.textContent = 'Elongated Embryo';
      } else {
        stageLabel.textContent = 'Early Embryo';
      }
    }
    
    // ==========================================================================
    // UI UPDATES
    // ==========================================================================
    
    function updateUI() {
      // Genome grid
      const genomeGrid = document.getElementById('genome-grid');
      genomeGrid.innerHTML = '';
      
      const expressed = Object.values(state.genome).filter(g => g.expressed).length;
      document.getElementById('expressed-count').textContent = expressed;
      document.getElementById('total-genes').textContent = GENES.length;
      
      Object.values(state.genome).forEach(gene => {
        const div = document.createElement('div');
        div.className = `gene ${gene.category} ${gene.expressed ? '' : 'inactive'}`;
        div.textContent = gene.expressed ? '✓' : '';
        div.title = `${gene.name}\nCoherence: ${gene.coherence}\n${gene.expressed ? `Expressed at t=${gene.expressionTime?.toFixed(1)}` : 'Not expressed'}`;
        genomeGrid.appendChild(div);
      });
      
      // Body state
      document.getElementById('body-elongation').textContent = (state.body.elongation * 100).toFixed(0);
      document.getElementById('body-uprightness').textContent = (state.body.uprightness * 100).toFixed(0);
      document.getElementById('body-head').textContent = state.body.hasHead ? (state.body.headSize * 100).toFixed(0) : '0';
      document.getElementById('body-limbs').textContent = state.body.limbBuds.length;
      
      // Timeline
      const timeline = document.getElementById('timeline');
      if (state.expressionHistory.length === 0) {
        timeline.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">Awaiting development...</div>';
      } else {
        const maxC = Math.max(...state.expressionHistory.map(e => e.coherence));
        timeline.innerHTML = state.expressionHistory.map(e => `
          <div class="timeline-event">
            <span class="time">t=${e.time.toFixed(1)}</span>
            <div class="bar"><div class="bar-fill" style="width: ${(e.coherence / maxC) * 100}%"></div></div>
            <span class="name">${e.name.split(' ')[0]}</span>
          </div>
        `).join('');
        timeline.scrollTop = timeline.scrollHeight;
      }
    }
    
    // ==========================================================================
    // CONTROLS
    // ==========================================================================
    
    let animationId = null;
    
    function startSimulation() {
      if (state.playing) return;
      state.playing = true;
      document.getElementById('btn-play').textContent = '⏸ Pause';
      document.getElementById('btn-play').classList.add('primary');
      
      function loop() {
        step();
        animationId = setTimeout(loop, 60);
      }
      loop();
    }
    
    function stopSimulation() {
      state.playing = false;
      document.getElementById('btn-play').textContent = '▶ Develop';
      if (animationId) clearTimeout(animationId);
    }
    
    function reset() {
      stopSimulation();
      state.genome = createGenome();
      state.body = createInitialBody();
      state.time = 0;
      state.expressionHistory = [];
      updateUI();
      renderBody();
      document.getElementById('dev-age').textContent = '0.0';
      document.getElementById('coherence').textContent = '0.0';
      document.getElementById('stability').textContent = '0.0';
      document.getElementById('omega').textContent = state.omega.toFixed(3);
    }
    
    // Event listeners
    document.getElementById('btn-play').addEventListener('click', () => {
      if (state.playing) stopSimulation();
      else startSimulation();
    });
    
    document.getElementById('btn-reset').addEventListener('click', reset);
    
    document.getElementById('speed').addEventListener('input', (e) => {
      state.speed = parseFloat(e.target.value);
      document.getElementById('speed-val').textContent = state.speed + '×';
    });
    
    document.getElementById('pressure').addEventListener('input', (e) => {
      state.pressure = parseFloat(e.target.value);
      document.getElementById('pressure-val').textContent = state.pressure.toFixed(1);
    });
    
    // Initialize
    reset();
  </script>
</body>
</html>
