<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Entropic Brain - CRR Dynamics</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Georgia, serif;
      background: linear-gradient(135deg, #0a0a14 0%, #12121f 50%, #0a0a14 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .header {
      padding: 1rem;
      text-align: center;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .header h1 {
      font-size: 1.5rem;
      color: #e8e0f0;
      letter-spacing: 0.1em;
      margin: 0;
      font-weight: normal;
    }

    .header p {
      color: rgba(200, 180, 220, 0.7);
      font-size: 0.85rem;
      margin-top: 4px;
    }

    .canvas-container {
      flex-grow: 1;
      position: relative;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .controls {
      padding: 1rem;
      background: rgba(0,0,0,0.4);
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .slider-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    .slider-label {
      font-size: 0.9rem;
      width: 80px;
    }

    .slider-label.left {
      color: rgba(255,200,200,0.9);
      text-align: right;
    }

    .slider-label.right {
      color: rgba(180,220,255,0.9);
      text-align: left;
    }

    .slider-wrapper {
      position: relative;
      width: 300px;
    }

    .omega-value {
      position: absolute;
      top: -1.5rem;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 0.9rem;
      font-family: monospace;
      transition: left 0.1s ease-out;
    }

    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      appearance: none;
      cursor: pointer;
      background: linear-gradient(to right, 
        hsla(340, 70%, 40%, 0.8) 0%, 
        hsla(280, 60%, 50%, 0.8) 50%, 
        hsla(200, 70%, 50%, 0.8) 100%);
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }

    .state-description {
      text-align: center;
      margin-bottom: 0.75rem;
    }

    .state-description p {
      color: rgba(255,255,255,0.8);
      font-size: 0.85rem;
      font-style: italic;
    }

    .math-context {
      display: flex;
      justify-content: center;
      gap: 2rem;
      text-align: center;
      font-size: 0.75rem;
      color: rgba(255,255,255,0.5);
    }

    .math-context .formula {
      font-family: monospace;
      margin-bottom: 2px;
    }

    .button-container {
      display: flex;
      justify-content: center;
      margin-top: 0.75rem;
    }

    .play-button {
      padding: 0.25rem 1rem;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.8);
      border: 1px solid rgba(255,255,255,0.2);
      cursor: pointer;
      font-size: 0.85rem;
      font-family: Georgia, serif;
      transition: background 0.2s;
    }

    .play-button:hover {
      background: rgba(255,255,255,0.2);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>THE ENTROPIC BRAIN</h1>
    <p>CRR Dynamics of Interpersonal Boundary Dissolution</p>
  </div>

  <div class="canvas-container">
    <canvas id="canvas"></canvas>
  </div>

  <div class="controls">
    <div class="slider-container">
      <span class="slider-label left">Low Ω</span>
      <div class="slider-wrapper">
        <div class="omega-value" id="omegaValue">Ω = 0.30</div>
        <input type="range" id="omegaSlider" min="0.1" max="0.95" step="0.01" value="0.3">
      </div>
      <span class="slider-label right">High Ω</span>
    </div>

    <div class="state-description">
      <p id="stateDescription">RIGID: Low Ω • High precision • Thick Markov blanket • Markovian dynamics • Attractor-locked</p>
    </div>

    <div class="math-context">
      <div>
        <div class="formula">exp(C/Ω)</div>
        <div>Memory weighting</div>
      </div>
      <div>
        <div class="formula">Low Ω → peaked</div>
        <div>Only recent/strong patterns</div>
      </div>
      <div>
        <div class="formula">High Ω → flat</div>
        <div>Full history accessible</div>
      </div>
    </div>

    <div class="button-container">
      <button class="play-button" id="playButton">⏸ Pause</button>
    </div>
  </div>

  <script>
    // State
    let omega = 0.3;
    let isPlaying = true;
    let time = 0;
    let animationId = null;

    // Particles
    let leftParticles = [];
    let rightParticles = [];
    let sharedParticles = [];

    // DOM elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const omegaSlider = document.getElementById('omegaSlider');
    const omegaValue = document.getElementById('omegaValue');
    const stateDescription = document.getElementById('stateDescription');
    const playButton = document.getElementById('playButton');

    // Initialize particles
    function initParticles(width, height) {
      const leftCenter = { x: width * 0.28, y: height * 0.5 };
      const rightCenter = { x: width * 0.72, y: height * 0.5 };
      const baseRadius = Math.min(width, height) * 0.18;

      leftParticles = [];
      rightParticles = [];
      sharedParticles = [];

      // Create layered particles representing temporal depth
      for (let layer = 0; layer < 5; layer++) {
        const depth = layer / 4;
        const layerRadius = baseRadius * (1 - depth * 0.3);
        const count = 25 - layer * 4;

        for (let i = 0; i < count; i++) {
          // Left particle
          leftParticles.push({
            x: leftCenter.x + (Math.random() - 0.5) * layerRadius,
            y: leftCenter.y + (Math.random() - 0.5) * layerRadius,
            baseX: leftCenter.x,
            baseY: leftCenter.y,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: Math.random() * 3 + 1,
            depth: depth,
            phase: Math.random() * Math.PI * 2,
            frequency: Math.random() * 0.02 + 0.01,
            hue: 340 + Math.random() * 40
          });

          // Right particle
          rightParticles.push({
            x: rightCenter.x + (Math.random() - 0.5) * layerRadius,
            y: rightCenter.y + (Math.random() - 0.5) * layerRadius,
            baseX: rightCenter.x,
            baseY: rightCenter.y,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: Math.random() * 3 + 1,
            depth: depth,
            phase: Math.random() * Math.PI * 2,
            frequency: Math.random() * 0.02 + 0.01,
            hue: 180 + Math.random() * 60
          });
        }
      }

      // Shared particles (emerge at high Ω)
      for (let i = 0; i < 30; i++) {
        sharedParticles.push({
          x: width * 0.5,
          y: height * 0.5,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: Math.random() * 4 + 2,
          phase: Math.random() * Math.PI * 2,
          hue: 280,
          birth: Math.random()
        });
      }
    }

    // Animation loop
    function animate() {
      const width = canvas.width;
      const height = canvas.height;
      time += 0.016;

      // Clear with trailing effect
      const trailAlpha = 0.08 + (1 - omega) * 0.15;
      ctx.fillStyle = `rgba(8, 8, 18, ${trailAlpha})`;
      ctx.fillRect(0, 0, width, height);

      const leftCenter = { x: width * 0.28, y: height * 0.5 };
      const rightCenter = { x: width * 0.72, y: height * 0.5 };
      const baseRadius = Math.min(width, height) * 0.18;

      // Boundary parameters
      const blanketThickness = (1 - omega) * 40 + 5;
      const boundaryOpacity = (1 - omega) * 0.8 + 0.1;

      // Draw the "ocean" between
      const oceanIntensity = omega * 0.4;
      const gradient = ctx.createLinearGradient(leftCenter.x, 0, rightCenter.x, 0);
      gradient.addColorStop(0, `hsla(340, 80%, 50%, ${oceanIntensity * 0.3})`);
      gradient.addColorStop(0.5, `hsla(280, 70%, 40%, ${oceanIntensity})`);
      gradient.addColorStop(1, `hsla(200, 80%, 50%, ${oceanIntensity * 0.3})`);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(width * 0.3, height * 0.2, width * 0.4, height * 0.6);

      // Draw flowing connection lines at high Ω
      if (omega > 0.4) {
        const connectionStrength = (omega - 0.4) / 0.6;
        ctx.strokeStyle = `hsla(280, 70%, 60%, ${connectionStrength * 0.3})`;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 8; i++) {
          const yOffset = Math.sin(time * 0.5 + i * 0.8) * 50;
          const waveAmp = Math.sin(time * 0.3 + i) * 20 * connectionStrength;
          
          ctx.beginPath();
          ctx.moveTo(leftCenter.x + baseRadius, leftCenter.y + yOffset);
          
          for (let t = 0; t <= 1; t += 0.05) {
            const x = leftCenter.x + baseRadius + t * (rightCenter.x - baseRadius - leftCenter.x - baseRadius);
            const y = leftCenter.y + yOffset + Math.sin(t * Math.PI * 3 + time) * waveAmp;
            ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
      }

      // Draw particles for an island
      function drawIsland(particles, center, isLeft) {
        particles.forEach((p, idx) => {
          // Depth-dependent visibility based on Ω
          const depthAccess = Math.exp(-p.depth * (1 - omega) * 5);
          
          if (Math.random() > depthAccess && p.depth > 0.3) return;

          // Movement becomes more chaotic at high Ω
          const entropy = omega * 2;
          p.vx += (Math.random() - 0.5) * entropy * 0.1;
          p.vy += (Math.random() - 0.5) * entropy * 0.1;
          
          // Attractor pull - stronger at low Ω
          const attractorStrength = (1 - omega) * 0.05 + 0.01;
          p.vx += (center.x - p.x) * attractorStrength;
          p.vy += (center.y - p.y) * attractorStrength;
          
          // Damping
          p.vx *= 0.95;
          p.vy *= 0.95;
          
          // At high Ω, particles can drift toward the other
          if (omega > 0.5) {
            const otherCenter = isLeft ? rightCenter : leftCenter;
            const driftStrength = (omega - 0.5) * 0.01;
            p.vx += (otherCenter.x - p.x) * driftStrength * (1 - p.depth);
            p.vy += (otherCenter.y - p.y) * driftStrength * (1 - p.depth);
          }
          
          p.x += p.vx;
          p.y += p.vy;
          
          // Breathing/pulsing
          const pulse = Math.sin(time * 2 + p.phase) * 0.3 + 1;
          const size = p.radius * pulse * (1 + omega * 0.5) * depthAccess;
          
          // Color shifts more at high Ω
          const hueShift = Math.sin(time + p.phase) * omega * 30;
          const saturation = 70 + omega * 20;
          const lightness = 50 + p.depth * 20 + Math.sin(time * 3 + idx) * 10;
          
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
          ctx.fillStyle = `hsla(${p.hue + hueShift}, ${saturation}%, ${lightness}%, ${0.7 * depthAccess})`;
          ctx.fill();
          
          // Glow effect
          if (size > 2) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);
            const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
            glowGrad.addColorStop(0, `hsla(${p.hue + hueShift}, ${saturation}%, ${lightness}%, ${0.3 * depthAccess})`);
            glowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGrad;
            ctx.fill();
          }
        });
      }

      drawIsland(leftParticles, leftCenter, true);
      drawIsland(rightParticles, rightCenter, false);

      // Shared particles emerge at high Ω
      if (omega > 0.5) {
        const sharedIntensity = (omega - 0.5) / 0.5;
        
        sharedParticles.forEach((p, idx) => {
          if (p.birth > sharedIntensity) return;
          
          // Orbit around the midpoint
          const midX = width * 0.5;
          const midY = height * 0.5;
          const orbitRadius = 50 + sharedIntensity * 100;
          
          p.phase += 0.02;
          const targetX = midX + Math.cos(p.phase + idx * 0.5) * orbitRadius;
          const targetY = midY + Math.sin(p.phase * 1.3 + idx * 0.3) * orbitRadius * 0.6;
          
          p.x += (targetX - p.x) * 0.05;
          p.y += (targetY - p.y) * 0.05;
          
          // Draw with blend of both colors
          const hue = 280 + Math.sin(time + idx) * 40;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius * sharedIntensity * 1.5, 0, Math.PI * 2);
          ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${sharedIntensity * 0.8})`;
          ctx.fill();
          
          // Glow
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius * 4, 0, Math.PI * 2);
          const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 4);
          grad.addColorStop(0, `hsla(${hue}, 80%, 60%, ${sharedIntensity * 0.4})`);
          grad.addColorStop(1, 'transparent');
          ctx.fillStyle = grad;
          ctx.fill();
        });
      }

      // Draw Markov blanket boundaries
      function drawBoundary(center, hue) {
        const breathe = Math.sin(time * 0.8) * 5;
        const radius = baseRadius + breathe;
        
        for (let i = 0; i < 3; i++) {
          const r = radius + i * blanketThickness / 3;
          const alpha = boundaryOpacity * (1 - i * 0.3);
          
          ctx.beginPath();
          ctx.arc(center.x, center.y, r, 0, Math.PI * 2);
          ctx.strokeStyle = `hsla(${hue}, 60%, 50%, ${alpha})`;
          ctx.lineWidth = blanketThickness / 3;
          ctx.stroke();
        }

        // Inner glow
        const innerGrad = ctx.createRadialGradient(
          center.x, center.y, 0,
          center.x, center.y, radius
        );
        innerGrad.addColorStop(0, `hsla(${hue}, 70%, 30%, 0.3)`);
        innerGrad.addColorStop(0.7, `hsla(${hue}, 60%, 20%, 0.1)`);
        innerGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = innerGrad;
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // Only draw strong boundaries at low Ω
      if (omega < 0.8) {
        drawBoundary(leftCenter, 340);
        drawBoundary(rightCenter, 200);
      }

      // Add flowing noise at high Ω
      if (omega > 0.6) {
        const noiseIntensity = (omega - 0.6) / 0.4;
        ctx.globalCompositeOperation = 'screen';
        
        for (let i = 0; i < 20; i++) {
          const x = Math.sin(time * 0.5 + i) * width * 0.3 + width * 0.5;
          const y = Math.cos(time * 0.3 + i * 0.7) * height * 0.3 + height * 0.5;
          const size = 30 + Math.sin(time + i) * 20;
          
          const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
          const hue = 280 + Math.sin(i + time) * 60;
          grad.addColorStop(0, `hsla(${hue}, 70%, 50%, ${noiseIntensity * 0.15})`);
          grad.addColorStop(1, 'transparent');
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.globalCompositeOperation = 'source-over';
      }

      // Draw labels
      ctx.font = '14px Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + omega * 0.3})`;
      
      const labelY = height * 0.85;
      ctx.fillText('Observer A', leftCenter.x, labelY);
      ctx.fillText('Observer B', rightCenter.x, labelY);
      
      if (omega > 0.5) {
        ctx.fillStyle = `rgba(255, 255, 255, ${(omega - 0.5) * 1.5})`;
        ctx.fillText('Shared State Space', width * 0.5, height * 0.15);
      }

      if (isPlaying) {
        animationId = requestAnimationFrame(animate);
      }
    }

    // Get state description based on omega
    function getStateDescription() {
      if (omega < 0.25) {
        return "RIGID: Low Ω • High precision • Thick Markov blanket • Markovian dynamics • Attractor-locked";
      } else if (omega < 0.5) {
        return "DEFENDED: Moderate Ω • Partial historical access • Habitual patterns dominate";
      } else if (omega < 0.75) {
        return "POROUS: Higher Ω • Non-Markovian • Deeper memory accessible • Boundaries softening";
      } else {
        return "FLUID: High Ω • Entropic brain state • Full historical access • Shared state space emerges";
      }
    }

    // Update omega value display position
    function updateOmegaDisplay() {
      const percentage = ((omega - 0.1) / 0.85) * 100;
      omegaValue.style.left = `${percentage}%`;
      omegaValue.textContent = `Ω = ${omega.toFixed(2)}`;
      stateDescription.textContent = getStateDescription();
    }

    // Handle resize
    function handleResize() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      initParticles(canvas.width, canvas.height);
    }

    // Event listeners
    omegaSlider.addEventListener('input', (e) => {
      omega = parseFloat(e.target.value);
      updateOmegaDisplay();
    });

    playButton.addEventListener('click', () => {
      isPlaying = !isPlaying;
      playButton.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
      if (isPlaying) {
        animationId = requestAnimationFrame(animate);
      }
    });

    window.addEventListener('resize', handleResize);

    // Initialize
    handleResize();
    updateOmegaDisplay();
    animate();
  </script>
</body>
</html>
