<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplet â€” CRR Nested Dynamics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .mode-toggle {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .mode-btn {
            padding: 12px 24px;
            background: rgba(20, 40, 60, 0.9);
            border: 1px solid rgba(100, 180, 255, 0.3);
            color: rgba(255, 255, 255, 0.8);
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .mode-btn:hover {
            background: rgba(40, 80, 120, 0.9);
            border-color: rgba(100, 200, 255, 0.5);
        }
        
        .mode-btn.active {
            background: rgba(100, 180, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.8);
            color: #fff;
            box-shadow: 0 0 20px rgba(100, 180, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="mode-toggle">
        <button class="mode-btn" id="scientificBtn">ðŸ”¬ Scientific</button>
        <button class="mode-btn active" id="photoBtn">ðŸ“· Photorealistic</button>
        <button class="mode-btn" id="soundBtn">ðŸ”Š Sound</button>
    </div>
    
    <script>
        /*
         * WATER DROPLET â€” CRR NESTED SCALE DYNAMICS
         * 
         * A single water droplet contains ~10Â²Â¹ molecules.
         * We model nested CRR at three scales:
         * 
         * SCALE 1: MOLECULAR (femtoseconds)
         * - Individual Hâ‚‚O vibrations
         * - C = vibrational energy accumulation
         * - Î© = quantum transition thresholds
         * - Î´ = phonon emission/absorption
         * - R = return to equilibrium geometry
         * 
         * SCALE 2: CLUSTER (picoseconds)  
         * - Hydrogen bond networks (4-6 molecules)
         * - C = H-bond strain accumulation
         * - Î© = network reorganization threshold
         * - Î´ = H-bond breaking/forming
         * - R = tetrahedral coordination memory
         * 
         * SCALE 3: DROPLET (milliseconds)
         * - Surface tension, shape dynamics
         * - C = surface energy accumulation
         * - Î© = capillary wave threshold
         * - Î´ = surface mode transitions
         * - R = spherical equilibrium memory
         * 
         * The droplet emerges from compressed molecular order.
         * Each scale's R feeds into the next scale's L.
         */
        
        // =====================================================
        // DIEGETIC SOUND ENGINE â€” Water Droplet Acoustics
        // =====================================================
        
        class WaterSoundscape {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.enabled = false;
                this.masterGain = null;
                
                // Molecular scale: high frequency shimmer
                this.molecularOsc = null;
                this.molecularGain = null;
                this.molecularFilter = null;
                
                // Cluster scale: mid-range resonance  
                this.clusterOsc = null;
                this.clusterGain = null;
                this.clusterFilter = null;
                
                // Droplet scale: low drone/resonance
                this.dropletOsc = null;
                this.dropletGain = null;
                
                // Surface tension hum
                this.surfaceNoise = null;
                this.surfaceFilter = null;
                this.surfaceGain = null;
                
                // Coherence tone (rising pitch as C approaches Î©)
                this.coherenceTone = null;
                this.coherenceGain = null;
            }
            
            async init() {
                if (this.initialized) return;
                
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master output
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                this.masterGain.connect(this.ctx.destination);
                
                // === MOLECULAR SCALE: Crystalline shimmer ===
                // High frequencies representing molecular vibrations
                this.molecularOsc = this.ctx.createOscillator();
                this.molecularOsc.type = 'sine';
                this.molecularOsc.frequency.value = 2400;  // High pitch
                
                this.molecularOsc2 = this.ctx.createOscillator();
                this.molecularOsc2.type = 'sine';
                this.molecularOsc2.frequency.value = 2650;  // Slight detuning
                
                this.molecularFilter = this.ctx.createBiquadFilter();
                this.molecularFilter.type = 'bandpass';
                this.molecularFilter.frequency.value = 2500;
                this.molecularFilter.Q.value = 5;
                
                this.molecularGain = this.ctx.createGain();
                this.molecularGain.gain.value = 0;
                
                // LFO for shimmer
                this.molecularLFO = this.ctx.createOscillator();
                this.molecularLFO.type = 'sine';
                this.molecularLFO.frequency.value = 8;
                this.molecularLFOGain = this.ctx.createGain();
                this.molecularLFOGain.gain.value = 100;
                this.molecularLFO.connect(this.molecularLFOGain);
                this.molecularLFOGain.connect(this.molecularOsc.frequency);
                this.molecularLFO.start();
                
                this.molecularOsc.connect(this.molecularFilter);
                this.molecularOsc2.connect(this.molecularFilter);
                this.molecularFilter.connect(this.molecularGain);
                this.molecularGain.connect(this.masterGain);
                this.molecularOsc.start();
                this.molecularOsc2.start();
                
                // === CLUSTER SCALE: Liquid resonance ===
                // Mid frequencies for hydrogen bond networks
                this.clusterOsc = this.ctx.createOscillator();
                this.clusterOsc.type = 'triangle';
                this.clusterOsc.frequency.value = 440;
                
                this.clusterOsc2 = this.ctx.createOscillator();
                this.clusterOsc2.type = 'triangle';
                this.clusterOsc2.frequency.value = 554;  // Major third
                
                this.clusterFilter = this.ctx.createBiquadFilter();
                this.clusterFilter.type = 'lowpass';
                this.clusterFilter.frequency.value = 800;
                this.clusterFilter.Q.value = 2;
                
                this.clusterGain = this.ctx.createGain();
                this.clusterGain.gain.value = 0;
                
                this.clusterOsc.connect(this.clusterFilter);
                this.clusterOsc2.connect(this.clusterFilter);
                this.clusterFilter.connect(this.clusterGain);
                this.clusterGain.connect(this.masterGain);
                this.clusterOsc.start();
                this.clusterOsc2.start();
                
                // === DROPLET SCALE: Deep resonance ===
                // Low frequencies for surface tension
                this.dropletOsc = this.ctx.createOscillator();
                this.dropletOsc.type = 'sine';
                this.dropletOsc.frequency.value = 80;
                
                this.dropletOsc2 = this.ctx.createOscillator();
                this.dropletOsc2.type = 'sine';
                this.dropletOsc2.frequency.value = 120;
                
                this.dropletGain = this.ctx.createGain();
                this.dropletGain.gain.value = 0;
                
                this.dropletOsc.connect(this.dropletGain);
                this.dropletOsc2.connect(this.dropletGain);
                this.dropletGain.connect(this.masterGain);
                this.dropletOsc.start();
                this.dropletOsc2.start();
                
                // === SURFACE NOISE: Gentle water ambience ===
                this.surfaceNoise = this.createPinkNoise();
                
                this.surfaceFilter = this.ctx.createBiquadFilter();
                this.surfaceFilter.type = 'bandpass';
                this.surfaceFilter.frequency.value = 1000;
                this.surfaceFilter.Q.value = 0.5;
                
                this.surfaceGain = this.ctx.createGain();
                this.surfaceGain.gain.value = 0;
                
                this.surfaceNoise.connect(this.surfaceFilter);
                this.surfaceFilter.connect(this.surfaceGain);
                this.surfaceGain.connect(this.masterGain);
                
                // === COHERENCE TONE: Rising tension ===
                this.coherenceTone = this.ctx.createOscillator();
                this.coherenceTone.type = 'sine';
                this.coherenceTone.frequency.value = 200;
                
                this.coherenceFilter = this.ctx.createBiquadFilter();
                this.coherenceFilter.type = 'bandpass';
                this.coherenceFilter.frequency.value = 200;
                this.coherenceFilter.Q.value = 15;
                
                this.coherenceGain = this.ctx.createGain();
                this.coherenceGain.gain.value = 0;
                
                this.coherenceTone.connect(this.coherenceFilter);
                this.coherenceFilter.connect(this.coherenceGain);
                this.coherenceGain.connect(this.masterGain);
                this.coherenceTone.start();
                
                this.initialized = true;
                console.log('ðŸ’§ Water soundscape initialized');
            }
            
            createPinkNoise() {
                const bufferSize = 2 * this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);
                
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                noise.start();
                return noise;
            }
            
            update(crrState) {
                if (!this.initialized || !this.enabled) return;
                
                const t = this.ctx.currentTime;
                const ramp = 0.1;
                
                // === MOLECULAR: Shimmer intensity based on molecular C ===
                const molRatio = crrState.molecular.C / crrState.molecular.omega;
                const molVol = 0.03 + molRatio * 0.05;
                const molFreq = 2200 + molRatio * 600;
                
                this.molecularGain.gain.linearRampToValueAtTime(molVol, t + ramp);
                this.molecularFilter.frequency.linearRampToValueAtTime(molFreq, t + ramp);
                this.molecularLFO.frequency.linearRampToValueAtTime(5 + molRatio * 10, t + ramp);
                
                // === CLUSTER: Resonance based on cluster coherence ===
                const clustRatio = crrState.cluster.C / crrState.cluster.omega;
                const clustVol = 0.02 + clustRatio * 0.04;
                const clustFreq = 350 + clustRatio * 200;
                
                this.clusterGain.gain.linearRampToValueAtTime(clustVol, t + ramp);
                this.clusterOsc.frequency.linearRampToValueAtTime(clustFreq, t + ramp);
                this.clusterOsc2.frequency.linearRampToValueAtTime(clustFreq * 1.26, t + ramp);
                
                // === DROPLET: Deep resonance based on surface coherence ===
                const dropRatio = crrState.droplet.C / crrState.droplet.omega;
                const dropVol = 0.04 + dropRatio * 0.06;
                const dropFreq = 60 + dropRatio * 40;
                
                this.dropletGain.gain.linearRampToValueAtTime(dropVol, t + ramp);
                this.dropletOsc.frequency.linearRampToValueAtTime(dropFreq, t + ramp);
                this.dropletOsc2.frequency.linearRampToValueAtTime(dropFreq * 1.5, t + ramp);
                
                // === SURFACE: Gentle water ambience ===
                this.surfaceGain.gain.linearRampToValueAtTime(0.015, t + ramp);
                
                // === COHERENCE TONE: Combined rising tension ===
                const avgRatio = (molRatio + clustRatio + dropRatio) / 3;
                const cohVol = avgRatio * 0.04;
                const cohFreq = 150 + avgRatio * 250;
                
                this.coherenceGain.gain.linearRampToValueAtTime(cohVol, t + ramp);
                this.coherenceTone.frequency.linearRampToValueAtTime(cohFreq, t + ramp);
                this.coherenceFilter.frequency.linearRampToValueAtTime(cohFreq, t + ramp);
            }
            
            triggerMolecularRupture() {
                if (!this.initialized || !this.enabled) return;
                
                const t = this.ctx.currentTime;
                
                // High-pitched crystalline ping
                const ping = this.ctx.createOscillator();
                ping.type = 'sine';
                ping.frequency.value = 3000 + Math.random() * 1000;
                ping.frequency.exponentialRampToValueAtTime(1500, t + 0.3);
                
                const pingGain = this.ctx.createGain();
                pingGain.gain.value = 0.08;
                pingGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                
                ping.connect(pingGain);
                pingGain.connect(this.masterGain);
                ping.start();
                ping.stop(t + 0.3);
            }
            
            triggerClusterRupture() {
                if (!this.initialized || !this.enabled) return;
                
                const t = this.ctx.currentTime;
                
                // Mid-range "glub" sound
                const glub = this.ctx.createOscillator();
                glub.type = 'sine';
                glub.frequency.value = 600;
                glub.frequency.exponentialRampToValueAtTime(200, t + 0.2);
                
                const glubGain = this.ctx.createGain();
                glubGain.gain.value = 0.1;
                glubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
                
                glub.connect(glubGain);
                glubGain.connect(this.masterGain);
                glub.start();
                glub.stop(t + 0.25);
            }
            
            triggerDropletRupture() {
                if (!this.initialized || !this.enabled) return;
                
                const t = this.ctx.currentTime;
                
                // Deep resonant "bloop"
                const bloop = this.ctx.createOscillator();
                bloop.type = 'sine';
                bloop.frequency.value = 150;
                bloop.frequency.exponentialRampToValueAtTime(60, t + 0.4);
                
                const bloopGain = this.ctx.createGain();
                bloopGain.gain.value = 0.15;
                bloopGain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                
                // Add some harmonics
                const bloop2 = this.ctx.createOscillator();
                bloop2.type = 'sine';
                bloop2.frequency.value = 300;
                bloop2.frequency.exponentialRampToValueAtTime(120, t + 0.4);
                
                const bloop2Gain = this.ctx.createGain();
                bloop2Gain.gain.value = 0.06;
                bloop2Gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                
                bloop.connect(bloopGain);
                bloopGain.connect(this.masterGain);
                bloop2.connect(bloop2Gain);
                bloop2Gain.connect(this.masterGain);
                
                bloop.start();
                bloop2.start();
                bloop.stop(t + 0.5);
                bloop2.stop(t + 0.4);
                
                // Noise splash
                const splash = this.createSplashNoise();
                const splashFilter = this.ctx.createBiquadFilter();
                splashFilter.type = 'bandpass';
                splashFilter.frequency.value = 2000;
                splashFilter.Q.value = 1;
                
                const splashGain = this.ctx.createGain();
                splashGain.gain.value = 0.08;
                splashGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                
                splash.connect(splashFilter);
                splashFilter.connect(splashGain);
                splashGain.connect(this.masterGain);
            }
            
            createSplashNoise() {
                const bufferSize = this.ctx.sampleRate * 0.3;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    const env = Math.exp(-i / (this.ctx.sampleRate * 0.05));
                    output[i] = (Math.random() * 2 - 1) * env;
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.start();
                return noise;
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                if (this.masterGain) {
                    this.masterGain.gain.linearRampToValueAtTime(
                        enabled ? 0.4 : 0,
                        this.ctx.currentTime + 0.3
                    );
                }
            }
            
            toggle() {
                this.setEnabled(!this.enabled);
                return this.enabled;
            }
        }
        
        const soundscape = new WaterSoundscape();
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // MODE STATE
        let photorealisticMode = true;
        
        // Mode toggle handlers
        document.getElementById('scientificBtn').addEventListener('click', () => {
            photorealisticMode = false;
            document.getElementById('scientificBtn').classList.add('active');
            document.getElementById('photoBtn').classList.remove('active');
        });
        
        document.getElementById('photoBtn').addEventListener('click', () => {
            photorealisticMode = true;
            document.getElementById('photoBtn').classList.add('active');
            document.getElementById('scientificBtn').classList.remove('active');
        });
        
        // Sound toggle
        document.getElementById('soundBtn').addEventListener('click', async () => {
            if (!soundscape.initialized) {
                await soundscape.init();
            }
            const isOn = soundscape.toggle();
            const btn = document.getElementById('soundBtn');
            btn.textContent = isOn ? 'ðŸ”Š Sound On' : 'ðŸ”‡ Sound Off';
            btn.classList.toggle('active', isOn);
        });
        
        // High DPI
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        resize();
        window.addEventListener('resize', resize);
        
        // =====================================================
        // PHYSICAL CONSTANTS
        // =====================================================
        
        const DROPLET_RADIUS = Math.min(window.innerWidth, window.innerHeight) * 0.35;
        const NUM_SURFACE_MOLECULES = 200;
        const NUM_INTERIOR_MOLECULES = 150;
        const NUM_CLUSTERS = 12;
        
        // =====================================================
        // CRR STATE â€” NESTED SCALES
        // =====================================================
        
        const CRR = {
            // Scale 1: Molecular
            molecular: {
                C: 0,
                C_archival: 0,
                omega: 1.0,
                L: 0,
                R: 1,
                ruptureIntensity: 0
            },
            
            // Scale 2: Cluster (H-bond networks)
            cluster: {
                C: 0,
                C_archival: 0,
                omega: 5.0,  // Slower timescale
                L: 0,
                R: 1,
                ruptureIntensity: 0
            },
            
            // Scale 3: Droplet (surface dynamics)
            droplet: {
                C: 0,
                C_archival: 0,
                omega: 20.0,  // Slowest timescale
                L: 0,
                R: 1,
                ruptureIntensity: 0
            }
        };
        
        // =====================================================
        // DROPLET STATE
        // =====================================================
        
        const droplet = {
            cx: 0,
            cy: 0,
            baseRadius: DROPLET_RADIUS,
            
            // Surface deformation modes (capillary waves)
            modes: [],
            
            // Surface wobble
            wobblePhase: 0,
            wobbleAmount: 0,
            
            // Internal flow
            flowPhase: 0,
            
            // Light refraction simulation
            causticsPhase: 0
        };
        
        // Initialize surface wave modes
        for (let i = 0; i < 8; i++) {
            droplet.modes.push({
                amplitude: 0,
                velocity: 0,
                frequency: 2 + i,  // Mode number
                phase: Math.random() * Math.PI * 2
            });
        }
        
        // =====================================================
        // MOLECULES (visible at surface)
        // =====================================================
        
        const molecules = [];
        
        // Surface molecules (visible)
        for (let i = 0; i < NUM_SURFACE_MOLECULES; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);  // Uniform on sphere
            
            molecules.push({
                theta: theta,
                phi: phi,
                depth: 0.95 + Math.random() * 0.05,  // Near surface
                
                // Individual CRR state
                C: Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2,
                vibrateAmp: 0.5 + Math.random() * 0.5,
                
                // H2O orientation
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                
                // Size (slight variation)
                scale: 0.8 + Math.random() * 0.4
            });
        }
        
        // Interior molecules (dimmer, seen through refraction)
        for (let i = 0; i < NUM_INTERIOR_MOLECULES; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            molecules.push({
                theta: theta,
                phi: phi,
                depth: 0.3 + Math.random() * 0.6,  // Interior
                
                C: Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2,
                vibrateAmp: 0.3 + Math.random() * 0.3,
                
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.01,
                
                scale: 0.5 + Math.random() * 0.3,
                isInterior: true
            });
        }
        
        // =====================================================
        // HYDROGEN BOND CLUSTERS
        // =====================================================
        
        const clusters = [];
        
        for (let i = 0; i < NUM_CLUSTERS; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            clusters.push({
                theta: theta,
                phi: phi,
                depth: 0.5 + Math.random() * 0.4,
                
                // Cluster CRR
                C: Math.random() * 2,
                coherence: Math.random(),
                
                // Network state
                bonds: 4 + Math.floor(Math.random() * 3),  // 4-6 bonds
                strain: 0,
                
                pulsePhase: Math.random() * Math.PI * 2
            });
        }
        
        // =====================================================
        // CRR DYNAMICS â€” NESTED SCALES
        // =====================================================
        
        function updateCRR(dt) {
            // === SCALE 1: MOLECULAR ===
            // Thermal fluctuations drive molecular vibrations
            CRR.molecular.L = 0.02 + Math.random() * 0.03;
            CRR.molecular.C += CRR.molecular.L;
            CRR.molecular.C_archival += CRR.molecular.L * 0.1;
            
            if (CRR.molecular.C >= CRR.molecular.omega) {
                CRR.molecular.C = 0;
                CRR.molecular.ruptureIntensity = 1;
                
                // Molecular rupture feeds cluster L
                CRR.cluster.L += 0.3;
                
                // Excite random molecules
                for (let i = 0; i < 5; i++) {
                    const mol = molecules[Math.floor(Math.random() * molecules.length)];
                    mol.vibrateAmp = 1.5;
                    mol.C = 0;
                }
                
                // Sound: crystalline ping
                soundscape.triggerMolecularRupture();
            }
            CRR.molecular.ruptureIntensity *= 0.92;
            CRR.molecular.R = Math.exp(CRR.molecular.C / CRR.molecular.omega);
            
            // === SCALE 2: CLUSTER ===
            // H-bond network dynamics
            CRR.cluster.L += 0.005 + Math.random() * 0.01;
            CRR.cluster.C += CRR.cluster.L;
            CRR.cluster.L *= 0.9;  // Decay
            CRR.cluster.C_archival += CRR.cluster.L * 0.05;
            
            if (CRR.cluster.C >= CRR.cluster.omega) {
                CRR.cluster.C = 0;
                CRR.cluster.ruptureIntensity = 1;
                
                // Cluster rupture feeds droplet L
                CRR.droplet.L += 0.5;
                
                // Reorganize a random cluster
                const cluster = clusters[Math.floor(Math.random() * clusters.length)];
                cluster.strain = 1;
                cluster.C = 0;
                
                // Sound: liquid glub
                soundscape.triggerClusterRupture();
            }
            CRR.cluster.ruptureIntensity *= 0.95;
            CRR.cluster.R = Math.exp(CRR.cluster.C / CRR.cluster.omega);
            
            // === SCALE 3: DROPLET ===
            // Surface tension dynamics
            CRR.droplet.L += 0.002 + Math.random() * 0.005;
            CRR.droplet.C += CRR.droplet.L;
            CRR.droplet.L *= 0.95;
            CRR.droplet.C_archival += CRR.droplet.L * 0.02;
            
            if (CRR.droplet.C >= CRR.droplet.omega) {
                CRR.droplet.C = 0;
                CRR.droplet.ruptureIntensity = 1;
                
                // Surface mode excitation
                droplet.wobbleAmount = 0.03;
                
                // Excite capillary waves
                const mode = droplet.modes[Math.floor(Math.random() * droplet.modes.length)];
                mode.velocity += (Math.random() - 0.5) * 0.01;
                
                // Sound: deep bloop
                soundscape.triggerDropletRupture();
            }
            CRR.droplet.ruptureIntensity *= 0.98;
            CRR.droplet.R = Math.exp(CRR.droplet.C / CRR.droplet.omega);
            
            // Update continuous soundscape
            soundscape.update(CRR);
        }
        
        // =====================================================
        // PHYSICS UPDATE
        // =====================================================
        
        function updatePhysics(dt) {
            // Update droplet center
            droplet.cx = window.innerWidth / 2;
            droplet.cy = window.innerHeight / 2;
            
            // Surface wave dynamics
            droplet.wobblePhase += 0.03;
            droplet.wobbleAmount *= 0.98;
            
            // Capillary wave modes (damped oscillators)
            droplet.modes.forEach(mode => {
                // Surface tension restoring force
                const k = 0.001 * mode.frequency * mode.frequency;
                const damping = 0.995;
                
                mode.velocity -= k * mode.amplitude;
                mode.velocity *= damping;
                mode.amplitude += mode.velocity;
                mode.phase += 0.02 * mode.frequency;
            });
            
            // Internal flow
            droplet.flowPhase += 0.01;
            droplet.causticsPhase += 0.015;
            
            // Update molecules
            molecules.forEach(mol => {
                // Vibration decay
                mol.vibrateAmp *= 0.995;
                mol.vibrateAmp = Math.max(0.3, mol.vibrateAmp);
                
                // Phase evolution
                mol.phase += 0.05 * mol.vibrateAmp;
                
                // Slow rotation
                mol.rotation += mol.rotationSpeed;
                
                // Individual CRR
                mol.C += 0.01 * mol.vibrateAmp;
                if (mol.C > 1) {
                    mol.C = 0;
                    mol.vibrateAmp = Math.min(1.5, mol.vibrateAmp + 0.2);
                }
            });
            
            // Update clusters
            clusters.forEach(cluster => {
                cluster.strain *= 0.97;
                cluster.pulsePhase += 0.03;
                cluster.C += 0.02;
                if (cluster.C > 3) {
                    cluster.C = 0;
                }
            });
        }
        
        // =====================================================
        // GET DROPLET RADIUS AT ANGLE (with deformation)
        // =====================================================
        
        function getDropletRadius(theta) {
            let r = droplet.baseRadius;
            
            // Add wobble
            r += droplet.wobbleAmount * droplet.baseRadius * 
                 Math.sin(2 * theta + droplet.wobblePhase);
            
            // Add capillary wave modes
            droplet.modes.forEach(mode => {
                r += mode.amplitude * droplet.baseRadius * 
                     Math.cos(mode.frequency * theta + mode.phase);
            });
            
            // Slight gravity-induced asymmetry (teardrop tendency)
            r += droplet.baseRadius * 0.02 * Math.cos(theta - Math.PI/2);
            
            return r;
        }
        
        // =====================================================
        // RENDERING
        // =====================================================
        
        function render() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cx = droplet.cx;
            const cy = droplet.cy;
            
            if (photorealisticMode) {
                renderPhotorealistic(w, h, cx, cy);
            } else {
                renderScientific(w, h, cx, cy);
            }
        }
        
        // =====================================================
        // PHOTOREALISTIC MODE â€” Maximum visual fidelity
        // =====================================================
        
        function renderPhotorealistic(w, h, cx, cy) {
            // Ultra-clean gradient background (like a lit surface)
            const bgGrad = ctx.createLinearGradient(0, 0, 0, h);
            bgGrad.addColorStop(0, '#2a3a4a');
            bgGrad.addColorStop(0.3, '#1e2d3d');
            bgGrad.addColorStop(0.7, '#152535');
            bgGrad.addColorStop(1, '#0f1a25');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Subtle surface texture (like brushed metal or glass)
            drawSurfaceTexture(w, h);
            
            // === CONTACT SHADOW (where droplet meets surface) ===
            drawContactShadow(cx, cy);
            
            // === MAIN DROPLET ===
            ctx.save();
            
            // Create droplet clipping path
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.clip();
            
            // Multi-layer water interior
            drawWaterInterior(cx, cy);
            
            // Deep caustics
            drawDeepCaustics(cx, cy);
            
            // Subsurface scattering layers
            drawSubsurfaceScattering(cx, cy);
            
            ctx.restore();
            
            // === SURFACE EFFECTS (outside clip) ===
            
            // Ultra-realistic Fresnel rim
            drawPhotoFresnelRim(cx, cy);
            
            // Environment reflection (curved distorted reflection)
            drawEnvironmentReflection(cx, cy);
            
            // Primary specular highlight (sun/light source)
            drawPhotoMainHighlight(cx, cy);
            
            // Secondary highlights
            drawPhotoSecondaryHighlights(cx, cy);
            
            // Edge definition with chromatic aberration hint
            drawPhotoEdge(cx, cy);
            
            // Micro-surface detail (tiny highlights)
            drawMicroHighlights(cx, cy);
        }
        
        function drawSurfaceTexture(w, h) {
            // Very subtle noise texture
            ctx.globalAlpha = 0.03;
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = Math.random() * 100 + 50;
                
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function drawContactShadow(cx, cy) {
            // Soft contact shadow
            const shadowY = cy + droplet.baseRadius * 0.95;
            
            // Outer soft shadow
            const shadow1 = ctx.createRadialGradient(
                cx, shadowY + 20, 0,
                cx, shadowY + 20, droplet.baseRadius * 1.3
            );
            shadow1.addColorStop(0, 'rgba(0, 0, 0, 0.35)');
            shadow1.addColorStop(0.3, 'rgba(0, 0, 0, 0.2)');
            shadow1.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');
            shadow1.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = shadow1;
            ctx.beginPath();
            ctx.ellipse(cx, shadowY + 20, droplet.baseRadius * 1.1, droplet.baseRadius * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner contact shadow (darker, sharper)
            const shadow2 = ctx.createRadialGradient(
                cx, shadowY + 5, 0,
                cx, shadowY + 5, droplet.baseRadius * 0.6
            );
            shadow2.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            shadow2.addColorStop(0.5, 'rgba(0, 0, 0, 0.25)');
            shadow2.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = shadow2;
            ctx.beginPath();
            ctx.ellipse(cx, shadowY + 5, droplet.baseRadius * 0.5, droplet.baseRadius * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawWaterInterior(cx, cy) {
            // Multiple gradient layers for depth
            
            // Layer 1: Base water color
            const water1 = ctx.createRadialGradient(
                cx - droplet.baseRadius * 0.2, cy - droplet.baseRadius * 0.3, 0,
                cx, cy, droplet.baseRadius * 1.2
            );
            water1.addColorStop(0, 'rgba(235, 248, 255, 0.98)');
            water1.addColorStop(0.15, 'rgba(210, 235, 250, 0.95)');
            water1.addColorStop(0.3, 'rgba(180, 220, 245, 0.92)');
            water1.addColorStop(0.5, 'rgba(140, 195, 235, 0.88)');
            water1.addColorStop(0.7, 'rgba(100, 165, 220, 0.85)');
            water1.addColorStop(0.85, 'rgba(70, 135, 200, 0.82)');
            water1.addColorStop(1, 'rgba(50, 110, 180, 0.8)');
            
            ctx.fillStyle = water1;
            ctx.fillRect(cx - droplet.baseRadius * 1.5, cy - droplet.baseRadius * 1.5,
                        droplet.baseRadius * 3, droplet.baseRadius * 3);
            
            // Layer 2: Depth gradient (darker at bottom)
            const water2 = ctx.createLinearGradient(cx, cy - droplet.baseRadius, cx, cy + droplet.baseRadius);
            water2.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
            water2.addColorStop(0.3, 'rgba(255, 255, 255, 0.05)');
            water2.addColorStop(0.7, 'rgba(0, 50, 100, 0.1)');
            water2.addColorStop(1, 'rgba(0, 30, 80, 0.2)');
            
            ctx.fillStyle = water2;
            ctx.fillRect(cx - droplet.baseRadius * 1.5, cy - droplet.baseRadius * 1.5,
                        droplet.baseRadius * 3, droplet.baseRadius * 3);
            
            // Layer 3: Subtle color variation (cyan tint in center)
            const water3 = ctx.createRadialGradient(cx, cy, 0, cx, cy, droplet.baseRadius * 0.8);
            water3.addColorStop(0, 'rgba(200, 240, 255, 0.15)');
            water3.addColorStop(0.5, 'rgba(180, 230, 250, 0.08)');
            water3.addColorStop(1, 'rgba(150, 210, 240, 0)');
            
            ctx.fillStyle = water3;
            ctx.fillRect(cx - droplet.baseRadius, cy - droplet.baseRadius,
                        droplet.baseRadius * 2, droplet.baseRadius * 2);
        }
        
        function drawDeepCaustics(cx, cy) {
            // More realistic caustic patterns
            const numCaustics = 25;
            const time = droplet.causticsPhase;
            
            for (let i = 0; i < numCaustics; i++) {
                const baseAngle = (i / numCaustics) * Math.PI * 2;
                const angle = baseAngle + Math.sin(time * 0.5 + i) * 0.3;
                const rBase = droplet.baseRadius * (0.2 + (i % 5) * 0.12);
                const r = rBase + Math.sin(time + i * 0.7) * 20;
                
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r * 0.9;
                
                const size = 15 + Math.sin(time * 0.8 + i * 1.3) * 10;
                const alpha = 0.04 + Math.sin(time + i) * 0.02;
                
                // Caustic shape (elongated, organic)
                const causticGrad = ctx.createRadialGradient(x, y, 0, x, y, size);
                causticGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha * 2})`);
                causticGrad.addColorStop(0.3, `rgba(240, 250, 255, ${alpha})`);
                causticGrad.addColorStop(0.7, `rgba(220, 245, 255, ${alpha * 0.5})`);
                causticGrad.addColorStop(1, 'rgba(200, 240, 255, 0)');
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(1.5, 0.7);  // Elongated shape
                
                ctx.fillStyle = causticGrad;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawSubsurfaceScattering(cx, cy) {
            // Light scattering through water
            
            // Upper hemisphere glow (light entering from top)
            const sss1 = ctx.createRadialGradient(
                cx, cy - droplet.baseRadius * 0.5, droplet.baseRadius * 0.2,
                cx, cy, droplet.baseRadius
            );
            sss1.addColorStop(0, 'rgba(255, 255, 255, 0.12)');
            sss1.addColorStop(0.3, 'rgba(240, 250, 255, 0.06)');
            sss1.addColorStop(1, 'rgba(220, 245, 255, 0)');
            
            ctx.fillStyle = sss1;
            ctx.beginPath();
            ctx.arc(cx, cy, droplet.baseRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Bottom internal reflection (light bouncing inside)
            const sss2 = ctx.createRadialGradient(
                cx, cy + droplet.baseRadius * 0.6, 0,
                cx, cy + droplet.baseRadius * 0.6, droplet.baseRadius * 0.5
            );
            sss2.addColorStop(0, 'rgba(200, 230, 255, 0.08)');
            sss2.addColorStop(0.5, 'rgba(180, 220, 250, 0.04)');
            sss2.addColorStop(1, 'rgba(150, 200, 240, 0)');
            
            ctx.fillStyle = sss2;
            ctx.beginPath();
            ctx.arc(cx, cy + droplet.baseRadius * 0.6, droplet.baseRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawPhotoFresnelRim(cx, cy) {
            // Realistic Fresnel effect - brighter at glancing angles
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Full rim with varying intensity
            for (let i = 0; i <= 360; i += 1) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                
                // Fresnel: stronger at edges perpendicular to view
                // Light from upper left
                const lightAngle = -Math.PI * 0.75;
                const angleDiff = Math.abs(theta - lightAngle);
                const fresnel = Math.pow(Math.cos(angleDiff * 0.5), 2);
                
                // Stronger on upper portion
                const heightFactor = 1 - (Math.sin(theta) + 1) * 0.3;
                
                const intensity = fresnel * heightFactor;
                
                if (intensity > 0.1) {
                    const rimGrad = ctx.createRadialGradient(x, y, 0, x, y, 8);
                    rimGrad.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.6})`);
                    rimGrad.addColorStop(0.3, `rgba(240, 250, 255, ${intensity * 0.3})`);
                    rimGrad.addColorStop(1, 'rgba(220, 245, 255, 0)');
                    
                    ctx.fillStyle = rimGrad;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function drawEnvironmentReflection(cx, cy) {
            // Curved environment reflection (like seeing room reflected)
            
            // Upper arc reflection (simulating light environment)
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            const reflectGrad = ctx.createLinearGradient(
                cx - droplet.baseRadius * 0.6, cy - droplet.baseRadius * 0.5,
                cx + droplet.baseRadius * 0.6, cy - droplet.baseRadius * 0.2
            );
            reflectGrad.addColorStop(0, 'rgba(200, 220, 240, 0)');
            reflectGrad.addColorStop(0.3, 'rgba(220, 235, 250, 0.08)');
            reflectGrad.addColorStop(0.5, 'rgba(240, 248, 255, 0.12)');
            reflectGrad.addColorStop(0.7, 'rgba(220, 235, 250, 0.08)');
            reflectGrad.addColorStop(1, 'rgba(200, 220, 240, 0)');
            
            ctx.fillStyle = reflectGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy - droplet.baseRadius * 0.35, 
                       droplet.baseRadius * 0.7, droplet.baseRadius * 0.25,
                       -0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawPhotoMainHighlight(cx, cy) {
            // Ultra-realistic main specular highlight
            
            const hlX = cx - droplet.baseRadius * 0.32;
            const hlY = cy - droplet.baseRadius * 0.35;
            
            // Soft outer glow
            const glow = ctx.createRadialGradient(hlX, hlY, 0, hlX, hlY, droplet.baseRadius * 0.5);
            glow.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            glow.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
            glow.addColorStop(0.6, 'rgba(250, 252, 255, 0.08)');
            glow.addColorStop(1, 'rgba(245, 250, 255, 0)');
            
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(hlX, hlY, droplet.baseRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Main highlight (slightly elongated)
            ctx.save();
            ctx.translate(hlX, hlY);
            ctx.rotate(-0.3);
            ctx.scale(1.2, 0.85);
            
            const main = ctx.createRadialGradient(0, 0, 0, 0, 0, droplet.baseRadius * 0.22);
            main.addColorStop(0, 'rgba(255, 255, 255, 0.98)');
            main.addColorStop(0.2, 'rgba(255, 255, 255, 0.9)');
            main.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            main.addColorStop(0.8, 'rgba(255, 255, 255, 0.15)');
            main.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.arc(0, 0, droplet.baseRadius * 0.22, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Sharp specular point (the "spark")
            const sparkX = hlX - droplet.baseRadius * 0.08;
            const sparkY = hlY - droplet.baseRadius * 0.06;
            
            const spark = ctx.createRadialGradient(sparkX, sparkY, 0, sparkX, sparkY, 12);
            spark.addColorStop(0, 'rgba(255, 255, 255, 1)');
            spark.addColorStop(0.4, 'rgba(255, 255, 255, 0.9)');
            spark.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = spark;
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Tiny extra spark
            const spark2 = ctx.createRadialGradient(sparkX + 15, sparkY + 8, 0, sparkX + 15, sparkY + 8, 5);
            spark2.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            spark2.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = spark2;
            ctx.beginPath();
            ctx.arc(sparkX + 15, sparkY + 8, 5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawPhotoSecondaryHighlights(cx, cy) {
            const highlights = [
                { x: 0.25, y: -0.52, r: 0.06, a: 0.4 },
                { x: 0.42, y: -0.28, r: 0.04, a: 0.3 },
                { x: -0.45, y: 0.35, r: 0.08, a: 0.15 },
                { x: 0.35, y: 0.42, r: 0.05, a: 0.1 },
                { x: -0.2, y: 0.55, r: 0.04, a: 0.08 },
                { x: 0.5, y: 0.1, r: 0.03, a: 0.2 },
            ];
            
            highlights.forEach(hl => {
                const x = cx + droplet.baseRadius * hl.x;
                const y = cy + droplet.baseRadius * hl.y;
                const r = droplet.baseRadius * hl.r;
                
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, `rgba(255, 255, 255, ${hl.a})`);
                grad.addColorStop(0.4, `rgba(250, 252, 255, ${hl.a * 0.5})`);
                grad.addColorStop(1, 'rgba(245, 250, 255, 0)');
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawPhotoEdge(cx, cy) {
            // Subtle edge with hint of chromatic aberration
            
            ctx.save();
            
            // Outer chromatic fringe (very subtle cyan/magenta)
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta) + 2;
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(180, 220, 255, 0.15)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Inner edge definition
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(60, 100, 140, 0.25)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawMicroHighlights(cx, cy) {
            // Tiny surface detail highlights
            const time = Date.now() * 0.001;
            
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2 + time * 0.1;
                const rFactor = 0.75 + Math.sin(i * 1.5) * 0.15;
                const r = droplet.baseRadius * rFactor;
                
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                
                // Only on upper half
                if (y < cy + droplet.baseRadius * 0.3) {
                    const twinkle = 0.3 + Math.sin(time * 3 + i * 2) * 0.2;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // =====================================================
        // SCIENTIFIC MODE â€” Shows molecular structure
        // =====================================================
        
        function renderScientific(w, h, cx, cy) {
            // Clear with subtle gradient background
            const bgGrad = ctx.createRadialGradient(cx, cy - 100, 0, cx, cy, h);
            bgGrad.addColorStop(0, '#1e2a4a');
            bgGrad.addColorStop(0.5, '#151d33');
            bgGrad.addColorStop(1, '#0a0f1a');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // === DROPLET SHADOW ===
            const shadowGrad = ctx.createRadialGradient(
                cx + 20, cy + droplet.baseRadius + 40, 0,
                cx + 20, cy + droplet.baseRadius + 40, droplet.baseRadius * 1.2
            );
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
            shadowGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.2)');
            shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.ellipse(cx + 20, cy + droplet.baseRadius + 40, 
                       droplet.baseRadius * 0.9, droplet.baseRadius * 0.3, 
                       0, 0, Math.PI * 2);
            ctx.fill();
            
            // === DRAW DROPLET BODY ===
            ctx.save();
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.clip();
            
            // === INTERIOR GRADIENT (water color) ===
            const waterGrad = ctx.createRadialGradient(
                cx - droplet.baseRadius * 0.3, cy - droplet.baseRadius * 0.3, 0,
                cx, cy, droplet.baseRadius * 1.1
            );
            waterGrad.addColorStop(0, 'rgba(200, 235, 255, 0.95)');
            waterGrad.addColorStop(0.2, 'rgba(150, 210, 250, 0.9)');
            waterGrad.addColorStop(0.5, 'rgba(100, 180, 240, 0.85)');
            waterGrad.addColorStop(0.8, 'rgba(60, 140, 220, 0.8)');
            waterGrad.addColorStop(1, 'rgba(40, 100, 180, 0.75)');
            ctx.fillStyle = waterGrad;
            ctx.fillRect(cx - droplet.baseRadius * 1.2, cy - droplet.baseRadius * 1.2,
                        droplet.baseRadius * 2.4, droplet.baseRadius * 2.4);
            
            // === INTERNAL CAUSTICS ===
            drawCaustics(cx, cy);
            
            // === DRAW INTERIOR MOLECULES ===
            molecules.filter(m => m.isInterior).forEach(mol => {
                drawMolecule(mol, cx, cy, 0.3);
            });
            
            // === DRAW CLUSTERS ===
            clusters.forEach(cluster => {
                drawCluster(cluster, cx, cy);
            });
            
            // === DRAW SURFACE MOLECULES ===
            molecules.filter(m => !m.isInterior).forEach(mol => {
                drawMolecule(mol, cx, cy, 0.7);
            });
            
            ctx.restore();
            
            // === SURFACE EFFECTS ===
            drawFresnelRim(cx, cy);
            drawMainHighlight(cx, cy);
            drawSecondaryHighlights(cx, cy);
            drawSurfaceEdge(cx, cy);
            
            // === CRR RUPTURE EFFECTS ===
            if (CRR.droplet.ruptureIntensity > 0.1) {
                const rippleGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, droplet.baseRadius * 1.2);
                rippleGrad.addColorStop(0, `rgba(200, 240, 255, ${0.2 * CRR.droplet.ruptureIntensity})`);
                rippleGrad.addColorStop(0.5, `rgba(150, 220, 255, ${0.1 * CRR.droplet.ruptureIntensity})`);
                rippleGrad.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = rippleGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, droplet.baseRadius * 1.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawCaustics(cx, cy) {
            // Simulated light caustics from internal refraction
            const numCaustics = 15;
            
            for (let i = 0; i < numCaustics; i++) {
                const angle = (i / numCaustics) * Math.PI * 2 + droplet.causticsPhase;
                const r = droplet.baseRadius * (0.3 + Math.sin(angle * 3 + droplet.causticsPhase) * 0.2);
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                
                const causticGrad = ctx.createRadialGradient(x, y, 0, x, y, 30 + Math.sin(droplet.causticsPhase + i) * 10);
                causticGrad.addColorStop(0, 'rgba(255, 255, 255, 0.08)');
                causticGrad.addColorStop(0.5, 'rgba(200, 240, 255, 0.04)');
                causticGrad.addColorStop(1, 'rgba(150, 220, 255, 0)');
                
                ctx.fillStyle = causticGrad;
                ctx.beginPath();
                ctx.arc(x, y, 30 + Math.sin(droplet.causticsPhase + i) * 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawMolecule(mol, cx, cy, opacity) {
            // Convert spherical to screen coordinates
            const r = droplet.baseRadius * mol.depth;
            const x = cx + Math.cos(mol.theta) * Math.sin(mol.phi) * r;
            const y = cy + Math.cos(mol.phi) * r * 0.8;  // Slight vertical compression
            const z = Math.sin(mol.theta) * Math.sin(mol.phi);  // For depth sorting
            
            // Size based on depth (perspective)
            const perspectiveScale = 0.5 + (z + 1) * 0.25;
            const baseSize = 4 * mol.scale * perspectiveScale;
            
            // Vibration effect
            const vibrate = Math.sin(mol.phase) * mol.vibrateAmp * 2;
            
            // Depth-based opacity
            const depthOpacity = opacity * (0.3 + mol.depth * 0.7) * perspectiveScale;
            
            // Draw H2O molecule
            const bondLen = baseSize * 2.5;
            const bondAngle = 104.45 * Math.PI / 180;
            const halfAngle = bondAngle / 2;
            
            // Hydrogen positions
            const h1x = x + Math.cos(mol.rotation - halfAngle) * (bondLen + vibrate);
            const h1y = y + Math.sin(mol.rotation - halfAngle) * (bondLen + vibrate);
            const h2x = x + Math.cos(mol.rotation + halfAngle) * (bondLen - vibrate * 0.5);
            const h2y = y + Math.sin(mol.rotation + halfAngle) * (bondLen - vibrate * 0.5);
            
            // Bonds
            ctx.strokeStyle = `rgba(180, 200, 220, ${depthOpacity * 0.5})`;
            ctx.lineWidth = baseSize * 0.3;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(h1x, h1y);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(h2x, h2y);
            ctx.stroke();
            
            // Oxygen (red)
            const oGrad = ctx.createRadialGradient(x - baseSize * 0.2, y - baseSize * 0.2, 0, x, y, baseSize);
            oGrad.addColorStop(0, `rgba(255, 150, 150, ${depthOpacity})`);
            oGrad.addColorStop(0.5, `rgba(220, 80, 80, ${depthOpacity})`);
            oGrad.addColorStop(1, `rgba(180, 40, 40, ${depthOpacity * 0.8})`);
            
            ctx.beginPath();
            ctx.arc(x, y, baseSize, 0, Math.PI * 2);
            ctx.fillStyle = oGrad;
            ctx.fill();
            
            // Hydrogens (white-blue)
            const hSize = baseSize * 0.6;
            
            [{ x: h1x, y: h1y }, { x: h2x, y: h2y }].forEach(h => {
                const hGrad = ctx.createRadialGradient(h.x - hSize * 0.2, h.y - hSize * 0.2, 0, h.x, h.y, hSize);
                hGrad.addColorStop(0, `rgba(255, 255, 255, ${depthOpacity})`);
                hGrad.addColorStop(0.5, `rgba(220, 235, 255, ${depthOpacity})`);
                hGrad.addColorStop(1, `rgba(180, 210, 250, ${depthOpacity * 0.8})`);
                
                ctx.beginPath();
                ctx.arc(h.x, h.y, hSize, 0, Math.PI * 2);
                ctx.fillStyle = hGrad;
                ctx.fill();
            });
        }
        
        function drawCluster(cluster, cx, cy) {
            const r = droplet.baseRadius * cluster.depth;
            const x = cx + Math.cos(cluster.theta) * Math.sin(cluster.phi) * r;
            const y = cy + Math.cos(cluster.phi) * r * 0.8;
            
            // Cluster glow (H-bond network)
            const pulse = 0.5 + Math.sin(cluster.pulsePhase) * 0.3;
            const strain = cluster.strain;
            const size = 25 + cluster.bonds * 5;
            
            const clusterGrad = ctx.createRadialGradient(x, y, 0, x, y, size);
            clusterGrad.addColorStop(0, `rgba(150, 200, 255, ${0.15 * pulse + strain * 0.2})`);
            clusterGrad.addColorStop(0.5, `rgba(100, 180, 255, ${0.08 * pulse})`);
            clusterGrad.addColorStop(1, 'rgba(80, 150, 255, 0)');
            
            ctx.fillStyle = clusterGrad;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // H-bond lines (tetrahedral network hint)
            if (cluster.coherence > 0.5) {
                ctx.strokeStyle = `rgba(180, 220, 255, ${0.1 * pulse})`;
                ctx.lineWidth = 1;
                
                for (let i = 0; i < cluster.bonds; i++) {
                    const angle = (i / cluster.bonds) * Math.PI * 2 + cluster.pulsePhase * 0.1;
                    const len = size * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
                    ctx.stroke();
                }
            }
        }
        
        function drawFresnelRim(cx, cy) {
            // Bright rim from Fresnel reflection at glancing angles
            ctx.save();
            
            for (let i = 0; i <= 360; i += 2) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                
                // Fresnel intensity varies with angle (brighter at edges)
                const normalAngle = theta;
                const viewAngle = Math.atan2(y - cy, x - cx);
                const fresnel = Math.pow(Math.abs(Math.sin(normalAngle - viewAngle)), 0.5);
                
                // Brighter on upper portion (light from above)
                const lightFactor = 0.5 + 0.5 * Math.cos(theta + Math.PI);
                
                const alpha = fresnel * lightFactor * 0.4;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawMainHighlight(cx, cy) {
            // Large primary specular highlight
            const hlX = cx - droplet.baseRadius * 0.35;
            const hlY = cy - droplet.baseRadius * 0.35;
            const hlR = droplet.baseRadius * 0.4;
            
            const hlGrad = ctx.createRadialGradient(hlX, hlY, 0, hlX, hlY, hlR);
            hlGrad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
            hlGrad.addColorStop(0.2, 'rgba(255, 255, 255, 0.7)');
            hlGrad.addColorStop(0.5, 'rgba(240, 250, 255, 0.3)');
            hlGrad.addColorStop(1, 'rgba(220, 240, 255, 0)');
            
            ctx.fillStyle = hlGrad;
            ctx.beginPath();
            ctx.arc(hlX, hlY, hlR, 0, Math.PI * 2);
            ctx.fill();
            
            // Sharp specular point
            const specGrad = ctx.createRadialGradient(hlX - 10, hlY - 10, 0, hlX - 10, hlY - 10, 15);
            specGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            specGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            specGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = specGrad;
            ctx.beginPath();
            ctx.arc(hlX - 10, hlY - 10, 15, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawSecondaryHighlights(cx, cy) {
            // Secondary smaller highlights
            const highlights = [
                { x: 0.2, y: -0.5, r: 0.08, a: 0.5 },
                { x: 0.4, y: -0.3, r: 0.05, a: 0.4 },
                { x: -0.5, y: 0.3, r: 0.1, a: 0.2 },
                { x: 0.3, y: 0.4, r: 0.06, a: 0.15 },
            ];
            
            highlights.forEach(hl => {
                const x = cx + droplet.baseRadius * hl.x;
                const y = cy + droplet.baseRadius * hl.y;
                const r = droplet.baseRadius * hl.r;
                
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                grad.addColorStop(0, `rgba(255, 255, 255, ${hl.a})`);
                grad.addColorStop(0.5, `rgba(240, 250, 255, ${hl.a * 0.5})`);
                grad.addColorStop(1, 'rgba(220, 240, 255, 0)');
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawSurfaceEdge(cx, cy) {
            // Subtle dark edge for definition
            ctx.save();
            ctx.beginPath();
            
            for (let i = 0; i <= 360; i++) {
                const theta = (i / 360) * Math.PI * 2;
                const r = getDropletRadius(theta);
                const x = cx + Math.cos(theta) * r;
                const y = cy + Math.sin(theta) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            ctx.strokeStyle = 'rgba(40, 80, 120, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }
        
        // =====================================================
        // CRR NUMERICAL DISPLAY
        // =====================================================
        
        function drawCRRDisplay() {
            // Only show in scientific mode or when not in full photorealistic
            if (photorealisticMode) {
                drawMinimalCRRIndicator();
                return;
            }
            
            const w = window.innerWidth;
            const cx = droplet.cx;
            const topY = droplet.cy - droplet.baseRadius - 180;
            
            ctx.save();
            
            // Background panel
            const panelWidth = 700;
            const panelHeight = 160;
            const panelX = cx - panelWidth / 2;
            const panelY = topY - 20;
            
            // Glass panel effect
            const panelGrad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelHeight);
            panelGrad.addColorStop(0, 'rgba(20, 40, 60, 0.85)');
            panelGrad.addColorStop(0.5, 'rgba(15, 30, 50, 0.9)');
            panelGrad.addColorStop(1, 'rgba(10, 25, 45, 0.85)');
            
            ctx.fillStyle = panelGrad;
            ctx.beginPath();
            ctx.roundRect(panelX, panelY, panelWidth, panelHeight, 10);
            ctx.fill();
            
            // Panel border
            ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Inner glow on rupture
            const maxRupture = Math.max(
                CRR.molecular.ruptureIntensity,
                CRR.cluster.ruptureIntensity,
                CRR.droplet.ruptureIntensity
            );
            if (maxRupture > 0.1) {
                ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
                ctx.shadowBlur = 20 * maxRupture;
            }
            
            // Title
            ctx.font = '600 14px "SF Mono", "Consolas", monospace';
            ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
            ctx.textAlign = 'center';
            ctx.fillText('CRR NESTED DYNAMICS â€” REAL-TIME', cx, panelY + 25);
            
            // Separator line
            ctx.strokeStyle = 'rgba(100, 180, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(panelX + 20, panelY + 35);
            ctx.lineTo(panelX + panelWidth - 20, panelY + 35);
            ctx.stroke();
            
            // Three columns for three scales
            const colWidth = panelWidth / 3;
            const scales = [
                { 
                    name: 'MOLECULAR', 
                    scale: 'femtoseconds',
                    data: CRR.molecular,
                    color: '#ff6b6b',
                    icon: 'âš›'
                },
                { 
                    name: 'CLUSTER', 
                    scale: 'picoseconds',
                    data: CRR.cluster,
                    color: '#4ecdc4',
                    icon: 'ðŸ”—'
                },
                { 
                    name: 'DROPLET', 
                    scale: 'milliseconds',
                    data: CRR.droplet,
                    color: '#45b7d1',
                    icon: 'ðŸ’§'
                }
            ];
            
            scales.forEach((scale, i) => {
                const colX = panelX + colWidth * i + colWidth / 2;
                const startY = panelY + 50;
                
                // Scale header
                ctx.font = '600 11px "SF Mono", "Consolas", monospace';
                ctx.fillStyle = scale.color;
                ctx.textAlign = 'center';
                ctx.fillText(`${scale.icon} ${scale.name}`, colX, startY);
                
                ctx.font = '400 9px "SF Mono", "Consolas", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillText(scale.scale, colX, startY + 12);
                
                // Coherence bar
                const barWidth = colWidth - 40;
                const barHeight = 8;
                const barX = colX - barWidth / 2;
                const barY = startY + 25;
                
                // Bar background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barWidth, barHeight, 3);
                ctx.fill();
                
                // Coherence fill
                const fillRatio = Math.min(scale.data.C / scale.data.omega, 1);
                const fillGrad = ctx.createLinearGradient(barX, barY, barX + barWidth * fillRatio, barY);
                fillGrad.addColorStop(0, scale.color);
                fillGrad.addColorStop(1, fillRatio > 0.8 ? '#fff' : scale.color);
                
                ctx.fillStyle = fillGrad;
                ctx.beginPath();
                ctx.roundRect(barX, barY, barWidth * fillRatio, barHeight, 3);
                ctx.fill();
                
                // Threshold marker
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(barX + barWidth, barY - 2);
                ctx.lineTo(barX + barWidth, barY + barHeight + 2);
                ctx.stroke();
                
                // Rupture flash
                if (scale.data.ruptureIntensity > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${scale.data.ruptureIntensity * 0.5})`;
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth, barHeight, 3);
                    ctx.fill();
                }
                
                // Numerical values
                ctx.font = '400 10px "SF Mono", "Consolas", monospace';
                ctx.textAlign = 'left';
                const valueX = colX - barWidth / 2;
                let valueY = barY + 22;
                
                // C(t)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText('C(t)', valueX, valueY);
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'right';
                ctx.fillText(scale.data.C.toFixed(3), valueX + barWidth, valueY);
                
                // Î©
                valueY += 14;
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText('Î©', valueX, valueY);
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.textAlign = 'right';
                ctx.fillText(scale.data.omega.toFixed(2), valueX + barWidth, valueY);
                
                // L(t)
                valueY += 14;
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText('L(t)', valueX, valueY);
                ctx.fillStyle = 'rgba(100, 255, 150, 0.9)';
                ctx.textAlign = 'right';
                ctx.fillText(scale.data.L.toFixed(4), valueX + barWidth, valueY);
                
                // R (regeneration)
                valueY += 14;
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText('R', valueX, valueY);
                ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';
                ctx.textAlign = 'right';
                const rVal = Math.min(scale.data.R, 999.99);
                ctx.fillText(rVal.toFixed(2), valueX + barWidth, valueY);
                
                // Rupture indicator
                if (scale.data.ruptureIntensity > 0.5) {
                    ctx.font = '700 10px "SF Mono", "Consolas", monospace';
                    ctx.fillStyle = `rgba(255, 100, 100, ${scale.data.ruptureIntensity})`;
                    ctx.textAlign = 'center';
                    ctx.fillText('Î´ RUPTURE', colX, valueY + 14);
                }
            });
            
            // Coupling arrows
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            
            const arrowY = panelY + 80;
            // Molecular â†’ Cluster
            ctx.beginPath();
            ctx.moveTo(panelX + colWidth - 10, arrowY);
            ctx.lineTo(panelX + colWidth + 10, arrowY);
            ctx.stroke();
            drawArrowHead(panelX + colWidth + 10, arrowY, 0);
            
            // Cluster â†’ Droplet
            ctx.beginPath();
            ctx.moveTo(panelX + colWidth * 2 - 10, arrowY);
            ctx.lineTo(panelX + colWidth * 2 + 10, arrowY);
            ctx.stroke();
            drawArrowHead(panelX + colWidth * 2 + 10, arrowY, 0);
            
            ctx.setLineDash([]);
            
            // Equation at bottom
            ctx.font = '400 10px "SF Mono", "Consolas", monospace';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.textAlign = 'center';
            ctx.fillText('C(t) = âˆ«L(Ï„)dÏ„  â†’  Î´(tâˆ’tâ‚€) when Câ‰¥Î©  â†’  R = exp(C/Î©)', cx, panelY + panelHeight - 10);
            
            ctx.restore();
        }
        
        function drawMinimalCRRIndicator() {
            // Subtle indicator for photorealistic mode
            const cx = droplet.cx;
            const cy = droplet.cy - droplet.baseRadius - 40;
            
            ctx.save();
            ctx.globalAlpha = 0.6;
            
            // Small coherence indicators (three dots)
            const scales = [
                { data: CRR.molecular, color: '#ff6b6b', x: -30 },
                { data: CRR.cluster, color: '#4ecdc4', x: 0 },
                { data: CRR.droplet, color: '#45b7d1', x: 30 }
            ];
            
            scales.forEach(scale => {
                const x = cx + scale.x;
                const fillRatio = Math.min(scale.data.C / scale.data.omega, 1);
                const radius = 6;
                
                // Background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.arc(x, cy, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Fill (as arc)
                if (fillRatio > 0) {
                    ctx.fillStyle = scale.color;
                    ctx.beginPath();
                    ctx.moveTo(x, cy);
                    ctx.arc(x, cy, radius, -Math.PI/2, -Math.PI/2 + fillRatio * Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Rupture flash
                if (scale.data.ruptureIntensity > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${scale.data.ruptureIntensity})`;
                    ctx.beginPath();
                    ctx.arc(x, cy, radius + 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.restore();
        }
        
        function drawArrowHead(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-6, -3);
            ctx.lineTo(-6, 3);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fill();
            ctx.restore();
        }
        
        // =====================================================
        // ANIMATION LOOP
        // =====================================================
        
        let lastTime = 0;
        
        function animate(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            
            updateCRR(dt);
            updatePhysics(dt);
            render();
            drawCRRDisplay();
            
            requestAnimationFrame(animate);
        }
        
        requestAnimationFrame(animate);
    </script>
</body>
</html>
