<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Living Sunrise - Enhanced Murmuration</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        canvas { display: block; touch-action: none; }
        
        /* FPS Counter */
        .fps { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #4ade80; font: 12px monospace; padding: 5px 10px; border-radius: 4px; z-index: 100; }
        .fps.warn { color: #fbbf24; }
        .fps.bad { color: #f87171; }
        
        /* Debug Panel */
        .debug { position: fixed; bottom: 70px; left: 10px; background: rgba(0,0,0,0.85); color: #fff; font: 10px monospace; padding: 8px 12px; border-radius: 4px; opacity: 0; transition: opacity 0.3s; line-height: 1.6; max-width: calc(100vw - 20px); max-height: 40vh; overflow-y: auto; z-index: 90; }
        .debug.show { opacity: 1; }
        .debug .t { color: #fcd34d; }
        .debug .v { color: #a78bfa; }
        .debug .section { border-top: 1px solid rgba(255,255,255,0.2); margin-top: 6px; padding-top: 6px; }
        
        /* Hide desktop hint on mobile */
        .hint { display: none; }
        
        /* Math Panel - Responsive */
        .math-panel { 
            position: fixed; top: 50px; left: 10px; 
            background: rgba(0,0,0,0.92); color: #e0e0e0; 
            font: 11px 'Courier New', monospace; 
            padding: 12px 16px; border-radius: 6px; 
            max-width: min(420px, calc(100vw - 20px)); 
            max-height: calc(100vh - 120px); 
            overflow-y: auto; opacity: 0; transition: opacity 0.3s; 
            border: 1px solid rgba(255,200,100,0.3); line-height: 1.5; 
            z-index: 95;
            -webkit-overflow-scrolling: touch;
        }
        .math-panel.show { opacity: 1; pointer-events: auto; }
        .math-panel h2 { color: #fcd34d; font-size: 13px; margin-bottom: 8px; border-bottom: 1px solid rgba(255,200,100,0.3); padding-bottom: 6px; }
        .math-panel h3 { color: #a78bfa; font-size: 11px; margin: 10px 0 4px 0; }
        .math-panel .eq { background: rgba(255,255,255,0.08); padding: 6px 10px; margin: 4px 0; border-radius: 4px; font-size: 11px; color: #fff; border-left: 2px solid #fcd34d; word-break: break-word; }
        .math-panel .note { color: #888; font-size: 9px; margin-top: 2px; }
        
        /* Mobile Controls */
        .mobile-controls {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.85);
            padding: 8px 10px; padding-bottom: max(8px, env(safe-area-inset-bottom));
            display: flex; flex-wrap: wrap; gap: 6px;
            justify-content: center; align-items: center;
            z-index: 1000;
            border-top: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            touch-action: manipulation;
        }
        .ctrl-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.25);
            color: #fff; font: 11px sans-serif;
            padding: 8px 12px; border-radius: 6px;
            cursor: pointer; transition: all 0.2s;
            min-width: 44px; min-height: 44px;
            display: flex; align-items: center; justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .ctrl-btn:active, .ctrl-btn.active {
            background: rgba(255,200,100,0.3);
            border-color: rgba(255,200,100,0.6);
        }
        .ctrl-btn.toggle-on {
            background: rgba(100,200,100,0.3);
            border-color: rgba(100,200,100,0.6);
        }
        .ctrl-btn .icon { font-size: 16px; margin-right: 4px; }
        .ctrl-btn.icon-only .icon { margin-right: 0; }
        
        /* Sirius touch hint */
        .sirius-hint {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: rgba(150, 180, 255, 0.9);
            font: 12px sans-serif;
            padding: 12px 20px; border-radius: 8px;
            border: 1px solid rgba(150, 180, 255, 0.4);
            opacity: 0; transition: opacity 0.5s;
            pointer-events: none; z-index: 80;
            text-align: center;
        }
        .sirius-hint.show { opacity: 1; }
        
        /* Responsive adjustments */
        @media (max-width: 480px) {
            .fps { font-size: 10px; padding: 4px 8px; top: 5px; right: 5px; }
            .debug { font-size: 9px; bottom: 65px; }
            .math-panel { font-size: 10px; top: 40px; padding: 10px 12px; }
            .math-panel h2 { font-size: 12px; }
            .math-panel h3 { font-size: 10px; }
            .math-panel .eq { font-size: 10px; padding: 5px 8px; }
            .ctrl-btn { padding: 6px 10px; font-size: 10px; min-width: 40px; min-height: 40px; }
        }
        
        @media (max-height: 500px) {
            .mobile-controls { padding: 5px 8px; gap: 4px; }
            .ctrl-btn { padding: 5px 8px; min-height: 36px; }
            .debug { max-height: 30vh; }
        }
    </style>
</head>
<body>
<div class="fps" id="fps">60 FPS</div>
<div class="math-panel" id="mathPanel">
    <h2>âŸ¨ CRR FRAMEWORK âŸ©</h2>
    <p style="color:#888;font-size:9px;margin-bottom:8px;">Coherence-Rupture-Regeneration by Alexander Sabine</p>
    <h3>â–¸ CORE EQUATIONS</h3>
    <div class="eq">C(x,t) = âˆ«L(x,Ï„)dÏ„ <span class="note">â€” Coherence accumulation</span></div>
    <div class="eq">Î´(now) â†’ Rupture at C â‰¥ Î© <span class="note">â€” Scale-invariant transition</span></div>
    <div class="eq">R = âˆ«Ï†Â·exp(C/Î©)Â·Î˜(...)dÏ„ <span class="note">â€” Memory-weighted regeneration</span></div>
    <div class="eq">Î© = 1/Ï€ (Zâ‚‚) | 1/2Ï€ (SO(2)) <span class="note">â€” Symmetry determines Î©</span></div>
    <h3>â–¸ ENHANCED MURMURATION</h3>
    <div class="eq">k = 7 topological neighbors <span class="note">â€” Scale-invariant interaction</span></div>
    <div class="eq">CRR rupture â†’ new move <span class="note">â€” Choreographed pattern changes</span></div>
    <div class="eq">Moves: vortex, wave, split, breathe, ribbon, column, sweep, tornado</div>
    <div class="eq">cohesionMult âˆˆ [0.7, 1.8] <span class="note">â€” Pattern-specific tightness</span></div>
    <div class="eq">angularMom drives swirl <span class="note">â€” Per-move rotation</span></div>
    <h3>â–¸ SUNRISE HEAT HAZE (Zâ‚‚)</h3>
    <div class="eq">Î© = 1/Ï€ â‰ˆ 0.318 <span class="note">â€” Shimmer intensity pulsing</span></div>
    <div class="eq">Intensity âˆ exp(C/Î©) <span class="note">â€” Memory-weighted glow</span></div>
    <h3>â–¸ RAINBOW OPTICS</h3>
    <div class="eq">C(s) = âˆ« LÂ·n(Î»)Â·ds <span class="note">â€” Phase accumulation in droplet</span></div>
    <div class="eq">Î©(Î») = Ï€Â·n(Î») <span class="note">â€” Zâ‚‚ symmetry at boundaries</span></div>
    <div class="eq">Î¸_primary â‰ˆ 42Â° | Î¸_secondary â‰ˆ 51Â° <span class="note">â€” Emergent caustic angles</span></div>
    <h3>â–¸ PREDATOR DYNAMICS</h3>
    <div class="eq">Î©_pred = 0.4 <span class="note">â€” Longer coherence cycles</span></div>
    <div class="eq">v_dive = 180Â·smoothAmp <span class="note">â€” Peak at rupture</span></div>
    <h3>â–¸ CRR STARS (Night)</h3>
    <div class="eq">Scintillation via CRR <span class="note">â€” Atmospheric turbulence</span></div>
    <div class="eq">Î© âˆ altitude Ã— brightness <span class="note">â€” Horizon stars twinkle more</span></div>
    <div class="eq">Chromatic shift âˆ CRR amplitude <span class="note">â€” Color shimmer</span></div>
    <h3>â–¸ SIRIUS A (Hyperreal)</h3>
    <div class="eq">Click to zoom â†’ stellar disk <span class="note">â€” 9,940 K Â· 25.4 Lâ˜‰</span></div>
    <div class="eq">Granulation = SO(2) CRR <span class="note">â€” Convective cells ~8 min</span></div>
    <div class="eq">P-mode oscillations <span class="note">â€” Ï„ â‰ˆ 46 min standing waves</span></div>
    <h3>â–¸ AURORA BOREALIS</h3>
    <div class="eq">Curtains = SO(2) CRR <span class="note">â€” Charged particle coherence</span></div>
    <div class="eq">Intensity âˆ CRR amplitude <span class="note">â€” Ruptures = brightness pulses</span></div>
    <h3>â–¸ MOONBOW (22Â° Halo)</h3>
    <div class="eq">Ice crystal refraction <span class="note">â€” CRR density fluctuations</span></div>
    <h3>â–¸ NOCTURNAL CREATURES</h3>
    <div class="eq">Bat Î© = 0.04-0.07 <span class="note">â€” Lower = erratic flight</span></div>
    <div class="eq">Owl Î© = 0.12 <span class="note">â€” Patient hunter</span></div>
    <div class="eq">Day/Night cycle: sunrise â†’ day 60s â†’ sunset â†’ night 60s</div>
    <p style="color:#555;font-size:8px;margin-top:10px;border-top:1px solid rgba(255,255,255,0.1);padding-top:6px;">cohere.org.uk | Zâ‚‚â†’Î©=1/Ï€, SO(2)â†’Î©=1/2Ï€</p>
</div>
<div class="debug" id="debug">
    <div><span class="t">Sun Phase:</span> <span class="v" id="sunPhase">0.00</span></div>
    <div><span class="t">Weather:</span> <span class="v" id="weatherState">clear</span></div>
    <div><span class="t">Rain Intensity:</span> <span class="v" id="rainInt">0%</span></div>
    <div><span class="t">Rainbow:</span> <span class="v" id="rainbowVis">0%</span></div>
    <div><span class="t">Sound:</span> <span class="v" id="soundState">OFF (press s)</span></div>
    <div class="section"></div>
    <div><span class="t">Flock C/Î©:</span> <span class="v" id="flockCoh">0.00</span></div>
    <div><span class="t">Flock State:</span> <span class="v" id="flockState">coh</span></div>
    <div><span class="t">Move:</span> <span class="v" id="currentMove">-</span></div>
    <div><span class="t">Flock Density:</span> <span class="v" id="flockDensity">0</span></div>
    <div><span class="t">Birds (fly/perch):</span> <span id="birds">0/0</span></div>
    <div class="section"></div>
    <div><span class="t">Predator:</span> <span class="v" id="predState">soar</span></div>
    <div><span class="t">Hunt C/Î©:</span> <span class="v" id="predCoh">0.00</span></div>
    <div class="section"></div>
    <div><span class="t">Bats:</span> <span class="v" id="batCount">0</span></div>
    <div><span class="t">Owl:</span> <span class="v" id="owlState">-</span></div>
    <div class="section"></div>
    <div><span class="t">Update:</span> <span id="upd">0</span>ms</div>
</div>
<div class="hint">m = math | c = debug | r = rain | s = sound | n = night | d = day | +/- = zoom Sirius</div>
<div class="mobile-controls" id="mobileControls">
    <button class="ctrl-btn" id="btnMath" title="Math Panel"><span class="icon">âˆ‘</span>Math</button>
    <button class="ctrl-btn" id="btnDebug" title="Debug Info"><span class="icon">âš™</span>Debug</button>
    <button class="ctrl-btn" id="btnRain" title="Toggle Rain"><span class="icon">ğŸŒ§</span>Rain</button>
    <button class="ctrl-btn" id="btnSound" title="Toggle Sound"><span class="icon">ğŸ”‡</span>Sound</button>
    <button class="ctrl-btn" id="btnNight" title="Skip to Night"><span class="icon">ğŸŒ™</span>Night</button>
    <button class="ctrl-btn" id="btnDay" title="Skip to Day"><span class="icon">â˜€</span>Day</button>
</div>
<div class="sirius-hint" id="siriusHint">Pinch or double-tap on SIRIUS to zoom</div>
<canvas id="c"></canvas>
<script>
/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  CRR MATHEMATICAL FRAMEWORK DEMONSTRATION                                      â•‘
â•‘  Coherence-Rupture-Regeneration by Alexander Sabine                           â•‘
â•‘                                                                                â•‘
â•‘  ENHANCED MURMURATION:                                                         â•‘
â•‘  - Topological neighbors (k=7) instead of metric distance                     â•‘
â•‘  - Turning wave propagation through delayed velocity response                  â•‘
â•‘  - Dynamic orbiting attractors for shape-shifting                             â•‘
â•‘  - Collective turn direction on CRR flock rupture                             â•‘
â•‘  - Density-responsive expansion/contraction                                    â•‘
â•‘                                                                                â•‘
â•‘  CORE EQUATIONS:                                                               â•‘
â•‘  C(x,t) = âˆ«L(x,Ï„)dÏ„           â€” Coherence: accumulated attention/energy       â•‘
â•‘  Î´(now) when C â‰¥ Î©            â€” Rupture: scale-invariant choice-moment        â•‘
â•‘  R = âˆ«Ï†(x,Ï„)Â·exp(C/Î©)Â·Î˜(...)dÏ„ â€” Regeneration: memory-weighted reconstruction â•‘
â•‘                                                                                â•‘
â•‘  Î©-SYMMETRY HYPOTHESIS:                                                        â•‘
â•‘  Zâ‚‚ (binary):     Î© = 1/Ï€  â‰ˆ 0.318                                            â•‘
â•‘  SO(2) (circular): Î© = 1/2Ï€ â‰ˆ 0.159                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const { sin, cos, sqrt, abs, floor, max, min, random, PI, atan2, exp, pow } = Math;
const PI2 = PI * 2;
let W, H, time = 0;

// CRR Constants from Î©-symmetry hypothesis
const OMEGA_Z2 = 1 / PI;        // â‰ˆ 0.318 for binary transitions
const OMEGA_SO2 = 1 / (2 * PI); // â‰ˆ 0.159 for continuous rotations

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIEGETIC SOUND SYSTEM - Sounds emerge from the scene
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const soundSystem = {
    ctx: null,
    enabled: false,
    initialized: false,
    masterGain: null,
    
    rain: { noise: null, filter: null, gain: null },
    wind: { noise: null, filter: null, gain: null },
    birds: { lastChirp: 0, chirpInterval: 2 },
    falcon: { lastCry: 0 },
    bats: { lastClick: 0, lastWingFlutter: 0 },
    owl: { lastHoot: 0 },
    
    init() {
        if (this.initialized) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.6;
            this.masterGain.connect(this.ctx.destination);
            
            this.rain.gain = this.ctx.createGain();
            this.rain.gain.gain.value = 0;
            this.rain.filter = this.ctx.createBiquadFilter();
            this.rain.filter.type = 'bandpass';
            this.rain.filter.frequency.value = 3000;
            this.rain.filter.Q.value = 0.5;
            this.rain.filter.connect(this.rain.gain);
            this.rain.gain.connect(this.masterGain);
            this.startNoise('rain');
            
            this.wind.gain = this.ctx.createGain();
            this.wind.gain.gain.value = 0;
            this.wind.filter = this.ctx.createBiquadFilter();
            this.wind.filter.type = 'lowpass';
            this.wind.filter.frequency.value = 400;
            this.wind.filter.Q.value = 1;
            this.wind.filter.connect(this.wind.gain);
            this.wind.gain.connect(this.masterGain);
            this.startNoise('wind');
            
            this.initialized = true;
        } catch (e) {
            console.log('Audio not available:', e);
        }
    },
    
    startNoise(type) {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        noise.loop = true;
        noise.connect(this[type].filter);
        noise.start();
        this[type].noise = noise;
    },
    
    chirp() {
        if (!this.ctx || !this.enabled) return;
        
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        const baseFreq = 2000 + Math.random() * 2000;
        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, now);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.3, now + 0.05);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, now + 0.15);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.08, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(now);
        osc.stop(now + 0.25);
    },
    
    flockStartle() {
        if (!this.ctx || !this.enabled) return;
        for (let i = 0; i < 8; i++) {
            setTimeout(() => this.chirp(), i * 30 + Math.random() * 50);
        }
    },
    
    falconCry() {
        if (!this.ctx || !this.enabled) return;
        if (this.ctx.currentTime - this.falcon.lastCry < 2) return;
        this.falcon.lastCry = this.ctx.currentTime;
        
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(1800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.6);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.12, now + 0.05);
        gain.gain.setValueAtTime(0.1, now + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(now);
        osc.stop(now + 0.8);
    },
    
    // Bat echolocation click - very short, high frequency pulse
    batClick(intensity = 1) {
        if (!this.ctx || !this.enabled) return;
        if (this.ctx.currentTime - this.bats.lastClick < 0.05) return;
        this.bats.lastClick = this.ctx.currentTime;
        
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        // Very high frequency click (bats use 20-100kHz, we simulate at audible range)
        const baseFreq = 4000 + Math.random() * 3000;
        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, now);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.7, now + 0.015);
        
        // Very short envelope
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.04 * intensity, now + 0.002);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(now);
        osc.stop(now + 0.03);
    },
    
    // Bat wing flutter - soft whooshing
    batFlutter() {
        if (!this.ctx || !this.enabled) return;
        if (this.ctx.currentTime - this.bats.lastWingFlutter < 0.3) return;
        this.bats.lastWingFlutter = this.ctx.currentTime;
        
        const now = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 0.15;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Filtered noise for flutter
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.sin(i / bufferSize * Math.PI);
        }
        
        const noise = this.ctx.createBufferSource();
        const filter = this.ctx.createBiquadFilter();
        const gain = this.ctx.createGain();
        
        noise.buffer = buffer;
        filter.type = 'bandpass';
        filter.frequency.value = 800 + Math.random() * 400;
        filter.Q.value = 2;
        
        gain.gain.setValueAtTime(0.015, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        noise.start(now);
    },
    
    // Owl hoot - low, haunting call
    owlHoot() {
        if (!this.ctx || !this.enabled) return;
        if (this.ctx.currentTime - this.owl.lastHoot < 4) return;
        this.owl.lastHoot = this.ctx.currentTime;
        
        const now = this.ctx.currentTime;
        
        // Two-note hoot pattern "hoo-HOO"
        for (let i = 0; i < 2; i++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            const startTime = now + i * 0.4;
            const freq = i === 0 ? 280 : 350;  // Second note slightly higher
            const duration = i === 0 ? 0.25 : 0.5;
            const volume = i === 0 ? 0.06 : 0.1;
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, startTime);
            osc.frequency.exponentialRampToValueAtTime(freq * 0.9, startTime + duration);
            
            filter.type = 'lowpass';
            filter.frequency.value = 600;
            filter.Q.value = 1;
            
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(volume, startTime + 0.05);
            gain.gain.setValueAtTime(volume * 0.8, startTime + duration * 0.6);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start(startTime);
            osc.stop(startTime + duration + 0.1);
        }
    },
    
    update(dt, rainIntensity, windIntensity, sunPhase, predatorState, flockRuptured, nightness = 0, flyingBats = 0, owlHunting = false) {
        if (!this.ctx || !this.enabled) return;
        
        const targetRain = rainIntensity * 0.5;
        this.rain.gain.gain.linearRampToValueAtTime(targetRain, this.ctx.currentTime + 0.1);
        this.rain.filter.frequency.value = 2000 + rainIntensity * 2000 + Math.sin(time * 0.5) * 500;
        
        const targetWind = (0.05 + sunPhase * 0.1 + rainIntensity * 0.15);
        this.wind.gain.gain.linearRampToValueAtTime(targetWind, this.ctx.currentTime + 0.1);
        this.wind.filter.frequency.value = 200 + rainIntensity * 300 + Math.sin(time * 0.3) * 100;
        
        // DAYTIME: Bird chirps
        const chirpChance = (1 - rainIntensity * 0.8) * (predatorState < 2 ? 1 : 0.2) * sunPhase * (1 - nightness);
        if (Math.random() < chirpChance * dt * 0.8) {
            this.chirp();
        }
        
        // NIGHTTIME: Bat clicks and owl hoots
        if (nightness > 0.5 && flyingBats > 0) {
            // Bat echolocation clicks - more frequent when more bats flying
            const clickChance = nightness * (flyingBats / 80) * 0.5;
            if (Math.random() < clickChance * dt) {
                this.batClick(0.5 + Math.random() * 0.5);
            }
            
            // Occasional wing flutter
            if (Math.random() < nightness * 0.02 * dt) {
                this.batFlutter();
            }
        }
        
        // Owl hoots - occasional at night
        if (nightness > 0.7 && Math.random() < 0.008 * dt) {
            this.owlHoot();
        }
        
        // Owl hunting cry
        if (owlHunting && Math.random() < 0.05 * dt) {
            this.owlHoot();
        }
    },
    
    toggle() {
        if (!this.initialized) {
            this.init();
        }
        this.enabled = !this.enabled;
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        return this.enabled;
    }
};

// Fast trig
const TN = 512;
const ST = new Float32Array(TN), CT = new Float32Array(TN);
for (let i = 0; i < TN; i++) { const a = i/TN*PI2; ST[i] = sin(a); CT[i] = cos(a); }
const fsin = a => ST[((a%PI2+PI2)%PI2)/PI2*TN|0];
const fcos = a => CT[((a%PI2+PI2)%PI2)/PI2*TN|0];
const lerp = (a,b,t) => a+(b-a)*t;
const clamp = (v,a,b) => max(a,min(b,v));

// Spatial hash for broad-phase neighbor finding
const CELL = 45;
let hash = {};
let flyingIndices = []; // Cached list of flying bird indices
const hkey = (x,y) => ((x/CELL|0) * 10000 + (y/CELL|0));

function buildHash(birds) {
    hash = {};
    flyingIndices.length = 0;
    for (let i = 0; i < birds.length; i++) {
        const b = birds[i]; 
        if (b.st !== 0) continue;
        flyingIndices.push(i);
        const k = hkey(b.x, b.y);
        (hash[k] || (hash[k] = [])).push(i);
    }
}

// Get candidates from nearby cells (for topological selection)
function getCandidates(x, y) {
    const r = [], cx = x/CELL|0, cy = y/CELL|0;
    for (let dx = -2; dx <= 2; dx++) {
        for (let dy = -2; dy <= 2; dy++) {
            const k = (cx+dx) * 10000 + (cy+dy);
            if (hash[k]) r.push(...hash[k]);
        }
    }
    return r;
}

// Pre-allocated arrays for bird rendering (performance)
const MAX_BIRDS = 500;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRR CLASS - Core implementation of Coherence-Rupture-Regeneration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class CRR {
    constructor(omega, lr = 0.1) {
        this.omega = omega;
        this.lr = lr;
        this.C = 0;
        this.st = 0;
        this.amp = 0;
        this.smoothAmp = 0;
    }
    
    update(dt, attn = 1) {
        if (this.st === 0) {
            this.C += this.lr * attn * dt;
            this.amp = min(1, this.C / this.omega);
            if (this.C >= this.omega) this.st = 1;
        }
        else if (this.st === 1) {
            this.amp = 1;
            this.st = 2;
        }
        else {
            const decay = 1.5 * exp(-min(this.C/this.omega, 4) * 0.5);
            this.C *= exp(-decay * dt);
            this.amp = this.C / this.omega;
            if (this.C < 0.01 * this.omega) { this.C = 0; this.st = 0; }
        }
        this.smoothAmp = lerp(this.smoothAmp, this.amp, min(1, dt * 8));
        return this.smoothAmp;
    }
    
    mem() { return exp(min(this.C / this.omega, 4)); }
    rupture() { if (this.st === 0 && this.C > 0.05 * this.omega) this.st = 1; }
    stateName() { return ['coh', 'RUP', 'reg'][this.st]; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRR RAINBOW PHYSICS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const RainbowCRR = {
    omega_base: PI,
    
    getN: function(wavelength_nm) {
        const Î» = wavelength_nm / 1000;
        return 1.3199 + 0.00653 / (Î» * Î»);
    },
    
    getOmega: function(wavelength_nm) {
        return this.omega_base * this.getN(wavelength_nm);
    },
    
    getL: function(wavelength_nm) {
        return 2 * PI * this.getN(wavelength_nm) / (wavelength_nm / 500);
    },
    
    spectrum: []
};

for (let nm = 700; nm >= 380; nm -= 8) {
    let r, g, b;
    if (nm >= 620) {
        r = 255;
        g = Math.floor(140 * (1 - (nm - 620) / 80));
        b = 0;
    } else if (nm >= 580) {
        r = 255;
        g = Math.floor(140 + 90 * (1 - (nm - 580) / 40));
        b = 0;
    } else if (nm >= 530) {
        r = Math.floor(255 * (nm - 530) / 50);
        g = 255;
        b = 0;
    } else if (nm >= 490) {
        r = 0;
        g = 255;
        b = Math.floor(200 * (1 - (nm - 490) / 40));
    } else if (nm >= 450) {
        r = 0;
        g = Math.floor(255 * (nm - 450) / 40);
        b = 255;
    } else {
        r = Math.floor(180 * (1 - (nm - 380) / 70));
        g = 0;
        b = 255;
    }
    RainbowCRR.spectrum.push({ nm, r, g, b });
}

function traceRayCRR(wavelength_nm, impactParam, reflections = 1) {
    if (abs(impactParam) >= 0.99) return null;
    
    const n = RainbowCRR.getN(wavelength_nm);
    const Î© = RainbowCRR.getOmega(wavelength_nm);
    const L = RainbowCRR.getL(wavelength_nm);
    const n_air = 1.0003;
    
    let totalC = 0;
    
    const sinI = abs(impactParam);
    const sinR = (n_air / n) * sinI;
    if (sinR > 1) return null;
    
    totalC += L * 0.1;
    totalC += L * n * 2 * sqrt(1 - sinR * sinR);
    
    for (let r = 0; r < reflections; r++) {
        totalC += L * n * 2 * sqrt(1 - sinR * sinR);
    }
    
    const theta_i = Math.asin(sinI);
    const theta_r = Math.asin(sinR);
    
    let deviation;
    if (reflections === 1) {
        deviation = 2 * theta_i - 4 * theta_r + PI;
    } else {
        deviation = 2 * theta_i - 6 * theta_r + 2 * PI;
    }
    
    let viewAngle = abs(PI - deviation) * 180 / PI;
    if (reflections === 2) {
        viewAngle = abs(deviation - PI) * 180 / PI;
    }
    
    const expCO = exp(totalC / Î©);
    const intensity = min(1, expCO * 0.0005);
    
    return { angle: viewAngle, intensity: intensity, wavelength: wavelength_nm, C: totalC, Î©: Î©, expCO: expCO };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEATHER SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const weather = {
    crr: new CRR(1.2, 0.025),
    state: 0,
    rainIntensity: 0,
    targetRainIntensity: 0,
    raindrops: [],
    rainbowVisible: 0,
    manualRain: false,
    
    init() {
        this.raindrops = [];
        this.state = 0;
        this.rainIntensity = 0;
    },
    
    update(dt, sunPhase) {
        this.crr.update(dt, 0.5);
        
        // No rain at night - check nighttime state
        const isNightTime = sunrise.isNight || (sunrise.cyclePhase && sunrise.cyclePhase > 0.8);
        
        // Force rain to stop at night
        if (isNightTime) {
            if (this.state > 0) {
                this.state = 3;  // Transition to stopping
            }
            this.manualRain = false;  // Disable manual rain at night
        }
        
        if ((sunPhase > 0.5 && !isNightTime) || this.manualRain) {
            if (this.manualRain && this.state === 0) {
                this.state = 1;
            }
            
            if (this.state === 0) {
                if (this.crr.st === 1 && random() < 0.3) {
                    this.state = 1;
                }
            } else if (this.state === 1) {
                this.targetRainIntensity = min(1, this.targetRainIntensity + dt * 0.15);
                if (this.targetRainIntensity > 0.7) {
                    this.state = 2;
                }
            } else if (this.state === 2) {
                this.targetRainIntensity = 0.8 + fsin(time * 0.5) * 0.2;
                if (this.crr.st === 1 && !this.manualRain) {
                    this.state = 3;
                }
            } else if (this.state === 3) {
                this.targetRainIntensity = max(0, this.targetRainIntensity - dt * 0.1);
                if (this.targetRainIntensity < 0.05) {
                    this.state = 0;
                    this.targetRainIntensity = 0;
                    this.manualRain = false;
                }
            }
        } else if (this.state === 3) {
            // Continue stopping rain even at night
            this.targetRainIntensity = max(0, this.targetRainIntensity - dt * 0.15);
            if (this.targetRainIntensity < 0.05) {
                this.state = 0;
                this.targetRainIntensity = 0;
            }
        }
        
        this.rainIntensity = lerp(this.rainIntensity, this.targetRainIntensity, dt * 2);
        
        const sunVisible = sunPhase > 0.2;
        const raining = this.rainIntensity > 0.1;
        const targetRainbow = (sunVisible && raining) ? min(1, this.rainIntensity * 1.5 + 0.3) : 0;
        this.rainbowVisible = lerp(this.rainbowVisible, targetRainbow, dt * 2);
        
        const spawnRate = this.rainIntensity * 25;
        for (let i = 0; i < spawnRate; i++) {
            if (random() < 0.7) {
                this.raindrops.push({
                    x: random() * W * 1.2 - W * 0.1,
                    y: -10 - random() * 50,
                    vx: -15 - random() * 10,
                    vy: 200 + random() * 150,
                    len: 8 + random() * 12,
                    alpha: 0.15 + random() * 0.2
                });
            }
        }
        
        const groundLevel = H * 0.88;
        for (let i = this.raindrops.length - 1; i >= 0; i--) {
            const drop = this.raindrops[i];
            drop.x += drop.vx * dt;
            drop.y += drop.vy * dt;
            if (drop.y > groundLevel + 10) {
                this.raindrops.splice(i, 1);
            }
        }
        
        if (this.raindrops.length > 1200) {
            this.raindrops.splice(0, this.raindrops.length - 1200);
        }
    },
    
    drawRain() {
        if (this.rainIntensity < 0.01) return;
        
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        
        for (const drop of this.raindrops) {
            const angle = atan2(drop.vy, drop.vx);
            const endX = drop.x + cos(angle) * drop.len;
            const endY = drop.y + sin(angle) * drop.len;
            
            const groundFade = drop.y > H * 0.7 ? 1 - (drop.y - H * 0.7) / (H * 0.18) : 1;
            const alpha = this.rainIntensity * 0.35 * drop.alpha * max(0.3, groundFade);
            
            ctx.strokeStyle = `rgba(180, 200, 220, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    },
    
    drawRainbow(sunX, sunY) {
        if (this.rainbowVisible < 0.01) return;
        
        const sunNormX = sunX / W;
        const antiSolarX = W * (1 - sunNormX);
        const sunHeight = (H * 0.88 - sunY) / H;
        const antiSolarY = H * 0.88 + sunHeight * H * 0.8;
        
        const baseSize = max(W, H);
        const primaryRadius = baseSize * 0.55;
        const secondaryRadius = baseSize * 0.72;
        const bandWidth = baseSize * 0.045;
        
        const arcStart = PI * 1.05;
        const arcEnd = PI * 1.95;
        
        for (let i = 0; i < RainbowCRR.spectrum.length; i++) {
            const color = RainbowCRR.spectrum[i];
            const t = i / RainbowCRR.spectrum.length;
            const r = primaryRadius - t * bandWidth;
            
            const trace = traceRayCRR(color.nm, 0.85, 1);
            const intensity = trace ? trace.intensity * 4 : 0.6;
            
            const warmBoost = color.nm > 550 ? 1 + (color.nm - 550) / 300 : 1;
            const coolFade = color.nm < 480 ? 0.6 + (color.nm - 380) / 250 : 1;
            
            ctx.beginPath();
            ctx.arc(antiSolarX, antiSolarY, r, arcStart, arcEnd);
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${this.rainbowVisible * intensity * 0.06 * warmBoost * coolFade})`;
            ctx.lineWidth = bandWidth / RainbowCRR.spectrum.length * 2;
            ctx.stroke();
        }
        
        for (let i = RainbowCRR.spectrum.length - 1; i >= 0; i--) {
            const color = RainbowCRR.spectrum[i];
            const t = (RainbowCRR.spectrum.length - 1 - i) / RainbowCRR.spectrum.length;
            const r = secondaryRadius - t * bandWidth * 0.7;
            
            const trace = traceRayCRR(color.nm, 0.95, 2);
            const intensity = trace ? trace.intensity * 2.5 : 0.35;
            
            const warmBoost = color.nm > 550 ? 1 + (color.nm - 550) / 300 : 1;
            const coolFade = color.nm < 480 ? 0.6 + (color.nm - 380) / 250 : 1;
            
            ctx.beginPath();
            ctx.arc(antiSolarX, antiSolarY, r, arcStart + 0.05, arcEnd - 0.05);
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${this.rainbowVisible * intensity * 0.03 * warmBoost * coolFade})`;
            ctx.lineWidth = bandWidth / RainbowCRR.spectrum.length * 1.5;
            ctx.stroke();
        }
        
        const darkBandInner = primaryRadius + bandWidth * 0.2;
        const darkBandOuter = secondaryRadius - bandWidth * 0.4;
        
        ctx.beginPath();
        ctx.arc(antiSolarX, antiSolarY, (darkBandInner + darkBandOuter) / 2, arcStart, arcEnd);
        ctx.lineWidth = (darkBandOuter - darkBandInner) * 0.8;
        ctx.strokeStyle = `rgba(0, 10, 30, ${this.rainbowVisible * 0.015})`;
        ctx.stroke();
    },
    
    stateName() {
        return ['clear', 'clouding', 'RAIN', 'clearing'][this.state];
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAHARA HEAT HAZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const desertHaze = {
    bands: [],
    initialized: false,
    
    init() {
        this.bands = [];
        
        const numBands = 8;
        for (let i = 0; i < numBands; i++) {
            const t = i / numBands;
            const heightBias = t * t * t;
            const baseY = H * (0.88 - heightBias * 0.25);
            
            this.bands.push({
                baseY: baseY,
                y: baseY,
                crr: new CRR(OMEGA_Z2, 0.2 + random() * 0.15),
                waveFreq: 0.002 + random() * 0.002,
                waveAmp: 1.5 + (1 - t) * 3,
                waveSpeed: 0.4 + random() * 0.3,
                phase: random() * PI2,
                thickness: 2 + (1 - t) * 4,
                baseAlpha: 0.008 + (1 - t) * 0.012,
                driftSpeed: 0.15 + random() * 0.2,
                driftAmp: 1 + random() * 2,
                driftPhase: random() * PI2,
                warmth: 0.3 + random() * 0.4,
                wave2Freq: 0.006 + random() * 0.004,
                wave2Amp: 0.8 + random() * 1.2,
                wave2Speed: 0.6 + random() * 0.4
            });
        }
        
        this.initialized = true;
    },
    
    update(dt, sunPhase) {
        if (!this.initialized) this.init();
        
        for (const band of this.bands) {
            band.crr.update(dt, 0.3 + sunPhase * 0.3);
            band.y = band.baseY + fsin(time * band.driftSpeed + band.driftPhase) * band.driftAmp;
        }
    },
    
    draw(sunPhase) {
        if (!this.initialized || sunPhase < 0.05) return;
        
        const rainFactor = 1 - weather.rainIntensity * 0.9;
        
        let sunriseIntensity;
        if (sunPhase < 0.1) {
            sunriseIntensity = sunPhase / 0.1;
        } else if (sunPhase < 0.4) {
            sunriseIntensity = 1.0;
        } else if (sunPhase < 0.65) {
            sunriseIntensity = 1.0 - (sunPhase - 0.4) / 0.25;
        } else {
            sunriseIntensity = 0;
        }
        
        if (sunriseIntensity < 0.01) return;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        for (const band of this.bands) {
            const shimmer = band.crr.smoothAmp;
            const alpha = band.baseAlpha * sunriseIntensity * (0.6 + shimmer * 0.4) * rainFactor;
            
            if (alpha < 0.002) continue;
            
            const horizonDist = (H * 0.88 - band.y) / (H * 0.3);
            const distanceFade = max(0, 1 - horizonDist);
            const finalAlpha = alpha * distanceFade;
            
            if (finalAlpha < 0.001) continue;
            
            ctx.beginPath();
            
            const segments = 80;
            const y = band.y;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const px = t * W;
                
                const wave1 = fsin(px * band.waveFreq + time * band.waveSpeed + band.phase) * band.waveAmp * shimmer;
                const wave2 = fsin(px * band.wave2Freq + time * band.wave2Speed + band.phase * 1.5) * band.wave2Amp * shimmer;
                const waveY = wave1 + wave2;
                
                const py = y + waveY - band.thickness * 0.5;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            
            for (let i = segments; i >= 0; i--) {
                const t = i / segments;
                const px = t * W;
                
                const wave1 = fsin(px * band.waveFreq + time * band.waveSpeed + band.phase + 0.2) * band.waveAmp * shimmer * 0.9;
                const wave2 = fsin(px * band.wave2Freq + time * band.wave2Speed + band.phase * 1.5 + 0.15) * band.wave2Amp * shimmer;
                const waveY = wave1 + wave2;
                
                const py = y + waveY + band.thickness * 0.5;
                ctx.lineTo(px, py);
            }
            
            ctx.closePath();
            
            const grad = ctx.createLinearGradient(0, y - band.thickness, 0, y + band.thickness);
            const r = 255;
            const g = 250 + band.warmth * 5 | 0;
            const b = 240 + band.warmth * 10 | 0;
            
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${finalAlpha * 0.5})`);
            grad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${finalAlpha})`);
            grad.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${finalAlpha * 0.5})`);
            grad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = grad;
            ctx.fill();
        }
        
        const groundAlpha = 0.015 * sunriseIntensity * rainFactor;
        if (groundAlpha > 0.003) {
            const groundY = H * 0.87;
            const groundGrad = ctx.createLinearGradient(0, groundY, 0, groundY - H * 0.06);
            
            const pulse = 0.8 + 0.2 * fsin(time * 0.8);
            
            groundGrad.addColorStop(0, `rgba(255, 252, 245, ${groundAlpha * pulse})`);
            groundGrad.addColorStop(0.5, `rgba(255, 250, 242, ${groundAlpha * 0.3 * pulse})`);
            groundGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, groundY - H * 0.06, W, H * 0.06);
        }
        
        ctx.restore();
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUNRISE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const sunrise = {
    crr: new CRR(2.0, 0.015),
    phase: 0, targetPhase: 0, x: 0.5, y: 1.0, radius: 0.11,
    rays: [],
    rayLayers: [],
    
    init() { 
        // Start at full daytime
        this.phase = 1;
        this.targetPhase = 1;
        this.cyclePhase = 0.5;  // At day hold point
        this.dayHoldTime = 0;
        this.nightHoldTime = 0;
        this.isDay = true;
        this.isNight = false;
        this.moonPhase = 0;
        this.y = 0.35;  // Sun high in sky
        desertHaze.init();
        
        this.rays = [];
        this.rayLayers = [];
        
        for (let i = 0; i < 24; i++) {
            const baseAngle = (i / 24) * PI2;
            this.rays.push({
                angle: baseAngle + (random() - 0.5) * 0.15,
                length: 0.6 + random() * 0.8,
                width: 0.012 + random() * 0.018,
                speed: 0.02 + random() * 0.04,
                phase: random() * PI2,
                intensity: 0.3 + random() * 0.4,
                driftSpeed: 0.005 + random() * 0.01,
                driftAmp: 0.02 + random() * 0.03
            });
        }
        
        for (let i = 0; i < 8; i++) {
            this.rayLayers.push({
                angle: (i / 8) * PI2 + random() * 0.3,
                length: 1.2 + random() * 0.6,
                width: 0.04 + random() * 0.06,
                speed: 0.008 + random() * 0.012,
                phase: random() * PI2,
                intensity: 0.15 + random() * 0.15
            });
        }
    },
    
    update(dt) {
        this.crr.update(dt, 0.8);
        
        // Day/night cycle phases:
        // 0.0 - 0.5: sunrise (sun rises)
        // 0.5: hold at day for DAY_DURATION seconds
        // 0.5 - 1.0: sunset (sun sets fully below horizon)
        // 1.0: hold at night for NIGHT_DURATION seconds
        // Then cycle back to 0
        
        if (!this.cyclePhase) this.cyclePhase = 0;
        if (!this.dayHoldTime) this.dayHoldTime = 0;
        if (!this.nightHoldTime) this.nightHoldTime = 0;
        if (!this.DAY_DURATION) this.DAY_DURATION = 60;
        if (!this.NIGHT_DURATION) this.NIGHT_DURATION = 60;
        if (this.isNight === undefined) this.isNight = true;
        if (this.isDay === undefined) this.isDay = false;
        if (this.moonPhase === undefined) this.moonPhase = 0;
        
        const cycleSpeed = 0.018;
        
        if (this.cyclePhase < 0.5) {
            // SUNRISE
            this.cyclePhase += dt * cycleSpeed;
            this.targetPhase = this.cyclePhase * 2;
            this.isNight = this.cyclePhase < 0.1;
            this.moonPhase = max(0, this.moonPhase - dt * 0.5);  // Moon sets
            if (this.cyclePhase >= 0.5) {
                this.cyclePhase = 0.5;
                this.targetPhase = 1;
                this.isDay = true;
                this.isNight = false;
                this.dayHoldTime = 0;
            }
        } else if (this.cyclePhase === 0.5 && this.dayHoldTime < this.DAY_DURATION) {
            // DAY - hold for 60 seconds
            this.dayHoldTime += dt;
            this.targetPhase = 1;
        } else if (this.cyclePhase >= 0.5 && this.cyclePhase < 1.0) {
            // SUNSET
            this.cyclePhase += dt * cycleSpeed;
            this.targetPhase = 2 - this.cyclePhase * 2;
            if (this.cyclePhase >= 0.75) this.isDay = false;
            if (this.cyclePhase >= 0.9) {
                this.moonPhase = min(1, this.moonPhase + dt * 0.3);  // Moon rises
            }
            if (this.cyclePhase >= 1.0) {
                this.cyclePhase = 1.0;
                this.targetPhase = 0;
                this.isNight = true;
                this.nightHoldTime = 0;
            }
        } else if (this.cyclePhase >= 1.0 && this.nightHoldTime < this.NIGHT_DURATION) {
            // NIGHT - hold for 60 seconds
            this.nightHoldTime += dt;
            this.moonPhase = min(1, this.moonPhase + dt * 0.15);
            this.targetPhase = 0;
        } else {
            // NIGHT OVER - restart cycle
            this.cyclePhase = 0;
            this.targetPhase = 0;
            this.isNight = true;  // Still night at start of sunrise
        }
        
        this.phase = lerp(this.phase, this.targetPhase, dt * 2);
        this.x = 0.48 + fsin(this.phase * 0.3) * 0.02;
        // Sun goes fully below horizon at night
        this.y = 0.85 - this.phase * 0.5;  // At phase=0, y=0.85 (horizon), at phase=1, y=0.35 (high)
        desertHaze.update(dt, this.phase);
    },
    
    isDusk() { return this.cyclePhase > 0.5 && this.cyclePhase < 0.9; },
    isDawn() { return this.cyclePhase > 0.05 && this.cyclePhase < 0.5; },
    
    drawMoon() {
        if (!this.moonPhase || this.moonPhase < 0.05) return;
        
        const moonAlpha = min(1, this.moonPhase);
        const moonY = H * (0.9 - this.moonPhase * 0.6);  // Rises from horizon
        const moonX = W * 0.25;  // Left side of sky
        const moonR = H * 0.045;
        
        ctx.save();
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CRR MOONBOW (Lunar Halo) - 22Â° ice crystal refraction
        // Very subtle, only visible when moon is bright
        // CRR drives subtle intensity variations in the halo
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.moonPhase > 0.3) {
            const haloRadius = moonR * 8;  // 22Â° halo scaled
            const haloAlpha = (this.moonPhase - 0.3) * 0.12;  // Very subtle
            
            // CRR-driven intensity variation around the halo
            const numSegments = 60;
            for (let i = 0; i < numSegments; i++) {
                const angle = (i / numSegments) * PI2;
                const nextAngle = ((i + 1) / numSegments) * PI2;
                
                // CRR variation - ice crystal density fluctuations
                const variation = fsin(angle * 3 + time * 0.2) * 0.3 + 
                                  fsin(angle * 7 + time * 0.15) * 0.2;
                const segmentAlpha = haloAlpha * (0.7 + variation * 0.3) * moonAlpha;
                
                if (segmentAlpha > 0.005) {
                    // Subtle spectral colors (moonbow is usually white but can show faint colors)
                    const hue = 200 + (angle / PI2) * 40;  // Slight blue-white variation
                    
                    ctx.strokeStyle = `hsla(${hue}, 20%, 90%, ${segmentAlpha})`;
                    ctx.lineWidth = moonR * 0.15;
                    ctx.beginPath();
                    ctx.arc(moonX, moonY, haloRadius, angle, nextAngle + 0.02);
                    ctx.stroke();
                }
            }
            
            // Inner glow of halo
            const innerGlow = ctx.createRadialGradient(
                moonX, moonY, haloRadius * 0.85,
                moonX, moonY, haloRadius * 1.15
            );
            innerGlow.addColorStop(0, 'transparent');
            innerGlow.addColorStop(0.4, `rgba(200, 210, 230, ${haloAlpha * 0.3 * moonAlpha})`);
            innerGlow.addColorStop(0.5, `rgba(210, 220, 240, ${haloAlpha * 0.5 * moonAlpha})`);
            innerGlow.addColorStop(0.6, `rgba(200, 210, 230, ${haloAlpha * 0.3 * moonAlpha})`);
            innerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(moonX, moonY, haloRadius * 1.2, 0, PI2);
            ctx.fill();
        }
        
        // Moon glow
        const glowR = moonR * 3;
        const glow = ctx.createRadialGradient(moonX, moonY, moonR * 0.5, moonX, moonY, glowR);
        glow.addColorStop(0, `rgba(200,210,230,${moonAlpha * 0.15})`);
        glow.addColorStop(0.3, `rgba(150,170,200,${moonAlpha * 0.08})`);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(moonX, moonY, glowR, 0, PI2);
        ctx.fill();
        
        // Moon body
        const moonGrad = ctx.createRadialGradient(
            moonX - moonR * 0.3, moonY - moonR * 0.3, 0,
            moonX, moonY, moonR
        );
        moonGrad.addColorStop(0, `rgba(250,250,255,${moonAlpha})`);
        moonGrad.addColorStop(0.7, `rgba(220,225,235,${moonAlpha})`);
        moonGrad.addColorStop(1, `rgba(180,185,200,${moonAlpha * 0.9})`);
        
        ctx.fillStyle = moonGrad;
        ctx.beginPath();
        ctx.arc(moonX, moonY, moonR, 0, PI2);
        ctx.fill();
        
        // Moon craters (subtle)
        ctx.fillStyle = `rgba(160,165,180,${moonAlpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(moonX + moonR * 0.2, moonY - moonR * 0.1, moonR * 0.15, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(moonX - moonR * 0.3, moonY + moonR * 0.3, moonR * 0.2, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(moonX + moonR * 0.1, moonY + moonR * 0.4, moonR * 0.12, 0, PI2);
        ctx.fill();
        
        ctx.restore();
    },
    
    // Draw ambient moonlight illumination over the scene
    drawMoonlight() {
        if (!this.moonPhase || this.moonPhase < 0.2) return;
        
        const moonAlpha = min(1, this.moonPhase);
        const moonX = W * 0.25;
        const moonY = H * (0.9 - this.moonPhase * 0.6);
        
        ctx.save();
        
        // Ambient moonlight wash - subtle blue tint over the scene
        const ambientAlpha = moonAlpha * 0.08;
        ctx.fillStyle = `rgba(180, 200, 230, ${ambientAlpha})`;
        ctx.fillRect(0, 0, W, H);
        
        // Moonlight rays/glow spreading down from moon
        const rayGrad = ctx.createRadialGradient(moonX, moonY, 0, moonX, H * 0.7, H * 0.8);
        rayGrad.addColorStop(0, `rgba(200, 215, 240, ${moonAlpha * 0.12})`);
        rayGrad.addColorStop(0.3, `rgba(180, 200, 230, ${moonAlpha * 0.08})`);
        rayGrad.addColorStop(0.6, `rgba(160, 180, 210, ${moonAlpha * 0.04})`);
        rayGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = rayGrad;
        ctx.fillRect(0, 0, W, H);
        
        // Ground illumination - helps see bats against grass/tree
        const groundGlow = ctx.createLinearGradient(0, H * 0.6, 0, H);
        groundGlow.addColorStop(0, 'transparent');
        groundGlow.addColorStop(0.5, `rgba(180, 195, 220, ${moonAlpha * 0.06})`);
        groundGlow.addColorStop(1, `rgba(160, 180, 210, ${moonAlpha * 0.1})`);
        ctx.fillStyle = groundGlow;
        ctx.fillRect(0, H * 0.6, W, H * 0.4);
        
        ctx.restore();
    },
    
    draw() {
        // Don't draw sun if below horizon
        if (this.phase < 0.08) return;
        
        const cx = W * this.x, cy = H * this.y, r = H * this.radius;
        const rainDim = 1 - weather.rainIntensity * 0.4;
        const int = (0.7 + this.phase * 0.3) * rainDim;
        
        desertHaze.draw(this.phase);
        
        // God rays
        if (this.phase > 0.05 && weather.rainIntensity < 0.8) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            const horizonFactor = max(0, 1 - (H * 0.88 - cy) / (H * 0.5));
            const atmosphericDensity = 0.3 + horizonFactor * 0.5;
            
            for (const ray of this.rayLayers) {
                const drift = fsin(time * ray.speed * 0.5 + ray.phase) * 0.02;
                const currentAngle = ray.angle + drift;
                const pulse = 0.7 + 0.3 * fsin(time * ray.speed * 0.3 + ray.phase);
                
                const rayDirY = sin(currentAngle);
                if (rayDirY > 0.3) continue;
                
                const rayAlpha = 0.008 * int * pulse * ray.intensity * atmosphericDensity * (1 - weather.rainIntensity * 0.7);
                
                if (rayAlpha > 0.001) {
                    const rayLen = r * (4 + ray.length * 6);
                    const rayWidth = r * ray.width * (1.5 + pulse * 0.2);
                    
                    const endX = cx + cos(currentAngle) * rayLen;
                    const endY = cy + sin(currentAngle) * rayLen;
                    
                    const grad = ctx.createLinearGradient(cx, cy, endX, endY);
                    
                    grad.addColorStop(0, `rgba(255, 230, 180, ${rayAlpha * 1.2})`);
                    grad.addColorStop(0.15, `rgba(255, 200, 140, ${rayAlpha})`);
                    grad.addColorStop(0.4, `rgba(255, 170, 100, ${rayAlpha * 0.5})`);
                    grad.addColorStop(0.7, `rgba(255, 140, 70, ${rayAlpha * 0.2})`);
                    grad.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    
                    const halfWidth = rayWidth * 0.5;
                    const ctrlDist = rayLen * 0.4;
                    
                    ctx.quadraticCurveTo(
                        cx + cos(currentAngle - halfWidth * 0.5) * ctrlDist,
                        cy + sin(currentAngle - halfWidth * 0.5) * ctrlDist,
                        endX + cos(currentAngle - PI/2) * rayWidth * rayLen * 0.02,
                        endY + sin(currentAngle - PI/2) * rayWidth * rayLen * 0.02
                    );
                    ctx.quadraticCurveTo(
                        cx + cos(currentAngle + halfWidth * 0.5) * ctrlDist,
                        cy + sin(currentAngle + halfWidth * 0.5) * ctrlDist,
                        cx, cy
                    );
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            for (const ray of this.rays) {
                const drift = fsin(time * ray.driftSpeed + ray.phase) * ray.driftAmp;
                const currentAngle = ray.angle + drift;
                
                const breathe = 0.85 + 0.15 * fsin(time * ray.speed + ray.phase);
                const shimmer = 0.95 + 0.05 * fsin(time * ray.speed * 3 + ray.phase * 2);
                
                const rayDirY = sin(currentAngle);
                if (rayDirY > 0.4) continue;
                
                const lowSunBoost = 1 + (1 - this.phase) * 0.5;
                
                const rayAlpha = 0.012 * int * breathe * shimmer * ray.intensity * lowSunBoost * (1 - weather.rainIntensity * 0.6);
                
                if (rayAlpha > 0.002) {
                    const rayLen = r * (2.5 + ray.length * 4);
                    const baseWidth = r * ray.width;
                    
                    const startWidth = baseWidth * 1.2;
                    const endWidth = baseWidth * 0.3;
                    
                    const endX = cx + cos(currentAngle) * rayLen;
                    const endY = cy + sin(currentAngle) * rayLen;
                    
                    const perpX = -sin(currentAngle);
                    const perpY = cos(currentAngle);
                    
                    const grad = ctx.createLinearGradient(cx, cy, endX, endY);
                    
                    const warmR = 255;
                    const warmG = 200 + this.phase * 40;
                    const warmB = 120 + this.phase * 80;
                    
                    grad.addColorStop(0, `rgba(${warmR}, ${warmG}, ${warmB}, ${rayAlpha * 0.8})`);
                    grad.addColorStop(0.1, `rgba(${warmR}, ${warmG - 20}, ${warmB - 30}, ${rayAlpha})`);
                    grad.addColorStop(0.3, `rgba(${warmR}, ${warmG - 40}, ${warmB - 50}, ${rayAlpha * 0.7})`);
                    grad.addColorStop(0.6, `rgba(${warmR}, ${warmG - 60}, ${warmB - 70}, ${rayAlpha * 0.3})`);
                    grad.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    
                    ctx.moveTo(cx + perpX * startWidth, cy + perpY * startWidth);
                    ctx.lineTo(endX + perpX * endWidth, endY + perpY * endWidth);
                    ctx.lineTo(endX - perpX * endWidth, endY - perpY * endWidth);
                    ctx.lineTo(cx - perpX * startWidth, cy - perpY * startWidth);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            const glowGrad = ctx.createRadialGradient(cx, cy, r * 0.9, cx, cy, r * 2);
            const glowAlpha = 0.015 * int * atmosphericDensity * (1 - weather.rainIntensity * 0.5);
            glowGrad.addColorStop(0, `rgba(255, 220, 160, ${glowAlpha})`);
            glowGrad.addColorStop(0.5, `rgba(255, 180, 100, ${glowAlpha * 0.4})`);
            glowGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 2, 0, PI2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Corona
        const hGlow = 1 + (1 - this.phase) * 0.8;
        
        for (let i = 5; i >= 0; i--) {
            const gr = r * (1.5 + i * 0.5) * hGlow;
            const a = (0.06 - i * 0.008) * int;
            
            const g = ctx.createRadialGradient(cx, cy, r * 0.8, cx, cy, gr);
            g.addColorStop(0, `rgba(255, ${200 + this.phase * 50 | 0}, ${120 + this.phase * 80 | 0}, ${a})`);
            g.addColorStop(0.4, `rgba(255, ${150 + this.phase * 50 | 0}, ${60 + this.phase * 50 | 0}, ${a * 0.5})`);
            g.addColorStop(0.7, `rgba(255, ${100 + this.phase * 40 | 0}, ${30 + this.phase * 30 | 0}, ${a * 0.2})`);
            g.addColorStop(1, 'transparent');
            
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(cx, cy, gr, 0, PI2);
            ctx.fill();
        }
        
        // Inner corona
        const innerCorona = ctx.createRadialGradient(cx, cy, r * 0.95, cx, cy, r * 1.4);
        innerCorona.addColorStop(0, `rgba(255, 255, 240, ${0.4 * int})`);
        innerCorona.addColorStop(0.3, `rgba(255, 250, 200, ${0.2 * int})`);
        innerCorona.addColorStop(1, 'transparent');
        ctx.fillStyle = innerCorona;
        ctx.beginPath();
        ctx.arc(cx, cy, r * 1.4, 0, PI2);
        ctx.fill();
        
        // Heat haze distortion
        let hazeDistortion = 0;
        if (this.phase < 0.1) {
            hazeDistortion = this.phase / 0.1;
        } else if (this.phase < 0.4) {
            hazeDistortion = 1.0;
        } else if (this.phase < 0.65) {
            hazeDistortion = 1.0 - (this.phase - 0.4) / 0.25;
        }
        hazeDistortion *= (1 - weather.rainIntensity);
        
        // Sun disc
        const disc = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        
        disc.addColorStop(0, `rgba(255, 255, ${250 + this.phase * 5 | 0}, ${int})`);
        disc.addColorStop(0.3, `rgba(255, 253, ${235 + this.phase * 15 | 0}, ${int})`);
        disc.addColorStop(0.6, `rgba(255, ${248 + this.phase * 7 | 0}, ${210 + this.phase * 25 | 0}, ${int})`);
        disc.addColorStop(0.8, `rgba(255, ${235 + this.phase * 15 | 0}, ${170 + this.phase * 40 | 0}, ${int * 0.95})`);
        disc.addColorStop(0.95, `rgba(255, ${200 + this.phase * 30 | 0}, ${100 + this.phase * 40 | 0}, ${int * 0.85})`);
        disc.addColorStop(1, `rgba(255, ${170 + this.phase * 30 | 0}, ${70 + this.phase * 30 | 0}, ${int * 0.7})`);
        
        ctx.fillStyle = disc;
        ctx.beginPath();
        
        if (hazeDistortion > 0.01) {
            const segments = 64;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * PI2;
                
                const wobble1 = fsin(angle * 3 + time * 2.4) * 0.0075 * hazeDistortion;
                const wobble2 = fsin(angle * 5 + time * 1.6 + 1) * 0.005 * hazeDistortion;
                const wobble3 = fsin(angle * 8 + time * 3.6 + 2) * 0.003 * hazeDistortion;
                const wobble4 = fsin(angle * 12 + time * 5.0 + 3) * 0.0015 * hazeDistortion;
                
                const verticalWobble = fsin(time * 1.0) * 0.006 * hazeDistortion;
                
                const totalWobble = 1 + wobble1 + wobble2 + wobble3 + wobble4;
                
                const px = cx + cos(angle) * r * totalWobble;
                const py = cy + sin(angle) * r * totalWobble * (1 + verticalWobble);
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        } else {
            ctx.arc(cx, cy, r, 0, PI2);
        }
        ctx.fill();
        
        if (weather.rainIntensity < 0.3) {
            ctx.strokeStyle = `rgba(255, 200, 150, ${0.3 * int * (1 - weather.rainIntensity)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 1.01, 0, PI2);
            ctx.stroke();
        }
        
        // Solar granulation
        ctx.save();
        ctx.globalCompositeOperation = 'overlay';
        ctx.globalAlpha = 0.08 * int;
        
        for (let i = 0; i < 8; i++) {
            const spotAngle = (i / 8) * PI2 + time * 0.01;
            const spotDist = r * (0.3 + (i % 3) * 0.2);
            const spotX = cx + cos(spotAngle) * spotDist;
            const spotY = cy + sin(spotAngle) * spotDist * 0.8;
            const spotR = r * (0.1 + (i % 2) * 0.05);
            
            const spotGrad = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, spotR);
            spotGrad.addColorStop(0, 'rgba(255, 250, 230, 0.3)');
            spotGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = spotGrad;
            ctx.beginPath();
            ctx.arc(spotX, spotY, spotR, 0, PI2);
            ctx.fill();
        }
        ctx.restore();
    },
    
    drawLensFlare() {
        const cx = W * this.x, cy = H * this.y, r = H * this.radius;
        
        let flareIntensity;
        if (this.phase < 0.1) {
            flareIntensity = this.phase / 0.1 * 0.5;
        } else if (this.phase < 0.35) {
            flareIntensity = 0.5 + (this.phase - 0.1) / 0.25 * 0.5;
        } else if (this.phase < 0.6) {
            flareIntensity = 1.0;
        } else if (this.phase < 0.85) {
            flareIntensity = 1.0 - (this.phase - 0.6) / 0.25;
        } else {
            flareIntensity = 0;
        }
        
        flareIntensity *= (1 - weather.rainIntensity * 0.8);
        
        if (flareIntensity < 0.02) return;
        
        const crrPulse = 0.85 + this.crr.smoothAmp * 0.15;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Anamorphic streak
        const streakLength = W * 1.2;
        const streakGrad = ctx.createLinearGradient(cx - streakLength/2, cy, cx + streakLength/2, cy);
        const streakAlpha = 0.025 * flareIntensity * crrPulse;
        
        streakGrad.addColorStop(0, 'transparent');
        streakGrad.addColorStop(0.15, `rgba(180, 220, 255, ${streakAlpha * 0.2})`);
        streakGrad.addColorStop(0.35, `rgba(200, 235, 255, ${streakAlpha * 0.6})`);
        streakGrad.addColorStop(0.5, `rgba(230, 245, 255, ${streakAlpha})`);
        streakGrad.addColorStop(0.65, `rgba(200, 235, 255, ${streakAlpha * 0.6})`);
        streakGrad.addColorStop(0.85, `rgba(180, 220, 255, ${streakAlpha * 0.2})`);
        streakGrad.addColorStop(1, 'transparent');
        
        ctx.strokeStyle = streakGrad;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - streakLength/2, cy);
        ctx.lineTo(cx + streakLength/2, cy);
        ctx.stroke();
        
        // Lens ghosts
        const centerX = W * 0.5, centerY = H * 0.5;
        const axisAngle = atan2(centerY - cy, centerX - cx);
        const axisDist = sqrt((centerX - cx) ** 2 + (centerY - cy) ** 2);
        
        const ghosts = [
            { pos: 0.25, size: 0.04, alpha: 0.06, color: [255, 200, 150], sides: 6 },
            { pos: 0.45, size: 0.025, alpha: 0.05, color: [200, 255, 200], sides: 6 },
            { pos: 0.7, size: 0.06, alpha: 0.04, color: [180, 220, 255], sides: 0 },
            { pos: 1.0, size: 0.035, alpha: 0.05, color: [255, 180, 220], sides: 6 },
            { pos: 1.3, size: 0.05, alpha: 0.04, color: [220, 200, 255], sides: 0 },
            { pos: 1.6, size: 0.02, alpha: 0.06, color: [255, 240, 200], sides: 6 },
            { pos: 1.9, size: 0.07, alpha: 0.03, color: [200, 230, 255], sides: 0 }
        ];
        
        for (const ghost of ghosts) {
            const gx = cx + cos(axisAngle) * axisDist * ghost.pos;
            const gy = cy + sin(axisAngle) * axisDist * ghost.pos;
            const gr = H * ghost.size * (0.8 + crrPulse * 0.2);
            const ga = ghost.alpha * flareIntensity * crrPulse;
            
            if (ga < 0.005) continue;
            
            const ghostGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gr);
            const [red, green, blue] = ghost.color;
            ghostGrad.addColorStop(0, `rgba(${red}, ${green}, ${blue}, ${ga})`);
            ghostGrad.addColorStop(0.5, `rgba(${red}, ${green}, ${blue}, ${ga * 0.5})`);
            ghostGrad.addColorStop(0.8, `rgba(${red}, ${green}, ${blue}, ${ga * 0.2})`);
            ghostGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = ghostGrad;
            ctx.beginPath();
            
            if (ghost.sides === 0) {
                ctx.arc(gx, gy, gr, 0, PI2);
            } else {
                for (let i = 0; i <= ghost.sides; i++) {
                    const angle = (i / ghost.sides) * PI2 - PI/2;
                    const px = gx + cos(angle) * gr;
                    const py = gy + sin(angle) * gr;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            }
            ctx.fill();
        }
        
        // Horizon glow
        const horizonY = H * 0.88;
        const glowHeight = H * 0.2;
        const horizonGlowAlpha = 0.06 * flareIntensity * crrPulse;
        
        const horizonGrad = ctx.createLinearGradient(0, horizonY, 0, horizonY - glowHeight);
        horizonGrad.addColorStop(0, `rgba(255, 180, 100, ${horizonGlowAlpha})`);
        horizonGrad.addColorStop(0.4, `rgba(255, 160, 80, ${horizonGlowAlpha * 0.4})`);
        horizonGrad.addColorStop(1, 'transparent');
        
        ctx.fillStyle = horizonGrad;
        ctx.fillRect(0, horizonY - glowHeight, W, glowHeight);
        
        ctx.restore();
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ATMOSPHERE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const atmosphere = {
    crr: new CRR(OMEGA_SO2, 0.08),
    colors: {
        nightTop: {r:8,g:10,b:22}, nightMid: {r:15,g:18,b:35}, nightHor: {r:25,g:22,b:40},
        dawnTop: {r:55,g:45,b:75}, dawnMid: {r:180,g:100,b:70}, dawnHor: {r:255,g:150,b:60},
        dayTop: {r:85,g:130,b:190}, dayMid: {r:150,g:175,b:210}, dayHor: {r:220,g:200,b:180},
        rainTop: {r:60,g:70,b:85}, rainMid: {r:90,g:100,b:115}, rainHor: {r:130,g:135,b:145}
    },
    cur: { top: null, mid: null, hor: null },
    update(dt, sunPhase) {
        this.crr.update(dt, 0.3 + sunPhase * 0.4);
        const t = sunPhase;
        const lc = (a,b,t) => ({r:lerp(a.r,b.r,t),g:lerp(a.g,b.g,t),b:lerp(a.b,b.b,t)});
        
        let baseTop, baseMid, baseHor;
        if (t < 0.3) {
            const p = t/0.3, s = p*p*(3-2*p);
            baseTop = lc(this.colors.nightTop, this.colors.dawnTop, s);
            baseMid = lc(this.colors.nightMid, this.colors.dawnMid, s);
            baseHor = lc(this.colors.nightHor, this.colors.dawnHor, s);
        } else {
            const p = (t-0.3)/0.7, s = p*p*(3-2*p);
            baseTop = lc(this.colors.dawnTop, this.colors.dayTop, s);
            baseMid = lc(this.colors.dawnMid, this.colors.dayMid, s);
            baseHor = lc(this.colors.dawnHor, this.colors.dayHor, s);
        }
        
        const rain = weather.rainIntensity;
        this.cur.top = lc(baseTop, this.colors.rainTop, rain * 0.7);
        this.cur.mid = lc(baseMid, this.colors.rainMid, rain * 0.7);
        this.cur.hor = lc(baseHor, this.colors.rainHor, rain * 0.7);
    },
    draw() {
        const c = this.cur, g = ctx.createLinearGradient(0, 0, 0, H*0.88);
        g.addColorStop(0, `rgb(${c.top.r|0},${c.top.g|0},${c.top.b|0})`);
        g.addColorStop(0.35, `rgb(${c.mid.r|0},${c.mid.g|0},${c.mid.b|0})`);
        g.addColorStop(0.7, `rgb(${c.hor.r|0},${c.hor.g|0},${c.hor.b|0})`);
        g.addColorStop(1, `rgb(${c.hor.r*0.9|0},${c.hor.g*0.85|0},${c.hor.b*0.8|0})`);
        ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRR STARS - Realistic twinkling via atmospheric scintillation modeled with CRR
// Stars twinkle due to turbulent air cells (eddies) causing rapid phase shifts
// Î© varies by apparent brightness and altitude (horizon stars twinkle more)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Star {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        
        // Star properties based on position
        const altitude = 1 - y / (H * 0.7);  // Higher = less twinkling
        const horizonFactor = max(0, 1 - altitude);  // More twinkling near horizon
        
        // Apparent magnitude (brightness) - power law distribution
        const magRand = random();
        this.magnitude = magRand < 0.02 ? 0 :   // 2% very bright
                         magRand < 0.1 ? 1 :    // 8% bright  
                         magRand < 0.3 ? 2 :    // 20% medium
                         magRand < 0.6 ? 3 :    // 30% dim
                         4;                      // 40% very dim
        
        // Size based on magnitude (brighter = larger apparent size)
        this.baseSize = (5 - this.magnitude) * 0.4 + 0.3;
        
        // Color - most stars white/blue-white, some yellow/orange/red
        const colorRand = random();
        if (colorRand < 0.6) {
            // White/blue-white (O, B, A, F stars)
            this.r = 220 + random() * 35;
            this.g = 225 + random() * 30;
            this.b = 255;
        } else if (colorRand < 0.85) {
            // Yellow/white (G stars like Sun)
            this.r = 255;
            this.g = 240 + random() * 15;
            this.b = 200 + random() * 40;
        } else if (colorRand < 0.95) {
            // Orange (K stars)
            this.r = 255;
            this.g = 180 + random() * 50;
            this.b = 120 + random() * 60;
        } else {
            // Red (M stars)
            this.r = 255;
            this.g = 150 + random() * 50;
            this.b = 100 + random() * 50;
        }
        
        // CRR for scintillation (twinkling)
        // Brighter stars and horizon stars have LOWER Î© (more rapid twinkling)
        // This matches reality: brighter stars show more noticeable scintillation
        const baseOmega = 0.15 + random() * 0.1;
        const brightnessBoost = (5 - this.magnitude) * 0.02;
        const horizonBoost = horizonFactor * 0.08;
        this.crr = new CRR(baseOmega - brightnessBoost - horizonBoost, 0.3 + random() * 0.4);
        
        // Phase offset for variety
        this.crr.C = random() * this.crr.omega * 2;
        
        // Proximity grouping - some stars appear in pairs/clusters
        this.hasCompanion = random() < 0.08;
        if (this.hasCompanion) {
            this.companionDx = (random() - 0.5) * 8;
            this.companionDy = (random() - 0.5) * 8;
            this.companionSize = this.baseSize * (0.3 + random() * 0.5);
            this.companionBrightness = 0.3 + random() * 0.5;
        }
    }
    
    update(dt) {
        // Atmospheric coherence input varies slightly
        const atmosphericTurbulence = 0.5 + fsin(time * 0.3 + this.x * 0.01) * 0.3;
        this.crr.update(dt, atmosphericTurbulence);
    }
    
    draw(visibility) {
        if (visibility < 0.01) return;
        
        // CRR-driven brightness oscillation
        // exp(C/Î©) creates the characteristic rapid fluctuations
        const crrFactor = this.crr.smoothAmp;
        const twinkle = 0.5 + crrFactor * 0.5;
        
        // Scintillation also causes color shifts (chromatic)
        const colorShift = (crrFactor - 0.5) * 0.15;
        
        const alpha = visibility * twinkle * (0.6 + (5 - this.magnitude) * 0.1);
        const size = this.baseSize * (0.8 + crrFactor * 0.4);
        
        // Main star
        const r = min(255, this.r + colorShift * 30);
        const g = min(255, this.g - abs(colorShift) * 20);
        const b = min(255, this.b - colorShift * 40);
        
        ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, size, 0, PI2);
        ctx.fill();
        
        // Glow for brighter stars
        if (this.magnitude < 2 && alpha > 0.3) {
            const glowSize = size * (2 + crrFactor);
            const glowAlpha = alpha * 0.15;
            ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${glowAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, glowSize, 0, PI2);
            ctx.fill();
        }
        
        // Companion star
        if (this.hasCompanion) {
            const compAlpha = alpha * this.companionBrightness;
            ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${compAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x + this.companionDx, this.y + this.companionDy, this.companionSize, 0, PI2);
            ctx.fill();
        }
    }
}

const starField = {
    stars: [],
    
    init() {
        this.stars = [];
        
        // Create realistic star distribution
        // More stars toward zenith, sparser near horizon
        // Clustered in "milky way" band
        const STAR_COUNT = 200;
        
        for (let i = 0; i < STAR_COUNT; i++) {
            let x, y;
            
            // 30% chance of being in "milky way" band (diagonal across sky)
            if (random() < 0.3) {
                const t = random();
                x = W * (0.1 + t * 0.8);
                y = H * (0.05 + (1 - t) * 0.35 + (random() - 0.5) * 0.15);
            } else {
                // Random distribution with altitude weighting
                x = random() * W;
                const altitudeWeight = random() * random();  // Bias toward zenith
                y = H * (0.02 + altitudeWeight * 0.55);
            }
            
            this.stars.push(new Star(x, y));
        }
    },
    
    update(dt) {
        for (const star of this.stars) {
            star.update(dt);
        }
    },
    
    draw() {
        // Stars only visible at night
        const nightness = 1 - sunrise.phase;
        if (nightness < 0.3) return;
        
        // Visibility affected by clouds and rain
        const cloudDim = 1 - weather.rainIntensity * 0.8;
        const visibility = max(0, (nightness - 0.3) / 0.7) * cloudDim;
        
        if (visibility < 0.01) return;
        
        for (const star of this.stars) {
            star.draw(visibility);
        }
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRR AURORA BOREALIS - Subtle northern lights with CRR-driven curtains
// Aurora caused by charged particles interacting with atmosphere
// Each curtain has its own CRR cycle (SO(2) - continuous wave motion)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const aurora = {
    curtains: [],
    
    init() {
        this.curtains = [];
        const NUM_CURTAINS = 5;
        
        for (let i = 0; i < NUM_CURTAINS; i++) {
            this.curtains.push({
                x: 0.1 + (i / NUM_CURTAINS) * 0.7,
                width: 0.08 + random() * 0.12,
                height: 0.15 + random() * 0.2,
                // CRR for wave motion
                crr: new CRR(OMEGA_SO2 * (0.8 + random() * 0.4), 0.3 + random() * 0.3),
                phase: random() * PI2,
                waveSpeed: 0.3 + random() * 0.4,
                // Color varies along curtain
                hue: 120 + random() * 40,  // Green to cyan
                intensity: 0.3 + random() * 0.4
            });
        }
    },
    
    update(dt) {
        for (const c of this.curtains) {
            c.crr.update(dt, 0.4 + fsin(time * 0.1 + c.phase) * 0.2);
            c.phase += c.waveSpeed * dt;
            
            // CRR ruptures cause intensity pulses
            if (c.crr.st === 1) {
                c.intensity = min(0.8, c.intensity + 0.2);
            } else {
                c.intensity = max(0.2, c.intensity - dt * 0.1);
            }
        }
    },
    
    draw() {
        const nightness = 1 - sunrise.phase;
        if (nightness < 0.6) return;  // Only show when very dark
        
        const visibility = max(0, (nightness - 0.6) / 0.4) * 0.15;  // Much more subtle
        if (visibility < 0.005) return;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        for (const c of this.curtains) {
            const baseX = W * c.x;
            const baseY = H * 0.01;
            const curtainH = H * c.height * 0.7;  // Shorter
            const curtainW = W * c.width * 0.7;   // Narrower
            
            // Draw curtain as vertical gradient with wave
            for (let i = 0; i < 15; i++) {  // Fewer segments
                const t = i / 15;
                const y = baseY + curtainH * t;
                
                // Wave motion driven by CRR
                const wave = fsin(c.phase + t * 3 + c.crr.smoothAmp * 2) * curtainW * 0.2;
                const x = baseX + wave;
                
                // Color shifts along height (green at top, fading to transparent)
                const hue = c.hue - t * 20;
                const sat = 40 + t * 15;  // Less saturated
                const light = 40 + (1 - t) * 25;  // Dimmer
                
                // Intensity varies with CRR - much lower alpha
                const alpha = visibility * c.intensity * (1 - t * 0.8) * (0.5 + c.crr.smoothAmp * 0.2);
                
                if (alpha > 0.003) {
                    const grad = ctx.createLinearGradient(x - curtainW/2, y, x + curtainW/2, y);
                    grad.addColorStop(0, 'transparent');
                    grad.addColorStop(0.35, `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.3})`);
                    grad.addColorStop(0.5, `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.6})`);
                    grad.addColorStop(0.65, `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.3})`);
                    grad.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = grad;
                    ctx.fillRect(x - curtainW, y, curtainW * 2, curtainH / 15 + 1);
                }
            }
        }
        
        ctx.restore();
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HYPERREAL STAR (SIRIUS) - Interactive zoom to full CRR star simulation
// One special star that reveals the full stellar CRR dynamics on hover/click
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const siriusStar = {
    x: 0,
    y: 0,
    baseSize: 2.5,
    crr: new CRR(0.12, 0.4),
    hovered: false,
    zoomLevel: 0,
    targetZoom: 0,
    showingDetail: false,
    
    // Stellar physics - 9,940 K A1V star
    SIRIUS: { r: 202, g: 218, b: 255 },
    
    // CRR-driven structures
    granulationCells: [],
    magneticLoops: [],
    prominences: [],
    scintillationPhase: 0,
    
    init() {
        this.x = W * 0.28;
        this.y = H * 0.18;
        this.scintillationPhase = random() * PI2;
        
        // Granulation cells - SO(2) CRR convective dynamics
        this.granulationCells = [];
        for (let i = 0; i < 60; i++) {
            this.granulationCells.push({
                angle: random() * PI2,
                radius: random(),
                size: 0.025 + random() * 0.04,
                lifePhase: random() * PI2,
                speed: 0.0001 + random() * 0.0002,
                crr: new CRR(OMEGA_SO2 * (0.8 + random() * 0.4), 0.3)
            });
        }
        
        // Magnetic loops - SO(2) coronal CRR
        this.magneticLoops = [];
        for (let i = 0; i < 6; i++) {
            this.magneticLoops.push({
                angle: (i / 6) * PI2 + random() * 0.3,
                height: 0.04 + random() * 0.1,
                width: 0.08 + random() * 0.12,
                crr: new CRR(OMEGA_SO2, 0.25),
                opacity: 0.1 + random() * 0.2
            });
        }
        
        // Prominences - Zâ‚‚ binary state (quiescent/active)
        this.prominences = [];
        for (let i = 0; i < 3; i++) {
            this.prominences.push({
                angle: (i / 3) * PI2 + random() * 0.5,
                maxHeight: 0.05 + random() * 0.08,
                width: 0.012 + random() * 0.015,
                curvature: (random() - 0.5) * 0.25,
                crr: new CRR(OMEGA_Z2, 0.4),
                active: random() > 0.6,
                height: 0
            });
        }
    },
    
    update(dt, mouseX, mouseY) {
        this.crr.update(dt, 0.5);
        
        // Always use dynamic position based on current canvas size
        this.x = W * 0.28;
        this.y = H * 0.18;
        
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        // Larger hover area as star grows when zoomed
        const hoverRadius = 60 + this.zoomLevel * 80;
        this.hovered = sqrt(dx*dx + dy*dy) < hoverRadius;
        
        // Directly set zoom - no lerp to prevent "pulling back"
        this.zoomLevel = this.targetZoom;
        
        // Update granulation
        for (const cell of this.granulationCells) {
            cell.crr.update(dt, 0.5);
            cell.angle += cell.speed * (1 + cell.crr.smoothAmp * 0.5);
            cell.lifePhase += 0.003;
        }
        
        // Update magnetic loops
        for (const loop of this.magneticLoops) {
            loop.crr.update(dt, 0.4);
            if (loop.crr.st === 1) {
                loop.opacity = min(0.6, loop.opacity + 0.2);
            } else {
                loop.opacity = max(0.1, loop.opacity - dt * 0.1);
            }
        }
        
        // Update prominences - Zâ‚‚ state transitions
        for (const prom of this.prominences) {
            prom.crr.update(dt, 0.6);
            if (prom.crr.st === 1 && random() < 0.3) {
                prom.active = !prom.active;
            }
            const targetH = prom.active ? prom.maxHeight : prom.maxHeight * 0.15;
            prom.height = lerp(prom.height, targetH, dt * (prom.active ? 0.8 : 0.3));
        }
    },
    
    // Handle scroll wheel zoom with delta value
    onScrollDelta(delta, mx, my) {
        // Check if visible (nighttime only)
        const nightness = 1 - sunrise.phase;
        if (nightness < 0.4) return false;
        
        // Calculate position dynamically (in case of resize)
        const starX = W * 0.28;
        const starY = H * 0.18;
        
        // Check hover directly with passed mouse coordinates
        const dx = mx - starX;
        const dy = my - starY;
        const dist = sqrt(dx*dx + dy*dy);
        // Very generous hit radius - 150px base plus more when zoomed
        const hitRadius = 150 + this.targetZoom * 200;
        const isHovered = dist < hitRadius;
        
        if (isHovered) {
            // Apply delta directly to zoom
            this.targetZoom = max(0, min(1, this.targetZoom + delta));
            this.zoomLevel = this.targetZoom;
            return true;  // Consumed the scroll
        }
        return false;
    },
    
    computeScintillation(t) {
        const f1 = 318, f2 = 159, f3 = 50;
        const sigmaI = 0.15 * (1 - this.zoomLevel * 0.9);
        const variation = 
            0.4 * fsin(f1 * t * 0.01 + this.scintillationPhase) +
            0.3 * fsin(f2 * t * 0.01 + this.scintillationPhase * 1.3) +
            0.3 * fsin(f3 * t * 0.01 + this.scintillationPhase * 0.7);
        return 1.0 + sigmaI * variation;
    },
    
    draw() {
        const nightness = 1 - sunrise.phase;
        if (nightness < 0.4) return;
        
        const visibility = max(0, (nightness - 0.4) / 0.6);
        if (visibility < 0.01) return;
        
        const brightness = this.computeScintillation(time) * visibility;
        const crrPulse = 0.8 + this.crr.smoothAmp * 0.4;
        // Size increases dramatically with zoom - up to 120px radius at full zoom
        const size = this.baseSize * (1 + this.zoomLevel * 50) * crrPulse;
        const rgb = this.SIRIUS;
        
        ctx.save();
        
        if (this.zoomLevel < 0.35) {
            // DISTANT VIEW - Point star with scintillation
            const glowSize = size * (4 + this.zoomLevel * 12);
            const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
            glow.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${brightness * 0.3})`);
            glow.addColorStop(0.3, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${brightness * 0.15})`);
            glow.addColorStop(0.6, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${brightness * 0.05})`);
            glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(this.x, this.y, glowSize, 0, PI2);
            ctx.fill();
            
            ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size, 0, PI2);
            ctx.fill();
            
            // Diffraction spikes
            if (this.zoomLevel < 0.15) {
                ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${brightness * 0.25})`;
                ctx.lineWidth = 0.5;
                for (let a = 0; a < 4; a++) {
                    const angle = a * PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + cos(angle) * size * 10, this.y + sin(angle) * size * 10);
                    ctx.stroke();
                }
            }
            
        } else {
            // ZOOMED VIEW - Full stellar disk
            
            // Corona + magnetic loops
            if (this.zoomLevel > 0.5) {
                const coronaGrad = ctx.createRadialGradient(this.x, this.y, size * 0.98, this.x, this.y, size * 1.35);
                coronaGrad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${0.1 * brightness})`);
                coronaGrad.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${0.04 * brightness})`);
                coronaGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = coronaGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 1.35, 0, PI2);
                ctx.fill();
                
                // Magnetic loops
                for (const loop of this.magneticLoops) {
                    const h = loop.height * size;
                    const foot1X = this.x + cos(loop.angle - loop.width/2) * size;
                    const foot1Y = this.y + sin(loop.angle - loop.width/2) * size;
                    const foot2X = this.x + cos(loop.angle + loop.width/2) * size;
                    const foot2Y = this.y + sin(loop.angle + loop.width/2) * size;
                    const apexX = this.x + cos(loop.angle) * (size + h);
                    const apexY = this.y + sin(loop.angle) * (size + h);
                    
                    ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${loop.opacity * brightness * 0.4})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(foot1X, foot1Y);
                    ctx.quadraticCurveTo(apexX, apexY, foot2X, foot2Y);
                    ctx.stroke();
                }
            }
            
            // Chromosphere (H-alpha pink)
            if (this.zoomLevel > 0.45) {
                const chromoInt = min(1, (this.zoomLevel - 0.45) * 3);
                const chromoGrad = ctx.createRadialGradient(this.x, this.y, size * 0.93, this.x, this.y, size * 1.02);
                chromoGrad.addColorStop(0, 'transparent');
                chromoGrad.addColorStop(0.4, `rgba(255, 140, 170, ${0.08 * chromoInt * brightness})`);
                chromoGrad.addColorStop(0.7, `rgba(255, 110, 150, ${0.1 * chromoInt * brightness})`);
                chromoGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = chromoGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 1.02, 0, PI2);
                ctx.fill();
            }
            
            // Stellar disk with limb darkening
            const diskGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);
            diskGrad.addColorStop(0, `rgba(255, 255, 255, ${brightness})`);
            diskGrad.addColorStop(0.1, `rgba(255, 252, 255, ${brightness})`);
            diskGrad.addColorStop(0.3, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${brightness})`);
            diskGrad.addColorStop(0.6, `rgba(${rgb.r * 0.9 | 0}, ${rgb.g * 0.92 | 0}, ${rgb.b}, ${brightness})`);
            diskGrad.addColorStop(0.85, `rgba(${rgb.r * 0.7 | 0}, ${rgb.g * 0.75 | 0}, ${rgb.b * 0.85 | 0}, ${brightness})`);
            diskGrad.addColorStop(0.95, `rgba(${rgb.r * 0.4 | 0}, ${rgb.g * 0.5 | 0}, ${rgb.b * 0.7 | 0}, ${brightness * 0.7})`);
            diskGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = diskGrad;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size, 0, PI2);
            ctx.fill();
            
            // Granulation
            if (this.zoomLevel > 0.6) {
                const granInt = min(1, (this.zoomLevel - 0.6) * 2.5);
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 0.95, 0, PI2);
                ctx.clip();
                
                for (const cell of this.granulationCells) {
                    const lifeBright = 0.5 + 0.5 * fsin(cell.lifePhase);
                    const cellDist = cell.radius * size * 0.88;
                    const cellX = this.x + cos(cell.angle) * cellDist;
                    const cellY = this.y + sin(cell.angle) * cellDist;
                    const cellR = cell.size * size;
                    
                    const alpha = 0.1 * granInt * lifeBright * brightness;
                    const cellGrad = ctx.createRadialGradient(cellX, cellY, 0, cellX, cellY, cellR);
                    cellGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    cellGrad.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha * 0.4})`);
                    cellGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = cellGrad;
                    ctx.beginPath();
                    ctx.arc(cellX, cellY, cellR, 0, PI2);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            // Prominences
            if (this.zoomLevel > 0.7) {
                const promInt = min(1, (this.zoomLevel - 0.7) * 3);
                for (const prom of this.prominences) {
                    if (prom.height < 0.005) continue;
                    const h = prom.height * size;
                    const w = prom.width * size;
                    const baseX = this.x + cos(prom.angle) * size * 0.99;
                    const baseY = this.y + sin(prom.angle) * size * 0.99;
                    const apexAngle = prom.angle + prom.curvature;
                    const apexX = this.x + cos(apexAngle) * (size + h);
                    const apexY = this.y + sin(apexAngle) * (size + h);
                    
                    const alpha = (prom.active ? 0.5 : 0.2) * promInt * brightness;
                    ctx.strokeStyle = `rgba(255, 100, 130, ${alpha})`;
                    ctx.lineWidth = w;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    ctx.quadraticCurveTo(apexX, apexY, baseX + w, baseY);
                    ctx.stroke();
                }
            }
        }
        
        // Zoom indicator - only show when not zoomed much
        if (visibility > 0.5 && this.zoomLevel < 0.3) {
            const circleR = 32 + this.zoomLevel * 30;
            const circleAlpha = (0.3 - this.zoomLevel) / 0.3;  // Fade out as zoom increases
            
            ctx.strokeStyle = `rgba(150, 180, 255, ${visibility * 0.4 * circleAlpha * (this.hovered ? 1 : 0.5)})`;
            ctx.lineWidth = this.hovered ? 1.5 : 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, circleR, 0, PI2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.font = '9px monospace';
            const labelX = this.x + circleR + 8;
            ctx.fillStyle = `rgba(150, 180, 255, ${visibility * 0.6 * circleAlpha * (this.hovered ? 1 : 0.6)})`;
            ctx.fillText('SIRIUS A', labelX, this.y - 8);
            ctx.fillStyle = `rgba(120, 150, 220, ${visibility * 0.5 * circleAlpha * (this.hovered ? 1 : 0.5)})`;
            
            // Detect touch device
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            if (this.hovered) {
                ctx.fillText(isTouchDevice ? 'âŠ• pinch to zoom' : 'âŠ• scroll to zoom', labelX, this.y + 4);
            } else {
                ctx.fillText(isTouchDevice ? 'â— tap + pinch' : 'â— hover + scroll', labelX, this.y + 4);
            }
        }
        
        ctx.restore();
    },
    
    onClick() {
        if (this.hovered) {
            // Toggle between full zoom and no zoom
            if (this.targetZoom > 0.5) {
                this.targetZoom = 0;
            } else {
                this.targetZoom = 1;
            }
            return true;
        }
        return false;
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLOUDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const clouds = [];

function initClouds() {
    clouds.length = 0;
    
    const cloudConfigs = [
        { x: 0.15, y: 0.10, scale: 0.12 },
        { x: 0.45, y: 0.06, scale: 0.09 },
        { x: 0.72, y: 0.12, scale: 0.14 },
        { x: 0.30, y: 0.17, scale: 0.07 },
        { x: 0.88, y: 0.14, scale: 0.08 }
    ];
    
    for (const cfg of cloudConfigs) {
        const pts = [];
        const numPts = 8;
        for (let i = 0; i < numPts; i++) {
            const a = (i / numPts) * PI2;
            const r = 0.4 + random() * 0.3;
            pts.push({ x: cos(a) * r, y: sin(a) * r * 0.4 });
        }
        
        clouds.push({
            x: cfg.x,
            y: cfg.y,
            scale: cfg.scale,
            pts: pts,
            speed: 0.00003 + random() * 0.00003,
            baseOpacity: 0.15 + random() * 0.1,
            curOpacity: 0
        });
    }
}

function updateClouds(dt) {
    for (const c of clouds) {
        c.x += c.speed * dt * 50;
        if (c.x > 1.25) c.x = -0.25;
        
        const rainFactor = 1 + weather.rainIntensity * 1.2;
        c.curOpacity = c.baseOpacity * (0.5 + sunrise.phase * 0.5) * rainFactor;
    }
}

function drawClouds() {
    for (const c of clouds) {
        if (c.curOpacity < 0.02) continue;
        
        ctx.save();
        ctx.translate(W * c.x, H * c.y);
        ctx.scale(W * c.scale, W * c.scale);
        
        ctx.beginPath();
        ctx.moveTo(c.pts[0].x, c.pts[0].y);
        for (let i = 1; i <= c.pts.length; i++) {
            const p = c.pts[i - 1];
            const q = c.pts[i % c.pts.length];
            ctx.quadraticCurveTo(p.x, p.y, (p.x + q.x) / 2, (p.y + q.y) / 2);
        }
        ctx.closePath();
        
        const rainGrey = weather.rainIntensity;
        const r = lerp(lerp(200, 255, sunrise.phase), 90, rainGrey);
        const g = lerp(lerp(180, 250, sunrise.phase), 95, rainGrey);
        const b = lerp(lerp(190, 255, sunrise.phase), 110, rainGrey);
        
        ctx.fillStyle = `rgba(${r|0}, ${g|0}, ${b|0}, ${c.curOpacity})`;
        ctx.fill();
        
        ctx.restore();
    }
}

// Tree
class Tree {
    constructor(bx,by,h) {
        this.bx=bx; this.by=by; this.h=h; this.crr=new CRR(1.5,0.03);
        this.branches=[]; this.perches=[]; this.sway=0;
        this.generate(); this.byDepth={};
        for (const b of this.branches) (this.byDepth[b.d]||(this.byDepth[b.d]=[])).push(b);
    }
    generate() {
        const add = (x1,y1,x2,y2,d,maxD) => {
            if (d > maxD) return;
            const mx=(x1+x2)/2+(random()-0.5)*this.h*0.016, my=(y1+y2)/2+(random()-0.5)*this.h*0.016;
            this.branches.push({x1,y1,cx:mx,cy:my,x2,y2,d,w:max(1.2,4.5*pow(0.68,d)),phase:random()*PI2,sw:0,tsw:0});
            
            if (d >= 1 && d <= 6 && abs(atan2(y2-y1,x2-x1)+PI/2) > 0.2) {
                for (let t = 0.2; t <= 0.85; t += 0.15) {
                    const mt = 1-t;
                    const px = mt*mt*x1 + 2*mt*t*mx + t*t*x2;
                    const py = mt*mt*y1 + 2*mt*t*my + t*t*y2;
                    this.perches.push({ x: px + (random()-0.5) * 3, y: py + (random()-0.5) * 2, occ: false });
                }
            }
            
            if (d < maxD) { 
                const n = 2 + floor(random()*2);
                const len = sqrt((x2-x1)**2+(y2-y1)**2) * (0.55+random()*0.18);
                const base = atan2(y2-y1, x2-x1);
                for (let i = 0; i < n; i++) { 
                    const a = base + (random()-0.5)*1.2; 
                    add(x2, y2, x2+cos(a)*len, y2+sin(a)*len, d+1, maxD); 
                }
            }
        };
        
        [[-0.16,0.46],[0,0.54],[0.16,0.46]].forEach(([ao,lm])=>{
            const a=-PI/2+ao;
            add(this.bx,this.by,this.bx+cos(a)*this.h*lm,this.by+sin(a)*this.h*lm,0,7);
        });
        
        for (let i=0;i<8;i++) { 
            const by=this.by-this.h*(0.08+i*0.11);
            const side=i%2===0?-1:1;
            const bl=this.h*(0.1+random()*0.12);
            const a=-PI/2+side*(0.3+random()*0.6); 
            add(this.bx,by,this.bx+cos(a)*bl,by+sin(a)*bl,1,6); 
        }
    }
    
    update(dt,wind) {
        const rainWind = 1 + weather.rainIntensity * 2.5;
        const ambientBreeze = fsin(time * 0.15) * 0.4 + 0.5;
        this.crr.update(dt, 0.08 + wind * 0.15 * rainWind);
        const gustStrength = this.crr.smoothAmp * 0.6;
        const totalWind = (ambientBreeze + gustStrength) * wind * rainWind;
        
        const slowSway = fsin(time * 0.2) * 0.003;
        const medSway = fsin(time * 0.45 + 1) * 0.002;
        const fastSway = fsin(time * 0.9 + 2) * 0.001;
        this.sway = lerp(this.sway, (slowSway + medSway + fastSway) * totalWind, min(1, dt * 2.5));
        
        for (const b of this.branches) {
            const depthFactor = (7 - b.d) / 7;
            const wave1 = fsin(time * 0.35 + b.phase) * 0.005;
            const wave2 = fsin(time * 0.7 + b.phase * 1.3 + b.d * 0.4) * 0.003;
            const wave3 = fsin(time * 1.2 + b.phase * 0.7) * 0.0015 * depthFactor;
            const gustEffect = gustStrength * depthFactor * 0.004;
            
            b.tsw = (wave1 + wave2 + wave3 + gustEffect) * depthFactor * totalWind;
            b.sw = lerp(b.sw, b.tsw, min(1, dt * (4 + b.d * 0.5)));
        }
    }
    
    draw() {
        ctx.lineCap='round';
        for (const d in this.byDepth) {
            const bs=this.byDepth[d],fade=pow(0.68,d),w=max(1.2,4.5*fade);
            ctx.strokeStyle=`rgba(12,10,8,${0.6*fade})`; ctx.lineWidth=w*3.5; ctx.beginPath();
            for (const b of bs) { const sw=b.sw+this.sway; ctx.moveTo(b.x1,b.y1); ctx.quadraticCurveTo(b.cx+sw*40,b.cy,b.x2+sw*80,b.y2); }
            ctx.stroke();
            ctx.strokeStyle=`rgba(18,15,12,${0.85*fade})`; ctx.lineWidth=w; ctx.beginPath();
            for (const b of bs) { const sw=b.sw+this.sway; ctx.moveTo(b.x1,b.y1); ctx.quadraticCurveTo(b.cx+sw*40,b.cy,b.x2+sw*80,b.y2); }
            ctx.stroke();
        }
        ctx.strokeStyle='rgba(10,8,6,0.95)'; ctx.lineWidth=18; ctx.beginPath();
        ctx.moveTo(this.bx,this.by+15); ctx.quadraticCurveTo(this.bx+this.sway*20,this.by-this.h*0.07,this.bx+this.sway*40,this.by-this.h*0.14); ctx.stroke();
    }
}

// Grass
class Grass {
    constructor(gy,W,H) { this.gy=gy; this.W=W; this.H=H; this.crr=new CRR(0.28,0.3); this.phase=0; this.stems=[]; this.generate(); }
    generate() {
        const treeX=this.W*0.82;
        for (let i=0;i<150;i++) {
            const x=(i/150)*this.W*1.1-this.W*0.05;
            if (abs(x-treeX)<this.W*0.08) continue;
            const h=this.H*(0.022+random()*0.048),lean=(random()-0.5)*0.35;
            this.stems.push({x:x+(random()-0.5)*6,h,lean,seed:random()>0.35,stype:floor(random()*3),phase:random()*PI2,omega:0.08+random()*0.12,sway:0,tsway:0});
            if (random()>0.45) this.stems.push({x:x+(random()-0.5)*10,h:h*(0.45+random()*0.4),lean:lean+(random()-0.5)*0.25,seed:random()>0.55,stype:floor(random()*3),phase:random()*PI2,omega:0.1+random()*0.1,sway:0,tsway:0});
        }
    }
    update(dt) {
        const rainWind = 1 + weather.rainIntensity * 1.5;
        this.crr.update(dt,0.4+fsin(time*0.12)*0.15);
        this.phase=this.crr.C*2.2;
        for (const s of this.stems) { 
            const wInf=fsin(s.x/this.W*9-this.phase)*0.5+0.5; 
            s.tsway=fsin(time*0.9+s.phase+this.phase*0.4)*0.01*wInf/(s.omega*5)*rainWind; 
            s.sway=lerp(s.sway,s.tsway,min(1,dt*5)); 
        }
    }
    draw() {
        ctx.fillStyle='#080808'; ctx.beginPath(); ctx.moveTo(0,this.gy);
        for (let x=0;x<=this.W;x+=15) ctx.lineTo(x,this.gy-fsin(x*0.01+this.phase*0.15)*2.5-1);
        ctx.lineTo(this.W,this.H); ctx.lineTo(0,this.H); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='#0a0a0a'; ctx.fillStyle='#0a0a0a'; ctx.lineCap='round';
        for (const s of this.stems) {
            const tipX=s.x+s.lean*s.h+s.sway*this.W,tipY=this.gy-s.h,ctrlX=s.x+s.lean*s.h*0.5+s.sway*this.W*0.6,ctrlY=(this.gy+tipY)/2;
            ctx.lineWidth=s.seed?1.1:0.7; ctx.beginPath(); ctx.moveTo(s.x,this.gy); ctx.quadraticCurveTo(ctrlX,ctrlY,tipX,tipY); ctx.stroke();
            if (s.seed) { ctx.save(); ctx.translate(tipX,tipY); ctx.rotate(atan2(tipY-ctrlY,tipX-ctrlX)+PI/2);
                if (s.stype===0) { ctx.beginPath(); ctx.ellipse(0,-3.5,1.8,5,0,0,PI2); ctx.fill(); }
                else if (s.stype===1) { ctx.beginPath(); ctx.ellipse(0,-7,2.2,8.5,0,0,PI2); ctx.fill(); }
                ctx.restore();
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREDATOR - Peregrine Falcon
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Predator {
    constructor(x,y) {
        this.x=x; this.y=y; this.vx=15; this.vy=0;
        this.crr = new CRR(0.4, 0.12);
        this.huntCRR = new CRR(0.4, 0.08);
        this.feedCRR = new CRR(0.6, 0.05);
        this.target = null;
        this.huntPhase = 0;
        this.baseSize = 3.5;
        this.size = this.baseSize;
        this.wingSpan = 12;
        this.wingPhase = random()*PI2;
        this.patrolX = x; this.patrolY = y; this.patrolR = 200;
        this.bank = 0;
        this.groundY = 0;
        this.feedTimer = 0;
        this.peckPhase = 0;
        this.lastFlightY = y;
        this.flightTimer = 0;
    }
    
    update(dt, birds, flock, grassY, tree) {
        this.crr.update(dt, 0.5);
        this.wingPhase += 4 * dt * (0.5 + this.crr.smoothAmp * 0.3);
        
        const perspectiveScale = 1 + 0.4 * (this.y / H);
        this.size = this.baseSize * perspectiveScale;
        
        let nearD = Infinity, nearB = null;
        let flyingCount = 0;
        let perchedCount = 0;
        
        for (const b of birds) {
            if (b.st === 0) {
                flyingCount++;
                const d = sqrt((b.x-this.x)**2+(b.y-this.y)**2);
                if (d < nearD) { nearD = d; nearB = b; }
            } else if (b.st === 2) {
                perchedCount++;
            }
        }
        
        if (this.huntPhase < 4) {
            this.flightTimer += dt;
        }
        const tiredEnoughToFeed = this.flightTimer > 15;
        const heavyRain = weather.rainIntensity > 0.6;
        const isNightTime = sunrise.isNight || (sunrise.cyclePhase && sunrise.cyclePhase > 0.85);
        
        if (this.huntPhase === 0) {
            this.huntCRR.update(dt, 0.3);
            
            // Falcon doesn't hunt at night - just patrol/rest
            
            const pa = time * 0.3;
            const tx = this.patrolX + cos(pa) * this.patrolR;
            const ty = this.patrolY + sin(pa) * this.patrolR * 0.4;
            this.vx = lerp(this.vx, (tx-this.x)*0.5, dt*2);
            this.vy = lerp(this.vy, (ty-this.y)*0.5, dt*2);
            
            if (tiredEnoughToFeed || heavyRain || isNightTime) {
                this.huntPhase = 4;
                this.groundY = grassY - 8;
                this.lastFlightY = this.y;
            } else if (nearB && nearD < 400 && this.huntCRR.C > this.huntCRR.omega * 0.3) {
                this.huntPhase = 1; this.target = nearB;
            }
        } else if (this.huntPhase === 1) {
            if (tiredEnoughToFeed || heavyRain || isNightTime) {
                this.huntPhase = 4;
                this.groundY = grassY - 8;
                this.lastFlightY = this.y;
                this.target = null;
            } else {
                this.huntCRR.update(dt, 1.5);
                if (this.target && this.target.st === 0) {
                    const dx=this.target.x-this.x, dy=this.target.y-this.y, d=sqrt(dx*dx+dy*dy);
                    const circleOff = (1 - this.huntCRR.smoothAmp) * 0.8;
                    const angle = atan2(dy,dx) + sin(time*3) * circleOff;
                    const spd = 40 + this.huntCRR.smoothAmp * 30;
                    this.vx = lerp(this.vx, cos(angle)*spd, dt*3);
                    this.vy = lerp(this.vy, sin(angle)*spd, dt*3);
                    if (d < 150) flock.rupture();
                    if (this.huntCRR.st === 1) this.huntPhase = 2;
                    if (d > 500) { this.huntPhase = 0; this.target = null; }
                } else { this.huntPhase = 0; this.target = null; }
            }
        } else if (this.huntPhase === 2) {
            this.huntCRR.update(dt, 0.3);
            if (this.target) {
                const dx=this.target.x-this.x, dy=this.target.y-this.y, d=sqrt(dx*dx+dy*dy);
                const diveSpd = 120 + this.huntCRR.smoothAmp * 60;
                const angle = atan2(dy,dx);
                this.vx = cos(angle) * diveSpd;
                this.vy = sin(angle) * diveSpd;
                if (d < 25) {
                    this.target.crr.rupture();
                    this.target.vx += (random()-0.5)*100;
                    this.target.vy -= 50+random()*30;
                    this.huntPhase = 3;
                }
                if (this.huntCRR.st === 2 && this.huntCRR.smoothAmp < 0.5) this.huntPhase = 3;
            } else this.huntPhase = 3;
        } else if (this.huntPhase === 3) {
            this.huntCRR.update(dt, 0.3);
            this.vx *= 0.98;
            this.vy = lerp(this.vy, -5, dt);
            if (this.huntCRR.st === 0) {
                this.huntPhase = 0; this.target = null;
                this.patrolX = lerp(this.patrolX, this.x, 0.3);
                this.patrolY = lerp(this.patrolY, this.y, 0.3);
            }
        } else if (this.huntPhase === 4) {
            this.vx = lerp(this.vx, 15, dt * 2);
            this.vy = lerp(this.vy, 25, dt * 2);
            
            if (this.y >= this.groundY - 5) {
                this.y = this.groundY;
                this.vx = 0; this.vy = 0;
                this.huntPhase = 5;
                this.feedCRR.C = 0; this.feedCRR.st = 0;
                this.feedTimer = 0;
            }
        } else if (this.huntPhase === 5) {
            this.feedCRR.update(dt, 0.8);
            this.feedTimer += dt;
            this.peckPhase += dt * 4;
            
            this.vx = 0; this.vy = 0;
            this.y = this.groundY;
            this.x += sin(this.peckPhase * 0.5) * 0.3;
            
            if (nearD < 200) {
                this.huntPhase = 6;
                flock.rupture();
            }
            
            const feedDuration = heavyRain ? 8 : 3;
            if (this.feedCRR.st === 0 && this.feedTimer > feedDuration) {
                this.huntPhase = 6;
                flock.rupture();
            }
        } else if (this.huntPhase === 6) {
            this.vy = lerp(this.vy, -40, dt * 3);
            this.vx = lerp(this.vx, 20 + random() * 10, dt * 2);
            
            if (this.y < this.lastFlightY + 50) {
                this.flightTimer = 0;
                if (nearB && flyingCount > 0 && !heavyRain) {
                    this.huntPhase = 1;
                    this.target = nearB;
                    this.huntCRR.C = this.huntCRR.omega * 0.5;
                } else {
                    this.huntPhase = 0;
                }
                this.huntCRR.st = 0;
                this.patrolX = this.x;
                this.patrolY = this.y;
            }
        }
        
        if (this.huntPhase !== 5) {
            this.x += this.vx * dt; 
            this.y += this.vy * dt;
        }
        
        if (this.huntPhase < 4 || this.huntPhase === 6) {
            if (this.x < W*0.05) this.vx += 30*dt;
            if (this.x > W*0.95) this.vx -= 30*dt;
            if (this.y < H*0.08) this.vy += 20*dt;
            if (this.y > H*0.65) this.vy -= 20*dt;
        }
        
        this.bank = lerp(this.bank, clamp(this.vx*0.02,-0.6,0.6), dt*4);
        const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
        if (spd > 180) { this.vx=this.vx/spd*180; this.vy=this.vy/spd*180; }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.huntPhase === 5) {
            const feedSize = this.size * 1.1;
            const peck = sin(this.peckPhase * 3) * 0.15;
            const headDip = max(0, sin(this.peckPhase * 3)) * 4;
            
            ctx.fillStyle = 'rgba(12,10,15,0.94)';
            
            ctx.beginPath();
            ctx.ellipse(0, 0, feedSize * 1.8, feedSize * 0.7, peck * 0.2, 0, PI2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(-feedSize * 0.3, -feedSize * 0.2, feedSize * 1.2, feedSize * 0.5, 0.1, 0, PI2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-feedSize * 1.5, 0);
            ctx.lineTo(-feedSize * 2.5, -feedSize * 0.5);
            ctx.lineTo(-feedSize * 2.8, 0);
            ctx.lineTo(-feedSize * 2.5, feedSize * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(12,10,15,0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-feedSize * 0.3, feedSize * 0.5);
            ctx.lineTo(-feedSize * 0.4, feedSize * 1.2);
            ctx.moveTo(feedSize * 0.3, feedSize * 0.5);
            ctx.lineTo(feedSize * 0.2, feedSize * 1.2);
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(12,10,15,0.94)';
            ctx.beginPath();
            ctx.arc(feedSize * 1.2, headDip * 0.5, feedSize * 0.45, 0, PI2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(feedSize * 1.5, headDip * 0.5);
            ctx.lineTo(feedSize * 1.9, headDip + feedSize * 0.3);
            ctx.lineTo(feedSize * 1.5, headDip * 0.5 + feedSize * 0.15);
            ctx.closePath();
            ctx.fill();
            
        } else {
            ctx.rotate(atan2(this.vy, this.vx));
            ctx.scale(1, 1-abs(this.bank)*0.3);
            
            const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
            const stretch = min(spd/60, 1.8);
            const flapInt = this.huntPhase === 2 ? 0.1 : (this.huntPhase === 6 ? 0.6 : 0.4);
            const flap = fsin(this.wingPhase) * flapInt * (1-this.huntCRR.smoothAmp*0.5);
            
            ctx.fillStyle = 'rgba(15,12,18,0.92)';
            
            ctx.beginPath(); 
            ctx.ellipse(0, 0, this.size*stretch*1.2, this.size*0.5, 0, 0, PI2); 
            ctx.fill();
            
            const ws = this.wingSpan * (this.size / this.baseSize);
            const sweep = 0.3 + this.huntCRR.smoothAmp*0.2;
            ctx.beginPath();
            ctx.moveTo(-this.size*0.3,0);
            ctx.quadraticCurveTo(-this.size*0.5,-ws*0.4*(1+flap),-this.size*sweep,-ws*(0.8+flap*0.15));
            ctx.quadraticCurveTo(this.size*0.3,-ws*0.3*(1+flap),this.size*0.4,0);
            ctx.quadraticCurveTo(this.size*0.3,ws*0.3*(1+flap),-this.size*sweep,ws*(0.8+flap*0.15));
            ctx.quadraticCurveTo(-this.size*0.5,ws*0.4*(1+flap),-this.size*0.3,0);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-this.size*stretch,0);
            ctx.lineTo(-this.size*stretch-this.size*1.2,-this.size*0.4);
            ctx.lineTo(-this.size*stretch-this.size*0.8,0);
            ctx.lineTo(-this.size*stretch-this.size*1.2,this.size*0.4);
            ctx.closePath(); 
            ctx.fill();
            
            ctx.beginPath(); 
            ctx.arc(this.size*stretch*0.8, 0, this.size*0.35, 0, PI2); 
            ctx.fill();
        }
        
        ctx.restore();
        
        if (this.huntPhase > 0 && this.huntPhase < 4) {
            ctx.strokeStyle = `rgba(255,100,50,${0.1+this.huntCRR.smoothAmp*0.2})`;
            ctx.lineWidth = 1; ctx.beginPath();
            ctx.arc(this.x,this.y,30+this.huntCRR.smoothAmp*20,0,PI2); ctx.stroke();
        }
    }
    
    stateName() { return ['soar','stalk','DIVE','recover','descend','FEED','takeoff'][this.huntPhase]; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATS - Nocturnal flyers with erratic CRR-driven flight
// Bats have more erratic movement than birds, with sudden direction changes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Bat {
    constructor(x, y, colony) {
        this.colony = colony;
        this.x = x;
        this.y = y;
        this.vx = (random() - 0.5) * 40;
        this.vy = (random() - 0.5) * 30;
        this.tvx = this.vx;
        this.tvy = this.vy;
        this.size = 1.8 + random() * 0.6;
        
        // Bats have LOWER Î© than birds - more frequent micro-ruptures
        // This creates their characteristic erratic flight
        this.crr = new CRR(0.04 + random() * 0.03, 0.8 + random() * 0.4);
        
        this.wingPhase = random() * PI2;
        this.wingSpeed = 18 + random() * 8;  // Faster wingbeats than birds
        
        // States: 0=flying, 1=roosting
        this.st = 0;
        this.roostT = 0;
        this.react = 0.9 + random() * 0.2;
        
        // Erratic direction change timer
        this.erraticTimer = random() * 2;
    }
    
    update(dt, allBats, owl, perches) {
        this.wingPhase += this.wingSpeed * dt;
        this.crr.update(dt, 0.6);
        
        // Roosting during day
        if (this.st === 1) {
            this.roostT += dt;
            // Wake up at dusk
            if (sunrise.isDusk() || sunrise.isNight) {
                if (random() < 0.02) {
                    this.st = 0;
                    this.vy = -20 - random() * 15;
                    this.vx = (random() - 0.5) * 30;
                }
            }
            return;
        }
        
        // Go to roost at dawn
        if (sunrise.isDawn() && sunrise.phase > 0.3) {
            if (random() < 0.01 && this.y > H * 0.4) {
                // Find a perch
                for (const p of perches) {
                    if (p.occ) continue;
                    const d = sqrt((this.x - p.x)**2 + (this.y - p.y)**2);
                    if (d < 100) {
                        this.st = 1;
                        this.x = p.x;
                        this.y = p.y;
                        p.occ = true;
                        this.roostT = 0;
                        return;
                    }
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ERRATIC FLIGHT - CRR ruptures cause sudden direction changes + echolocation
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        this.erraticTimer += dt;
        
        // CRR ruptures trigger direction changes AND echolocation clicks
        const wasCoherent = this.crr.st === 0;
        
        if (this.crr.st === 1 || this.erraticTimer > 1.5 + random()) {
            this.erraticTimer = 0;
            // Sudden velocity change
            this.tvx += (random() - 0.5) * 60;
            this.tvy += (random() - 0.5) * 40;
            
            // Echolocation click on CRR rupture (diegetic sound!)
            if (wasCoherent && random() < 0.4) {
                soundSystem.batClick(0.3 + this.crr.smoothAmp * 0.7);
            }
        }
        
        // Occasional wing flutter sound
        if (random() < 0.002) {
            soundSystem.batFlutter();
        }
        
        // Loose flocking - bats are less cohesive than birds
        let ax = 0, ay = 0, cx = 0, cy = 0, nc = 0;
        
        for (const b of allBats) {
            if (b === this || b.st !== 0) continue;
            const dx = b.x - this.x;
            const dy = b.y - this.y;
            const d = sqrt(dx*dx + dy*dy);
            
            if (d < 80 && d > 0) {
                // Weak separation
                if (d < 20) {
                    this.tvx -= dx/d * 2;
                    this.tvy -= dy/d * 2;
                }
                ax += b.vx;
                ay += b.vy;
                cx += b.x;
                cy += b.y;
                nc++;
            }
        }
        
        if (nc > 0) {
            // Weak alignment
            this.tvx += (ax/nc - this.vx) * 0.05;
            this.tvy += (ay/nc - this.vy) * 0.05;
            // Weak cohesion
            this.tvx += (cx/nc - this.x) * 0.008;
            this.tvy += (cy/nc - this.y) * 0.008;
        }
        
        // Central tendency
        const toCenterX = W * 0.5 - this.x;
        const toCenterY = H * 0.35 - this.y;
        this.tvx += toCenterX * 0.01;
        this.tvy += toCenterY * 0.01;
        
        // OWL AVOIDANCE
        if (owl && owl.huntPhase !== 4) {
            const dx = this.x - owl.x;
            const dy = this.y - owl.y;
            const d = sqrt(dx*dx + dy*dy);
            if (d < 150 && d > 0) {
                const f = (150 - d) / 150 * 80;
                this.tvx += dx/d * f;
                this.tvy += dy/d * f;
                if (d < 60) this.crr.rupture();  // Panic!
            }
        }
        
        // Update velocity with erratic lerp
        this.vx = lerp(this.vx, this.tvx, dt * 8);
        this.vy = lerp(this.vy, this.tvy, dt * 8);
        
        // Speed limits - bats are fast
        const spd = sqrt(this.vx*this.vx + this.vy*this.vy);
        if (spd > 90) {
            this.vx = this.vx/spd * 90;
            this.vy = this.vy/spd * 90;
        } else if (spd < 20 && spd > 0) {
            this.vx = this.vx/spd * 20;
            this.vy = this.vy/spd * 20;
        }
        
        // Boundaries
        if (this.x < W * 0.05) this.vx += 15;
        if (this.x > W * 0.95) this.vx -= 15;
        if (this.y < H * 0.05) this.vy += 10;
        if (this.y > H * 0.70) this.vy -= 10;
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
    }
    
    draw() {
        if (this.st === 1) return;  // Roosting bats not visible
        
        const angle = atan2(this.vy, this.vx);
        const flap = fsin(this.wingPhase) * 0.5;
        
        // Moonlight boost for visibility
        const moonlit = sunrise.moonPhase ? sunrise.moonPhase * 0.3 : 0;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(angle);
        
        // Bat body - dark but with moonlit edge
        ctx.fillStyle = `rgba(35,30,45,${0.9 + moonlit * 0.1})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size * 0.8, this.size * 0.4, 0, 0, PI2);
        ctx.fill();
        
        // Bat wings - membrane-like, pointed
        const ws = this.size * 3;
        const wingLift = 0.3 + flap * 0.5;
        
        // Wing fill - slightly lighter for moonlight
        ctx.fillStyle = `rgba(${40 + moonlit * 30 | 0},${35 + moonlit * 30 | 0},${50 + moonlit * 40 | 0},0.85)`;
        ctx.beginPath();
        // Upper wing with finger-like projections
        ctx.moveTo(-this.size * 0.2, 0);
        ctx.quadraticCurveTo(-this.size * 0.3, -ws * wingLift * 0.4, this.size * 0.5, -ws * wingLift);
        ctx.lineTo(this.size * 0.3, -ws * wingLift * 0.6);
        ctx.lineTo(this.size * 0.1, -ws * wingLift * 0.3);
        ctx.lineTo(this.size * 0.1, 0);
        // Lower wing
        ctx.lineTo(this.size * 0.1, ws * wingLift * 0.3);
        ctx.lineTo(this.size * 0.3, ws * wingLift * 0.6);
        ctx.lineTo(this.size * 0.5, ws * wingLift);
        ctx.quadraticCurveTo(-this.size * 0.3, ws * wingLift * 0.4, -this.size * 0.2, 0);
        ctx.fill();
        
        // Subtle moonlit highlight on wings
        if (moonlit > 0.1) {
            ctx.strokeStyle = `rgba(180, 200, 220, ${moonlit * 0.4})`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

// Bat colony (like flock but simpler)
class BatColony {
    constructor() {
        this.crr = new CRR(0.5, 0.15);
    }
    update(dt) {
        this.crr.update(dt, 0.4);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OWL - Nocturnal predator with silent flight and CRR hunting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Owl {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = 12;
        this.wingSpan = 45;
        this.wingPhase = 0;
        
        // Owl CRR - patient hunter with long coherence build
        this.huntCRR = new CRR(0.12, 0.4);  // Higher Î© = more patient
        
        // Hunt phases: 0=perched, 1=glide, 2=strike, 3=recover, 4=feed
        this.huntPhase = 0;
        this.target = null;
        this.perchPos = { x: x, y: y };
        this.patrolTimer = 0;
        this.feedTimer = 0;
        this.bank = 0;
    }
    
    update(dt, bats, tree) {
        this.huntCRR.update(dt, this.huntPhase === 1 ? 0.8 : 0.3);
        this.wingPhase += dt * (this.huntPhase === 2 ? 25 : 8);
        
        // Count active bats
        let activeBats = 0;
        let nearestBat = null;
        let nearestD = Infinity;
        
        for (const bat of bats) {
            if (bat.st !== 0) continue;
            activeBats++;
            const d = sqrt((bat.x - this.x)**2 + (bat.y - this.y)**2);
            if (d < nearestD) {
                nearestD = d;
                nearestBat = bat;
            }
        }
        
        // Only hunt at night
        const isNight = sunrise.isNight || (sunrise.cyclePhase > 0.85);
        
        if (this.huntPhase === 0) {
            // PERCHED - waiting on tree
            this.x = this.perchPos.x;
            this.y = this.perchPos.y;
            this.vx = this.vy = 0;
            
            // Start hunting when CRR ruptures and bats are active
            if (isNight && activeBats > 5 && this.huntCRR.st === 1 && nearestD < 300) {
                this.huntPhase = 1;
                this.target = nearestBat;
            }
        } else if (this.huntPhase === 1) {
            // SILENT GLIDE - approaching target
            if (!this.target || this.target.st !== 0) {
                this.target = nearestBat;
            }
            
            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const d = sqrt(dx*dx + dy*dy);
                
                // Silent approach - slower than falcon
                const approachSpeed = 60;
                this.vx = lerp(this.vx, dx/d * approachSpeed, dt * 2);
                this.vy = lerp(this.vy, dy/d * approachSpeed, dt * 2);
                
                // Strike when close
                if (d < 40) {
                    this.huntPhase = 2;
                }
                
                // Give up if too far
                if (d > 400) {
                    this.huntPhase = 3;
                }
            } else {
                this.huntPhase = 3;
            }
        } else if (this.huntPhase === 2) {
            // STRIKE
            if (this.target && this.target.st === 0) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const d = sqrt(dx*dx + dy*dy);
                
                if (d < 15) {
                    // Catch!
                    this.target.st = 1;  // Bat is caught (roosting state)
                    this.target.x = -100;  // Remove from view
                    this.huntPhase = 4;
                    this.feedTimer = 0;
                } else if (d > 80) {
                    // Missed
                    this.huntPhase = 3;
                } else {
                    this.vx = lerp(this.vx, dx/d * 100, dt * 4);
                    this.vy = lerp(this.vy, dy/d * 100, dt * 4);
                }
            } else {
                this.huntPhase = 3;
            }
        } else if (this.huntPhase === 3) {
            // RECOVER - return to perch
            const dx = this.perchPos.x - this.x;
            const dy = this.perchPos.y - this.y;
            const d = sqrt(dx*dx + dy*dy);
            
            this.vx = lerp(this.vx, dx/d * 40, dt * 2);
            this.vy = lerp(this.vy, dy/d * 40, dt * 2);
            
            if (d < 20) {
                this.huntPhase = 0;
                this.huntCRR.C = 0;
            }
        } else if (this.huntPhase === 4) {
            // FEED
            this.feedTimer += dt;
            this.vx *= 0.95;
            this.vy *= 0.95;
            
            if (this.feedTimer > 4) {
                this.huntPhase = 3;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Boundaries
        this.x = clamp(this.x, W * 0.05, W * 0.95);
        this.y = clamp(this.y, H * 0.1, H * 0.7);
        
        this.bank = lerp(this.bank, clamp(this.vx * 0.015, -0.4, 0.4), dt * 3);
    }
    
    draw() {
        // Only draw at night
        const nightness = 1 - sunrise.phase;
        if (nightness < 0.3) return;
        
        const alpha = min(1, (nightness - 0.3) / 0.4);
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.huntPhase === 0) {
            // Perched owl - facing forward
            ctx.fillStyle = `rgba(80,70,60,${alpha * 0.95})`;
            
            // Body
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size * 0.8, this.size * 1.2, 0, 0, PI2);
            ctx.fill();
            
            // Head
            ctx.beginPath();
            ctx.arc(0, -this.size * 1.1, this.size * 0.7, 0, PI2);
            ctx.fill();
            
            // Ear tufts
            ctx.beginPath();
            ctx.moveTo(-this.size * 0.4, -this.size * 1.6);
            ctx.lineTo(-this.size * 0.2, -this.size * 2.1);
            ctx.lineTo(0, -this.size * 1.6);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(this.size * 0.4, -this.size * 1.6);
            ctx.lineTo(this.size * 0.2, -this.size * 2.1);
            ctx.lineTo(0, -this.size * 1.6);
            ctx.fill();
            
            // Eyes - glowing
            ctx.fillStyle = `rgba(255,200,50,${alpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(-this.size * 0.25, -this.size * 1.1, this.size * 0.2, 0, PI2);
            ctx.arc(this.size * 0.25, -this.size * 1.1, this.size * 0.2, 0, PI2);
            ctx.fill();
            
        } else {
            // Flying owl
            const angle = atan2(this.vy, this.vx);
            ctx.rotate(angle);
            ctx.scale(1, 1 - abs(this.bank) * 0.2);
            
            const flap = fsin(this.wingPhase) * 0.3;
            
            ctx.fillStyle = `rgba(70,60,50,${alpha * 0.9})`;
            
            // Body
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size * 1.3, this.size * 0.6, 0, 0, PI2);
            ctx.fill();
            
            // Wide wings - owl wings are broad and rounded
            const ws = this.wingSpan;
            ctx.beginPath();
            ctx.moveTo(-this.size * 0.3, 0);
            ctx.quadraticCurveTo(-this.size * 0.2, -ws * (0.3 + flap * 0.3), this.size * 0.2, -ws * (0.7 + flap * 0.2));
            ctx.quadraticCurveTo(this.size * 0.5, -ws * (0.5 + flap * 0.2), this.size * 0.3, 0);
            ctx.quadraticCurveTo(this.size * 0.5, ws * (0.5 + flap * 0.2), this.size * 0.2, ws * (0.7 + flap * 0.2));
            ctx.quadraticCurveTo(-this.size * 0.2, ws * (0.3 + flap * 0.3), -this.size * 0.3, 0);
            ctx.fill();
            
            // Head
            ctx.beginPath();
            ctx.arc(this.size * 1.1, 0, this.size * 0.5, 0, PI2);
            ctx.fill();
            
            // Glowing eyes
            if (this.huntPhase === 1 || this.huntPhase === 2) {
                ctx.fillStyle = `rgba(255,200,50,${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.size * 1.3, -this.size * 0.1, this.size * 0.12, 0, PI2);
                ctx.arc(this.size * 1.3, this.size * 0.1, this.size * 0.12, 0, PI2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }
    
    stateName() {
        return ['perched', 'glide', 'STRIKE', 'return', 'FEED'][this.huntPhase];
    }
}

// Global bat/owl variables
let bats = [];
let batColony = null;
let owl = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED STARLINGS - Topological neighbors + turning waves + TIGHT FLOCKING
// Optimized for 400+ birds at 60fps
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Bird {
    constructor(x, y, flock) {
        this.crr = new CRR(0.06 + random() * 0.05, 1.0);
        this.flock = flock;
        this.x = x; this.y = y;
        // Gentler initial velocity - let cohesion build first
        this.vx = (random() - 0.5) * 25; 
        this.vy = (random() - 0.5) * 15;
        // Target velocity for smooth turning waves
        this.tvx = this.vx;
        this.tvy = this.vy;
        this.size = 1.0 + random() * 0.3;
        this.wph = random() * PI2; 
        this.wsp = 12 + random() * 5;
        this.st = 0; // 0=flying, 1=landing, 2=perched, 3=takeoff
        this.perch = null; 
        this.perchT = 0; 
        this.timer = 0;
        this.react = 0.85 + random() * 0.3;
        // Local density tracking
        this.localDensity = 0;
        // Angular momentum for swirling
        this.angMom = 0;
    }
    
    update(dt, allBirds, attrs, scare, perches, pred, flockTurnDir, flockAngMom, flockCenterX, flockCenterY) {
        this.timer += dt;
        this.wph += this.wsp * dt;  // Always update wing phase
        
        // Day/night state for roosting behavior
        const isNightTime = sunrise.isNight || (sunrise.cyclePhase && sunrise.cyclePhase > 0.85);
        const isDusk = sunrise.isDusk && sunrise.isDusk();
        const isDawn = sunrise.isDawn && sunrise.isDawn();
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE: PERCHED - sleep at night, wake at dawn
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.st === 2) {
            this.perchT += dt;
            
            // At night, birds sleep (very low chance of waking)
            if (isNightTime && !isDawn) {
                // Only startle response can wake them
                const scared = scare && sqrt((this.x-scare.x)**2+(this.y-scare.y)**2) < scare.r * 0.8;
                if (scared) {
                    this.st = 3;
                    this.vy = -25 - random() * 15;
                    this.vx = (random() - 0.5) * 20;
                    this.tvx = this.vx;
                    this.tvy = this.vy;
                    if (this.perch) {
                        this.perch.occ = false;
                        this.perch = null;
                    }
                }
                return;
            }
            
            // Check every 0.4 seconds for takeoff conditions
            if (this.timer > 0.4) {
                this.timer = 0;
                
                const scared = scare && sqrt((this.x-scare.x)**2+(this.y-scare.y)**2) < scare.r * 1.3;
                const predFlying = pred && pred.huntPhase !== 5;
                const predNear = predFlying && sqrt((this.x-pred.x)**2+(this.y-pred.y)**2) < 180;
                const flockRupture = this.flock.st === 1;
                const rainStopped = weather.rainIntensity < 0.2 && this.perchT > 2;
                
                // Natural takeoff timing - wake up at dawn!
                const minRestTime = isDawn ? 1 : (3 + this.react * 4);
                const restless = this.perchT > minRestTime && random() < (isDawn ? 0.08 : 0.03);
                const veryRestless = this.perchT > 12 && random() < 0.06;
                
                // Rejoin flock periodically (but not at night)
                const shouldRejoin = !isNightTime && this.perchT > 5 && random() < 0.012;
                
                if (scared || predNear || flockRupture || rainStopped || restless || veryRestless || shouldRejoin) {
                    this.st = 3;  // Takeoff
                    this.vy = -28 - random() * 18;
                    this.vx = (random() - 0.5) * 25 - 12;
                    this.tvx = this.vx;
                    this.tvy = this.vy;
                    if (this.perch) {
                        this.perch.occ = false;
                        this.perch = null;
                    }
                }
            }
            return;
        }
        
        this.crr.update(dt, this.st === 0 ? 1 : 0.3);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE: TAKEOFF
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.st === 3) {
            this.vy -= 40 * dt;  // Upward boost
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            if (this.timer > 0.35) {
                this.st = 0;
                this.tvx = this.vx;
                this.tvy = this.vy;
            }
            return;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE: LANDING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (this.st === 1) {
            if (!this.perch) {
                this.st = 0;
                return;
            }
            const dx = this.perch.x - this.x;
            const dy = this.perch.y - this.y;
            const d = sqrt(dx*dx + dy*dy);
            
            if (d < 3) {
                this.st = 2;  // Landed
                this.x = this.perch.x;
                this.y = this.perch.y;
                this.vx = this.vy = 0;
                this.perchT = 0;
            } else {
                const landSpeed = min(d * 2.5, 60);
                this.vx = dx / d * landSpeed;
                this.vy = dy / d * landSpeed;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            return;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TOPOLOGICAL NEIGHBOR SELECTION (k=7 nearest) - VERY TIGHT DISTANCES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const candidates = getCandidates(this.x, this.y);
        const K_NEIGHBORS = 7;
        
        // Collect all flying birds with distances
        const neighbors = [];
        for (const i of candidates) {
            const o = allBirds[i];
            if (o === this || o.st !== 0) continue;
            const dx = o.x - this.x;
            const dy = o.y - this.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < 100*100) { // Slightly larger range for better connectivity
                neighbors.push({ bird: o, d2, dx, dy, d: sqrt(d2) });
            }
        }
        
        // Sort by distance, take k nearest
        neighbors.sort((a, b) => a.d2 - b.d2);
        const kNearest = neighbors.slice(0, K_NEIGHBORS);
        
        // Calculate local density
        this.localDensity = kNearest.length > 0 ? 
            K_NEIGHBORS / (kNearest[kNearest.length-1]?.d || 30) : 0;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FLOCKING FORCES - Tight cohesion with choreography multipliers
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const fm = min(this.flock.mem() / 4, 2.0);
        const choreo = this.flock.getChoreo();
        const cohesionMult = choreo ? choreo.cohesionMult : 1.0;
        const separationMult = choreo && choreo.separationMult ? choreo.separationMult : 1.0;
        
        let sx = 0, sy = 0;
        let ax = 0, ay = 0;
        let cx = 0, cy = 0;
        let angSum = 0;
        let nc = 0;
        
        for (const n of kNearest) {
            const { bird: o, d, dx, dy } = n;
            
            // SEPARATION - modulated by choreography
            if (d < 12 * separationMult && d > 0) {
                const f = (12 * separationMult - d) / (12 * separationMult) / (this.crr.omega * 5);
                sx -= dx/d * f;
                sy -= dy/d * f;
            }
            
            ax += o.vx;
            ay += o.vy;
            cx += o.x;
            cy += o.y;
            angSum += o.angMom;
            nc++;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLOBAL FLOCK COHESION - pulls isolated birds back to main flock
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (nc < 4) {
            // Bird has few neighbors - strongly attract to global flock center
            const globalPull = (4 - nc) * 0.015;  // Stronger when more isolated
            this.tvx += (flockCenterX - this.x) * globalPull;
            this.tvy += (flockCenterY - this.y) * globalPull;
        }
        
        if (nc > 0) {
            // Separation
            this.tvx += sx * 1.6 * this.react;
            this.tvy += sy * 1.6 * this.react;
            
            // STRONG Alignment
            const af = (0.14 + fm * 0.12) * this.react;
            this.tvx += (ax/nc - this.vx) * af;
            this.tvy += (ay/nc - this.vy) * af;
            
            // VERY STRONG Cohesion - multiplied by choreography
            const cf = (0.035 + fm * 0.030) * this.react * cohesionMult;
            this.tvx += (cx/nc - this.x) * cf;
            this.tvy += (cy/nc - this.y) * cf;
            
            // Angular momentum from neighbors + choreography
            const choreoAng = choreo ? choreo.angularMom * 0.3 : 0;
            this.angMom = lerp(this.angMom, angSum / nc + choreoAng, 0.12);
        } else {
            // No neighbors at all - strong pull to flock center
            this.tvx += (flockCenterX - this.x) * 0.05;
            this.tvy += (flockCenterY - this.y) * 0.05;
        }
        
        // Apply angular momentum as perpendicular velocity
        if (abs(this.angMom) > 0.01) {
            const spd = sqrt(this.vx*this.vx + this.vy*this.vy);
            if (spd > 5) {
                const perpX = -this.vy / spd;
                const perpY = this.vx / spd;
                this.tvx += perpX * this.angMom * 0.8;
                this.tvy += perpY * this.angMom * 0.8;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLLECTIVE TURN on flock rupture - with angular momentum
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (flockTurnDir && this.flock.st === 1) {
            const turnStrength = 0.18 * this.react;
            this.tvx += flockTurnDir.x * turnStrength;
            this.tvy += flockTurnDir.y * turnStrength;
            // Add swirl
            this.angMom += flockAngMom * 0.3;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DYNAMIC ATTRACTORS - reduced, choreography now drives movement
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        for (const a of attrs) { 
            const dx = a.x - this.x;
            const dy = a.y - this.y;
            const d = sqrt(dx*dx + dy*dy); 
            if (d > 0 && d < 300) {
                const strength = (1 - d/300) * 0.4 * a.s;
                this.tvx += dx/d * strength;
                this.tvy += dy/d * strength;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHOREOGRAPHY-DRIVEN GRAVITY - pull toward pattern target
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let targetX = W * 0.5;
        let targetY = H * 0.38;
        
        // Use choreography target if available
        if (choreo) {
            targetX = choreo.targetX;
            targetY = choreo.targetY;
            
            // Handle split mode - birds attracted to one of two points
            if (choreo.splitMode && choreo.splitDist > 20) {
                // Split based on bird position relative to center
                const side = this.x > W * 0.5 ? 1 : -1;
                targetX = W * 0.5 + side * choreo.splitDist;
            }
            
            // Vertical bias for column move
            if (choreo.verticalBias) {
                this.tvy += choreo.verticalBias * 1.5;
            }
        }
        
        // Rain shifts target toward tree
        if (weather.rainIntensity > 0.3) {
            const rainPull = weather.rainIntensity * 0.35;
            targetX = lerp(targetX, W * 0.75, rainPull);
            targetY = lerp(targetY, H * 0.45, rainPull);
        }
        
        // NIGHT - strong pull toward tree for roosting
        if (isNightTime || isDusk) {
            const nightPull = isNightTime ? 0.8 : 0.5;
            targetX = lerp(targetX, W * 0.78, nightPull);
            targetY = lerp(targetY, H * 0.5, nightPull);
        }
        
        const toCenterX = targetX - this.x;
        const toCenterY = targetY - this.y;
        const distFromCenter = sqrt(toCenterX*toCenterX + toCenterY*toCenterY);
        const gravityStrength = 0.08 + 0.28 * max(0, (distFromCenter - 60) / 200);
        this.tvx += toCenterX / max(distFromCenter, 1) * gravityStrength;
        this.tvy += toCenterY / max(distFromCenter, 1) * gravityStrength;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PREDATOR AVOIDANCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (pred && pred.huntPhase !== 5) {
            const dx = this.x - pred.x;
            const dy = this.y - pred.y;
            const d = sqrt(dx*dx + dy*dy);
            if (d < 200 && d > 0) {
                const f = (200 - d) / 200 * 120;
                this.tvx += dx/d * f;
                this.tvy += dy/d * f;
                // Add swirl away from predator
                if (d < 100) {
                    this.angMom += (random() > 0.5 ? 1 : -1) * 2;
                }
                if (d < 80) this.crr.rupture();
            }
        }
        
        // STARTLE
        if (scare) { 
            const dx = this.x - scare.x;
            const dy = this.y - scare.y;
            const d = sqrt(dx*dx + dy*dy); 
            if (d < scare.r && d > 0) {
                this.tvx += dx/d * (scare.r-d)/scare.r * 70;
                this.tvy += dy/d * (scare.r-d)/scare.r * 70;
                this.angMom += (random() > 0.5 ? 1 : -1) * 3;
                this.crr.rupture();
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TURNING WAVE - smooth velocity update
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const turnLerp = min(1, dt * (10 + this.localDensity * 3));
        this.vx = lerp(this.vx, this.tvx, turnLerp);
        this.vy = lerp(this.vy, this.tvy, turnLerp);
        
        // Decay angular momentum
        this.angMom *= 0.98;
        
        // Boundary forces - MUCH STRONGER to keep flock on screen
        const margin = 0.08;
        const boundaryForce = 8;
        if (this.x < W * margin) this.vx += boundaryForce * (1 - this.x / (W * margin));
        if (this.x > W * (1 - margin)) this.vx -= boundaryForce * (1 - (W - this.x) / (W * margin));
        if (this.y < H * margin) this.vy += boundaryForce * (1 - this.y / (H * margin));
        if (this.y > H * 0.75) this.vy -= boundaryForce * (1 - (H * 0.88 - this.y) / (H * 0.13));
        
        // Speed limits - moderate speed keeps flock cohesive
        const spd = sqrt(this.vx*this.vx + this.vy*this.vy);
        if (spd > 75) { 
            this.vx = this.vx/spd * 75; 
            this.vy = this.vy/spd * 75; 
        } else if (spd < 18 && spd > 0) { 
            this.vx = this.vx/spd * 18; 
            this.vy = this.vy/spd * 18; 
        }
        
        // Update position
        this.x += this.vx * dt; 
        this.y += this.vy * dt;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PERCHING LOGIC - natural tree landing + night roosting
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const predatorFeeding = pred && pred.huntPhase === 5;
        const raining = weather.rainIntensity > 0.4;
        const nearTree = this.x > W * 0.6;
        const veryNearTree = this.x > W * 0.72 && this.y > H * 0.45;
        const movingSlow = spd < 35;
        
        // Night roosting - starlings sleep at night!
        
        // Calculate perch chance based on conditions
        let perchChance = 0;
        
        // STRONG night roosting behavior
        if (isNightTime || isDusk) {
            if (nearTree) {
                perchChance = 0.015;  // High chance to roost at night
            } else {
                perchChance = 0.003;  // Even if not near tree, try to find one
            }
        } else if (veryNearTree) {
            if (raining) {
                perchChance = 0.004;
            } else if (predatorFeeding) {
                perchChance = 0.003;
            } else if (movingSlow) {
                perchChance = 0.002;
            } else {
                perchChance = 0.0008;
            }
        } else if (nearTree) {
            if (raining) {
                perchChance = 0.0015;
            } else if (predatorFeeding) {
                perchChance = 0.001;
            } else if (movingSlow && this.y > H * 0.5) {
                perchChance = 0.0005;
            }
        }
        
        // Less reactive birds perch more
        if (this.react < 0.95) {
            perchChance *= 1.3;
        }
        
        if (random() < perchChance) {
            // Find nearest available perch
            let best = null;
            let bestD = (isNightTime || isDusk) ? 200 : (veryNearTree ? 80 : 120);
            
            for (const p of perches) {
                if (p.occ) continue;
                const d = sqrt((this.x - p.x)**2 + (this.y - p.y)**2);
                if (d < bestD) {
                    bestD = d;
                    best = p;
                }
            }
            
            if (best) {
                this.st = 1;
                this.perch = best;
                best.occ = true;
                this.timer = 0;
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BIRD DRAWING - Beautiful flapping wings, ALL states visible
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawBirds(birds) {
    ctx.fillStyle = 'rgba(18,18,24,0.9)';
    
    for (const b of birds) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PERCHED - sitting still on branch
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (b.st === 2) {
            ctx.save();
            ctx.translate(b.x, b.y);
            
            // Body - slightly puffed when perched
            ctx.beginPath();
            ctx.ellipse(0, 0, b.size * 1.1, b.size * 0.9, 0, 0, PI2);
            ctx.fill();
            
            // Folded wings - subtle tuck
            ctx.beginPath();
            ctx.ellipse(b.size * 0.2, 0, b.size * 0.8, b.size * 0.5, 0.2, 0, PI2);
            ctx.fill();
            
            ctx.restore();
            continue;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FLYING / LANDING / TAKEOFF - with flapping wings
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const angle = atan2(b.vy, b.vx);
        const spd = sqrt(b.vx*b.vx + b.vy*b.vy);
        
        // Wing flap speed varies by state
        let flapMult = 1.0;
        if (b.st === 3) flapMult = 1.4;  // Faster flapping on takeoff
        if (b.st === 1) flapMult = 0.7;  // Slower on landing approach
        
        const flap = fsin(b.wph * flapMult) * 0.45;
        
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(angle);
        
        // Body - elongates with speed
        const stretch = 1 + min(spd / 120, 0.35);
        ctx.beginPath();
        ctx.ellipse(0, 0, b.size * 1.35 * stretch, b.size * 0.5, 0, 0, PI2);
        ctx.fill();
        
        // Wings with beautiful flapping motion
        const ws = b.size * 2.6;
        const wingLift = 0.42 + flap * 0.38;
        
        ctx.beginPath();
        // Right wing (top in flight direction)
        ctx.moveTo(-b.size * 0.25, 0);
        ctx.quadraticCurveTo(
            -b.size * 0.05, -ws * wingLift * 0.55,
            b.size * 0.35, -ws * wingLift
        );
        ctx.quadraticCurveTo(
            b.size * 0.18, -ws * wingLift * 0.25,
            b.size * 0.12, 0
        );
        // Left wing (bottom in flight direction)
        ctx.quadraticCurveTo(
            b.size * 0.18, ws * wingLift * 0.25,
            b.size * 0.35, ws * wingLift
        );
        ctx.quadraticCurveTo(
            -b.size * 0.05, ws * wingLift * 0.55,
            -b.size * 0.25, 0
        );
        ctx.fill();
        
        ctx.restore();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED FLOCK - CRR collective coherence with choreographed moves
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Flock {
    constructor() {
        this.crr = new CRR(0.6, 0.22);  // Slightly faster cycles for more moves
        this.st = 0;
        this.turnDir = { x: 0, y: 0 };
        this.angularMomentum = 0;
        this.lastRuptureTime = 0;
        this.choreoMods = null;  // Current choreography modifiers
    }
    
    update(dt, birds) {
        const prevSt = this.crr.st;
        this.crr.update(dt, 0.5);
        this.st = this.crr.st;
        
        // Calculate flock center
        let cx = 0, cy = 0, count = 0;
        let avgVx = 0, avgVy = 0;
        for (const b of birds) {
            if (b.st === 0) {
                cx += b.x; cy += b.y;
                avgVx += b.vx; avgVy += b.vy;
                count++;
            }
        }
        if (count > 0) {
            cx /= count; cy /= count;
            avgVx /= count; avgVy /= count;
        }
        
        // On rupture, trigger new choreographed move
        if (this.crr.st === 1 && prevSt === 0) {
            Choreographer.onRupture();
            
            // Calculate turn direction based on new move
            const turnSign = random() > 0.5 ? 1 : -1;
            const turnAngle = turnSign * (PI/3 + random() * PI/4);
            const mag = sqrt(avgVx*avgVx + avgVy*avgVy);
            const baseAngle = atan2(avgVy, avgVx);
            const newAngle = baseAngle + turnAngle;
            
            this.turnDir.x = cos(newAngle) * mag * 0.5;
            this.turnDir.y = sin(newAngle) * mag * 0.5;
            this.angularMomentum = turnSign * (1.5 + random() * 2);
            this.lastRuptureTime = time;
        }
        
        // Update choreography
        this.choreoMods = Choreographer.update(dt, cx, cy);
        
        // Apply choreography angular momentum
        if (this.choreoMods) {
            this.angularMomentum = lerp(this.angularMomentum, this.choreoMods.angularMom, dt * 2);
        }
        
        // Fade turn direction
        const fadeTime = time - this.lastRuptureTime;
        if (fadeTime > 0.4) {
            this.turnDir.x *= 0.94;
            this.turnDir.y *= 0.94;
        }
    }
    
    mem() { return this.crr.mem(); }
    rupture() { this.crr.rupture(); }
    stateName() { return this.crr.stateName(); }
    getTurnDir() { 
        const mag = sqrt(this.turnDir.x**2 + this.turnDir.y**2);
        return mag > 0.1 ? this.turnDir : null; 
    }
    getAngularMomentum() {
        return this.angularMomentum;
    }
    getChoreo() {
        return this.choreoMods;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MURMURATION CHOREOGRAPHER - CRR-driven classic patterns
// Each flock rupture triggers a new move from the repertoire
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Choreographer = {
    // Move repertoire - each is a classic murmuration pattern
    moves: [
        'vortex',      // Swirling spiral
        'wave',        // Sinusoidal wave propagation
        'split',       // Divide and reunite
        'breathe',     // Expand and contract
        'ribbon',      // Figure-8 twist
        'column',      // Vertical rise
        'sweep',       // Horizontal sweep
        'tornado'      // Tight spinning column
    ],
    
    currentMove: 'vortex',
    moveIndex: 0,
    moveTime: 0,
    moveDuration: 0,
    
    // Move-specific state
    vortexSign: 1,
    splitPhase: 0,
    breathePhase: 0,
    ribbonPhase: 0,
    sweepDir: 1,
    
    // Initialize
    init() {
        this.moveIndex = floor(random() * this.moves.length);
        this.currentMove = this.moves[this.moveIndex];
        this.moveTime = 0;
        this.moveDuration = 4 + random() * 4;
        this.vortexSign = random() > 0.5 ? 1 : -1;
    },
    
    // Called on flock CRR rupture - select next move
    onRupture() {
        // Cycle through moves, occasionally random
        if (random() < 0.3) {
            this.moveIndex = floor(random() * this.moves.length);
        } else {
            this.moveIndex = (this.moveIndex + 1) % this.moves.length;
        }
        this.currentMove = this.moves[this.moveIndex];
        this.moveTime = 0;
        this.moveDuration = 4 + random() * 5;
        
        // Reset move-specific state
        this.vortexSign = random() > 0.5 ? 1 : -1;
        this.splitPhase = 0;
        this.breathePhase = 0;
        this.sweepDir = random() > 0.5 ? 1 : -1;
    },
    
    // Update and return forces to apply to birds
    update(dt, flockCenterX, flockCenterY) {
        this.moveTime += dt;
        
        // Return movement modifiers based on current pattern
        const t = this.moveTime;
        const phase = (t / this.moveDuration) * PI2;
        
        // Occasionally bias the flock toward tree area for natural perching
        const treeVisitBias = sin(t * 0.15) > 0.7 ? 0.15 : 0;  // ~30% of time drifts toward tree
        const baseX = W * (0.5 + treeVisitBias);
        
        switch (this.currentMove) {
            case 'vortex':
                // Swirling spiral - constant angular momentum
                return {
                    angularMom: this.vortexSign * 2.5,
                    targetX: baseX + cos(t * 0.3) * 80,
                    targetY: H * 0.38 + sin(t * 0.4) * 40,
                    cohesionMult: 1.3,
                    name: 'Vortex Spiral'
                };
                
            case 'wave':
                // Sinusoidal wave - oscillating vertical bias
                return {
                    angularMom: sin(t * 2) * 1.5,
                    targetX: baseX + sin(t * 0.5) * 140,
                    targetY: H * 0.38 + sin(t * 1.5) * 60,
                    cohesionMult: 1.2,
                    name: 'Wave Flow'
                };
                
            case 'split':
                // Split and merge - two attractors
                this.splitPhase = sin(t * 0.8);
                const splitDist = abs(this.splitPhase) * 110;
                return {
                    angularMom: 0,
                    targetX: baseX + (this.splitPhase > 0 ? splitDist : -splitDist) * 0.3,
                    targetY: H * 0.38,
                    splitMode: true,
                    splitDist: splitDist,
                    cohesionMult: 1.0 + abs(this.splitPhase) * 0.3,
                    name: 'Split & Merge'
                };
                
            case 'breathe':
                // Expand and contract - pulsing cohesion
                this.breathePhase = sin(t * 1.2);
                return {
                    angularMom: this.breathePhase * 0.8,
                    targetX: baseX,
                    targetY: H * 0.38,
                    cohesionMult: 0.7 + (1 + this.breathePhase) * 0.5,
                    separationMult: 1.5 - this.breathePhase * 0.4,
                    name: 'Breathe'
                };
                
            case 'ribbon':
                // Figure-8 twist
                this.ribbonPhase = t * 0.6;
                return {
                    angularMom: cos(this.ribbonPhase * 2) * 2,
                    targetX: baseX + sin(this.ribbonPhase) * 160,
                    targetY: H * 0.38 + sin(this.ribbonPhase * 2) * 70,
                    cohesionMult: 1.4,
                    name: 'Ribbon Twist'
                };
                
            case 'column':
                // Vertical rise and fall
                const columnY = sin(t * 0.7) * 100;
                return {
                    angularMom: sin(t * 3) * 0.5,
                    targetX: baseX + sin(t * 0.4) * 60,
                    targetY: H * 0.35 + columnY,
                    cohesionMult: 1.5,
                    verticalBias: cos(t * 0.7) * 0.8,
                    name: 'Column Rise'
                };
                
            case 'sweep':
                // Horizontal sweep across screen - visits tree area
                const sweepX = sin(t * 0.4) * (W * 0.32);
                return {
                    angularMom: -this.sweepDir * cos(t * 0.4) * 1.5,
                    targetX: W * 0.5 + sweepX,
                    targetY: H * 0.38 + cos(t * 0.8) * 40,
                    cohesionMult: 1.3,
                    name: 'Horizontal Sweep'
                };
                
            case 'tornado':
                // Tight spinning column
                return {
                    angularMom: this.vortexSign * 4,
                    targetX: baseX + cos(t * 0.2) * 40,
                    targetY: H * 0.38 + sin(t * 0.5) * 80,
                    cohesionMult: 1.8,
                    name: 'Tornado'
                };
                
            default:
                return {
                    angularMom: 0,
                    targetX: baseX,
                    targetY: H * 0.38,
                    cohesionMult: 1.0,
                    name: 'Default'
                };
        }
    }
};
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let attrs = [];

function updateAttractors(dt) {
    // Attractors orbit around CENTER of flying area - keeps flock visible
    const centerX = W * 0.5;
    const centerY = H * 0.38;
    
    for (let i = 0; i < attrs.length; i++) {
        const a = attrs[i];
        const phase = time * a.orbitSpeed + a.orbitPhase;
        a.x = centerX + cos(phase) * a.orbitRadius;
        a.y = centerY + sin(phase) * a.orbitRadius * 0.4 + 
              sin(phase * 2 + a.orbitPhase) * 25;
        
        // Keep attractors within bounds
        a.x = clamp(a.x, W * 0.15, W * 0.85);
        a.y = clamp(a.y, H * 0.12, H * 0.65);
    }
}

function initAttractors() {
    attrs = [
        { x: 0, y: 0, s: 1.0, orbitRadius: 140, orbitSpeed: 0.15, orbitPhase: 0 },
        { x: 0, y: 0, s: 0.7, orbitRadius: 100, orbitSpeed: -0.22, orbitPhase: PI * 0.7 },
        { x: 0, y: 0, s: 0.8, orbitRadius: 160, orbitSpeed: 0.10, orbitPhase: PI * 1.3 }
    ];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let tree, grass, birds = [], flock, pred, scare = null;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

function init() {
    resize();
    sunrise.init();
    weather.init();
    atmosphere.cur = { top: atmosphere.colors.dayTop, mid: atmosphere.colors.dayMid, hor: atmosphere.colors.dayHor };
    initClouds();
    initAttractors();
    starField.init();
    aurora.init();
    siriusStar.init();
    
    const grassY = H * 0.88;
    tree = new Tree(W * 0.82, grassY, H * 0.52);
    grass = new Grass(grassY, W, H);
    
    flock = new Flock();
    birds = [];
    Choreographer.init();
    
    // 500 BIRDS centered on screen in tight cluster
    const cx = W * 0.5, cy = H * 0.35;
    const BIRD_COUNT = 500;
    for (let i = 0; i < BIRD_COUNT; i++) {
        const a = random() * PI2;
        const r = random() * random() * random() * 60;
        birds.push(new Bird(cx + cos(a) * r, cy + sin(a) * r * 0.35, flock));
    }
    
    pred = new Predator(W * 0.15, H * 0.25);
    
    // BATS - start roosting, will wake at dusk
    batColony = new BatColony();
    bats = [];
    const BAT_COUNT = 80;
    for (let i = 0; i < BAT_COUNT; i++) {
        const bat = new Bat(
            W * 0.75 + (random() - 0.5) * W * 0.2,
            H * 0.45 + random() * H * 0.2,
            batColony
        );
        bat.st = 1;  // Start roosting
        bats.push(bat);
    }
    
    // OWL - perches on tree at night
    owl = new Owl(W * 0.78, H * 0.52);
    owl.perchPos = { x: W * 0.78, y: H * 0.52 };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastTime = 0, frameCount = 0, fpsTime = 0, showDebug = false, showMath = false;
let lastPredState = 0;
let mouseX = 0, mouseY = 0;

function frame(timestamp) {
    const dt = min(0.05, (timestamp - lastTime) / 1000);
    lastTime = timestamp;
    time += dt;
    
    frameCount++;
    fpsTime += dt;
    if (fpsTime >= 0.5) {
        const fps = frameCount / fpsTime;
        document.getElementById('fps').textContent = fps.toFixed(0) + ' FPS';
        document.getElementById('fps').className = 'fps' + (fps < 30 ? ' bad' : fps < 50 ? ' warn' : '');
        frameCount = 0; fpsTime = 0;
    }
    
    const t0 = performance.now();
    
    // Update
    sunrise.update(dt);
    weather.update(dt, sunrise.phase);
    atmosphere.update(dt, sunrise.phase);
    updateClouds(dt);
    updateAttractors(dt);
    
    const wind = 0.5 + sunrise.phase * 0.5;
    tree.update(dt, wind);
    grass.update(dt);
    
    flock.update(dt, birds);
    buildHash(birds);
    
    const flockTurnDir = flock.getTurnDir();
    const flockAngMom = flock.getAngularMomentum();
    
    // Calculate global flock center for reuniting separated birds
    let flockCenterX = 0, flockCenterY = 0;
    let flyingCount = 0;
    for (const b of birds) {
        if (b.st === 0) {
            flockCenterX += b.x;
            flockCenterY += b.y;
            flyingCount++;
        }
    }
    if (flyingCount > 0) {
        flockCenterX /= flyingCount;
        flockCenterY /= flyingCount;
    } else {
        flockCenterX = W * 0.5;
        flockCenterY = H * 0.38;
    }
    
    for (const b of birds) {
        b.update(dt, birds, attrs, scare, tree.perches, pred, flockTurnDir, flockAngMom, flockCenterX, flockCenterY);
    }
    
    pred.update(dt, birds, flock, grass.gy, tree);
    
    // STARS - update twinkling
    starField.update(dt);
    
    // AURORA - update curtain waves
    aurora.update(dt);
    
    // SIRIUS - interactive hyperreal star
    siriusStar.update(dt, mouseX, mouseY);
    
    // BATS & OWL - nocturnal creatures
    const isNightTime = sunrise.isNight || (sunrise.cyclePhase && sunrise.cyclePhase > 0.85);
    
    batColony.update(dt);
    for (const bat of bats) {
        bat.update(dt, bats, owl, tree.perches);
    }
    
    if (owl) {
        owl.update(dt, bats, tree);
    }
    
    // Sound
    const predStateChanged = pred.huntPhase !== lastPredState;
    const falconCryTrigger = predStateChanged && (pred.huntPhase === 2 || pred.huntPhase === 6);
    if (falconCryTrigger && soundSystem.enabled) {
        soundSystem.falconCry();
    }
    lastPredState = pred.huntPhase;
    
    // Calculate nightness for sound
    const nightnessSound = 1 - sunrise.phase;
    const flyingBatsCount = bats.filter(b => b.st === 0).length;
    const owlIsHunting = owl && (owl.huntPhase === 1 || owl.huntPhase === 2);
    soundSystem.update(dt, weather.rainIntensity, 0.5 + sunrise.phase * 0.5, sunrise.phase, pred.huntPhase, flock.st === 1, nightnessSound, flyingBatsCount, owlIsHunting);
    
    if (scare) {
        scare.r += dt * 80;
        scare.alpha -= dt * 0.8;
        if (scare.alpha <= 0) scare = null;
    }
    
    // Draw
    atmosphere.draw();
    starField.draw();  // Stars behind everything
    aurora.draw();     // Aurora in night sky
    sunrise.drawMoon();  // Moon at night
    siriusStar.draw(); // Interactive hyperreal star - in front of moon when zoomed
    sunrise.drawMoonlight();  // Ambient moonlight illumination
    weather.drawRainbow(W * sunrise.x, H * sunrise.y);
    drawClouds();
    sunrise.draw();
    sunrise.drawLensFlare();
    weather.drawRain();
    tree.draw();
    
    // Draw creatures with proper day/night fading
    const nightness = 1 - sunrise.phase;
    
    // STARLINGS - visible during day, fade out at dusk
    const birdAlpha = max(0, min(1, (1 - nightness - 0.2) / 0.4));  // Fade between nightness 0.2-0.6
    if (birdAlpha > 0.01) {
        ctx.save();
        ctx.globalAlpha = birdAlpha;
        drawBirds(birds);
        pred.draw();
        ctx.restore();
    }
    
    // BATS & OWL - visible at night, fade in at dusk
    // Moonlit scene makes them more visible
    const batAlpha = max(0, min(1, (nightness - 0.3) / 0.4));  // Fade between nightness 0.3-0.7
    const moonBoost = sunrise.moonPhase ? sunrise.moonPhase * 0.3 : 0;  // Brighter with moon
    if (batAlpha > 0.01) {
        ctx.save();
        ctx.globalAlpha = min(1, batAlpha + moonBoost);
        for (const bat of bats) {
            bat.draw();
        }
        if (owl) owl.draw();
        ctx.restore();
    }
    
    grass.draw();
    
    if (scare) {
        ctx.strokeStyle = `rgba(255,200,100,${scare.alpha * 0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(scare.x, scare.y, scare.r, 0, PI2);
        ctx.stroke();
    }
    
    const updMs = performance.now() - t0;
    
    // Debug
    if (showDebug) {
        const flying = birds.filter(b => b.st === 0).length;
        const perched = birds.filter(b => b.st === 2).length;
        
        // Calculate average density
        let totalDensity = 0;
        for (const b of birds) if (b.st === 0) totalDensity += b.localDensity;
        const avgDensity = flying > 0 ? (totalDensity / flying).toFixed(2) : '0';
        
        document.getElementById('sunPhase').textContent = sunrise.phase.toFixed(2);
        document.getElementById('weatherState').textContent = weather.stateName();
        document.getElementById('rainInt').textContent = (weather.rainIntensity * 100).toFixed(0) + '%';
        document.getElementById('rainbowVis').textContent = (weather.rainbowVisible * 100).toFixed(0) + '%';
        document.getElementById('soundState').textContent = soundSystem.enabled ? 'ON' : 'OFF';
        // Sync mobile button state
        const soundBtn = document.getElementById('btnSound');
        if (soundBtn) {
            soundBtn.classList.toggle('toggle-on', soundSystem.enabled);
            soundBtn.querySelector('.icon').textContent = soundSystem.enabled ? 'ğŸ”Š' : 'ğŸ”‡';
        }
        const rainBtn = document.getElementById('btnRain');
        if (rainBtn) rainBtn.classList.toggle('toggle-on', weather.manualRain);
        document.getElementById('flockCoh').textContent = (flock.crr.C / flock.crr.omega).toFixed(2);
        document.getElementById('flockState').textContent = flock.stateName();
        document.getElementById('currentMove').textContent = Choreographer.currentMove;
        document.getElementById('flockDensity').textContent = avgDensity;
        document.getElementById('birds').textContent = `${flying}/${perched}`;
        document.getElementById('predState').textContent = pred.stateName();
        document.getElementById('predCoh').textContent = (pred.huntCRR.C / pred.huntCRR.omega).toFixed(2);
        
        // Night creatures
        const flyingBats = bats.filter(b => b.st === 0).length;
        const roosting = bats.length - flyingBats;
        document.getElementById('batCount').textContent = `${flyingBats}/${roosting}`;
        document.getElementById('owlState').textContent = owl ? owl.stateName() : '-';
        
        document.getElementById('upd').textContent = updMs.toFixed(1);
        
        // Show cycle phase
        const cyclePhaseStr = sunrise.cyclePhase ? sunrise.cyclePhase.toFixed(2) : '0.00';
        document.getElementById('sunPhase').textContent = `${sunrise.phase.toFixed(2)} (${cyclePhaseStr})`;
    }
    
    requestAnimationFrame(frame);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('resize', () => {
    resize();
    grass = new Grass(H * 0.88, W, H);
    siriusStar.init();  // Reinitialize position on resize
});

// Track mouse position for Sirius star interaction
canvas.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

// Touch move tracking for Sirius hover
canvas.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
    }
}, { passive: true });

// Scroll wheel for Sirius zoom - on document for reliability
let lastScrollTime = 0;
document.addEventListener('wheel', (e) => {
    const now = performance.now();
    // Debounce rapid scroll events (trackpad momentum can cause issues)
    if (now - lastScrollTime < 30) return;  // Throttle to ~30fps
    lastScrollTime = now;
    
    // Use actual deltaY for smoother control (normalized)
    const delta = -e.deltaY * 0.002;  // Negative because scroll down = positive deltaY
    const clamped = max(-0.3, min(0.3, delta));  // Clamp to prevent huge jumps
    
    if (siriusStar.onScrollDelta(clamped, e.clientX, e.clientY)) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, { passive: false });

canvas.addEventListener('click', (e) => {
    // Check if clicking on Sirius star first
    if (siriusStar.onClick()) {
        return;  // Handled by Sirius
    }
    
    // Otherwise, startle the flock
    scare = { x: e.clientX, y: e.clientY, r: 30, alpha: 1 };
    flock.rupture();
    soundSystem.flockStartle();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOBILE TOUCH HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let touchStartTime = 0;
let touchStartPos = { x: 0, y: 0 };
let lastTouchDist = 0;
let isPinching = false;
let lastTapTime = 0;
let siriusHintShown = false;

function getTouchDist(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return sqrt(dx * dx + dy * dy);
}

function getTouchCenter(touches) {
    return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
    };
}

function isNearSirius(x, y) {
    const starX = W * 0.28;
    const starY = H * 0.18;
    const dx = x - starX;
    const dy = y - starY;
    const dist = sqrt(dx * dx + dy * dy);
    const hitRadius = 120 + siriusStar.targetZoom * 200;
    return dist < hitRadius;
}

function showSiriusHint() {
    if (siriusHintShown) return;
    const nightness = 1 - sunrise.phase;
    if (nightness < 0.4) return;
    
    const hint = document.getElementById('siriusHint');
    hint.classList.add('show');
    siriusHintShown = true;
    setTimeout(() => hint.classList.remove('show'), 3000);
}

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchStartTime = performance.now();
    
    if (e.touches.length === 1) {
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        mouseX = touchStartPos.x;
        mouseY = touchStartPos.y;
        isPinching = false;
        
        // Show Sirius hint if near it
        if (isNearSirius(touchStartPos.x, touchStartPos.y)) {
            showSiriusHint();
        }
    } else if (e.touches.length === 2) {
        isPinching = true;
        lastTouchDist = getTouchDist(e.touches);
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    
    if (e.touches.length === 2 && isPinching) {
        // Pinch zoom for Sirius
        const center = getTouchCenter(e.touches);
        const newDist = getTouchDist(e.touches);
        const delta = (newDist - lastTouchDist) * 0.008;
        lastTouchDist = newDist;
        
        // Check if pinch center is near Sirius
        if (isNearSirius(center.x, center.y)) {
            siriusStar.targetZoom = max(0, min(1, siriusStar.targetZoom + delta));
            siriusStar.zoomLevel = siriusStar.targetZoom;
        }
    } else if (e.touches.length === 1) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
    }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    const touchDuration = performance.now() - touchStartTime;
    
    if (!isPinching && touchDuration < 300 && e.changedTouches.length === 1) {
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        const dx = endX - touchStartPos.x;
        const dy = endY - touchStartPos.y;
        const dist = sqrt(dx * dx + dy * dy);
        
        // Only register as tap if finger didn't move much
        if (dist < 20) {
            const now = performance.now();
            
            // Double-tap detection for Sirius
            if (now - lastTapTime < 350 && isNearSirius(endX, endY)) {
                // Double-tap on Sirius - toggle zoom
                if (siriusStar.targetZoom > 0.5) {
                    siriusStar.targetZoom = 0;
                } else {
                    siriusStar.targetZoom = 1;
                }
                lastTapTime = 0;
                return;
            }
            lastTapTime = now;
            
            // Single tap - check Sirius first
            mouseX = endX;
            mouseY = endY;
            const nightness = 1 - sunrise.phase;
            if (nightness > 0.4 && isNearSirius(endX, endY)) {
                // Near Sirius but single tap - show hint
                showSiriusHint();
                return;
            }
            
            // Otherwise startle flock
            scare = { x: endX, y: endY, r: 30, alpha: 1 };
            flock.rupture();
            soundSystem.flockStartle();
        }
    }
    
    isPinching = false;
}, { passive: true });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOBILE CONTROL BUTTONS - Using pointerup for reliable touch/mouse handling
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addButtonHandler(id, handler) {
    const btn = document.getElementById(id);
    if (!btn) return;
    
    // Use pointerup for unified touch/mouse handling
    btn.addEventListener('pointerup', (e) => {
        e.preventDefault();
        e.stopPropagation();
        handler();
    });
    
    // Prevent context menu on long press
    btn.addEventListener('contextmenu', (e) => e.preventDefault());
}

addButtonHandler('btnMath', () => {
    showMath = !showMath;
    document.getElementById('mathPanel').classList.toggle('show', showMath);
    document.getElementById('btnMath').classList.toggle('toggle-on', showMath);
});

addButtonHandler('btnDebug', () => {
    showDebug = !showDebug;
    document.getElementById('debug').classList.toggle('show', showDebug);
    document.getElementById('btnDebug').classList.toggle('toggle-on', showDebug);
});

addButtonHandler('btnRain', () => {
    weather.manualRain = !weather.manualRain;
    if (weather.manualRain && weather.state === 0) {
        weather.state = 1;
    } else if (!weather.manualRain && weather.state === 2) {
        weather.state = 3;
    }
    document.getElementById('btnRain').classList.toggle('toggle-on', weather.manualRain);
});

addButtonHandler('btnSound', () => {
    const enabled = soundSystem.toggle();
    document.getElementById('btnSound').classList.toggle('toggle-on', enabled);
    document.getElementById('btnSound').querySelector('.icon').textContent = enabled ? 'ğŸ”Š' : 'ğŸ”‡';
});

addButtonHandler('btnNight', () => {
    sunrise.cyclePhase = 1.0;
    sunrise.phase = 0;
    sunrise.targetPhase = 0;
    sunrise.isNight = true;
    sunrise.isDay = false;
    sunrise.moonPhase = 0.5;
    sunrise.nightHoldTime = 0;
    atmosphere.cur = { 
        top: atmosphere.colors.nightTop, 
        mid: atmosphere.colors.nightMid, 
        hor: atmosphere.colors.nightHor 
    };
});

addButtonHandler('btnDay', () => {
    sunrise.cyclePhase = 0.5;
    sunrise.phase = 1;
    sunrise.targetPhase = 1;
    sunrise.isNight = false;
    sunrise.isDay = true;
    sunrise.moonPhase = 0;
    sunrise.dayHoldTime = 0;
    atmosphere.cur = { 
        top: atmosphere.colors.dayTop, 
        mid: atmosphere.colors.dayMid, 
        hor: atmosphere.colors.dayHor 
    };
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'c') {
        showDebug = !showDebug;
        document.getElementById('debug').classList.toggle('show', showDebug);
    }
    if (e.key === 'm') {
        showMath = !showMath;
        document.getElementById('mathPanel').classList.toggle('show', showMath);
    }
    if (e.key === 'r') {
        weather.manualRain = !weather.manualRain;
        if (weather.manualRain && weather.state === 0) {
            weather.state = 1;
        } else if (!weather.manualRain && weather.state === 2) {
            weather.state = 3;
        }
    }
    if (e.key === 's') {
        const enabled = soundSystem.toggle();
        console.log('Sound:', enabled ? 'ON' : 'OFF');
    }
    if (e.key === 'n') {
        // Skip to night for testing Sirius
        sunrise.cyclePhase = 1.0;
        sunrise.phase = 0;
        sunrise.targetPhase = 0;
        sunrise.isNight = true;
        sunrise.isDay = false;
        sunrise.moonPhase = 0.5;
        sunrise.nightHoldTime = 0;
        // Update atmosphere to night colors
        atmosphere.cur = { 
            top: atmosphere.colors.nightTop, 
            mid: atmosphere.colors.nightMid, 
            hor: atmosphere.colors.nightHor 
        };
    }
    if (e.key === 'd') {
        // Skip to day
        sunrise.cyclePhase = 0.5;
        sunrise.phase = 1;
        sunrise.targetPhase = 1;
        sunrise.isNight = false;
        sunrise.isDay = true;
        sunrise.moonPhase = 0;
        sunrise.dayHoldTime = 0;
        // Update atmosphere to day colors
        atmosphere.cur = { 
            top: atmosphere.colors.dayTop, 
            mid: atmosphere.colors.dayMid, 
            hor: atmosphere.colors.dayHor 
        };
    }
    // Zoom Sirius with + and - keys
    if (e.key === '+' || e.key === '=') {
        siriusStar.targetZoom = min(1, siriusStar.targetZoom + 0.15);
    }
    if (e.key === '-' || e.key === '_') {
        siriusStar.targetZoom = max(0, siriusStar.targetZoom - 0.15);
    }
});

// Start
init();
requestAnimationFrame(frame);

</script>
</body>
</html>
