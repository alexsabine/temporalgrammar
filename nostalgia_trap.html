<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Trap of Nostalgia | CRR</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: Georgia, 'Times New Roman', serif;
            background: #f5f5f5;
            color: #1a1a1a;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
            max-width: 600px;
            padding: 2rem;
        }

        .poem-line {
            font-size: 1.4rem;
            font-style: italic;
            color: #333;
            opacity: 0;
            transition: opacity 2s ease;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 30px #f5f5f5, 0 0 60px #f5f5f5;
        }

        .poem-line.visible { opacity: 1; }
        .poem-line.fading { opacity: 0.3; }

        .title-overlay {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
        }

        .title-overlay h1 {
            font-size: 1.8rem;
            font-weight: normal;
            color: #333;
            letter-spacing: 0.05em;
        }

        .title-overlay p {
            font-size: 0.95rem;
            color: #666;
            font-style: italic;
            margin-top: 0.3rem;
        }

        .controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 1rem;
        }

        button {
            font-family: Georgia, serif;
            font-size: 0.9rem;
            padding: 0.6rem 1.5rem;
            border: 1px solid #999;
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #333;
            color: #fff;
            border-color: #333;
        }

        .info {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            font-size: 0.8rem;
            color: #888;
            text-align: right;
            z-index: 10;
        }

        .year-display {
            position: absolute;
            top: 5rem;
            right: 2rem;
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #666;
            z-index: 10;
        }

        .coherence-display {
            position: absolute;
            top: 7rem;
            right: 2rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #888;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas"></canvas>
        
        <div class="title-overlay">
            <h1>The Trap of Nostalgia</h1>
            <p>after Ted Hughes' "The Rain Horse"</p>
        </div>

        <div class="text-overlay">
            <div class="poem-line" id="line1"></div>
            <div class="poem-line" id="line2"></div>
            <div class="poem-line" id="line3"></div>
        </div>

        <div class="year-display" id="yearDisplay">Year 0</div>
        <div class="coherence-display" id="coherenceDisplay">C = 0.000</div>

        <div class="controls">
            <button id="returnBtn">Attempt Return</button>
            <button id="forwardBtn">Move Forward</button>
            <button id="resetBtn">Begin Again</button>
        </div>

        <div class="info">
            <div>Basin depth fades with absence</div>
            <div>The horse emerges in the space between</div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height, dpr;
    
    function resize() {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);
    }
    resize();
    window.addEventListener('resize', resize);

    // Poems
    const poems = [
        { trigger: 'start', lines: [
            "He sought the meaningful sensation",
            "he remembered from youth—",
            "but found only the dullness of feeling nothing."
        ]},
        { trigger: 'return', lines: [
            "The basin he once knew",
            "exists now only as ghost,",
            "a memory the landscape no longer holds."
        ]},
        { trigger: 'horse', lines: [
            "Then the horse appears—",
            "black, wild, malevolent—",
            "what backward movement summons."
        ]},
        { trigger: 'trapped', lines: [
            "Nostalgia is the belief",
            "that backward movement through time is possible,",
            "that what rupture dissolved can be reconstituted."
        ]},
        { trigger: 'forward', lines: [
            "The only path is through—",
            "not return but continuation,",
            "not recovery but regeneration."
        ]},
        { trigger: 'peace', lines: [
            "What feels like loss",
            "is transformation waiting;",
            "the new basin forming."
        ]}
    ];

    let currentPoem = null;

    function showPoem(triggerName) {
        const poem = poems.find(p => p.trigger === triggerName);
        if (!poem) return;
        currentPoem = { ...poem, startTime: Date.now() };
    }

    function updatePoem() {
        const line1 = document.getElementById('line1');
        const line2 = document.getElementById('line2');
        const line3 = document.getElementById('line3');
        
        if (!currentPoem) {
            line1.classList.remove('visible', 'fading');
            line2.classList.remove('visible', 'fading');
            line3.classList.remove('visible', 'fading');
            return;
        }

        const elapsed = Date.now() - currentPoem.startTime;
        
        line1.textContent = currentPoem.lines[0] || '';
        line2.textContent = currentPoem.lines[1] || '';
        line3.textContent = currentPoem.lines[2] || '';

        if (elapsed > 500) line1.classList.add('visible');
        if (elapsed > 1500) line2.classList.add('visible');
        if (elapsed > 2500) line3.classList.add('visible');

        if (elapsed > 8000) {
            line1.classList.add('fading');
            line2.classList.add('fading');
            line3.classList.add('fading');
        }
        if (elapsed > 10000) {
            line1.classList.remove('visible', 'fading');
            line2.classList.remove('visible', 'fading');
            line3.classList.remove('visible', 'fading');
            currentPoem = null;
        }
    }

    // State
    let state = {
        time: 0,
        yearsPassed: 0,
        x: 0.25,
        coherence: 0,
        mode: 'present',
        homeBasinDepth: 1.0,
        presentBasinDepth: 0.3,
        horsePresence: 0,
        horseX: 0.5,
        raindrops: [],
        memories: [],
        velocityX: 0,
        displayX: 0.25,
        trapped: false,
        atPeace: false
    };

    // Rain
    function createRaindrop() {
        return {
            x: Math.random() * width,
            y: -20,
            speed: 6 + Math.random() * 8,
            length: 20 + Math.random() * 35,
            opacity: 0.2 + Math.random() * 0.4,
            wind: -2 - Math.random() * 2
        };
    }

    for (let i = 0; i < 300; i++) {
        const drop = createRaindrop();
        drop.y = Math.random() * height;
        state.raindrops.push(drop);
    }

    function addMemory(x, intensity) {
        state.memories.push({
            x: x,
            opacity: intensity * 0.4,
            age: 0
        });
    }

    // Landscape
    function landscape(x) {
        const homeWell = state.homeBasinDepth * 0.8 * Math.exp(-Math.pow(x - 0.25, 2) / 0.02);
        const presentWell = state.presentBasinDepth * 0.6 * Math.exp(-Math.pow(x - 0.75, 2) / 0.03);
        const barrier = 0.4 * Math.exp(-Math.pow(x - 0.5, 2) / 0.01);
        const horseWell = state.horsePresence * 0.5 * Math.exp(-Math.pow(x - 0.5, 2) / 0.015);
        return -homeWell - presentWell + barrier + horseWell * 0.5;
    }

    function landscapeGradient(x) {
        const dx = 0.001;
        return (landscape(x + dx) - landscape(x - dx)) / (2 * dx);
    }

    // Draw horse silhouette
    function drawHorse(hx, groundY, scale, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#1a1a1a';
        ctx.strokeStyle = '#1a1a1a';
        
        const breathe = Math.sin(state.time * 1.5) * 3;
        const legPhase = state.time * 2.5;
        
        // Dimensions
        const bodyLen = 90 * scale;
        const bodyH = 40 * scale;
        const legLen = 55 * scale;
        const neckLen = 45 * scale;
        const headLen = 38 * scale;
        
        const bodyY = groundY - legLen - bodyH / 2 + breathe;
        const cx = hx;
        
        // Body
        ctx.beginPath();
        ctx.ellipse(cx, bodyY, bodyLen / 2, bodyH / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Hindquarters (slightly larger)
        ctx.beginPath();
        ctx.ellipse(cx - bodyLen * 0.25, bodyY + 5 * scale, bodyLen * 0.3, bodyH * 0.55, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Neck
        const neckStartX = cx + bodyLen * 0.35;
        const neckStartY = bodyY - bodyH * 0.25;
        const neckEndX = neckStartX + neckLen * 0.4;
        const neckEndY = neckStartY - neckLen * 0.8;
        
        ctx.beginPath();
        ctx.moveTo(neckStartX - 12 * scale, neckStartY + 5 * scale);
        ctx.bezierCurveTo(
            neckStartX - 5 * scale, neckStartY - neckLen * 0.4,
            neckEndX - 15 * scale, neckEndY + 10 * scale,
            neckEndX - 8 * scale, neckEndY
        );
        ctx.lineTo(neckEndX + 10 * scale, neckEndY + 8 * scale);
        ctx.bezierCurveTo(
            neckEndX + 5 * scale, neckEndY + 20 * scale,
            neckStartX + 15 * scale, neckStartY - neckLen * 0.2,
            neckStartX + 12 * scale, neckStartY + 10 * scale
        );
        ctx.closePath();
        ctx.fill();
        
        // Head
        const headX = neckEndX + headLen * 0.35;
        const headY = neckEndY - 5 * scale;
        
        ctx.beginPath();
        ctx.ellipse(headX, headY, headLen / 2, headLen / 3, 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Jaw
        ctx.beginPath();
        ctx.ellipse(headX + headLen * 0.15, headY + headLen * 0.15, headLen * 0.35, headLen * 0.18, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.beginPath();
        ctx.moveTo(headX - 6 * scale, headY - 8 * scale);
        ctx.quadraticCurveTo(headX - 10 * scale, headY - 28 * scale, headX - 2 * scale, headY - 14 * scale);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(headX + 2 * scale, headY - 10 * scale);
        ctx.quadraticCurveTo(headX + 6 * scale, headY - 30 * scale, headX + 12 * scale, headY - 14 * scale);
        ctx.fill();
        
        // Mane (wild, flowing)
        ctx.lineWidth = 2.5 * scale;
        ctx.lineCap = 'round';
        for (let i = 0; i < 12; i++) {
            const t = i / 11;
            const mx = neckStartX + (neckEndX - neckStartX) * t * 0.8;
            const my = neckStartY + (neckEndY - neckStartY) * t - 8 * scale;
            const wave = Math.sin(state.time * 3 + i * 0.4) * 8 * scale;
            const len = (15 + i * 2) * scale;
            
            ctx.beginPath();
            ctx.moveTo(mx, my);
            ctx.quadraticCurveTo(
                mx - len * 0.6 + wave,
                my + len * 0.3,
                mx - len + wave * 1.3,
                my + len * 0.8
            );
            ctx.stroke();
        }
        
        // Forelock
        for (let i = 0; i < 4; i++) {
            const wave = Math.sin(state.time * 3.5 + i * 0.3) * 5 * scale;
            ctx.beginPath();
            ctx.moveTo(headX - 5 * scale + i * 3 * scale, headY - 12 * scale);
            ctx.quadraticCurveTo(
                headX - 10 * scale + wave,
                headY - 5 * scale,
                headX - 15 * scale + wave,
                headY + 5 * scale
            );
            ctx.stroke();
        }
        
        // Four legs with proper joints
        const legs = [
            { x: cx + bodyLen * 0.3, front: true, phase: 0 },
            { x: cx + bodyLen * 0.15, front: true, phase: 0.5 },
            { x: cx - bodyLen * 0.25, front: false, phase: 1.0 },
            { x: cx - bodyLen * 0.38, front: false, phase: 1.5 }
        ];
        
        ctx.lineWidth = 7 * scale;
        ctx.lineCap = 'round';
        
        legs.forEach(leg => {
            const swing = Math.sin(legPhase + leg.phase * Math.PI) * 10 * scale;
            const hipY = bodyY + bodyH * 0.25;
            const kneeY = hipY + legLen * 0.45;
            const ankleY = hipY + legLen * 0.8;
            const hoofY = groundY - 8 * scale;
            
            const kneeOffset = leg.front ? swing * 0.3 : -swing * 0.3;
            const hoofOffset = leg.front ? swing * 0.6 : -swing * 0.4;
            
            // Upper leg
            ctx.beginPath();
            ctx.moveTo(leg.x, hipY);
            ctx.quadraticCurveTo(
                leg.x + kneeOffset * 0.5,
                (hipY + kneeY) / 2,
                leg.x + kneeOffset,
                kneeY
            );
            ctx.stroke();
            
            // Lower leg
            ctx.beginPath();
            ctx.moveTo(leg.x + kneeOffset, kneeY);
            ctx.quadraticCurveTo(
                leg.x + kneeOffset * 0.8,
                (kneeY + ankleY) / 2,
                leg.x + hoofOffset * 0.7,
                ankleY
            );
            ctx.stroke();
            
            // Cannon/pastern
            ctx.lineWidth = 5 * scale;
            ctx.beginPath();
            ctx.moveTo(leg.x + hoofOffset * 0.7, ankleY);
            ctx.lineTo(leg.x + hoofOffset, hoofY);
            ctx.stroke();
            ctx.lineWidth = 7 * scale;
            
            // Hoof
            ctx.beginPath();
            ctx.ellipse(leg.x + hoofOffset, hoofY + 3 * scale, 6 * scale, 4 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Tail (flowing)
        const tailX = cx - bodyLen * 0.5;
        const tailY = bodyY + bodyH * 0.1;
        ctx.lineWidth = 4 * scale;
        
        for (let i = 0; i < 8; i++) {
            const wave = Math.sin(state.time * 2.5 + i * 0.3) * 12 * scale;
            ctx.beginPath();
            ctx.moveTo(tailX - i * 2 * scale, tailY + i * 3 * scale);
            ctx.bezierCurveTo(
                tailX - 25 * scale + wave,
                tailY + 25 * scale,
                tailX - 35 * scale + wave * 1.2,
                tailY + 50 * scale,
                tailX - 30 * scale + wave * 1.5,
                tailY + 70 * scale + i * 3 * scale
            );
            ctx.stroke();
        }
        
        // Eye (glinting white)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(headX + 6 * scale, headY - 2 * scale, 4 * scale, 3 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupil
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(headX + 7 * scale, headY - 2 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Nostril
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.ellipse(headX + headLen * 0.42, headY + headLen * 0.15, 3 * scale, 2 * scale, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    showPoem('start');

    function step() {
        const dt = 0.016;
        state.time += dt;

        if (state.mode === 'present' || state.mode === 'forward') {
            state.yearsPassed += dt * 0.5;
        }

        // Home basin fades
        if (state.x > 0.4) {
            state.homeBasinDepth *= 0.9995;
            state.homeBasinDepth = Math.max(0.1, state.homeBasinDepth);
        }

        // Present basin deepens
        if (state.x > 0.6 && state.mode === 'forward') {
            state.presentBasinDepth += dt * 0.02;
            state.presentBasinDepth = Math.min(1.0, state.presentBasinDepth);
        }

        if (state.mode === 'returning') {
            const targetX = 0.25;
            state.velocityX += (targetX - state.x) * 0.001;
            
            if (state.x > 0.35 && state.x < 0.65) {
                state.horsePresence += dt * 0.3;
                state.horsePresence = Math.min(1.0, state.horsePresence);
            }
            
            if (state.horsePresence > 0.7 && !state.trapped) {
                state.trapped = true;
                showPoem('trapped');
            }
        } else if (state.mode === 'forward') {
            const targetX = 0.75;
            state.velocityX += (targetX - state.x) * 0.0008;
            state.horsePresence *= 0.98;
            
            if (state.x > 0.7 && state.presentBasinDepth > 0.6 && !state.atPeace) {
                state.atPeace = true;
                showPoem('peace');
            }
        } else {
            const grad = landscapeGradient(state.x);
            state.velocityX -= grad * 0.0001;
        }

        state.velocityX *= 0.98;
        state.x += state.velocityX;
        state.x = Math.max(0.05, Math.min(0.95, state.x));
        state.displayX += (state.x - state.displayX) * 0.08;

        const energy = landscape(state.x);
        const coherenceRate = 1 / (1 + Math.abs(energy));
        state.coherence += coherenceRate * dt;

        if (Math.random() < 0.1) addMemory(state.x, coherenceRate);

        // Rain
        state.raindrops.forEach(drop => {
            drop.y += drop.speed;
            drop.x += drop.wind;
            if (drop.y > height + 30) {
                drop.y = -30;
                drop.x = Math.random() * width;
            }
            if (drop.x < -20) drop.x = width + 20;
        });

        state.memories = state.memories.filter(m => {
            m.age += dt;
            m.opacity *= 0.995;
            return m.opacity > 0.01 && m.age < 30;
        });

        if (state.horsePresence > 0.1) {
            state.horseX += (state.x - state.horseX) * 0.015 + (Math.random() - 0.5) * 0.005;
        }

        document.getElementById('yearDisplay').textContent = `Year ${Math.floor(state.yearsPassed)}`;
        document.getElementById('coherenceDisplay').textContent = `C = ${state.coherence.toFixed(3)}`;
    }

    function draw() {
        // Sky gradient based on horse presence
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        const darkness = state.horsePresence * 0.3;
        skyGradient.addColorStop(0, `rgb(${200 - darkness * 80}, ${200 - darkness * 80}, ${210 - darkness * 60})`);
        skyGradient.addColorStop(1, `rgb(${245 - darkness * 50}, ${245 - darkness * 50}, ${245 - darkness * 40})`);
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);

        const padL = width * 0.1;
        const padR = width * 0.1;
        const plotW = width - padL - padR;
        const groundY = height * 0.65;

        // Rain - heavier with horse presence
        const rainIntensity = 0.5 + state.horsePresence * 0.5;
        ctx.lineCap = 'round';
        state.raindrops.forEach(drop => {
            ctx.globalAlpha = drop.opacity * rainIntensity;
            ctx.strokeStyle = `rgba(60, 70, 90, 0.7)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x + drop.wind * 4, drop.y + drop.length);
            ctx.stroke();
        });
        ctx.globalAlpha = 1;

        // Puddle reflections on ground
        if (state.horsePresence > 0.2) {
            for (let i = 0; i < 5; i++) {
                const px = padL + (0.2 + i * 0.15) * plotW;
                const py = groundY + 80 + i * 10;
                ctx.globalAlpha = state.horsePresence * 0.15;
                ctx.fillStyle = 'rgba(100, 110, 130, 0.3)';
                ctx.beginPath();
                ctx.ellipse(px, py, 40 + i * 10, 8, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // Memory traces
        state.memories.forEach(m => {
            const mx = padL + m.x * plotW;
            ctx.beginPath();
            ctx.arc(mx, groundY - 20, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(100, 100, 120, ${m.opacity})`;
            ctx.fill();
        });

        // Landscape
        ctx.beginPath();
        for (let i = 0; i <= 200; i++) {
            const lx = i / 200;
            const ly = landscape(lx);
            const px = padL + lx * plotW;
            const py = groundY - ly * 150;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Ghost of original basin
        if (state.homeBasinDepth < 0.9) {
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const lx = i / 100 * 0.5;
                const originalDepth = 0.8 * Math.exp(-Math.pow(lx - 0.25, 2) / 0.02);
                const currentDepth = state.homeBasinDepth * 0.8 * Math.exp(-Math.pow(lx - 0.25, 2) / 0.02);
                const ghostDepth = originalDepth - currentDepth;
                const px = padL + lx * plotW;
                const py = groundY + ghostDepth * 150;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.strokeStyle = `rgba(100, 100, 120, ${0.4 * (1 - state.homeBasinDepth)})`;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Labels
        ctx.font = '14px Georgia';
        ctx.fillStyle = `rgba(80, 80, 90, ${state.homeBasinDepth * 0.7 + 0.2})`;
        ctx.textAlign = 'center';
        ctx.fillText('what was', padL + 0.25 * plotW, groundY + 60);
        
        ctx.fillStyle = `rgba(80, 80, 90, ${state.presentBasinDepth * 0.7 + 0.2})`;
        ctx.fillText('what could be', padL + 0.75 * plotW, groundY + 60);

        // Draw the horse
        if (state.horsePresence > 0.05) {
            const hx = padL + state.horseX * plotW;
            const baseY = groundY - landscape(state.horseX) * 150;
            
            // Mist around horse
            const mistGradient = ctx.createRadialGradient(hx, baseY - 50, 0, hx, baseY - 50, 180);
            mistGradient.addColorStop(0, `rgba(60, 60, 70, ${state.horsePresence * 0.2})`);
            mistGradient.addColorStop(0.6, `rgba(100, 100, 110, ${state.horsePresence * 0.1})`);
            mistGradient.addColorStop(1, 'rgba(200, 200, 200, 0)');
            ctx.fillStyle = mistGradient;
            ctx.fillRect(hx - 200, baseY - 200, 400, 250);
            
            const scale = 0.7 + state.horsePresence * 0.5;
            drawHorse(hx, baseY, scale, state.horsePresence * 0.85);
            
            if (state.horsePresence > 0.3) {
                ctx.font = 'italic 13px Georgia';
                ctx.fillStyle = `rgba(40, 40, 50, ${state.horsePresence * 0.6})`;
                ctx.textAlign = 'center';
                ctx.fillText('what backward movement summons', hx, baseY + 45);
            }
        }

        // Wanderer
        const wx = padL + state.displayX * plotW;
        const wy = groundY - landscape(state.displayX) * 150 - 15;

        const glowRadius = 15 + Math.min(state.coherence, 2) * 10;
        const gradient = ctx.createRadialGradient(wx, wy, 0, wx, wy, glowRadius);
        gradient.addColorStop(0, 'rgba(80, 80, 100, 0.3)');
        gradient.addColorStop(1, 'rgba(80, 80, 100, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(wx, wy, glowRadius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(wx, wy - 8, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(wx, wy - 2);
        ctx.lineTo(wx, wy + 15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(wx, wy + 15);
        ctx.lineTo(wx - 6, wy + 30);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(wx, wy + 15);
        ctx.lineTo(wx + 6, wy + 30);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(wx, wy + 5);
        ctx.lineTo(wx - 8, wy + 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(wx, wy + 5);
        ctx.lineTo(wx + 8, wy + 12);
        ctx.stroke();

        updatePoem();
    }

    function animate() {
        step();
        draw();
        requestAnimationFrame(animate);
    }

    document.getElementById('returnBtn').addEventListener('click', () => {
        if (state.mode !== 'returning') {
            state.mode = 'returning';
            state.trapped = false;
            showPoem('return');
            setTimeout(() => {
                if (state.mode === 'returning' && state.horsePresence < 0.3) {
                    showPoem('horse');
                }
            }, 4000);
        }
    });

    document.getElementById('forwardBtn').addEventListener('click', () => {
        state.mode = 'forward';
        state.trapped = false;
        state.atPeace = false;
        showPoem('forward');
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        state = {
            time: 0,
            yearsPassed: 0,
            x: 0.25,
            coherence: 0,
            mode: 'present',
            homeBasinDepth: 1.0,
            presentBasinDepth: 0.3,
            horsePresence: 0,
            horseX: 0.5,
            raindrops: state.raindrops,
            memories: [],
            velocityX: 0,
            displayX: 0.25,
            trapped: false,
            atPeace: false
        };
        showPoem('start');
    });

    animate();
    </script>
</body>
</html>
