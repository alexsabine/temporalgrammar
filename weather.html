<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Thunderstorm - Physically Accurate Bidirectional Lightning</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #ffffff;
            color: #1a1a1a;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }

        .main-container {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.06);
            max-width: 1400px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .header .subtitle {
            color: #666666;
            font-size: 1rem;
            font-weight: 400;
            margin-bottom: 20px;
        }

        .math-explanation {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            margin-bottom: 30px;
        }

        .math-explanation-header {
            padding: 16px 20px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
            border-bottom: 1px solid #dee2e6;
        }

        .math-explanation-header:hover {
            background: #f8f9fa;
        }

        .math-explanation-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: #495057;
        }

        .math-explanation-arrow {
            font-size: 1.2rem;
            color: #6c757d;
            transition: transform 0.3s ease;
        }

        .math-explanation-arrow.open {
            transform: rotate(180deg);
        }

        .math-explanation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .math-explanation-content.open {
            max-height: 600px;
            overflow-y: auto;
        }

        .math-explanation-inner {
            padding: 24px;
            line-height: 1.7;
        }

        .math-section {
            margin-bottom: 24px;
        }

        .math-section h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #212529;
            margin-bottom: 12px;
        }

        .math-section p {
            color: #495057;
            margin-bottom: 12px;
            font-size: 0.9rem;
        }

        .equation-block {
            background: #ffffff;
            border: 1px solid #dee2e6;
            padding: 16px;
            margin: 16px 0;
            overflow-x: auto;
        }

        .code-mapping {
            background: #f8f9fa;
            border-left: 3px solid #6c757d;
            padding: 12px 16px;
            margin: 12px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #212529;
        }

        .mapping-arrow {
            color: #6c757d;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .equation-banner {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            font-family: 'Georgia', monospace;
            font-size: 0.95rem;
            color: #495057;
            margin-bottom: 30px;
        }

        .crr-status {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #2563eb;
            border-radius: 12px;
            padding: 25px;
            text-align: left;
            box-shadow: 0 4px 20px rgba(37, 99, 235, 0.1);
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .crr-status.coherence {
            border-color: #059669;
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.03) 0%, rgba(16, 185, 129, 0.05) 100%);
        }

        .crr-status.rupture {
            border-color: #dc2626;
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.03) 0%, rgba(239, 68, 68, 0.05) 100%);
        }

        .crr-status.regeneration {
            border-color: #7c3aed;
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.03) 0%, rgba(139, 92, 246, 0.05) 100%);
        }

        .current-phase {
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            color: #2563eb;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .crr-status.coherence .current-phase { color: #059669; }
        .crr-status.rupture .current-phase { color: #dc2626; }
        .crr-status.regeneration .current-phase { color: #7c3aed; }

        .phase-description {
            font-size: 0.9rem;
            color: #666666;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .code-snippet {
            background: #1e293b;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
            overflow-x: auto;
            border-left: 4px solid #2563eb;
        }

        .crr-status.coherence .code-snippet { border-left-color: #059669; }
        .crr-status.rupture .code-snippet { border-left-color: #dc2626; }
        .crr-status.regeneration .code-snippet { border-left-color: #7c3aed; }

        .code-comment {
            color: #94a3b8;
        }

        .code-function {
            color: #fbbf24;
        }

        .code-variable {
            color: #34d399;
        }

        .code-operator {
            color: #f472b6;
        }

        .coherence-display {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .coherence-display h3 {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coherence-graph {
            width: 100%;
            height: 120px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            position: relative;
            margin-bottom: 15px;
        }

        #coherence-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .coherence-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .coherence-metric {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }

        .coherence-label {
            color: #6c757d;
        }

        .coherence-value {
            font-weight: 500;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        .simulation-area {
            position: relative;
            width: 100%;
            height: 650px;
            background: linear-gradient(135deg, #87ceeb, #4682b4);
            border: 2px solid #e5e5e5;
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        #atmosphere-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .button-row {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .control-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            color: #374151;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #f9fafb;
            border-color: #2563eb;
            color: #2563eb;
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: #2563eb;
            color: #ffffff;
            border-color: #2563eb;
        }

        .control-btn.audio-enabled {
            background: #16a34a;
            color: #ffffff;
            border-color: #16a34a;
        }

        .control-btn.audio-error {
            background: #dc2626;
            color: #ffffff;
            border-color: #dc2626;
        }

        .controls-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
        }

        .control-panel h3 {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: #6c757d;
        }

        .slider-value {
            font-weight: 500;
            color: #1a1a1a;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #2563eb;
            border-radius: 50%;
            cursor: pointer;
        }

        .mode-toggle {
            display: flex;
            gap: 8px;
            margin: 15px 0;
        }

        .mode-btn {
            flex: 1;
            padding: 8px 12px;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            color: #6c757d;
            cursor: pointer;
            text-align: center;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .mode-btn.active {
            background: #2563eb;
            color: #ffffff;
            border-color: #2563eb;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 12px 0;
            font-size: 0.9rem;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
        }

        .metric-card h3 {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .metric-label {
            color: #6c757d;
        }

        .metric-value {
            font-weight: 500;
            color: #1a1a1a;
        }

        .sound-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(245, 158, 11, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
            z-index: 1000;
        }

        .sound-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>CRR Thunderstorm System</h1>
            <div class="subtitle">Physically Accurate Bidirectional Lightning Attachment</div>
        </div>

        <div class="math-explanation">
            <div class="math-explanation-header" id="math-toggle">
                <div class="math-explanation-title">Mathematical Explanation: CRR Framework & Bidirectional Attachment Physics</div>
                <div class="math-explanation-arrow" id="math-arrow">▼</div>
            </div>
            <div class="math-explanation-content" id="math-content">
                <div class="math-explanation-inner">
                    <div class="math-section">
                        <h3>1. Electric Field Accumulation and Coherence</h3>
                        <p>Atmospheric electric fields accumulate through charge separation processes in thunderclouds. The CRR coherence operator represents this accumulation mathematically.</p>
                        
                        <div class="equation-block">
                            <strong>Classical Atmospheric Physics:</strong><br>
                            $$\mathbf{E}(x,t) = -\nabla \phi(x,t)$$
                            $$\frac{\partial \rho}{\partial t} = -\nabla \cdot \mathbf{J}$$
                            where \(\rho\) is charge density and \(\mathbf{J}\) is current density.
                        </div>

                        <div class="equation-block">
                            <strong>CRR Coherence Mapping:</strong><br>
                            $$C(x,t) = \int_0^t L(x,\tau) \, d\tau$$
                            where \(L(x,t)\) represents the local charge accumulation rate:<br>
                            $$L(x,t) = \mu(x,t) \cdot \sigma(x,t) \cdot \rho_{\text{moisture}}(x,t)$$
                        </div>

                        <div class="code-mapping">
                            <strong>Computational Implementation:</strong><br>
                            L_functional() = moisture × chargeRate × density × ageFactor<br>
                            C += L_functional() × dt  // Euler integration
                        </div>

                        <div class="mapping-arrow">
                            → The coherence \(C(t)\) accumulates as clouds develop charge separation through updrafts and ice particle collisions. The functional \(L(x,t)\) encodes moisture content, particle density, and atmospheric conductivity.
                        </div>
                    </div>

                    <div class="math-section">
                        <h3>2. Critical Breakdown Field and Rupture Threshold</h3>
                        <p>Lightning occurs when the electric field exceeds the dielectric breakdown threshold of air. This is mapped to the CRR rupture condition.</p>

                        <div class="equation-block">
                            <strong>Classical Breakdown Physics:</strong><br>
                            $$E_{\text{breakdown}} \approx 3 \times 10^6 \, \text{V/m} \, (p/p_0)$$
                            where \(p\) is atmospheric pressure. Breakdown occurs when:<br>
                            $$|\mathbf{E}(x,t)| \geq E_{\text{breakdown}}$$
                        </div>

                        <div class="equation-block">
                            <strong>CRR Rupture Mapping:</strong><br>
                            $$C_{\text{crit}} = \Omega \ln\left(\frac{\Lambda}{\lambda_0}\right)$$
                            Rupture occurs deterministically when:<br>
                            $$C(x,t) \geq C_{\text{crit}}$$
                        </div>

                        <div class="code-mapping">
                            <strong>Computational Implementation:</strong><br>
                            C_crit = Omega × log(Lambda / lambda0)<br>
                            if (cloud.C >= cloud.C_crit) {<br>
                            &nbsp;&nbsp;performRupture();  // Deterministic trigger<br>
                            }
                        </div>

                        <div class="mapping-arrow">
                            → The parameters map as: \(\Omega\) ∝ temperature scale affecting ionization rates, \(\Lambda/\lambda_0\) ∝ the ratio of field enhancement factors to ambient conditions. When accumulated coherence exceeds the critical threshold, discharge initiates.
                        </div>
                    </div>

                    <div class="math-section">
                        <h3>3. Leader Propagation and Field-Guided Pathfinding</h3>
                        <p>Lightning leaders propagate through regions of high field strength, following the path of least resistance. This is implemented through field-based pathfinding.</p>

                        <div class="equation-block">
                            <strong>Classical Leader Physics:</strong><br>
                            $$\mathbf{v}_{\text{leader}} \propto \mathbf{E}_{\text{local}} + \nabla|\mathbf{E}|$$
                            Leader steps follow field gradients with stochastic perturbations.
                        </div>

                        <div class="equation-block">
                            <strong>CRR Implementation:</strong><br>
                            Step selection weighted by:<br>
                            $$S(x') = \alpha|\mathbf{E}(x')| + \beta C_{\text{field}}(x') + \gamma(y' - y) + \epsilon$$
                            where \(\epsilon\) represents stochastic branching.
                        </div>

                        <div class="code-mapping">
                            <strong>Computational Implementation:</strong><br>
                            score = fieldAttraction × 0.35 + coherenceAttraction × 0.45<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ groundAttraction × 0.035 + random() × 0.25<br>
                            nextPos = argmax(score)  // Select highest-scoring position
                        </div>

                        <div class="mapping-arrow">
                            → Leaders propagate step-by-step through the electric field grid, with each step weighted by local field strength and coherence. Branching occurs probabilistically based on the branching rate parameter.
                        </div>
                    </div>

                    <div class="math-section">
                        <h3>4. Positive Leaders from Ground</h3>
                        <p>When downward leaders approach the ground, upward positive leaders can emerge from tall objects or field-enhanced points, propagating upward to meet the descending leader.</p>

                        <div class="equation-block">
                            <strong>Positive Leader Initiation:</strong><br>
                            When downward leader reaches height threshold:<br>
                            $h_{\text{leader}} \leq h_{\text{threshold}} \approx 100\text{px}$
                            Positive leader initiates with strong parent-seeking bias:<br>
                            $S_{\text{up}}(x') = \alpha_p|\vec{r}_{\text{parent}}|^{-1} + \beta|\mathbf{E}(x')| + \gamma C_{\text{field}}(x') + \epsilon$
                            Maximum propagation: \(\Delta h_{\text{max}} \approx 120\text{px}\)
                        </div>

                        <div class="code-mapping">
                            <strong>Computational Implementation:</strong><br>
                            if (leaderY >= groundLevel - 100 && !hasPositiveLeader) {<br>
                            &nbsp;&nbsp;// Probabilistic spawn (60-85% based on proximity & field)<br>
                            &nbsp;&nbsp;probability = 0.6 + heightFactor×0.25 + fieldFactor;<br>
                            &nbsp;&nbsp;if (random() < probability) createPositiveLeader();<br>
                            }<br>
                            // Strong bias toward parent: parentAttraction × 0.6<br>
                            // Terminates if parent dies or distance > 120px
                        </div>

                        <div class="mapping-arrow">
                            → Positive leaders emerge probabilistically (60-85% chance) when downward leaders are within ~100px of ground. Probability increases with proximity and local field strength. They propagate upward with strong attraction to the parent leader's position, creating the classic bidirectional attachment. They terminate if the parent becomes inactive or if they propagate more than 120px without connecting, preventing unrealistic long-distance propagation.
                        </div>
                    </div>

                    <div class="math-section">
                        <h3>5. Post-Discharge Recovery and Regeneration</h3>
                        <p>After discharge, the atmospheric system recovers through charge redistribution. The CRR regeneration operator weights this recovery by accumulated history.</p>

                        <div class="equation-block">
                            <strong>Classical Recovery:</strong><br>
                            $$\frac{\partial \mathbf{E}}{\partial t} = -\frac{\mathbf{E}}{\tau_{\text{relax}}} + \mathbf{S}_{\text{source}}$$
                            where \(\tau_{\text{relax}}\) is the relaxation timescale.
                        </div>

                        <div class="equation-block">
                            <strong>CRR Regeneration Mapping:</strong><br>
                            $$\mathcal{R}[\chi](x,t) = \int_{-\infty}^t \phi(x,\tau) \exp\left(\frac{C(x,\tau)}{\Omega}\right) d\tau$$
                            Weight function exponentially amplifies based on prior coherence.
                        </div>

                        <div class="code-mapping">
                            <strong>Computational Implementation:</strong><br>
                            rebirth_integral = 0;<br>
                            for (hist of C_history) {<br>
                            &nbsp;&nbsp;rebirth_integral += exp(hist.C / Omega) × dt;<br>
                            }<br>
                            rebirthWeight = rebirth_integral / normalization;
                        </div>

                        <div class="mapping-arrow">
                            → After rupture, clouds retain 20% of accumulated coherence as "memory." Future charging is weighted by \(\exp(C/\Omega)\), representing enhanced ionization paths created by prior discharges. This produces the observed tendency for repeated strikes in the same location.
                        </div>
                    </div>

                    <div class="math-section">
                        <h3>Summary: CRR as a Coarse-Grained Description</h3>
                        <p>The CRR framework provides a coarse-grained mathematical description of thunderstorm electrodynamics. The coherence integral \(C(t) = \int_0^t L \, d\tau\) accumulates charge separation work. The rupture condition \(C \geq C_{\text{crit}}\) represents deterministic breakdown. The regeneration operator \(\mathcal{R} \propto \exp(C/\Omega)\) encodes memory effects in post-discharge recovery. Positive leaders from ground add physical realism to the bidirectional attachment process, spawning probabilistically (60-85% base chance) based on proximity and field strength, with strong parent-seeking behavior and realistic propagation limits.</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="equation-banner">
            CRR Core: C(x,t) = ∫₀ᵗ L(x,τ) dτ • Rupture at C ≥ Ω·log(Λ/λ₀) • R[χ] ∝ exp(C/Ω)
        </div>

        <div class="crr-status coherence" id="crr-status">
            <div class="current-phase" id="current-crr-phase">Coherence Phase: C(x,t) = ∫₀ᵗ L(x,τ) dτ</div>
            <div class="phase-description" id="crr-description">Atmospheric coherence building through charge accumulation</div>
            <div class="code-snippet" id="code-snippet">
<span class="code-comment">// Authentic CRR: C(t) = ∫₀ᵗ L(x,τ) dτ</span>
<span class="code-variable">cloud.C</span> <span class="code-operator">+=</span> <span class="code-variable">cloud.L_functional</span>() <span class="code-operator">*</span> <span class="code-variable">dt</span>;
<span class="code-comment">// Rupture when C >= C_crit</span>
<span class="code-operator">if</span> (<span class="code-variable">cloud.C</span> <span class="code-operator">>=</span> <span class="code-variable">cloud.C_crit</span>) <span class="code-function">rupture</span>();
            </div>
        </div>

        <div class="coherence-display">
            <h3>Coherence Accumulation C(t) vs Critical Threshold C_crit</h3>
            <div class="coherence-graph">
                <canvas id="coherence-canvas" width="800" height="120"></canvas>
            </div>
            <div class="coherence-metrics">
                <div class="coherence-metric">
                    <span class="coherence-label">Max C(t):</span>
                    <span class="coherence-value" id="max-coherence">0.00</span>
                </div>
                <div class="coherence-metric">
                    <span class="coherence-label">C_crit:</span>
                    <span class="coherence-value" id="c-critical">0.00</span>
                </div>
                <div class="coherence-metric">
                    <span class="coherence-label">Ω (scale):</span>
                    <span class="coherence-value" id="omega-val">1.00</span>
                </div>
                <div class="coherence-metric">
                    <span class="coherence-label">Λ/λ₀:</span>
                    <span class="coherence-value" id="lambda-ratio">10.0</span>
                </div>
                <div class="coherence-metric">
                    <span class="coherence-label">Next Rupture:</span>
                    <span class="coherence-value" id="next-rupture">---</span>
                </div>
                <div class="coherence-metric">
                    <span class="coherence-label">Phase:</span>
                    <span class="coherence-value" id="phase-indicator">Building</span>
                </div>
            </div>
        </div>

        <div class="simulation-area">
            <canvas id="atmosphere-canvas" width="1000" height="650"></canvas>
        </div>

        <div class="button-row">
            <button class="control-btn" id="start-btn">Start System</button>
            <button class="control-btn" id="surge-btn">Storm Surge</button>
            <button class="control-btn" id="audio-btn">Enable Thunder</button>
            <button class="control-btn" id="reset-btn">Reset</button>
        </div>

        <div class="controls-section">
            <div class="control-panel">
                <h3>CRR Parameters</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Ω (Temperature)</span>
                        <span class="slider-value" id="omega-display">1.0</span>
                    </div>
                    <input type="range" id="omega-slider" min="0.5" max="3.0" step="0.1" value="1.0">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Λ (UV Cutoff)</span>
                        <span class="slider-value" id="lambda-display">10.0</span>
                    </div>
                    <input type="range" id="lambda-slider" min="5.0" max="25.0" step="1.0" value="10.0">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>λ₀ (IR Scale)</span>
                        <span class="slider-value" id="lambda0-display">1.0</span>
                    </div>
                    <input type="range" id="lambda0-slider" min="0.5" max="3.0" step="0.1" value="1.0">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>L Rate</span>
                        <span class="slider-value" id="l-rate-display">0.15</span>
                    </div>
                    <input type="range" id="l-rate-slider" min="0.05" max="0.5" step="0.01" value="0.15">
                </div>
            </div>

            <div class="control-panel">
                <h3>Lightning System</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Branch Rate</span>
                        <span class="slider-value" id="branch-val">0.3</span>
                    </div>
                    <input type="range" id="branching-rate" min="0.1" max="0.6" step="0.05" value="0.3">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Step Size</span>
                        <span class="slider-value" id="step-val">8</span>
                    </div>
                    <input type="range" id="step-size" min="4" max="15" step="1" value="8">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Positive Leader Prob</span>
                        <span class="slider-value" id="pos-leader-prob-val">60%</span>
                    </div>
                    <input type="range" id="positive-leader-prob" min="0.0" max="1.0" step="0.05" value="0.6">
                </div>
                <div class="mode-toggle">
                    <div class="mode-btn active" id="bolt-mode">Bolt</div>
                    <div class="mode-btn" id="sheet-mode">Sheet</div>
                    <div class="mode-btn" id="mixed-mode">Mixed</div>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="show-fields" checked>
                    <label>Show Fields</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="positive-leaders-enabled" checked>
                    <label>Enable Positive Leaders</label>
                </div>
            </div>

            <div class="control-panel">
                <h3>Atmospheric System</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Wind Speed</span>
                        <span class="slider-value" id="wind-val">0.4</span>
                    </div>
                    <input type="range" id="wind-speed" min="0.1" max="1.0" step="0.05" value="0.4">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Cloud Formation</span>
                        <span class="slider-value" id="cloud-form-val">0.3</span>
                    </div>
                    <input type="range" id="cloud-formation" min="0.1" max="0.8" step="0.05" value="0.3">
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="rain-enabled">
                    <label>Enable Rain</label>
                </div>
            </div>

            <div class="control-panel">
                <h3>Audio System</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Volume</span>
                        <span class="slider-value" id="volume-val">0.7</span>
                    </div>
                    <input type="range" id="thunder-volume" min="0.0" max="1.0" step="0.05" value="0.7">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Reverb</span>
                        <span class="slider-value" id="reverb-val">0.6</span>
                    </div>
                    <input type="range" id="reverb-amount" min="0.0" max="1.0" step="0.1" value="0.6">
                </div>
            </div>
        </div>

        <div class="metrics-panel">
            <div class="metric-card">
                <h3>CRR Status</h3>
                <div class="metric-row">
                    <span class="metric-label">Phase:</span>
                    <span class="metric-value" id="storm-phase">Coherence</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Clouds:</span>
                    <span class="metric-value" id="clouds-count">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Avg C(t):</span>
                    <span class="metric-value" id="avg-coherence">0.00</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">State:</span>
                    <span class="metric-value" id="system-state">Stable</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Lightning</h3>
                <div class="metric-row">
                    <span class="metric-label">Ruptures:</span>
                    <span class="metric-value" id="strikes-count">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Active Leaders:</span>
                    <span class="metric-value" id="leaders-count">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Positive Leaders:</span>
                    <span class="metric-value" id="positive-leaders-count">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Last C at Rupture:</span>
                    <span class="metric-value" id="rupture-coherence">---</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Performance</h3>
                <div class="metric-row">
                    <span class="metric-label">FPS:</span>
                    <span class="metric-value" id="fps-display">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Audio:</span>
                    <span class="metric-value" id="audio-status">Off</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Rain Drops:</span>
                    <span class="metric-value" id="rain-drops">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Mode:</span>
                    <span class="metric-value" id="lightning-mode-display">Bolt</span>
                </div>
            </div>
        </div>
    </div>

    <div class="sound-indicator" id="sound-indicator">Thunder</div>

    <script>
        // Dropdown toggle
        document.getElementById('math-toggle').addEventListener('click', () => {
            const content = document.getElementById('math-content');
            const arrow = document.getElementById('math-arrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        });

        // === ROBUST AUDIO SYSTEM ===
        
        class UCFThunderSoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.reverbNode = null;
                this.enabled = false;
                this.ready = false;
                this.volume = 0.7;
                this.reverbAmount = 0.6;
                this.initAttempts = 0;
                this.maxInitAttempts = 3;
            }

            async init() {
                try {
                    this.initAttempts++;
                    console.log(`Audio init attempt ${this.initAttempts}/${this.maxInitAttempts}`);
                    
                    if (this.audioContext) {
                        try {
                            await this.audioContext.close();
                        } catch (e) {
                            console.warn('Error closing old context:', e);
                        }
                    }
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.volume;
                    
                    await this.createReverb();
                    this.masterGain.connect(this.audioContext.destination);
                    
                    let waitCount = 0;
                    while (this.audioContext.state !== 'running' && waitCount < 10) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        waitCount++;
                    }
                    
                    if (this.audioContext.state !== 'running') {
                        throw new Error('AudioContext failed to start');
                    }
                    
                    await this.playTestSound();
                    
                    this.enabled = true;
                    this.ready = true;
                    console.log('Audio system initialized successfully');
                    return true;
                    
                } catch (error) {
                    console.error('Audio init failed:', error);
                    
                    if (this.initAttempts < this.maxInitAttempts) {
                        console.log('Retrying audio init...');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        return this.init();
                    }
                    
                    this.enabled = false;
                    this.ready = false;
                    return false;
                }
            }

            async createReverb() {
                const convolver = this.audioContext.createConvolver();
                const reverbTime = 2.5;
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * reverbTime;
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay;
                    }
                }

                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            async playTestSound() {
                return new Promise((resolve, reject) => {
                    try {
                        const now = this.audioContext.currentTime;
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.frequency.value = 200;
                        osc.type = 'sine';
                        
                        gain.gain.value = 0;
                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.1, now + 0.01);
                        gain.gain.linearRampToValueAtTime(0, now + 0.05);
                        
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        
                        osc.start(now);
                        osc.stop(now + 0.05);
                        
                        osc.onended = () => resolve();
                        
                        setTimeout(() => resolve(), 100);
                    } catch (e) {
                        reject(e);
                    }
                });
            }

            generateThunder(intensity, coherence) {
                if (!this.enabled || !this.ready || !this.audioContext) {
                    console.warn('Audio not ready');
                    return;
                }

                try {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }

                    const now = this.audioContext.currentTime;
                    const scaledIntensity = Math.max(0.3, intensity * (1 + Math.log(1 + coherence * 0.1)));
                    const duration = 1.5 + scaledIntensity * 2.0;

                    const mainGain = this.audioContext.createGain();
                    const lowPass = this.audioContext.createBiquadFilter();
                    const highPass = this.audioContext.createBiquadFilter();
                    
                    lowPass.type = 'lowpass';
                    lowPass.frequency.value = 200 + scaledIntensity * 300;
                    highPass.type = 'highpass';
                    highPass.frequency.value = 30;

                    mainGain.gain.value = 0;
                    mainGain.gain.setValueAtTime(0, now);
                    mainGain.gain.exponentialRampToValueAtTime(scaledIntensity * this.volume * 0.8, now + 0.1);
                    mainGain.gain.exponentialRampToValueAtTime(scaledIntensity * this.volume * 0.3, now + 0.5);
                    mainGain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                    this.createRumble(now, duration, scaledIntensity, mainGain, lowPass, highPass);
                    
                    if (scaledIntensity > 0.6) {
                        this.createCrack(now, scaledIntensity, mainGain);
                    }

                    this.connectReverb(mainGain);
                    this.showIndicator();
                    
                } catch (error) {
                    console.error('Error generating thunder:', error);
                }
            }

            createRumble(startTime, duration, intensity, mainGain, lowPass, highPass) {
                [40, 60, 80, 120].forEach((freq) => {
                    try {
                        const osc = this.audioContext.createOscillator();
                        const oscGain = this.audioContext.createGain();
                        const lfo = this.audioContext.createOscillator();
                        const lfoGain = this.audioContext.createGain();
                        
                        osc.type = 'sawtooth';
                        osc.frequency.value = freq + Math.random() * 10;
                        lfo.type = 'sine';
                        lfo.frequency.value = 2 + Math.random() * 3;
                        lfoGain.gain.value = 5;
                        oscGain.gain.value = (0.3 + intensity * 0.4) / 4;
                        
                        lfo.connect(lfoGain);
                        lfoGain.connect(osc.frequency);
                        osc.connect(oscGain);
                        oscGain.connect(highPass);
                        highPass.connect(lowPass);
                        lowPass.connect(mainGain);
                        
                        osc.start(startTime);
                        lfo.start(startTime);
                        osc.stop(startTime + duration);
                        lfo.stop(startTime + duration);
                    } catch (e) {
                        console.warn('Rumble oscillator error:', e);
                    }
                });
            }

            createCrack(startTime, intensity, mainGain) {
                try {
                    const bufferSize = this.audioContext.sampleRate * 0.2;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        const decay = Math.exp(-i / (bufferSize * 0.1));
                        data[i] = (Math.random() * 2 - 1) * decay;
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const crackGain = this.audioContext.createGain();
                    const crackFilter = this.audioContext.createBiquadFilter();
                    
                    source.buffer = buffer;
                    crackFilter.type = 'bandpass';
                    crackFilter.frequency.value = 2000 + intensity * 3000;
                    crackFilter.Q.value = 2;
                    crackGain.gain.value = intensity * 0.8;
                    
                    source.connect(crackFilter);
                    crackFilter.connect(crackGain);
                    crackGain.connect(mainGain);
                    source.start(startTime);
                } catch (e) {
                    console.warn('Crack sound error:', e);
                }
            }

            connectReverb(mainGain) {
                try {
                    if (this.reverbAmount > 0 && this.reverbNode) {
                        const dryGain = this.audioContext.createGain();
                        const wetGain = this.audioContext.createGain();
                        
                        dryGain.gain.value = 1 - this.reverbAmount;
                        wetGain.gain.value = this.reverbAmount;
                        
                        mainGain.connect(dryGain);
                        mainGain.connect(this.reverbNode);
                        this.reverbNode.connect(wetGain);
                        
                        dryGain.connect(this.masterGain);
                        wetGain.connect(this.masterGain);
                    } else {
                        mainGain.connect(this.masterGain);
                    }
                } catch (e) {
                    console.warn('Reverb connection error:', e);
                    mainGain.connect(this.masterGain);
                }
            }

            showIndicator() {
                const indicator = document.getElementById('sound-indicator');
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 1000);
            }

            setVolume(v) { 
                this.volume = v; 
                if (this.masterGain) {
                    this.masterGain.gain.value = v;
                }
            }
            
            setReverb(r) { 
                this.reverbAmount = r; 
            }
            
            async disable() {
                this.enabled = false;
                this.ready = false;
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    try {
                        await this.audioContext.close();
                    } catch (e) {
                        console.warn('Error closing audio context:', e);
                    }
                }
                this.audioContext = null;
                this.masterGain = null;
                this.reverbNode = null;
            }
        }

        // === CRR CLOUD CLASS ===
        
        class CRRCloud {
            constructor(x, y, width, height, density, Omega, Lambda, lambda0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.density = density;
                this.vx = (Math.random() - 0.5) * 0.1;
                this.vy = (Math.random() - 0.5) * 0.02;
                
                this.Omega = Omega;
                this.Lambda = Lambda;
                this.lambda0 = lambda0;
                this.C = 0;
                this.C_history = [];
                this.C_crit = Omega * Math.log(Lambda / lambda0);
                this.L_rate_base = 0.15;
                
                this.moisture = 0.4 + Math.random() * 0.3;
                this.temperature = 275 + Math.random() * 10;
                this.charge = 0;
                this.age = 0;
                
                this.chargeTop = { charge: 0, x: x, y: y - height * 0.3 };
                this.chargeBottom = { charge: 0, x: x, y: y + height * 0.3 };
                
                this.particles = [];
                this.generateParticles();
                
                this.phase = 'coherence';
                this.ruptureCount = 0;
                this.lastRuptureCoherence = 0;
            }
            
            generateParticles() {
                const numParticles = Math.floor(this.density * 35);
                for (let i = 0; i < numParticles; i++) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.height,
                        size: 1 + Math.random() * 2.5,
                        opacity: 0.25 + Math.random() * 0.35
                    });
                }
            }
            
            L_functional() {
                const chargeFactor = (Math.abs(this.chargeTop.charge) + Math.abs(this.chargeBottom.charge)) * 0.5;
                const moistureFactor = this.moisture;
                const densityFactor = this.density;
                const ageFactor = Math.min(1.0, this.age / 100);
                
                return this.L_rate_base * moistureFactor * densityFactor * (1 + chargeFactor) * ageFactor;
            }
            
            updateCoherence(dt) {
                const L_current = this.L_functional();
                this.C += L_current * dt;
                
                this.C_history.push({ t: this.age, C: this.C, L: L_current });
                if (this.C_history.length > 100) {
                    this.C_history.shift();
                }
            }
            
            checkRupture() {
                return this.C >= this.C_crit;
            }
            
            performRupture() {
                this.lastRuptureCoherence = this.C;
                this.ruptureCount++;
                this.phase = 'rupture';
                
                const dischargeAmount = this.C * 0.8;
                this.C = this.C * 0.2;
                
                this.chargeTop.charge *= 0.3;
                this.chargeBottom.charge *= 0.3;
                
                return {
                    x: this.x,
                    y: this.y,
                    chargeTop: this.chargeTop,
                    chargeBottom: this.chargeBottom,
                    intensity: dischargeAmount,
                    coherence: this.lastRuptureCoherence
                };
            }
            
            computeRebirthWeight() {
                if (this.C_history.length === 0) return 1.0;
                
                let rebirth_integral = 0;
                const dt = 1.0;
                
                for (let hist of this.C_history) {
                    rebirth_integral += Math.exp(hist.C / this.Omega) * dt;
                }
                
                const normalized = rebirth_integral / (this.C_history.length * Math.exp(this.C_crit / this.Omega));
                return Math.min(normalized, 5.0);
            }
            
            update(dt, windSpeed, stormIntensity) {
                this.age++;
                
                this.vx += (Math.random() - 0.5) * windSpeed * 0.0015;
                this.vy += (Math.random() - 0.5) * windSpeed * 0.0008;
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -this.width) this.x = 1000 + this.width;
                if (this.x > 1000 + this.width) this.x = -this.width;
                
                const chargeRate = windSpeed * stormIntensity * 0.018;
                this.chargeTop.charge += chargeRate * (1 + this.density);
                this.chargeTop.charge = Math.min(this.chargeTop.charge, 2.2);
                this.chargeBottom.charge -= chargeRate * (1 + this.density);
                this.chargeBottom.charge = Math.max(this.chargeBottom.charge, -1.8);
                this.charge = Math.abs(this.chargeTop.charge) + Math.abs(this.chargeBottom.charge);
                
                this.updateCoherence(dt);
                
                if (this.phase === 'rupture') {
                    this.phase = 'regeneration';
                } else if (this.phase === 'regeneration' && this.C < this.C_crit * 0.3) {
                    this.phase = 'coherence';
                } else if (this.C > this.C_crit * 0.8 && this.phase === 'coherence') {
                    this.phase = 'pre-rupture';
                }
                
                for (let particle of this.particles) {
                    particle.x += (Math.random() - 0.5) * 0.12;
                    particle.y += (Math.random() - 0.5) * 0.06;
                    
                    const dx = particle.x - this.x;
                    const dy = particle.y - this.y;
                    if (Math.abs(dx) > this.width * 0.5) particle.x = this.x + dx * 0.8;
                    if (Math.abs(dy) > this.height * 0.5) particle.y = this.y + dy * 0.8;
                }
            }
        }

        // === CRR ATMOSPHERE ===
        
        class CRRAtmosphere {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cloudLevel = 100;
                this.groundLevel = height - 50;
                
                this.Omega = 1.0;
                this.Lambda = 10.0;
                this.lambda0 = 1.0;
                this.L_rate = 0.15;
                
                this.gridScale = 4;
                this.gridWidth = Math.floor(width / this.gridScale);
                this.gridHeight = Math.floor(height / this.gridScale);
                this.gridSize = this.gridWidth * this.gridHeight;
                this.electricField = new Float32Array(this.gridSize);
                this.coherenceField = new Float32Array(this.gridSize);
                
                this.params = {
                    windSpeed: 0.4,
                    cloudFormation: 0.3,
                    branchingRate: 0.3,
                    stepSize: 8,
                    positiveLeaderProbability: 0.6
                };
                
                this.running = false;
                this.showFields = true;
                this.rainEnabled = false;
                this.lightningMode = 'bolt';
                this.positiveLeadersEnabled = true;
                
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;
                
                this.sun = { x: width * 0.85, y: 60, intensity: 0.8, coverage: 0 };
                
                this.clouds = [];
                this.rainDrops = [];
                this.lightningLeaders = [];
                this.positiveLeaders = [];
                this.lightningStrokes = [];
                this.sheetFlashes = [];
                this.lightningParticles = [];
                
                this.ruptureCount = 0;
                this.lastRuptureCoherence = 0;
                this.currentRebirthWeight = 1.0;
                
                this.soundSystem = new UCFThunderSoundSystem();
                this.audioEnabled = false;
                
                this.coherenceHistory = [];
                this.maxHistoryLength = 200;
                
                this.initializeSystem();
            }
            
            initializeSystem() {
                console.log('=== CRR SYSTEM INIT ===');
                console.log(`C_crit = ${(this.Omega * Math.log(this.Lambda / this.lambda0)).toFixed(3)}`);
                
                for (let i = 0; i < 3; i++) {
                    this.createCloud(
                        Math.random() * this.width,
                        this.cloudLevel + Math.random() * 40,
                        30 + Math.random() * 50,
                        15 + Math.random() * 25,
                        0.15 + Math.random() * 0.2
                    );
                }
            }
            
            createCloud(x, y, width, height, density) {
                const cloud = new CRRCloud(x, y, width, height, density, this.Omega, this.Lambda, this.lambda0);
                cloud.L_rate_base = this.L_rate;
                this.clouds.push(cloud);
                return cloud;
            }
            
            updateCRRParameters(omega, lambda, lambda0, L_rate) {
                this.Omega = omega;
                this.Lambda = lambda;
                this.lambda0 = lambda0;
                this.L_rate = L_rate;
                
                for (let cloud of this.clouds) {
                    cloud.Omega = omega;
                    cloud.Lambda = lambda;
                    cloud.lambda0 = lambda0;
                    cloud.L_rate_base = L_rate;
                    cloud.C_crit = omega * Math.log(lambda / lambda0);
                }
            }
            
            gridIndex(x, y) {
                const gx = Math.floor(x / this.gridScale);
                const gy = Math.floor(y / this.gridScale);
                if (gx < 0 || gx >= this.gridWidth || gy < 0 || gy >= this.gridHeight) return -1;
                return gy * this.gridWidth + gx;
            }
            
            updateFields() {
                this.electricField.fill(0);
                
                for (let cloud of this.clouds) {
                    this.addChargeToField(cloud.chargeTop, cloud.density);
                    this.addChargeToField(cloud.chargeBottom, cloud.density);
                }
                
                for (let y = 1; y < this.gridHeight - 1; y++) {
                    for (let x = 1; x < this.gridWidth - 1; x++) {
                        const idx = y * this.gridWidth + x;
                        
                        let spatial = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                spatial += this.electricField[(y + dy) * this.gridWidth + (x + dx)];
                            }
                        }
                        spatial /= 8;
                        
                        this.coherenceField[idx] = spatial * 0.8;
                    }
                }
            }
            
            addChargeToField(chargeRegion, density) {
                const gridX = Math.floor(chargeRegion.x / this.gridScale);
                const gridY = Math.floor(chargeRegion.y / this.gridScale);
                const influence = 9;
                
                for (let dy = -influence; dy <= influence; dy++) {
                    for (let dx = -influence; dx <= influence; dx++) {
                        const gx = gridX + dx;
                        const gy = gridY + dy;
                        
                        if (gx >= 0 && gx < this.gridWidth && gy >= 0 && gy < this.gridHeight) {
                            const idx = gy * this.gridWidth + gx;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < influence) {
                                const contribution = chargeRegion.charge * 
                                                  Math.exp(-dist / (influence * 0.4)) * 
                                                  density;
                                this.electricField[idx] += contribution;
                            }
                        }
                    }
                }
            }
            
            step() {
                const dt = 0.016;
                
                for (let cloud of this.clouds) {
                    cloud.update(dt, this.params.windSpeed, 0.5);
                    
                    if (cloud.checkRupture()) {
                        const ruptureData = cloud.performRupture();
                        
                        if (this.lightningMode === 'bolt' || this.lightningMode === 'mixed') {
                            this.createLightningLeader(ruptureData);
                        }
                        if (this.lightningMode === 'sheet' || this.lightningMode === 'mixed') {
                            this.createSheetLightning(cloud, ruptureData.coherence);
                        }
                        
                        this.ruptureCount++;
                        this.lastRuptureCoherence = ruptureData.coherence;
                        
                        console.log(`RUPTURE: C=${ruptureData.coherence.toFixed(3)}`);
                    }
                    
                    this.currentRebirthWeight = cloud.computeRebirthWeight();
                }
                
                if (this.clouds.length < 7 && Math.random() < this.params.cloudFormation * 0.01) {
                    this.createCloud(
                        Math.random() * this.width,
                        this.cloudLevel + Math.random() * 60,
                        40 + Math.random() * 80,
                        20 + Math.random() * 40,
                        0.2 + Math.random() * 0.4
                    );
                }
                
                this.updateFields();
                this.updateLightning();
                
                if (this.rainEnabled) {
                    this.updateRain();
                }
                
                this.updateSunCoverage();
                this.updateCoherenceHistory();
                this.updatePerformance();
            }
            
            createLightningLeader(ruptureData) {
                if (this.lightningLeaders.length >= 10) return;
                
                this.lightningLeaders.push({
                    path: [{x: ruptureData.x, y: ruptureData.y}],
                    branches: [],
                    currentX: ruptureData.x,
                    currentY: ruptureData.y,
                    intensity: ruptureData.intensity * 0.8,
                    age: 0,
                    active: true,
                    direction: Math.PI * 0.5 + (Math.random() - 0.5) * 0.7,
                    stepSize: this.params.stepSize,
                    generation: 0,
                    coherence: ruptureData.coherence,
                    hasPositiveLeader: false,
                    positiveLeaderAttempted: false
                });
            }
            
            createPositiveLeader(targetX, parentLeader, spawnProbability) {
                const groundX = targetX + (Math.random() - 0.5) * 30;
                
                this.positiveLeaders.push({
                    path: [{x: groundX, y: this.groundLevel}],
                    currentX: groundX,
                    currentY: this.groundLevel,
                    intensity: parentLeader.intensity * 0.7,
                    age: 0,
                    active: true,
                    direction: Math.PI * 1.5 + (Math.random() - 0.5) * 0.5,
                    stepSize: this.params.stepSize * 0.85,
                    generation: 0,
                    coherence: parentLeader.coherence,
                    parentLeader: parentLeader,
                    startY: this.groundLevel,
                    maxPropagationDistance: 120
                });
                
                parentLeader.hasPositiveLeader = true;
                console.log(`Positive leader spawned (P=${(spawnProbability*100).toFixed(0)}%) - parent at Y=${parentLeader.currentY.toFixed(0)}px`);
            }
            
            createSheetLightning(cloud, coherence) {
                this.sheetFlashes.push({
                    x: cloud.x,
                    y: cloud.y,
                    width: cloud.width * 1.8,
                    height: cloud.height * 1.5,
                    intensity: 0.8 + Math.random() * 0.4,
                    age: 0,
                    maxAge: 6 + Math.random() * 4,
                    pulseRate: 2 + Math.random() * 2,
                    coherence: coherence
                });
                
                if (this.audioEnabled && this.soundSystem.ready) {
                    this.soundSystem.generateThunder(0.4, coherence);
                }
            }
            
            updateLightning() {
                for (let i = this.sheetFlashes.length - 1; i >= 0; i--) {
                    const flash = this.sheetFlashes[i];
                    flash.age++;
                    if (flash.age > flash.maxAge) {
                        this.sheetFlashes.splice(i, 1);
                    }
                }
                
                // Update downward leaders
                for (let i = this.lightningLeaders.length - 1; i >= 0; i--) {
                    const leader = this.lightningLeaders[i];
                    
                    if (!leader.active) {
                        leader.intensity *= 0.94;
                        leader.age++;
                        if (leader.age > 110 || leader.intensity < 0.06) {
                            this.lightningLeaders.splice(i, 1);
                        }
                        continue;
                    }
                    
                    leader.age++;
                    
                    // Check if we should spawn a positive leader (probabilistic)
                    if (this.positiveLeadersEnabled && 
                        !leader.hasPositiveLeader && 
                        !leader.positiveLeaderAttempted &&
                        leader.currentY >= this.groundLevel - 100 && 
                        leader.currentY < this.groundLevel - 10) {
                        
                        // Calculate spawn probability based on distance and field strength
                        const distanceToGround = this.groundLevel - leader.currentY;
                        const heightFactor = 1.0 - (distanceToGround / 90); // 0 to 1, higher when closer
                        
                        const gridIdx = this.gridIndex(leader.currentX, leader.currentY);
                        const fieldStrength = gridIdx >= 0 ? Math.abs(this.electricField[gridIdx]) : 0;
                        const fieldFactor = Math.min(fieldStrength * 0.3, 0.25); // 0 to 0.25
                        
                        // Base probability from params, increases with height and field
                        const spawnProbability = this.params.positiveLeaderProbability + (heightFactor * 0.25) + fieldFactor;
                        
                        leader.positiveLeaderAttempted = true; // Only attempt once per leader
                        
                        if (Math.random() < spawnProbability) {
                            this.createPositiveLeader(leader.currentX, leader, spawnProbability);
                        }
                    }
                    
                    if (leader.generation < 2 && leader.path.length > 4 && 
                        Math.random() < this.params.branchingRate * 0.08) {
                        this.createBranch(leader);
                    }
                    
                    const nextPos = this.findNextPosition(leader, false);
                    if (nextPos && nextPos.y < this.groundLevel) {
                        leader.path.push({x: nextPos.x, y: nextPos.y});
                        leader.currentX = nextPos.x;
                        leader.currentY = nextPos.y;
                        
                        this.createParticle(nextPos.x, nextPos.y, leader.intensity);
                        
                        if (nextPos.y >= this.groundLevel - 5) {
                            this.createReturnStroke(leader);
                            leader.active = false;
                        }
                    } else {
                        leader.active = false;
                    }
                }
                
                // Update upward positive leaders
                for (let i = this.positiveLeaders.length - 1; i >= 0; i--) {
                    const posLeader = this.positiveLeaders[i];
                    
                    if (!posLeader.active) {
                        posLeader.intensity *= 0.94;
                        posLeader.age++;
                        if (posLeader.age > 110 || posLeader.intensity < 0.06) {
                            this.positiveLeaders.splice(i, 1);
                        }
                        continue;
                    }
                    
                    posLeader.age++;
                    
                    // Check if parent downward leader is still active
                    if (!posLeader.parentLeader || !posLeader.parentLeader.active) {
                        posLeader.active = false;
                        console.log('Positive leader terminated: parent inactive');
                        continue;
                    }
                    
                    // Check propagation distance limit
                    const distanceTraveled = posLeader.startY - posLeader.currentY;
                    if (distanceTraveled > posLeader.maxPropagationDistance) {
                        posLeader.active = false;
                        console.log('Positive leader terminated: max distance reached');
                        continue;
                    }
                    
                    // Check for connection with downward leader
                    const dx = posLeader.currentX - posLeader.parentLeader.currentX;
                    const dy = posLeader.currentY - posLeader.parentLeader.currentY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 25) {
                        // Connection made!
                        this.connectLeaders(posLeader.parentLeader, posLeader);
                        posLeader.active = false;
                        posLeader.parentLeader.active = false;
                        continue;
                    }
                    
                    const nextPos = this.findNextPositionForPositiveLeader(posLeader);
                    if (nextPos && nextPos.y > this.cloudLevel) {
                        posLeader.path.push({x: nextPos.x, y: nextPos.y});
                        posLeader.currentX = nextPos.x;
                        posLeader.currentY = nextPos.y;
                        
                        this.createParticle(nextPos.x, nextPos.y, posLeader.intensity * 0.8);
                    } else {
                        posLeader.active = false;
                    }
                }
                
                for (let i = this.lightningStrokes.length - 1; i >= 0; i--) {
                    const stroke = this.lightningStrokes[i];
                    
                    if (!stroke.active) {
                        stroke.intensity *= 0.9;
                        stroke.age++;
                        if (stroke.age > 90 || stroke.intensity < 0.1) {
                            this.lightningStrokes.splice(i, 1);
                        }
                        continue;
                    }
                    
                    stroke.currentIndex += stroke.speed;
                    if (stroke.currentIndex >= stroke.path.length) {
                        stroke.active = false;
                    }
                    stroke.age++;
                }
                
                for (let i = this.lightningParticles.length - 1; i >= 0; i--) {
                    const particle = this.lightningParticles[i];
                    particle.age++;
                    particle.intensity *= 0.95;
                    
                    if (particle.age > particle.maxAge || particle.intensity < 0.06) {
                        this.lightningParticles.splice(i, 1);
                    }
                }
            }
            
            connectLeaders(downLeader, upLeader) {
                const connectionY = (downLeader.currentY + upLeader.currentY) / 2;
                const upwardDistance = upLeader.startY - upLeader.currentY;
                console.log(`Leaders connected at Y=${connectionY.toFixed(0)}px! Positive leader propagated ${upwardDistance.toFixed(0)}px upward.`);
                
                // Combine paths: down leader + reversed up leader
                const combinedPath = [...downLeader.path, ...upLeader.path.slice().reverse()];
                
                this.lightningStrokes.push({
                    path: combinedPath.reverse(),
                    currentIndex: 0,
                    intensity: (downLeader.intensity + upLeader.intensity) * 1.3,
                    age: 0,
                    active: true,
                    speed: 12 + Math.random() * 8,
                    coherence: downLeader.coherence
                });
                
                if (this.audioEnabled && this.soundSystem.ready) {
                    this.soundSystem.generateThunder(downLeader.intensity / 2.2, downLeader.coherence);
                }
            }
            
            createBranch(parentLeader) {
                if (parentLeader.path.length < 3) return;
                
                const branchPoint = parentLeader.path[parentLeader.path.length - 2];
                const branchAngle = parentLeader.direction + (Math.random() - 0.5) * Math.PI * 0.7;
                
                this.lightningLeaders.push({
                    path: [{x: branchPoint.x, y: branchPoint.y}],
                    branches: [],
                    currentX: branchPoint.x,
                    currentY: branchPoint.y,
                    intensity: parentLeader.intensity * 0.65,
                    age: 0,
                    active: true,
                    direction: branchAngle,
                    stepSize: parentLeader.stepSize * 0.75,
                    generation: parentLeader.generation + 1,
                    coherence: parentLeader.coherence,
                    hasPositiveLeader: false,
                    positiveLeaderAttempted: false
                });
            }
            
            findNextPosition(leader, isUpward) {
                const attempts = 12;
                let bestPos = null;
                let maxScore = -Infinity;
                
                for (let i = 0; i < attempts; i++) {
                    const angle = leader.direction + (Math.random() - 0.5) * 1.1;
                    const distance = leader.stepSize * (0.8 + Math.random() * 0.4);
                    
                    const testX = Math.floor(leader.currentX + Math.cos(angle) * distance);
                    const testY = Math.floor(leader.currentY + Math.sin(angle) * distance);
                    
                    if (testX >= 0 && testX < this.width && testY >= 0 && testY < this.height) {
                        const gridIdx = this.gridIndex(testX, testY);
                        if (gridIdx < 0) continue;
                        
                        const fieldAttraction = Math.abs(this.electricField[gridIdx]) * 0.35;
                        const coherenceAttraction = this.coherenceField[gridIdx] * 0.45;
                        
                        // Reverse gravity term for upward leaders
                        const gravityTerm = isUpward ? 
                            Math.max(0, (leader.currentY - testY)) * 0.035 :
                            Math.max(0, (testY - leader.currentY)) * 0.035;
                        
                        const score = fieldAttraction + coherenceAttraction + gravityTerm + Math.random() * 0.25;
                        
                        if (score > maxScore) {
                            maxScore = score;
                            bestPos = {x: testX, y: testY};
                        }
                    }
                }
                
                return bestPos;
            }
            
            findNextPositionForPositiveLeader(posLeader) {
                const attempts = 15;
                let bestPos = null;
                let maxScore = -Infinity;
                
                // Target the parent downward leader's current position
                const targetX = posLeader.parentLeader.currentX;
                const targetY = posLeader.parentLeader.currentY;
                
                for (let i = 0; i < attempts; i++) {
                    const angle = posLeader.direction + (Math.random() - 0.5) * 0.8;
                    const distance = posLeader.stepSize * (0.8 + Math.random() * 0.4);
                    
                    const testX = Math.floor(posLeader.currentX + Math.cos(angle) * distance);
                    const testY = Math.floor(posLeader.currentY + Math.sin(angle) * distance);
                    
                    if (testX >= 0 && testX < this.width && testY >= 0 && testY < this.height) {
                        const gridIdx = this.gridIndex(testX, testY);
                        if (gridIdx < 0) continue;
                        
                        // Calculate distance to parent leader
                        const dxToParent = targetX - testX;
                        const dyToParent = targetY - testY;
                        const distToParent = Math.sqrt(dxToParent * dxToParent + dyToParent * dyToParent);
                        
                        // Strong attraction to parent leader position (inverse distance)
                        const parentAttraction = (1.0 / (1.0 + distToParent * 0.01)) * 0.6;
                        
                        const fieldAttraction = Math.abs(this.electricField[gridIdx]) * 0.2;
                        const coherenceAttraction = this.coherenceField[gridIdx] * 0.25;
                        
                        // Upward bias
                        const upwardBias = Math.max(0, (posLeader.currentY - testY)) * 0.02;
                        
                        const score = parentAttraction + fieldAttraction + coherenceAttraction + upwardBias + Math.random() * 0.15;
                        
                        if (score > maxScore) {
                            maxScore = score;
                            bestPos = {x: testX, y: testY};
                        }
                    }
                }
                
                return bestPos;
            }
            
            createReturnStroke(leader) {
                this.lightningStrokes.push({
                    path: [...leader.path].reverse(),
                    currentIndex: 0,
                    intensity: leader.intensity * 2.2,
                    age: 0,
                    active: true,
                    speed: 9 + Math.random() * 7,
                    coherence: leader.coherence
                });
                
                if (this.audioEnabled && this.soundSystem.ready) {
                    this.soundSystem.generateThunder(leader.intensity / 2.5, leader.coherence);
                }
            }
            
            createParticle(x, y, intensity) {
                this.lightningParticles.push({
                    x: x + (Math.random() - 0.5) * 5,
                    y: y + (Math.random() - 0.5) * 5,
                    intensity: intensity * 0.8,
                    age: 0,
                    maxAge: 22 + Math.random() * 18,
                    size: 2 + intensity * 3.5
                });
            }
            
            updateRain() {
                for (let cloud of this.clouds) {
                    if (cloud.moisture > 0.5 && Math.random() < 0.005) {
                        this.rainDrops.push({
                            x: cloud.x + (Math.random() - 0.5) * cloud.width,
                            y: cloud.y + cloud.height * 0.4,
                            vx: (Math.random() - 0.5) * this.params.windSpeed * 0.6,
                            vy: 2.5 + Math.random() * 2.5,
                            size: 0.5 + Math.random() * 1.2,
                            opacity: 0.5 + Math.random() * 0.3,
                            age: 0
                        });
                    }
                }
                
                for (let i = this.rainDrops.length - 1; i >= 0; i--) {
                    const drop = this.rainDrops[i];
                    drop.x += drop.vx;
                    drop.y += drop.vy;
                    drop.vy += 0.12;
                    drop.age++;
                    
                    if (drop.y > this.groundLevel || drop.age > 220) {
                        this.rainDrops.splice(i, 1);
                    }
                }
            }
            
            updateSunCoverage() {
                let totalCoverage = 0;
                for (let cloud of this.clouds) {
                    const dx = cloud.x - this.sun.x;
                    const dy = cloud.y - this.sun.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < cloud.width * 0.8) {
                        const coverage = (1 - dist / (cloud.width * 0.8)) * cloud.density;
                        totalCoverage += coverage;
                    }
                }
                this.sun.coverage = Math.min(totalCoverage * 100, 90);
                this.sun.intensity = 0.8 * (1 - totalCoverage * 0.6);
            }
            
            updateCoherenceHistory() {
                let maxC = 0;
                let avgC = 0;
                for (let cloud of this.clouds) {
                    if (cloud.C > maxC) maxC = cloud.C;
                    avgC += cloud.C;
                }
                if (this.clouds.length > 0) avgC /= this.clouds.length;
                
                this.coherenceHistory.push({
                    maxC: maxC,
                    avgC: avgC,
                    C_crit: this.Omega * Math.log(this.Lambda / this.lambda0)
                });
                
                if (this.coherenceHistory.length > this.maxHistoryLength) {
                    this.coherenceHistory.shift();
                }
            }
            
            updatePerformance() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = now;
                }
            }
            
            triggerStormSurge() {
                console.log('Storm Surge');
                for (let cloud of this.clouds) {
                    cloud.C += cloud.C_crit * 0.3;
                    cloud.chargeTop.charge *= 1.6;
                    cloud.chargeBottom.charge *= 1.6;
                }
                
                for (let i = 0; i < 2; i++) {
                    this.createCloud(
                        Math.random() * this.width,
                        this.cloudLevel + Math.random() * 50,
                        55 + Math.random() * 70,
                        28 + Math.random() * 35,
                        0.35 + Math.random() * 0.35
                    );
                }
            }
            
            render(ctx) {
                this.renderSky(ctx);
                this.renderSun(ctx);
                
                if (this.showFields) {
                    this.renderFields(ctx);
                }
                
                this.renderClouds(ctx);
                
                if (this.rainEnabled) {
                    this.renderRain(ctx);
                }
                
                this.renderLightning(ctx);
                this.renderGround(ctx);
            }
            
            renderSky(ctx) {
                const darkness = this.sun.coverage * 0.008;
                const skyGradient = ctx.createLinearGradient(0, 0, 0, this.height);
                
                const r1 = Math.floor(135 - darkness * 85);
                const g1 = Math.floor(206 - darkness * 105);
                const b1 = Math.floor(235 - darkness * 125);
                
                skyGradient.addColorStop(0, `rgb(${r1}, ${g1}, ${b1})`);
                skyGradient.addColorStop(0.6, `rgb(${Math.floor(r1 * 0.7)}, ${Math.floor(g1 * 0.8)}, ${Math.floor(b1 * 0.9)})`);
                skyGradient.addColorStop(1, `rgb(${Math.floor(r1 * 0.5)}, ${Math.floor(g1 * 0.6)}, ${Math.floor(b1 * 0.7)})`);
                
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, this.width, this.height);
            }
            
            renderSun(ctx) {
                const alpha = Math.max(0.2, 1 - this.sun.coverage * 0.01);
                const size = 22 + this.sun.intensity * 18;
                
                const gradient = ctx.createRadialGradient(
                    this.sun.x, this.sun.y, 0,
                    this.sun.x, this.sun.y, size * 1.8
                );
                gradient.addColorStop(0, `rgba(255, 240, 70, ${alpha})`);
                gradient.addColorStop(0.4, `rgba(255, 200, 20, ${alpha * 0.6})`);
                gradient.addColorStop(1, `rgba(255, 160, 0, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(this.sun.x - size * 1.8, this.sun.y - size * 1.8, size * 3.6, size * 3.6);
            }
            
            renderFields(ctx) {
                for (let y = 0; y < this.gridHeight; y += 2) {
                    for (let x = 0; x < this.gridWidth; x += 2) {
                        const idx = y * this.gridWidth + x;
                        const coherence = Math.abs(this.coherenceField[idx]);
                        
                        if (coherence > 0.35) {
                            const realX = x * this.gridScale;
                            const realY = y * this.gridScale;
                            const alpha = Math.min(coherence * 0.05, 0.18);
                            const size = 3 + coherence * 5;
                            
                            ctx.fillStyle = `rgba(120, 160, 250, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(realX, realY, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            
            renderClouds(ctx) {
                for (let cloud of this.clouds) {
                    const baseColor = 170;
                    const alpha = Math.min(cloud.density * 0.75, 0.85);
                    
                    const gradient = ctx.createRadialGradient(
                        cloud.x, cloud.y - cloud.height * 0.2, 0,
                        cloud.x, cloud.y, cloud.width * 0.6
                    );
                    gradient.addColorStop(0, `rgba(${baseColor + 35}, ${baseColor + 35}, ${baseColor + 45}, ${alpha})`);
                    gradient.addColorStop(0.7, `rgba(${baseColor}, ${baseColor}, ${baseColor + 15}, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(${baseColor - 25}, ${baseColor - 25}, ${baseColor}, ${alpha * 0.4})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(cloud.x, cloud.y, cloud.width * 0.5, cloud.height * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    for (let particle of cloud.particles) {
                        const pAlpha = particle.opacity * cloud.density * 0.45;
                        ctx.fillStyle = `rgba(${baseColor + 15}, ${baseColor + 15}, ${baseColor + 25}, ${pAlpha})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            renderRain(ctx) {
                for (let drop of this.rainDrops) {
                    ctx.fillStyle = `rgba(173, 216, 230, ${drop.opacity})`;
                    ctx.fillRect(drop.x - drop.size * 0.5, drop.y - drop.size * 3.5, drop.size, drop.size * 5);
                }
            }
            
            renderLightning(ctx) {
                for (let flash of this.sheetFlashes) {
                    const pulse = Math.sin(flash.age * flash.pulseRate) * 0.5 + 0.5;
                    const alpha = flash.intensity * pulse * (1 - flash.age / flash.maxAge) * 0.12;
                    
                    if (alpha > 0.02) {
                        const gradient = ctx.createRadialGradient(
                            flash.x, flash.y, 0,
                            flash.x, flash.y, Math.max(flash.width, flash.height)
                        );
                        gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(220, 240, 255, ${alpha * 0.6})`);
                        gradient.addColorStop(1, `rgba(180, 200, 255, 0)`);
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(
                            flash.x - flash.width * 0.5,
                            flash.y - flash.height * 0.5,
                            flash.width,
                            flash.height
                        );
                    }
                }
                
                // Render downward leaders
                for (let leader of this.lightningLeaders) {
                    if (leader.path.length < 2) continue;
                    
                    const alpha = Math.min(leader.intensity * 0.7, 0.9);
                    
                    ctx.strokeStyle = `rgba(245, 250, 255, ${alpha})`;
                    ctx.lineWidth = 1 + leader.intensity * 1.2;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(leader.path[0].x, leader.path[0].y);
                    for (let i = 1; i < leader.path.length; i++) {
                        ctx.lineTo(leader.path[i].x, leader.path[i].y);
                    }
                    ctx.stroke();
                }
                
                // Render upward positive leaders (slightly different color)
                for (let posLeader of this.positiveLeaders) {
                    if (posLeader.path.length < 2) continue;
                    
                    const alpha = Math.min(posLeader.intensity * 0.65, 0.85);
                    
                    ctx.strokeStyle = `rgba(255, 245, 240, ${alpha})`;
                    ctx.lineWidth = 1 + posLeader.intensity * 1.1;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(posLeader.path[0].x, posLeader.path[0].y);
                    for (let i = 1; i < posLeader.path.length; i++) {
                        ctx.lineTo(posLeader.path[i].x, posLeader.path[i].y);
                    }
                    ctx.stroke();
                }
                
                for (let stroke of this.lightningStrokes) {
                    if (stroke.path.length < 2) continue;
                    
                    const visibleLength = Math.floor(stroke.currentIndex);
                    if (visibleLength < 2) continue;
                    
                    const visiblePath = stroke.path.slice(0, visibleLength);
                    const alpha = Math.min(stroke.intensity * 0.85, 1.0) * (1 - stroke.age / 90);
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = 1.5 + stroke.intensity * 2.2;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(visiblePath[0].x, visiblePath[0].y);
                    for (let i = 1; i < visiblePath.length; i++) {
                        ctx.lineTo(visiblePath[i].x, visiblePath[i].y);
                    }
                    ctx.stroke();
                    
                    ctx.strokeStyle = `rgba(220, 240, 255, ${alpha * 0.3})`;
                    ctx.lineWidth = 3.5 + stroke.intensity * 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(visiblePath[0].x, visiblePath[0].y);
                    for (let i = 1; i < visiblePath.length; i++) {
                        ctx.lineTo(visiblePath[i].x, visiblePath[i].y);
                    }
                    ctx.stroke();
                }
                
                for (let particle of this.lightningParticles) {
                    const alpha = Math.min(particle.intensity * 0.6, 0.8) * (1 - particle.age / particle.maxAge);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.lineCap = 'butt';
            }
            
            renderGround(ctx) {
                const groundGradient = ctx.createLinearGradient(0, this.groundLevel, 0, this.height);
                groundGradient.addColorStop(0, 'rgba(101, 67, 33, 0.9)');
                groundGradient.addColorStop(1, 'rgba(62, 39, 35, 1.0)');
                
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, this.groundLevel, this.width, this.height - this.groundLevel);
            }
        }

        function renderCoherenceGraph(atmosphere) {
            const canvas = document.getElementById('coherence-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            
            if (atmosphere.coherenceHistory.length < 2) return;
            
            const C_crit = atmosphere.Omega * Math.log(atmosphere.Lambda / atmosphere.lambda0);
            const maxScale = Math.max(C_crit * 1.2, 0.1);
            
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = height - (i / 5) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            const critY = height - (C_crit / maxScale) * height;
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, critY);
            ctx.lineTo(width, critY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#dc2626';
            ctx.font = '11px Inter';
            ctx.fillText('C_crit', 5, critY - 5);
            
            ctx.strokeStyle = '#059669';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const history = atmosphere.coherenceHistory;
            for (let i = 0; i < history.length; i++) {
                const x = (i / history.length) * width;
                const y = height - (history[i].maxC / maxScale) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < history.length; i++) {
                const x = (i / history.length) * width;
                const y = height - (history[i].avgC / maxScale) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            ctx.font = '10px Inter';
            ctx.fillStyle = '#059669';
            ctx.fillText('Max C(t)', width - 70, 15);
            ctx.fillStyle = '#2563eb';
            ctx.fillText('Avg C(t)', width - 70, 28);
        }

        // === APPLICATION ===
        let atmosphere = null;
        let running = false;
        let animationId = null;

        const canvas = document.getElementById('atmosphere-canvas');
        const ctx = canvas.getContext('2d');

        function initializeSystem() {
            atmosphere = new CRRAtmosphere(1000, 650);
            atmosphere.render(ctx);
            updateUI();
            renderCoherenceGraph(atmosphere);
        }

        function runAnimationLoop() {
            if (!running) return;
            
            atmosphere.step();
            atmosphere.render(ctx);
            updateUI();
            renderCoherenceGraph(atmosphere);
            
            animationId = requestAnimationFrame(runAnimationLoop);
        }

        function updateUI() {
            if (!atmosphere) return;
            
            const C_crit = atmosphere.Omega * Math.log(atmosphere.Lambda / atmosphere.lambda0);
            document.getElementById('c-critical').textContent = C_crit.toFixed(3);
            document.getElementById('omega-val').textContent = atmosphere.Omega.toFixed(2);
            document.getElementById('lambda-ratio').textContent = (atmosphere.Lambda / atmosphere.lambda0).toFixed(1);
            
            let maxC = 0;
            let avgC = 0;
            let nextRupture = '---';
            let phaseText = 'Building';
            
            for (let cloud of atmosphere.clouds) {
                if (cloud.C > maxC) maxC = cloud.C;
                avgC += cloud.C;
                
                if (cloud.C > C_crit * 0.8 && nextRupture === '---') {
                    const remaining = C_crit - cloud.C;
                    const rate = cloud.L_functional();
                    if (rate > 0.001) {
                        const seconds = remaining / (rate * 60);
                        nextRupture = `~${Math.ceil(seconds)}s`;
                        phaseText = 'Imminent';
                    }
                }
            }
            
            if (atmosphere.clouds.length > 0) avgC /= atmosphere.clouds.length;
            
            document.getElementById('max-coherence').textContent = maxC.toFixed(3);
            document.getElementById('avg-coherence').textContent = avgC.toFixed(3);
            document.getElementById('next-rupture').textContent = nextRupture;
            document.getElementById('phase-indicator').textContent = phaseText;
            
            const hasLightning = atmosphere.lightningLeaders.length > 0 || atmosphere.lightningStrokes.length > 0 || atmosphere.sheetFlashes.length > 0;
            document.getElementById('storm-phase').textContent = hasLightning ? 'Rupture' : 'Coherence';
            document.getElementById('clouds-count').textContent = atmosphere.clouds.length;
            document.getElementById('strikes-count').textContent = atmosphere.ruptureCount;
            document.getElementById('leaders-count').textContent = atmosphere.lightningLeaders.length;
            document.getElementById('positive-leaders-count').textContent = atmosphere.positiveLeaders.length;
            document.getElementById('rupture-coherence').textContent = atmosphere.lastRuptureCoherence > 0 ? atmosphere.lastRuptureCoherence.toFixed(3) : '---';
            document.getElementById('fps-display').textContent = atmosphere.fps;
            document.getElementById('rain-drops').textContent = atmosphere.rainDrops.length;
            
            const audioStatusText = atmosphere.audioEnabled ? (atmosphere.soundSystem.ready ? 'Ready' : 'Initializing') : 'Off';
            document.getElementById('audio-status').textContent = audioStatusText;
            
            document.getElementById('system-state').textContent = hasLightning ? 'Active' : 'Building';
            document.getElementById('lightning-mode-display').textContent = atmosphere.lightningMode.charAt(0).toUpperCase() + atmosphere.lightningMode.slice(1);
            
            updateCRRPhaseDisplay();
        }

        function updateCRRPhaseDisplay() {
            const hasLightning = atmosphere.lightningLeaders.length > 0 || atmosphere.lightningStrokes.length > 0 || atmosphere.sheetFlashes.length > 0;
            let maxC = 0;
            for (let cloud of atmosphere.clouds) {
                if (cloud.C > maxC) maxC = cloud.C;
            }
            const C_crit = atmosphere.Omega * Math.log(atmosphere.Lambda / atmosphere.lambda0);
            
            let newPhase = 'coherence';
            let title = 'Coherence Phase: C(x,t) = ∫₀ᵗ L(x,τ) dτ';
            let description = 'Atmospheric coherence building via Euler integration';
            let codeSnippet = `<span class="code-comment">// Authentic CRR: C(t) = ∫₀ᵗ L(x,τ) dτ</span>
<span class="code-variable">cloud.C</span> <span class="code-operator">+=</span> <span class="code-variable">cloud.L_functional</span>() <span class="code-operator">*</span> <span class="code-variable">dt</span>;
<span class="code-comment">// Rupture when C >= C_crit</span>
<span class="code-operator">if</span> (<span class="code-variable">cloud.C</span> <span class="code-operator">>=</span> <span class="code-variable">cloud.C_crit</span>) <span class="code-function">rupture</span>();`;
            
            if (hasLightning) {
                newPhase = 'rupture';
                title = 'Rupture Phase: Deterministic at C ≥ C_crit';
                description = `Lightning at C(t) ≥ C_crit = ${C_crit.toFixed(3)}`;
                codeSnippet = `<span class="code-comment">// Rupture: stepped leader growth</span>
<span class="code-variable">nextPos</span> <span class="code-operator">=</span> <span class="code-function">findPath</span>(<span class="code-variable">leader</span>, <span class="code-variable">electricField</span>);
<span class="code-variable">leader.path</span>.<span class="code-function">push</span>(<span class="code-variable">nextPos</span>);
<span class="code-operator">if</span> (<span class="code-variable">reachedGround</span>) <span class="code-function">createReturnStroke</span>();`;
            } else if (maxC > C_crit * 0.3) {
                newPhase = 'regeneration';
                title = 'Regeneration Phase: R[χ] ∝ exp(C/Ω)';
                description = 'Exponential rebirth weighting from history';
                codeSnippet = `<span class="code-comment">// Rebirth: exp(C/Ω) weighting</span>
<span class="code-operator">for</span> (<span class="code-variable">hist</span> <span class="code-operator">of</span> <span class="code-variable">C_history</span>) {
    <span class="code-variable">rebirth</span> <span class="code-operator">+=</span> Math.<span class="code-function">exp</span>(<span class="code-variable">hist.C</span> <span class="code-operator">/</span> <span class="code-variable">Omega</span>) <span class="code-operator">*</span> <span class="code-variable">dt</span>;
}`;
            }
            
            const statusElement = document.getElementById('crr-status');
            statusElement.className = `crr-status ${newPhase}`;
            document.getElementById('current-crr-phase').textContent = title;
            document.getElementById('crr-description').textContent = description;
            document.getElementById('code-snippet').innerHTML = codeSnippet;
        }

        // === EVENT HANDLERS ===
        document.getElementById('start-btn').addEventListener('click', () => {
            running = !running;
            const btn = document.getElementById('start-btn');
            
            if (running) {
                btn.textContent = 'Pause';
                btn.classList.add('active');
                runAnimationLoop();
            } else {
                btn.textContent = 'Start System';
                btn.classList.remove('active');
                if (animationId) cancelAnimationFrame(animationId);
            }
        });

        document.getElementById('surge-btn').addEventListener('click', () => {
            if (atmosphere) atmosphere.triggerStormSurge();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            running = false;
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('start-btn').textContent = 'Start System';
            document.getElementById('start-btn').classList.remove('active');
            if (atmosphere && atmosphere.soundSystem) atmosphere.soundSystem.disable();
            initializeSystem();
        });

        document.getElementById('audio-btn').addEventListener('click', async () => {
            const btn = document.getElementById('audio-btn');
            
            if (!atmosphere.audioEnabled) {
                btn.textContent = 'Initializing...';
                btn.disabled = true;
                
                const success = await atmosphere.soundSystem.init();
                
                if (success) {
                    atmosphere.audioEnabled = true;
                    btn.textContent = 'Disable Thunder';
                    btn.classList.add('audio-enabled');
                    btn.classList.remove('audio-error');
                    console.log('Audio enabled successfully');
                } else {
                    btn.textContent = 'Audio Failed (Click to Retry)';
                    btn.classList.add('audio-error');
                    atmosphere.audioEnabled = false;
                }
                
                btn.disabled = false;
            } else {
                await atmosphere.soundSystem.disable();
                atmosphere.audioEnabled = false;
                btn.textContent = 'Enable Thunder';
                btn.classList.remove('audio-enabled');
                btn.classList.remove('audio-error');
            }
        });

        // CRR parameters
        document.getElementById('omega-slider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('omega-display').textContent = val.toFixed(1);
            if (atmosphere) atmosphere.updateCRRParameters(val, atmosphere.Lambda, atmosphere.lambda0, atmosphere.L_rate);
        });

        document.getElementById('lambda-slider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('lambda-display').textContent = val.toFixed(1);
            if (atmosphere) atmosphere.updateCRRParameters(atmosphere.Omega, val, atmosphere.lambda0, atmosphere.L_rate);
        });

        document.getElementById('lambda0-slider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('lambda0-display').textContent = val.toFixed(1);
            if (atmosphere) atmosphere.updateCRRParameters(atmosphere.Omega, atmosphere.Lambda, val, atmosphere.L_rate);
        });

        document.getElementById('l-rate-slider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('l-rate-display').textContent = val.toFixed(2);
            if (atmosphere) atmosphere.updateCRRParameters(atmosphere.Omega, atmosphere.Lambda, atmosphere.lambda0, val);
        });

        // Lightning controls
        document.getElementById('branching-rate').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('branch-val').textContent = val.toFixed(1);
            if (atmosphere) atmosphere.params.branchingRate = val;
        });

        document.getElementById('step-size').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('step-val').textContent = val;
            if (atmosphere) atmosphere.params.stepSize = val;
        });

        document.getElementById('positive-leader-prob').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('pos-leader-prob-val').textContent = `${Math.round(val * 100)}%`;
            if (atmosphere) atmosphere.params.positiveLeaderProbability = val;
        });

        ['bolt-mode', 'sheet-mode', 'mixed-mode'].forEach(modeId => {
            document.getElementById(modeId).addEventListener('click', () => {
                if (atmosphere) {
                    const mode = modeId.split('-')[0];
                    atmosphere.lightningMode = mode;
                    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                    document.getElementById(modeId).classList.add('active');
                }
            });
        });

        // Other controls
        ['wind-speed', 'cloud-formation'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                const label = id.split('-')[0];
                document.getElementById(`${label}-val`).textContent = val.toFixed(1);
                
                if (atmosphere) {
                    const paramMap = {
                        'wind-speed': 'windSpeed',
                        'cloud-formation': 'cloudFormation'
                    };
                    atmosphere.params[paramMap[id]] = val;
                }
            });
        });

        document.getElementById('thunder-volume').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('volume-val').textContent = val.toFixed(1);
            if (atmosphere) atmosphere.soundSystem.setVolume(val);
        });

        document.getElementById('reverb-amount').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('reverb-val').textContent = val.toFixed(1);
            if (atmosphere) atmosphere.soundSystem.setReverb(val);
        });

        document.getElementById('show-fields').addEventListener('change', (e) => {
            if (atmosphere) atmosphere.showFields = e.target.checked;
        });

        document.getElementById('rain-enabled').addEventListener('change', (e) => {
            if (atmosphere) atmosphere.rainEnabled = e.target.checked;
        });

        document.getElementById('positive-leaders-enabled').addEventListener('change', (e) => {
            if (atmosphere) atmosphere.positiveLeadersEnabled = e.target.checked;
        });

        // === INIT ===
        initializeSystem();
        console.log("=== AUTHENTIC CRR SYSTEM WITH PHYSICALLY ACCURATE POSITIVE LEADERS ===");
        console.log("Positive leaders: 60-85% spawn probability within 100px of ground");
        console.log("Parent-seeking behavior, max propagation 120px");
    </script>
</body>
</html>