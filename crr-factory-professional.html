<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Factory Dynamics | Cohere Research</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600&family=Playfair+Display:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #030508;
      --bg-secondary: #0a0f1a;
      --bg-tertiary: #111827;
      --accent-indigo: #6366f1;
      --accent-violet: #8b5cf6;
      --accent-cyan: #06b6d4;
      --accent-emerald: #10b981;
      --accent-amber: #f59e0b;
      --accent-rose: #f43f5e;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --border-subtle: rgba(99, 102, 241, 0.15);
      --glow-indigo: rgba(99, 102, 241, 0.4);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: var(--bg-primary);
      font-family: 'Inter', -apple-system, sans-serif;
      color: var(--text-primary);
      overflow-x: hidden;
    }

    /* Animated background */
    .bg-animation {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(139, 92, 246, 0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(6, 182, 212, 0.04) 0%, transparent 60%);
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: 1800px;
      margin: 0 auto;
      padding: 16px 20px;
    }

    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0 24px;
      border-bottom: 1px solid var(--border-subtle);
      margin-bottom: 20px;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-indigo), var(--accent-violet));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem;
      font-weight: 600;
      color: white;
      box-shadow: 0 4px 20px var(--glow-indigo);
    }

    .brand {
      display: flex;
      flex-direction: column;
    }

    .brand-name {
      font-family: 'Playfair Display', serif;
      font-size: 1.4rem;
      font-weight: 500;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-indigo));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .brand-tagline {
      font-size: 0.65rem;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .header-title {
      text-align: center;
      flex: 1;
    }

    .header-title h1 {
      font-family: 'Inter', sans-serif;
      font-size: 1.1rem;
      font-weight: 300;
      letter-spacing: 0.4em;
      color: var(--text-secondary);
      text-transform: uppercase;
    }

    .header-stats {
      display: flex;
      gap: 24px;
    }

    .header-stat {
      text-align: right;
    }

    .header-stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.3rem;
      font-weight: 300;
    }

    .header-stat-label {
      font-size: 0.6rem;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    /* Main Layout */
    .main-grid {
      display: grid;
      grid-template-columns: 280px 1fr 300px;
      gap: 20px;
      min-height: calc(100vh - 180px);
    }

    @media (max-width: 1400px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Panels */
    .panel {
      background: linear-gradient(180deg, rgba(17, 24, 39, 0.8) 0%, rgba(10, 15, 26, 0.9) 100%);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      overflow: hidden;
    }

    .panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-subtle);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel-title {
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .panel-content {
      padding: 20px;
    }

    /* Control Bar */
    .control-bar {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px 20px;
      background: rgba(17, 24, 39, 0.6);
      border-radius: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .btn {
      font-family: 'Inter', sans-serif;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      padding: 12px 28px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-emerald), #059669);
      color: white;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .btn-primary.running {
      background: linear-gradient(135deg, var(--accent-rose), #dc2626);
      box-shadow: 0 4px 15px rgba(244, 63, 94, 0.3);
    }

    .btn-secondary {
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      color: var(--accent-indigo);
    }

    .btn-secondary:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
      padding-left: 16px;
      border-left: 1px solid var(--border-subtle);
    }

    .control-label {
      font-size: 0.65rem;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .control-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-indigo);
      min-width: 30px;
    }

    input[type="range"] {
      width: 100px;
      height: 4px;
      -webkit-appearance: none;
      background: rgba(99, 102, 241, 0.2);
      border-radius: 2px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent-indigo);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px var(--glow-indigo);
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent-indigo);
    }

    /* Canvas Container */
    .canvas-wrapper {
      position: relative;
      background: var(--bg-primary);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 
        inset 0 0 100px rgba(99, 102, 241, 0.05),
        0 0 60px rgba(0, 0, 0, 0.5);
    }

    #factoryCanvas {
      display: block;
      width: 100%;
      height: auto;
    }

    .canvas-overlay {
      position: absolute;
      top: 16px;
      left: 16px;
      display: flex;
      gap: 12px;
    }

    .overlay-badge {
      padding: 6px 12px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
    }

    .overlay-badge.live {
      border-color: var(--accent-emerald);
      color: var(--accent-emerald);
    }

    .overlay-badge.live::before {
      content: '';
      display: inline-block;
      width: 6px;
      height: 6px;
      background: var(--accent-emerald);
      border-radius: 50%;
      margin-right: 6px;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .stat-card {
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid var(--border-subtle);
      border-radius: 10px;
      padding: 14px;
      transition: all 0.2s ease;
    }

    .stat-card:hover {
      border-color: rgba(99, 102, 241, 0.3);
      background: rgba(15, 23, 42, 0.7);
    }

    .stat-card-label {
      font-size: 0.6rem;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .stat-card-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.4rem;
      font-weight: 300;
    }

    .stat-card-value.indigo { color: var(--accent-indigo); }
    .stat-card-value.emerald { color: var(--accent-emerald); }
    .stat-card-value.amber { color: var(--accent-amber); }
    .stat-card-value.cyan { color: var(--accent-cyan); }
    .stat-card-value.violet { color: var(--accent-violet); }
    .stat-card-value.rose { color: var(--accent-rose); }

    /* CRR Section */
    .crr-section {
      margin-top: 20px;
    }

    .crr-equations {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.05));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .equation {
      font-family: 'Times New Roman', Georgia, serif;
      font-size: 0.95rem;
      color: var(--accent-violet);
      margin-bottom: 8px;
      padding-left: 12px;
      border-left: 2px solid var(--accent-indigo);
    }

    .equation:last-child {
      margin-bottom: 0;
    }

    .equation strong {
      color: var(--accent-cyan);
    }

    .validation-card {
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid var(--border-subtle);
      border-radius: 10px;
      padding: 16px;
    }

    .validation-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .validation-row:last-child {
      border-bottom: none;
    }

    .validation-label {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .validation-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .validation-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.6rem;
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .validation-status.valid {
      background: rgba(16, 185, 129, 0.15);
      color: var(--accent-emerald);
    }

    .validation-status.pending {
      background: rgba(245, 158, 11, 0.15);
      color: var(--accent-amber);
    }

    /* Agent Types */
    .agent-types {
      margin-top: 20px;
    }

    .agent-type-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      margin-bottom: 8px;
      transition: all 0.2s ease;
    }

    .agent-type-card:hover {
      border-color: rgba(99, 102, 241, 0.3);
    }

    .agent-type-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .agent-type-info {
      flex: 1;
    }

    .agent-type-name {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .agent-type-desc {
      font-size: 0.6rem;
      color: var(--text-muted);
    }

    .agent-type-count {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 500;
    }

    /* Events Log */
    .events-container {
      max-height: 280px;
      overflow-y: auto;
    }

    .events-container::-webkit-scrollbar {
      width: 4px;
    }

    .events-container::-webkit-scrollbar-track {
      background: rgba(99, 102, 241, 0.05);
      border-radius: 2px;
    }

    .events-container::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.2);
      border-radius: 2px;
    }

    .event-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      margin-bottom: 6px;
      border-left: 3px solid;
      transition: all 0.2s ease;
    }

    .event-item:hover {
      background: rgba(15, 23, 42, 0.6);
    }

    .event-item.production { border-color: var(--accent-emerald); }
    .event-item.delivery { border-color: var(--accent-cyan); }
    .event-item.rupture { border-color: var(--accent-violet); }
    .event-item.quality { border-color: var(--accent-amber); }

    .event-icon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
    }

    .event-icon.production { background: rgba(16, 185, 129, 0.2); color: var(--accent-emerald); }
    .event-icon.delivery { background: rgba(6, 182, 212, 0.2); color: var(--accent-cyan); }
    .event-icon.rupture { background: rgba(139, 92, 246, 0.2); color: var(--accent-violet); }
    .event-icon.quality { background: rgba(245, 158, 11, 0.2); color: var(--accent-amber); }

    .event-content {
      flex: 1;
    }

    .event-title {
      font-size: 0.7rem;
      font-weight: 500;
      color: var(--text-primary);
    }

    .event-detail {
      font-size: 0.6rem;
      color: var(--text-muted);
    }

    .event-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.6rem;
      color: var(--text-muted);
    }

    /* Insight Box */
    .insight-box {
      margin-top: 20px;
      padding: 16px;
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(6, 182, 212, 0.05));
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: 12px;
    }

    .insight-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--accent-emerald);
      margin-bottom: 8px;
    }

    .insight-text {
      font-size: 0.7rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    /* Mini Chart */
    .mini-chart {
      height: 60px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      margin-top: 12px;
      overflow: hidden;
      position: relative;
    }

    .mini-chart-canvas {
      width: 100%;
      height: 100%;
    }

    /* Footer */
    footer {
      margin-top: 24px;
      padding: 16px 0;
      border-top: 1px solid var(--border-subtle);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .footer-links {
      display: flex;
      gap: 20px;
    }

    .footer-link {
      color: var(--text-muted);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .footer-link:hover {
      color: var(--accent-indigo);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 30px;
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    /* Production Line Indicator */
    .production-lines {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    .production-line {
      flex: 1;
      padding: 10px;
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      text-align: center;
    }

    .production-line-label {
      font-size: 0.55rem;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .production-line-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .production-line-bar {
      height: 3px;
      background: rgba(99, 102, 241, 0.2);
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
    }

    .production-line-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-indigo), var(--accent-violet));
      border-radius: 2px;
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="bg-animation"></div>
  
  <div class="container">
    <header>
      <div class="logo-section">
        <div class="logo">Î©</div>
        <div class="brand">
          <div class="brand-name">Cohere Research</div>
          <div class="brand-tagline">Coherenceâ€“Ruptureâ€“Regeneration</div>
        </div>
      </div>
      
      <div class="header-title">
        <h1>Adaptive Factory Dynamics</h1>
      </div>
      
      <div class="header-stats">
        <div class="header-stat">
          <div class="header-stat-value" style="color: var(--accent-emerald);" id="headerProduction">0</div>
          <div class="header-stat-label">Units Produced</div>
        </div>
        <div class="header-stat">
          <div class="header-stat-value" style="color: var(--accent-cyan);" id="headerEfficiency">0%</div>
          <div class="header-stat-label">Efficiency</div>
        </div>
      </div>
    </header>

    <div class="main-grid">
      <!-- Left Panel -->
      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">System Metrics</span>
        </div>
        <div class="panel-content">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-card-label">Tick</div>
              <div class="stat-card-value indigo" id="statTick">0</div>
            </div>
            <div class="stat-card">
              <div class="stat-card-label">Agents</div>
              <div class="stat-card-value violet" id="statAgents">0</div>
            </div>
            <div class="stat-card">
              <div class="stat-card-label">Deliveries</div>
              <div class="stat-card-value emerald" id="statDeliveries">0</div>
            </div>
            <div class="stat-card">
              <div class="stat-card-label">Ruptures</div>
              <div class="stat-card-value amber" id="statRuptures">0</div>
            </div>
            <div class="stat-card">
              <div class="stat-card-label">Throughput</div>
              <div class="stat-card-value cyan" id="statThroughput">0</div>
            </div>
            <div class="stat-card">
              <div class="stat-card-label">Field CÌ„</div>
              <div class="stat-card-value violet" id="statCoherence">0.000</div>
            </div>
          </div>

          <div class="production-lines">
            <div class="production-line">
              <div class="production-line-label">Line A</div>
              <div class="production-line-value" style="color: var(--accent-emerald);" id="lineA">0</div>
              <div class="production-line-bar">
                <div class="production-line-fill" id="lineABar" style="width: 0%"></div>
              </div>
            </div>
            <div class="production-line">
              <div class="production-line-label">Line B</div>
              <div class="production-line-value" style="color: var(--accent-cyan);" id="lineB">0</div>
              <div class="production-line-bar">
                <div class="production-line-fill" id="lineBBar" style="width: 0%"></div>
              </div>
            </div>
            <div class="production-line">
              <div class="production-line-label">Line C</div>
              <div class="production-line-value" style="color: var(--accent-violet);" id="lineC">0</div>
              <div class="production-line-bar">
                <div class="production-line-fill" id="lineCBar" style="width: 0%"></div>
              </div>
            </div>
          </div>

          <div class="crr-section">
            <div class="panel-title" style="margin-bottom: 12px;">CRR Framework</div>
            <div class="crr-equations">
              <div class="equation"><strong>C</strong>(x,t) = âˆ« L(x,Ï„) dÏ„</div>
              <div class="equation"><strong>Î´</strong>(now) â€” rupture event</div>
              <div class="equation"><strong>R</strong> = âˆ« Ï† Â· exp(C/Î©) dÏ„</div>
            </div>
            
            <div class="validation-card">
              <div class="validation-row">
                <span class="validation-label">Î©_Zâ‚‚ = 1/Ï€</span>
                <span class="validation-value" style="color: var(--accent-indigo);" id="omegaValue">0.3183</span>
              </div>
              <div class="validation-row">
                <span class="validation-label">CV Predicted</span>
                <span class="validation-value" style="color: var(--accent-violet);" id="cvPredicted">0.1592</span>
              </div>
              <div class="validation-row">
                <span class="validation-label">CV Measured</span>
                <span class="validation-value" id="cvMeasured" style="color: var(--accent-amber);">â€”</span>
              </div>
              <div class="validation-row">
                <span class="validation-label">Status</span>
                <span class="validation-status pending" id="validationStatus">Collecting data</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Center Panel -->
      <div class="panel" style="display: flex; flex-direction: column;">
        <div class="panel-content" style="flex: 1; display: flex; flex-direction: column;">
          <div class="control-bar">
            <button class="btn btn-primary" id="btnStart">
              <span>â–¶</span> START
            </button>
            <button class="btn btn-secondary" id="btnReset">RESET</button>
            
            <div class="control-group">
              <span class="control-label">Speed</span>
              <input type="range" id="speedSlider" min="1" max="100" value="60">
            </div>
            
            <div class="control-group">
              <span class="control-label">Agents</span>
              <input type="range" id="agentSlider" min="8" max="30" value="16">
              <span class="control-value" id="agentCount">16</span>
            </div>
            
            <div class="control-group">
              <input type="checkbox" id="showField" checked>
              <span class="control-label">Field</span>
            </div>
            
            <div class="control-group">
              <input type="checkbox" id="showTrails" checked>
              <span class="control-label">Trails</span>
            </div>
            
            <div class="control-group">
              <input type="checkbox" id="showZones">
              <span class="control-label">Zones</span>
            </div>
          </div>

          <div class="canvas-wrapper" style="flex: 1; position: relative;">
            <canvas id="factoryCanvas"></canvas>
            <div class="canvas-overlay">
              <div class="overlay-badge live" id="statusBadge">SIMULATION PAUSED</div>
              <div class="overlay-badge" style="color: var(--accent-violet);">
                Î©: <span id="overlayOmega">0.318</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Panel -->
      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">Agent Manifest</span>
        </div>
        <div class="panel-content">
          <div class="agent-types" id="agentTypes"></div>
          
          <div style="margin-top: 20px;">
            <div class="panel-title" style="margin-bottom: 12px;">Event Stream</div>
            <div class="events-container" id="eventsLog">
              <div class="empty-state">Awaiting simulation start...</div>
            </div>
          </div>

          <div class="insight-box">
            <div class="insight-title">
              <span>âš¡</span> Emergent Coordination
            </div>
            <div class="insight-text">
              No central scheduler coordinates agent movements. Each agent makes locally optimal decisions 
              weighted by the non-Markovian coherence field C(x,t). Global efficiency emerges from 
              CRR dynamics: coherence accumulation creates "memory" in space, ruptures trigger phase 
              transitions, and regeneration weights historical paths by exp(C/Î©).
            </div>
          </div>

          <div class="mini-chart">
            <canvas id="chartCanvas" class="mini-chart-canvas"></canvas>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div>Â© 2025 Cohere Research | cohere.org.uk</div>
      <div class="footer-links">
        <a href="#" class="footer-link">Documentation</a>
        <a href="#" class="footer-link">Theory</a>
        <a href="#" class="footer-link">Contact</a>
      </div>
    </footer>
  </div>

  <script>
    // ============================================
    // CRR FACTORY SIMULATION
    // Professional-Grade Implementation
    // ============================================

    const CONFIG = {
      GRID_COLS: 48,
      GRID_ROWS: 28,
      CELL_SIZE: 22,
      
      // CRR Parameters
      OMEGA_Z2: 1 / Math.PI,
      OMEGA_SO2: 1 / (2 * Math.PI),
      get CV_PREDICTED() { return this.OMEGA_Z2 / 2; },
      
      // Field dynamics
      COHERENCE_DECAY: 0.993,
      COHERENCE_DEPOSIT: 0.015,
      COHERENCE_SPREAD: 2.8,
      
      // Visual
      TRAIL_LENGTH: 35,
      PATH_RECALC_INTERVAL: 12,
    };

    // Agent type definitions
    const AGENT_TYPES = {
      forklift: {
        name: 'Forklift',
        icon: 'ðŸšœ',
        color: '#3b82f6',
        speed: 0.22,
        omega: CONFIG.OMEGA_Z2,
        count: 0,
      },
      carrier: {
        name: 'Carrier Bot',
        icon: 'ðŸ¤–',
        color: '#10b981',
        speed: 0.28,
        omega: CONFIG.OMEGA_Z2 * 0.9,
        count: 0,
      },
      transporter: {
        name: 'Transporter',
        icon: 'ðŸ“¦',
        color: '#f59e0b',
        speed: 0.18,
        omega: CONFIG.OMEGA_Z2 * 1.1,
        count: 0,
      },
    };

    // Color palette
    const COLORS = [
      '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
      '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9',
      '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
      '#ec4899', '#f43f5e', '#fb7185', '#38bdf8', '#4ade80',
      '#facc15', '#fb923c', '#f87171', '#a78bfa', '#818cf8',
      '#2dd4bf', '#34d399', '#a3e635', '#fbbf24', '#f472b6',
    ];

    // Factory layout
    const LAYOUT = {
      // Production stations
      stations: [
        { x: 6, y: 4, w: 4, h: 3, type: 'assembly', line: 'A' },
        { x: 6, y: 12, w: 4, h: 3, type: 'assembly', line: 'B' },
        { x: 6, y: 20, w: 4, h: 3, type: 'assembly', line: 'C' },
        { x: 20, y: 4, w: 4, h: 3, type: 'processing', line: 'A' },
        { x: 20, y: 12, w: 4, h: 3, type: 'processing', line: 'B' },
        { x: 20, y: 20, w: 4, h: 3, type: 'processing', line: 'C' },
        { x: 34, y: 4, w: 4, h: 3, type: 'quality', line: 'A' },
        { x: 34, y: 12, w: 4, h: 3, type: 'quality', line: 'B' },
        { x: 34, y: 20, w: 4, h: 3, type: 'quality', line: 'C' },
      ],
      
      // Storage racks
      racks: [
        { x: 13, y: 2, w: 3, h: 6 },
        { x: 13, y: 10, w: 3, h: 6 },
        { x: 13, y: 18, w: 3, h: 6 },
        { x: 27, y: 2, w: 3, h: 6 },
        { x: 27, y: 10, w: 3, h: 6 },
        { x: 27, y: 18, w: 3, h: 6 },
      ],
      
      // Input zones (raw materials)
      inputs: [
        { x: 0, y: 5, line: 'A' },
        { x: 0, y: 13, line: 'B' },
        { x: 0, y: 21, line: 'C' },
      ],
      
      // Output zones (finished goods)
      outputs: [
        { x: 47, y: 5, line: 'A' },
        { x: 47, y: 13, line: 'B' },
        { x: 47, y: 21, line: 'C' },
      ],
      
      // Charging stations
      charging: [
        { x: 22, y: 0 },
        { x: 24, y: 0 },
        { x: 22, y: 27 },
        { x: 24, y: 27 },
      ],
    };

    // ============================================
    // STATE MANAGEMENT
    // ============================================
    const state = {
      running: false,
      tick: 0,
      agents: [],
      coherenceField: null,
      settings: {
        speed: 60,
        agentCount: 16,
        showField: true,
        showTrails: true,
        showZones: false,
      },
      stats: {
        deliveries: 0,
        ruptures: 0,
        production: { A: 0, B: 0, C: 0 },
        throughput: 0,
        avgCoherence: 0,
        measuredCV: null,
        decisionIntervals: [],
        efficiencyHistory: [],
      },
      events: [],
    };

    // ============================================
    // CANVAS SETUP
    // ============================================
    const canvas = document.getElementById('factoryCanvas');
    const ctx = canvas.getContext('2d');
    const chartCanvas = document.getElementById('chartCanvas');
    const chartCtx = chartCanvas.getContext('2d');

    function resizeCanvas() {
      const container = canvas.parentElement;
      const maxWidth = container.clientWidth - 32;
      const aspectRatio = CONFIG.GRID_COLS / CONFIG.GRID_ROWS;
      
      let width = Math.min(maxWidth, CONFIG.GRID_COLS * CONFIG.CELL_SIZE);
      let height = width / aspectRatio;
      
      canvas.width = CONFIG.GRID_COLS * CONFIG.CELL_SIZE;
      canvas.height = CONFIG.GRID_ROWS * CONFIG.CELL_SIZE;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      
      // Chart canvas
      chartCanvas.width = chartCanvas.parentElement.clientWidth;
      chartCanvas.height = 60;
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ============================================
    // COHERENCE FIELD
    // ============================================
    function createField() {
      return new Float32Array(CONFIG.GRID_COLS * CONFIG.GRID_ROWS);
    }

    function getField(field, x, y) {
      const ix = Math.floor(x);
      const iy = Math.floor(y);
      if (ix < 0 || ix >= CONFIG.GRID_COLS || iy < 0 || iy >= CONFIG.GRID_ROWS) return 0;
      return field[iy * CONFIG.GRID_COLS + ix];
    }

    function setField(field, x, y, value) {
      const ix = Math.floor(x);
      const iy = Math.floor(y);
      if (ix < 0 || ix >= CONFIG.GRID_COLS || iy < 0 || iy >= CONFIG.GRID_ROWS) return;
      field[iy * CONFIG.GRID_COLS + ix] = Math.min(1, Math.max(0, value));
    }

    function depositCoherence(field, x, y, amount) {
      const spread = CONFIG.COHERENCE_SPREAD;
      const r = Math.ceil(spread);
      
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= spread) {
            const falloff = Math.exp(-dist * dist / (spread * 0.7));
            const current = getField(field, x + dx, y + dy);
            setField(field, x + dx, y + dy, current + amount * falloff);
          }
        }
      }
    }

    function decayField(field) {
      for (let i = 0; i < field.length; i++) {
        field[i] *= CONFIG.COHERENCE_DECAY;
      }
    }

    // ============================================
    // SPATIAL HASH
    // ============================================
    class SpatialHash {
      constructor(cellSize = 4) {
        this.cellSize = cellSize;
        this.cells = new Map();
      }

      clear() {
        this.cells.clear();
      }

      hash(x, y) {
        return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`;
      }

      insert(agent) {
        const key = this.hash(agent.x, agent.y);
        if (!this.cells.has(key)) this.cells.set(key, []);
        this.cells.get(key).push(agent);
      }

      query(x, y, radius) {
        const results = [];
        const cr = Math.ceil(radius / this.cellSize);
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);

        for (let dy = -cr; dy <= cr; dy++) {
          for (let dx = -cr; dx <= cr; dx++) {
            const cell = this.cells.get(`${cx + dx},${cy + dy}`);
            if (cell) {
              for (const agent of cell) {
                if (Math.hypot(agent.x - x, agent.y - y) <= radius) {
                  results.push(agent);
                }
              }
            }
          }
        }
        return results;
      }
    }

    const spatialHash = new SpatialHash();

    // ============================================
    // PATHFINDING
    // ============================================
    function isBlocked(x, y) {
      if (x < 0 || x >= CONFIG.GRID_COLS || y < 0 || y >= CONFIG.GRID_ROWS) return true;
      
      for (const rack of LAYOUT.racks) {
        if (x >= rack.x && x < rack.x + rack.w && y >= rack.y && y < rack.y + rack.h) {
          return true;
        }
      }
      
      for (const station of LAYOUT.stations) {
        if (x >= station.x && x < station.x + station.w && y >= station.y && y < station.y + station.h) {
          return true;
        }
      }
      
      return false;
    }

    function findPath(startX, startY, endX, endY, field, omega, agentId) {
      const start = { x: Math.round(startX), y: Math.round(startY) };
      const end = { x: Math.round(endX), y: Math.round(endY) };
      
      // Clamp end to valid position
      end.x = Math.max(0, Math.min(CONFIG.GRID_COLS - 1, end.x));
      end.y = Math.max(0, Math.min(CONFIG.GRID_ROWS - 1, end.y));
      
      const openSet = [{ ...start, g: 0, h: 0, f: 0, parent: null }];
      const closedSet = new Set();
      const heuristic = (x, y) => Math.abs(x - end.x) + Math.abs(y - end.y);
      
      let iterations = 0;
      const maxIterations = 800;
      
      while (openSet.length > 0 && iterations < maxIterations) {
        iterations++;
        
        // Find lowest f
        let lowestIdx = 0;
        for (let i = 1; i < openSet.length; i++) {
          if (openSet[i].f < openSet[lowestIdx].f) lowestIdx = i;
        }
        
        const current = openSet.splice(lowestIdx, 1)[0];
        
        if (current.x === end.x && current.y === end.y) {
          const path = [];
          let node = current;
          while (node.parent) {
            path.unshift({ x: node.x, y: node.y });
            node = node.parent;
          }
          return path;
        }
        
        closedSet.add(`${current.x},${current.y}`);
        
        const neighbors = [
          { x: current.x, y: current.y - 1 },
          { x: current.x, y: current.y + 1 },
          { x: current.x - 1, y: current.y },
          { x: current.x + 1, y: current.y },
        ];
        
        for (const neighbor of neighbors) {
          if (closedSet.has(`${neighbor.x},${neighbor.y}`)) continue;
          if (isBlocked(neighbor.x, neighbor.y)) continue;
          
          // Check other agents
          const nearbyAgents = spatialHash.query(neighbor.x, neighbor.y, 0.9);
          const hasOtherAgent = nearbyAgents.some(a => a.id !== agentId);
          
          // CRR: exp(C/Î©) weighting
          const coherence = getField(field, neighbor.x, neighbor.y);
          const regenWeight = Math.exp(coherence / omega);
          
          const baseCost = 1 / (1 + regenWeight * 0.4);
          const moveCost = hasOtherAgent ? baseCost + 4 : baseCost;
          
          const g = current.g + moveCost;
          const h = heuristic(neighbor.x, neighbor.y);
          const f = g + h;
          
          const existing = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
          if (existing) {
            if (g < existing.g) {
              existing.g = g;
              existing.f = f;
              existing.parent = current;
            }
          } else {
            openSet.push({ ...neighbor, g, h, f, parent: current });
          }
        }
      }
      
      return [];
    }

    // ============================================
    // AGENTS
    // ============================================
    function createAgents(count) {
      const agents = [];
      const types = Object.keys(AGENT_TYPES);
      
      // Reset counts
      for (const type of types) {
        AGENT_TYPES[type].count = 0;
      }
      
      for (let i = 0; i < count; i++) {
        const typeKey = types[i % types.length];
        const type = AGENT_TYPES[typeKey];
        type.count++;
        
        const line = ['A', 'B', 'C'][i % 3];
        const input = LAYOUT.inputs.find(inp => inp.line === line);
        const output = LAYOUT.outputs.find(out => out.line === line);
        
        // Stagger starting positions
        const startX = 10 + (i % 6) * 5;
        const startY = 3 + Math.floor(i / 6) * 8;
        
        agents.push({
          id: i,
          x: startX,
          y: startY,
          type: typeKey,
          color: COLORS[i % COLORS.length],
          speed: type.speed + (Math.random() - 0.5) * 0.05,
          omega: type.omega + (Math.random() - 0.5) * 0.02,
          line: line,
          state: 'toInput',
          targetX: input.x + 1,
          targetY: input.y,
          carrying: false,
          cargo: null,
          trail: [],
          path: [],
          pathAge: 0,
          lastRuptureTime: 0,
          stationIdx: 0,
        });
      }
      
      return agents;
    }

    function getNextTarget(agent) {
      const line = agent.line;
      const stations = LAYOUT.stations.filter(s => s.line === line);
      const input = LAYOUT.inputs.find(inp => inp.line === line);
      const output = LAYOUT.outputs.find(out => out.line === line);
      
      if (agent.state === 'toInput') {
        return { x: input.x + 1, y: input.y };
      } else if (agent.state === 'toStation') {
        const station = stations[agent.stationIdx];
        return { x: station.x + station.w + 1, y: station.y + 1 };
      } else if (agent.state === 'toOutput') {
        return { x: output.x - 1, y: output.y };
      }
      
      return { x: agent.x, y: agent.y };
    }

    // ============================================
    // SIMULATION
    // ============================================
    function simulationStep() {
      const { agents, coherenceField } = state;
      
      // Update spatial hash
      spatialHash.clear();
      for (const agent of agents) {
        spatialHash.insert(agent);
      }
      
      // Update agents
      for (const agent of agents) {
        const target = getNextTarget(agent);
        agent.targetX = target.x;
        agent.targetY = target.y;
        
        const dist = Math.hypot(agent.x - agent.targetX, agent.y - agent.targetY);
        
        // Check if reached target - RUPTURE
        if (dist < 1.2) {
          state.stats.ruptures++;
          
          // Record interval for CV
          if (agent.lastRuptureTime > 0) {
            const interval = state.tick - agent.lastRuptureTime;
            state.stats.decisionIntervals.push(interval);
            if (state.stats.decisionIntervals.length > 300) {
              state.stats.decisionIntervals.shift();
            }
          }
          agent.lastRuptureTime = state.tick;
          
          const stations = LAYOUT.stations.filter(s => s.line === agent.line);
          
          if (agent.state === 'toInput') {
            agent.state = 'toStation';
            agent.stationIdx = 0;
            agent.carrying = true;
            agent.cargo = 'raw';
            addEvent('pickup', agent, 'Raw materials loaded');
          } else if (agent.state === 'toStation') {
            const station = stations[agent.stationIdx];
            addEvent('rupture', agent, `${station.type} complete`);
            
            agent.stationIdx++;
            if (agent.stationIdx >= stations.length) {
              agent.state = 'toOutput';
              agent.cargo = 'finished';
            }
          } else if (agent.state === 'toOutput') {
            agent.state = 'toInput';
            agent.carrying = false;
            agent.cargo = null;
            state.stats.deliveries++;
            state.stats.production[agent.line]++;
            addEvent('delivery', agent, `Line ${agent.line} unit complete`);
          }
          
          // Omega modulation
          agent.omega = AGENT_TYPES[agent.type].omega + (Math.random() - 0.5) * 0.015;
          agent.path = [];
        }
        
        // Path finding
        agent.pathAge++;
        if (agent.path.length === 0 || agent.pathAge > CONFIG.PATH_RECALC_INTERVAL) {
          agent.path = findPath(
            agent.x, agent.y,
            agent.targetX, agent.targetY,
            coherenceField,
            agent.omega,
            agent.id
          );
          agent.pathAge = 0;
        }
        
        // Movement
        if (agent.path.length > 0) {
          const next = agent.path[0];
          const dx = next.x - agent.x;
          const dy = next.y - agent.y;
          const stepDist = Math.hypot(dx, dy);
          
          if (stepDist < 0.2) {
            agent.path.shift();
          } else {
            const newX = agent.x + (dx / stepDist) * agent.speed;
            const newY = agent.y + (dy / stepDist) * agent.speed;
            
            const nearby = spatialHash.query(newX, newY, 0.5);
            const collision = nearby.some(a => a.id !== agent.id && Math.hypot(a.x - newX, a.y - newY) < 0.4);
            
            if (!collision && !isBlocked(Math.round(newX), Math.round(newY))) {
              agent.x = newX;
              agent.y = newY;
            } else {
              agent.path = [];
            }
          }
        }
        
        // Trail
        agent.trail.push({ x: agent.x, y: agent.y });
        if (agent.trail.length > CONFIG.TRAIL_LENGTH) {
          agent.trail.shift();
        }
        
        // Deposit coherence
        depositCoherence(coherenceField, agent.x, agent.y, CONFIG.COHERENCE_DEPOSIT);
      }
      
      // Decay field
      decayField(coherenceField);
      
      state.tick++;
      updateStats();
    }

    function updateStats() {
      const field = state.coherenceField;
      let total = 0;
      for (let i = 0; i < field.length; i++) {
        total += field[i];
      }
      state.stats.avgCoherence = total / field.length;
      
      // Throughput
      state.stats.throughput = state.tick > 0
        ? (state.stats.deliveries / state.tick * 100).toFixed(1)
        : 0;
      
      // CV calculation
      const intervals = state.stats.decisionIntervals;
      if (intervals.length >= 15) {
        const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const variance = intervals.reduce((a, b) => a + (b - mean) ** 2, 0) / intervals.length;
        state.stats.measuredCV = Math.sqrt(variance) / mean;
      }
      
      // Efficiency
      const maxPossible = state.tick > 0 ? state.tick / 50 : 1;
      const efficiency = Math.min(100, (state.stats.deliveries / Math.max(1, maxPossible)) * 100);
      state.stats.efficiencyHistory.push(efficiency);
      if (state.stats.efficiencyHistory.length > 100) {
        state.stats.efficiencyHistory.shift();
      }
    }

    function addEvent(type, agent, detail) {
      state.events.unshift({
        type,
        agentId: agent.id,
        agentType: agent.type,
        line: agent.line,
        detail,
        tick: state.tick,
      });
      
      if (state.events.length > 30) {
        state.events.pop();
      }
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
      const { coherenceField, agents, settings } = state;
      const cs = CONFIG.CELL_SIZE;
      
      // Clear
      ctx.fillStyle = '#050508';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Coherence field
      if (settings.showField) {
        for (let y = 0; y < CONFIG.GRID_ROWS; y++) {
          for (let x = 0; x < CONFIG.GRID_COLS; x++) {
            const value = getField(coherenceField, x, y);
            if (value > 0.008) {
              const alpha = Math.min(0.65, value * 0.85);
              ctx.fillStyle = `rgba(99, 102, 241, ${alpha})`;
              ctx.fillRect(x * cs, y * cs, cs, cs);
            }
          }
        }
      }
      
      // Grid
      ctx.strokeStyle = 'rgba(99, 102, 241, 0.06)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= CONFIG.GRID_COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cs, 0);
        ctx.lineTo(x * cs, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= CONFIG.GRID_ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cs);
        ctx.lineTo(canvas.width, y * cs);
        ctx.stroke();
      }
      
      // Production flow zones
      if (settings.showZones) {
        const lines = [
          { y: 3, h: 7, color: 'rgba(16, 185, 129, 0.08)' },
          { y: 11, h: 7, color: 'rgba(6, 182, 212, 0.08)' },
          { y: 19, h: 7, color: 'rgba(139, 92, 246, 0.08)' },
        ];
        for (const line of lines) {
          ctx.fillStyle = line.color;
          ctx.fillRect(0, line.y * cs, canvas.width, line.h * cs);
        }
      }
      
      // Racks
      for (const rack of LAYOUT.racks) {
        const gradient = ctx.createLinearGradient(
          rack.x * cs, rack.y * cs,
          (rack.x + rack.w) * cs, (rack.y + rack.h) * cs
        );
        gradient.addColorStop(0, '#1e3a8a');
        gradient.addColorStop(1, '#312e81');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(rack.x * cs, rack.y * cs, rack.w * cs, rack.h * cs);
        
        ctx.strokeStyle = '#4f46e5';
        ctx.lineWidth = 2;
        ctx.strokeRect(rack.x * cs, rack.y * cs, rack.w * cs, rack.h * cs);
        
        // Shelf lines
        ctx.strokeStyle = 'rgba(79, 70, 229, 0.25)';
        ctx.lineWidth = 1;
        for (let i = 1; i < rack.h; i++) {
          ctx.beginPath();
          ctx.moveTo(rack.x * cs, (rack.y + i) * cs);
          ctx.lineTo((rack.x + rack.w) * cs, (rack.y + i) * cs);
          ctx.stroke();
        }
      }
      
      // Stations
      const stationColors = {
        assembly: { fill: '#065f46', stroke: '#10b981', label: 'ASM' },
        processing: { fill: '#1e40af', stroke: '#3b82f6', label: 'PRC' },
        quality: { fill: '#7c2d12', stroke: '#f59e0b', label: 'QC' },
      };
      
      for (const station of LAYOUT.stations) {
        const colors = stationColors[station.type];
        
        ctx.fillStyle = colors.fill;
        ctx.fillRect(station.x * cs, station.y * cs, station.w * cs, station.h * cs);
        
        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 2;
        ctx.strokeRect(station.x * cs, station.y * cs, station.w * cs, station.h * cs);
        
        // Label
        ctx.fillStyle = colors.stroke;
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
          colors.label,
          (station.x + station.w / 2) * cs,
          (station.y + station.h / 2) * cs
        );
      }
      
      // Input zones
      for (const input of LAYOUT.inputs) {
        ctx.fillStyle = 'rgba(16, 185, 129, 0.25)';
        ctx.fillRect(input.x * cs, input.y * cs, cs, cs * 2);
        
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 2;
        ctx.strokeRect(input.x * cs, input.y * cs, cs, cs * 2);
        
        ctx.fillStyle = '#10b981';
        ctx.font = 'bold 9px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('IN', input.x * cs + cs / 2, input.y * cs + cs);
      }
      
      // Output zones
      for (const output of LAYOUT.outputs) {
        ctx.fillStyle = 'rgba(6, 182, 212, 0.25)';
        ctx.fillRect(output.x * cs, output.y * cs, cs, cs * 2);
        
        ctx.strokeStyle = '#06b6d4';
        ctx.lineWidth = 2;
        ctx.strokeRect(output.x * cs, output.y * cs, cs, cs * 2);
        
        ctx.fillStyle = '#06b6d4';
        ctx.font = 'bold 9px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('OUT', output.x * cs + cs / 2, output.y * cs + cs);
      }
      
      // Charging stations
      for (const charging of LAYOUT.charging) {
        ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
        ctx.fillRect(charging.x * cs, charging.y * cs, cs * 2, cs);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 1;
        ctx.strokeRect(charging.x * cs, charging.y * cs, cs * 2, cs);
        
        ctx.fillStyle = '#f59e0b';
        ctx.font = '8px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('âš¡', (charging.x + 1) * cs, charging.y * cs + cs / 2 + 3);
      }
      
      // Agent trails
      if (settings.showTrails) {
        for (const agent of agents) {
          if (agent.trail.length > 1) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            for (let i = 1; i < agent.trail.length; i++) {
              const alpha = 0.08 + (i / agent.trail.length) * 0.35;
              ctx.strokeStyle = agent.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
              ctx.lineWidth = 2;
              
              ctx.beginPath();
              ctx.moveTo(agent.trail[i - 1].x * cs + cs / 2, agent.trail[i - 1].y * cs + cs / 2);
              ctx.lineTo(agent.trail[i].x * cs + cs / 2, agent.trail[i].y * cs + cs / 2);
              ctx.stroke();
            }
          }
        }
      }
      
      // Agents
      for (const agent of agents) {
        const cx = agent.x * cs + cs / 2;
        const cy = agent.y * cs + cs / 2;
        const size = cs * 0.75;
        
        // Glow
        const glowGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 1.3);
        glowGradient.addColorStop(0, agent.color + '50');
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(cx, cy, size * 1.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        const bodyGradient = ctx.createLinearGradient(cx - size / 2, cy - size / 2, cx + size / 2, cy + size / 2);
        bodyGradient.addColorStop(0, agent.color);
        bodyGradient.addColorStop(1, agent.color + 'cc');
        
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.roundRect(cx - size / 2, cy - size / 2, size, size, 4);
        ctx.fill();
        
        // Border
        ctx.strokeStyle = agent.carrying ? '#fbbf24' : 'rgba(255,255,255,0.5)';
        ctx.lineWidth = agent.carrying ? 3 : 2;
        ctx.beginPath();
        ctx.roundRect(cx - size / 2, cy - size / 2, size, size, 4);
        ctx.stroke();
        
        // ID
        ctx.fillStyle = 'white';
        ctx.font = 'bold 9px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(agent.id + 1, cx, cy);
        
        // Cargo indicator
        if (agent.carrying) {
          const cargoColor = agent.cargo === 'raw' ? '#10b981' : '#06b6d4';
          ctx.fillStyle = cargoColor;
          ctx.beginPath();
          ctx.arc(cx + size / 2 - 2, cy - size / 2 + 2, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      }
    }

    function renderChart() {
      const history = state.stats.efficiencyHistory;
      const w = chartCanvas.width;
      const h = chartCanvas.height;
      
      chartCtx.fillStyle = 'rgba(15, 23, 42, 0.5)';
      chartCtx.fillRect(0, 0, w, h);
      
      if (history.length < 2) return;
      
      const maxVal = 100;
      const step = w / (history.length - 1);
      
      // Draw line
      chartCtx.beginPath();
      chartCtx.moveTo(0, h - (history[0] / maxVal) * h);
      
      for (let i = 1; i < history.length; i++) {
        chartCtx.lineTo(i * step, h - (history[i] / maxVal) * h);
      }
      
      chartCtx.strokeStyle = '#6366f1';
      chartCtx.lineWidth = 2;
      chartCtx.stroke();
      
      // Fill
      chartCtx.lineTo(w, h);
      chartCtx.lineTo(0, h);
      chartCtx.closePath();
      
      const gradient = chartCtx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, 'rgba(99, 102, 241, 0.3)');
      gradient.addColorStop(1, 'rgba(99, 102, 241, 0)');
      chartCtx.fillStyle = gradient;
      chartCtx.fill();
    }

    // ============================================
    // UI UPDATES
    // ============================================
    function updateUI() {
      const { stats, agents } = state;
      
      // Stats
      document.getElementById('statTick').textContent = state.tick;
      document.getElementById('statAgents').textContent = agents.length;
      document.getElementById('statDeliveries').textContent = stats.deliveries;
      document.getElementById('statRuptures').textContent = stats.ruptures;
      document.getElementById('statThroughput').textContent = stats.throughput;
      document.getElementById('statCoherence').textContent = stats.avgCoherence.toFixed(4);
      
      // Header stats
      const totalProduction = stats.production.A + stats.production.B + stats.production.C;
      document.getElementById('headerProduction').textContent = totalProduction;
      
      const efficiency = state.tick > 0 
        ? Math.min(100, (stats.deliveries / (state.tick / 80)) * 100).toFixed(0)
        : 0;
      document.getElementById('headerEfficiency').textContent = efficiency + '%';
      
      // Production lines
      document.getElementById('lineA').textContent = stats.production.A;
      document.getElementById('lineB').textContent = stats.production.B;
      document.getElementById('lineC').textContent = stats.production.C;
      
      const maxLine = Math.max(stats.production.A, stats.production.B, stats.production.C, 1);
      document.getElementById('lineABar').style.width = (stats.production.A / maxLine * 100) + '%';
      document.getElementById('lineBBar').style.width = (stats.production.B / maxLine * 100) + '%';
      document.getElementById('lineCBar').style.width = (stats.production.C / maxLine * 100) + '%';
      
      // CRR validation
      const cvMeasured = document.getElementById('cvMeasured');
      const validationStatus = document.getElementById('validationStatus');
      
      if (stats.measuredCV !== null) {
        cvMeasured.textContent = stats.measuredCV.toFixed(4);
        const diff = Math.abs(stats.measuredCV - CONFIG.CV_PREDICTED);
        
        if (diff < 0.025) {
          cvMeasured.style.color = 'var(--accent-emerald)';
          validationStatus.className = 'validation-status valid';
          validationStatus.textContent = 'âœ“ Validated';
        } else if (diff < 0.05) {
          cvMeasured.style.color = 'var(--accent-amber)';
          validationStatus.className = 'validation-status pending';
          validationStatus.textContent = 'Converging...';
        } else {
          cvMeasured.style.color = 'var(--accent-amber)';
          validationStatus.className = 'validation-status pending';
          validationStatus.textContent = 'Collecting data';
        }
      }
      
      document.getElementById('overlayOmega').textContent = CONFIG.OMEGA_Z2.toFixed(3);
      
      // Agent types
      updateAgentTypes();
      updateEventsLog();
      renderChart();
    }

    function updateAgentTypes() {
      const container = document.getElementById('agentTypes');
      container.innerHTML = Object.entries(AGENT_TYPES).map(([key, type]) => `
        <div class="agent-type-card">
          <div class="agent-type-icon" style="background: ${type.color}30; color: ${type.color};">
            ${type.icon}
          </div>
          <div class="agent-type-info">
            <div class="agent-type-name">${type.name}</div>
            <div class="agent-type-desc">Î©: ${type.omega.toFixed(3)}</div>
          </div>
          <div class="agent-type-count" style="color: ${type.color};">${type.count}</div>
        </div>
      `).join('');
    }

    function updateEventsLog() {
      const container = document.getElementById('eventsLog');
      
      if (state.events.length === 0) {
        container.innerHTML = '<div class="empty-state">Awaiting simulation start...</div>';
        return;
      }
      
      const icons = {
        pickup: 'ðŸ“¥',
        delivery: 'ðŸ“¤',
        rupture: 'âš¡',
        quality: 'âœ“',
      };
      
      container.innerHTML = state.events.slice(0, 15).map(event => `
        <div class="event-item ${event.type}">
          <div class="event-icon ${event.type}">${icons[event.type] || 'â€¢'}</div>
          <div class="event-content">
            <div class="event-title">${event.detail}</div>
            <div class="event-detail">Agent ${event.agentId + 1} â€¢ Line ${event.line}</div>
          </div>
          <div class="event-time">T${event.tick}</div>
        </div>
      `).join('');
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;
    let accumulator = 0;

    function gameLoop(timestamp) {
      if (state.running) {
        const delta = timestamp - lastTime;
        const stepTime = 1000 / (state.settings.speed * 0.5 + 8);
        accumulator += delta;
        
        while (accumulator >= stepTime) {
          simulationStep();
          accumulator -= stepTime;
        }
      }
      
      lastTime = timestamp;
      render();
      updateUI();
      requestAnimationFrame(gameLoop);
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    function reset() {
      state.running = false;
      state.tick = 0;
      state.coherenceField = createField();
      state.agents = createAgents(state.settings.agentCount);
      state.stats = {
        deliveries: 0,
        ruptures: 0,
        production: { A: 0, B: 0, C: 0 },
        throughput: 0,
        avgCoherence: 0,
        measuredCV: null,
        decisionIntervals: [],
        efficiencyHistory: [],
      };
      state.events = [];
      
      document.getElementById('btnStart').innerHTML = '<span>â–¶</span> START';
      document.getElementById('btnStart').classList.remove('running');
      document.getElementById('statusBadge').textContent = 'SIMULATION PAUSED';
      
      updateAgentTypes();
    }

    // Event listeners
    document.getElementById('btnStart').addEventListener('click', () => {
      state.running = !state.running;
      const btn = document.getElementById('btnStart');
      const badge = document.getElementById('statusBadge');
      
      if (state.running) {
        btn.innerHTML = '<span>â– </span> PAUSE';
        btn.classList.add('running');
        badge.textContent = 'LIVE';
      } else {
        btn.innerHTML = '<span>â–¶</span> START';
        btn.classList.remove('running');
        badge.textContent = 'SIMULATION PAUSED';
      }
    });

    document.getElementById('btnReset').addEventListener('click', reset);

    document.getElementById('speedSlider').addEventListener('input', (e) => {
      state.settings.speed = parseInt(e.target.value);
    });

    document.getElementById('agentSlider').addEventListener('input', (e) => {
      const count = parseInt(e.target.value);
      document.getElementById('agentCount').textContent = count;
      state.settings.agentCount = count;
    });

    document.getElementById('agentSlider').addEventListener('change', () => {
      if (!state.running) reset();
    });

    document.getElementById('showField').addEventListener('change', (e) => {
      state.settings.showField = e.target.checked;
    });

    document.getElementById('showTrails').addEventListener('change', (e) => {
      state.settings.showTrails = e.target.checked;
    });

    document.getElementById('showZones').addEventListener('change', (e) => {
      state.settings.showZones = e.target.checked;
    });

    // Initialize
    document.getElementById('omegaValue').textContent = CONFIG.OMEGA_Z2.toFixed(4);
    document.getElementById('cvPredicted').textContent = CONFIG.CV_PREDICTED.toFixed(4);
    
    reset();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
