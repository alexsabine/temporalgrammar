<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Maze Solver - Parameter Tuning</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 2000px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .header h1 {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #a78bfa 0%, #ec4899 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .header p {
      font-size: 14px;
      color: #94a3b8;
    }
    
    .formalism-box {
      background: rgba(167, 139, 250, 0.1);
      border: 1px solid rgba(167, 139, 250, 0.3);
      color: #c4b5fd;
      padding: 15px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 13px;
      font-family: 'Courier New', monospace;
      text-align: center;
      line-height: 1.6;
    }
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 420px 380px;
      gap: 20px;
    }
    
    .panel {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .difficulty-selector {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .difficulty-label {
      color: #94a3b8;
      font-size: 13px;
      font-weight: 600;
      margin-right: 5px;
    }
    
    .difficulty-btn {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #94a3b8;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    .difficulty-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-1px);
    }
    
    .difficulty-btn.active {
      background: rgba(167, 139, 250, 0.3);
      border-color: rgba(167, 139, 250, 0.5);
      color: #c4b5fd;
      font-weight: 600;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 10px 20px;
      background: linear-gradient(135deg, #a78bfa 0%, #ec4899 100%);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(167, 139, 250, 0.4);
    }
    
    .btn.secondary {
      background: linear-gradient(135deg, #475569 0%, #334155 100%);
    }
    
    canvas {
      display: block;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin-bottom: 10px;
    }
    
    .legend {
      font-size: 11px;
      color: #64748b;
      line-height: 1.7;
    }
    
    .stats-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .stats-card {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(167, 139, 250, 0.3);
    }
    
    .stats-card h3 {
      font-size: 16px;
      margin-bottom: 12px;
      color: #a78bfa;
      font-weight: 600;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .stat-label {
      color: #94a3b8;
    }
    
    .stat-value {
      font-weight: 700;
      color: #fff;
    }
    
    .stat-value.good {
      color: #4ade80;
    }
    
    .stat-value.excellent {
      color: #fbbf24;
    }
    
    .graph-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
    }
    
    .graph-label {
      font-size: 11px;
      color: #64748b;
      margin-bottom: 8px;
    }
    
    /* Parameter Sliders */
    .param-panel {
      max-height: 700px;
      overflow-y: auto;
    }
    
    .param-panel::-webkit-scrollbar {
      width: 6px;
    }
    
    .param-panel::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    
    .param-panel::-webkit-scrollbar-thumb {
      background: rgba(167, 139, 250, 0.5);
      border-radius: 3px;
    }
    
    .param-section {
      margin-bottom: 20px;
    }
    
    .param-section-title {
      font-size: 14px;
      color: #a78bfa;
      font-weight: 600;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(167, 139, 250, 0.3);
    }
    
    .param-group {
      margin-bottom: 15px;
    }
    
    .param-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 12px;
    }
    
    .param-name {
      color: #cbd5e1;
      font-weight: 500;
    }
    
    .param-value {
      color: #a78bfa;
      font-weight: 700;
      font-family: 'Courier New', monospace;
    }
    
    .param-slider {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }
    
    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: linear-gradient(135deg, #a78bfa 0%, #ec4899 100%);
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .param-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: linear-gradient(135deg, #a78bfa 0%, #ec4899 100%);
      cursor: pointer;
      border: none;
    }
    
    .param-description {
      font-size: 10px;
      color: #64748b;
      margin-top: 4px;
      font-style: italic;
    }
    
    .preset-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .preset-btn {
      padding: 6px 12px;
      background: rgba(16, 185, 129, 0.2);
      border: 1px solid rgba(16, 185, 129, 0.5);
      border-radius: 6px;
      color: #10b981;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    .preset-btn:hover {
      background: rgba(16, 185, 129, 0.3);
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üß† CRR Maze Solver - Parameter Tuning Lab</h1>
      <p>Interactive exploration of Coherence-Rupture-Regeneration dynamics</p>
    </div>
    
    <div class="formalism-box">
      <strong>C(x,t)</strong> = ‚à´ L(x,œÑ) dœÑ  ‚Ä¢  
      <strong>R[œá]</strong> = ‚à´ œÜ(x,œÑ)¬∑e^(C/Œ©)¬∑Œò(t-œÑ) dœÑ  ‚Ä¢  
      <strong>Rupture:</strong> Œ¥(t-t‚ÇÄ) when C > threshold
    </div>
    
    <div class="main-grid">
      <div class="panel">
        <div class="difficulty-selector">
          <span class="difficulty-label">Difficulty:</span>
          <button class="difficulty-btn active" onclick="setDifficulty('easy')" id="diff-easy">
            Easy (25√ó25)
          </button>
          <button class="difficulty-btn" onclick="setDifficulty('medium')" id="diff-medium">
            Medium (35√ó35)
          </button>
          <button class="difficulty-btn" onclick="setDifficulty('hard')" id="diff-hard">
            Hard (45√ó45)
          </button>
        </div>
        
        <div class="controls">
          <button class="btn" id="startBtn" onclick="toggleSimulation()">Start Agent</button>
          <button class="btn secondary" onclick="resetSimulation()">New Episode</button>
          <button class="btn secondary" onclick="speedUp()">
            Speed: <span id="speedLabel">1x</span>
          </button>
        </div>
        
        <canvas id="mazeCanvas"></canvas>
        
        <div class="legend">
          <strong style="color: #a78bfa;">Purple glow:</strong> Coherence C(x) ‚Ä¢ 
          <strong style="color: #fbbf24;">Yellow dots:</strong> Memory œÜ(x,œÑ) ‚Ä¢ 
          <strong style="color: #ec4899;">Pink arrows:</strong> Regeneration R[œá]
        </div>
      </div>
      
      <div class="stats-panel">
        <div class="stats-card">
          <h3>üìä Performance Metrics</h3>
          <div class="stat-row">
            <span class="stat-label">Episodes:</span>
            <span class="stat-value" id="episodes">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Current Steps:</span>
            <span class="stat-value" id="steps">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Successes:</span>
            <span class="stat-value good" id="successes">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Success Rate:</span>
            <span class="stat-value" id="rate">0%</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Avg Steps (last 10):</span>
            <span class="stat-value excellent" id="avg">N/A</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Best Run:</span>
            <span class="stat-value" id="best">N/A</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Global Coherence C:</span>
            <span class="stat-value" id="coherence">0.0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Ruptures Œ¥(t):</span>
            <span class="stat-value" id="ruptures">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Intelligence tanh(C/Œ©):</span>
            <span class="stat-value" id="intelligence">0.00</span>
          </div>
        </div>
        
        <div class="stats-card">
          <div class="graph-label">Coherence Evolution C(t)</div>
          <div class="graph-container">
            <canvas id="coherenceGraph" width="380" height="120"></canvas>
          </div>
        </div>
      </div>
      
      <div class="panel param-panel">
        <h3 style="color: #a78bfa; margin-bottom: 15px;">üéõÔ∏è CRR Parameters</h3>
        
        <div class="preset-buttons">
          <button class="preset-btn" onclick="loadPreset('original')">üìã Original</button>
          <button class="preset-btn" onclick="loadPreset('enhanced')">‚ú® Enhanced</button>
          <button class="preset-btn" onclick="loadPreset('aggressive')">‚ö° Aggressive</button>
          <button class="preset-btn" onclick="loadPreset('conservative')">üõ°Ô∏è Conservative</button>
        </div>
        
        <!-- Coherence Function Parameters -->
        <div class="param-section">
          <div class="param-section-title">Coherence Function: C(x,t) = ‚à´L(x,œÑ)dœÑ</div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Base Learning Rate L‚ÇÄ</span>
              <span class="param-value" id="val-base-learning-rate">0.03</span>
            </div>
            <input type="range" class="param-slider" id="slider-base-learning" 
                   min="0.01" max="0.20" step="0.01" value="0.03" 
                   oninput="updateParam('BASE_LEARNING_RATE', this.value)">
            <div class="param-description">Base rate of coherence accumulation</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Novelty Bonus</span>
              <span class="param-value" id="val-novelty-bonus">1.2</span>
            </div>
            <input type="range" class="param-slider" id="slider-novelty" 
                   min="0.5" max="3.0" step="0.1" value="1.2" 
                   oninput="updateParam('NOVELTY_BONUS', this.value)">
            <div class="param-description">Coherence boost for first visit</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Revisit Penalty</span>
              <span class="param-value" id="val-revisit-penalty">0.25</span>
            </div>
            <input type="range" class="param-slider" id="slider-revisit" 
                   min="0.0" max="1.0" step="0.05" value="0.25" 
                   oninput="updateParam('REVISIT_PENALTY', this.value)">
            <div class="param-description">Penalty for returning to visited cells</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Temporal Penalty</span>
              <span class="param-value" id="val-temporal-penalty">0.02</span>
            </div>
            <input type="range" class="param-slider" id="slider-temporal-penalty" 
                   min="0.0" max="0.10" step="0.01" value="0.02" 
                   oninput="updateParam('TEMPORAL_PENALTY', this.value)">
            <div class="param-description">Time-based coherence decay</div>
          </div>
        </div>
        
        <!-- Regeneration Operator Parameters -->
        <div class="param-section">
          <div class="param-section-title">Regeneration: R[œá] = ‚à´œÜ¬∑e^(C/Œ©)¬∑Œò(t-œÑ)dœÑ</div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Temperature Œ©</span>
              <span class="param-value" id="val-omega">50</span>
            </div>
            <input type="range" class="param-slider" id="slider-omega" 
                   min="20" max="200" step="5" value="50" 
                   oninput="updateParam('OMEGA', this.value)">
            <div class="param-description">Controls coherence weighting sensitivity</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Spatial Range</span>
              <span class="param-value" id="val-spatial-range">8</span>
            </div>
            <input type="range" class="param-slider" id="slider-spatial" 
                   min="4" max="20" step="1" value="8" 
                   oninput="updateParam('SPATIAL_RANGE', this.value)">
            <div class="param-description">Radius of spatial memory influence</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Temporal Decay Œ±</span>
              <span class="param-value" id="val-temporal-decay">0.0050</span>
            </div>
            <input type="range" class="param-slider" id="slider-temporal-decay" 
                   min="0.001" max="0.015" step="0.0005" value="0.005" 
                   oninput="updateParam('TEMPORAL_DECAY', this.value)">
            <div class="param-description">Rate of temporal memory decay</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Memory Capacity</span>
              <span class="param-value" id="val-memory-capacity">25</span>
            </div>
            <input type="range" class="param-slider" id="slider-memory-cap" 
                   min="10" max="100" step="5" value="25" 
                   oninput="updateParam('MEMORY_CAPACITY', this.value)">
            <div class="param-description">Max memories per location</div>
          </div>
        </div>
        
        <!-- Rupture Parameters -->
        <div class="param-section">
          <div class="param-section-title">Rupture: Œ¥(t-t‚ÇÄ)</div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Rupture Threshold</span>
              <span class="param-value" id="val-rupture-threshold">120</span>
            </div>
            <input type="range" class="param-slider" id="slider-threshold" 
                   min="50" max="300" step="10" value="120" 
                   oninput="updateParam('RUPTURE_THRESHOLD', this.value)">
            <div class="param-description">Coherence level triggering rupture</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Rupture Reduction</span>
              <span class="param-value" id="val-rupture-multiplier">0.35</span>
            </div>
            <input type="range" class="param-slider" id="slider-rupture-mult" 
                   min="0.1" max="0.9" step="0.05" value="0.35" 
                   oninput="updateParam('RUPTURE_MULTIPLIER', this.value)">
            <div class="param-description">Fraction of C remaining after rupture</div>
          </div>
        </div>
        
        <!-- Action Selection Parameters -->
        <div class="param-section">
          <div class="param-section-title">Intelligence: tanh(C/Œ©)</div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Goal Weight</span>
              <span class="param-value" id="val-goal-weight-base">0.3</span>
            </div>
            <input type="range" class="param-slider" id="slider-goal-weight" 
                   min="0.1" max="2.0" step="0.1" value="0.3" 
                   oninput="updateParam('GOAL_WEIGHT_BASE', this.value)">
            <div class="param-description">Base goal distance heuristic</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Intelligence Goal Boost</span>
              <span class="param-value" id="val-intel-goal-mult">0.7</span>
            </div>
            <input type="range" class="param-slider" id="slider-intel-goal" 
                   min="0.0" max="2.0" step="0.1" value="0.7" 
                   oninput="updateParam('INTEL_GOAL_MULT', this.value)">
            <div class="param-description">How intelligence amplifies goal-seeking</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Exploration Noise</span>
              <span class="param-value" id="val-exploration-noise">2.0</span>
            </div>
            <input type="range" class="param-slider" id="slider-explore-noise" 
                   min="0.5" max="5.0" step="0.25" value="2.0" 
                   oninput="updateParam('EXPLORATION_NOISE', this.value)">
            <div class="param-description">Random exploration strength</div>
          </div>
          
          <div class="param-group">
            <div class="param-label">
              <span class="param-name">Regeneration Weight</span>
              <span class="param-value" id="val-regeneration-weight">1.0</span>
            </div>
            <input type="range" class="param-slider" id="slider-regen-weight" 
                   min="0.0" max="3.0" step="0.1" value="1.0" 
                   oninput="updateParam('REGENERATION_WEIGHT', this.value)">
            <div class="param-description">Influence of R[œá] on action selection</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===================================================================
    // TUNABLE CRR PARAMETERS
    // ===================================================================
    
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const graphCanvas = document.getElementById('coherenceGraph');
    const graphCtx = graphCanvas.getContext('2d');
    
    // Maze parameters
    let MAZE_SIZE = 25;
    let CELL_SIZE = 20;
    let GOAL_X = MAZE_SIZE - 2;
    let GOAL_Y = MAZE_SIZE - 2;
    
    // CRR parameters (all tunable via sliders)
    let OMEGA = 50;
    let RUPTURE_THRESHOLD = 120;
    let RUPTURE_MULTIPLIER = 0.35;
    let SPATIAL_RANGE = 8;
    let TEMPORAL_DECAY = 0.005;
    let MEMORY_CAPACITY = 25;
    let BASE_LEARNING_RATE = 0.03;
    let REVISIT_PENALTY = 0.25;
    let TEMPORAL_PENALTY = 0.02;
    let NOVELTY_BONUS = 1.2;
    let GOAL_WEIGHT_BASE = 0.3;
    let INTEL_GOAL_MULT = 0.7;
    let EXPLORATION_NOISE = 2.0;
    let REGENERATION_WEIGHT = 1.0;
    
    // Simulation state
    let currentDifficulty = 'easy';
    let isRunning = false;
    let speed = 1;
    let frameSkip = 2;
    let ruptureEffect = 0;
    let coherenceHistory = [];
    let maze, agent, animationId;
    
    // ===================================================================
    // PARAMETER UPDATE FUNCTIONS
    // ===================================================================
    
    function updateParam(paramName, value) {
      const numValue = parseFloat(value);
      window[paramName] = numValue;
      
      // Update display
      const displayId = 'val-' + paramName.toLowerCase().replace(/_/g, '-');
      const display = document.getElementById(displayId);
      if (display) {
        if (numValue < 1) {
          display.textContent = numValue.toFixed(4);
        } else if (numValue < 10) {
          display.textContent = numValue.toFixed(2);
        } else {
          display.textContent = Math.round(numValue);
        }
      }
    }
    
    function loadPreset(presetName) {
      let params = {};
      
      if (presetName === 'original') {
        params = {
          BASE_LEARNING_RATE: 0.03,
          NOVELTY_BONUS: 1.2,
          REVISIT_PENALTY: 0.25,
          TEMPORAL_PENALTY: 0.02,
          OMEGA: 50,
          SPATIAL_RANGE: 8,
          TEMPORAL_DECAY: 0.005,
          MEMORY_CAPACITY: 25,
          RUPTURE_THRESHOLD: 120,
          RUPTURE_MULTIPLIER: 0.35,
          GOAL_WEIGHT_BASE: 0.3,
          INTEL_GOAL_MULT: 0.7,
          EXPLORATION_NOISE: 2.0,
          REGENERATION_WEIGHT: 1.0
        };
      } else if (presetName === 'enhanced') {
        params = {
          BASE_LEARNING_RATE: 0.06,
          NOVELTY_BONUS: 1.5,
          REVISIT_PENALTY: 0.15,
          TEMPORAL_PENALTY: 0.01,
          OMEGA: 50,
          SPATIAL_RANGE: 12,
          TEMPORAL_DECAY: 0.002,
          MEMORY_CAPACITY: 40,
          RUPTURE_THRESHOLD: 150,
          RUPTURE_MULTIPLIER: 0.35,
          GOAL_WEIGHT_BASE: 0.2,
          INTEL_GOAL_MULT: 1.2,
          EXPLORATION_NOISE: 1.5,
          REGENERATION_WEIGHT: 1.5
        };
      } else if (presetName === 'aggressive') {
        params = {
          BASE_LEARNING_RATE: 0.10,
          NOVELTY_BONUS: 2.0,
          REVISIT_PENALTY: 0.10,
          TEMPORAL_PENALTY: 0.005,
          OMEGA: 40,
          SPATIAL_RANGE: 15,
          TEMPORAL_DECAY: 0.001,
          MEMORY_CAPACITY: 50,
          RUPTURE_THRESHOLD: 200,
          RUPTURE_MULTIPLIER: 0.25,
          GOAL_WEIGHT_BASE: 0.1,
          INTEL_GOAL_MULT: 1.5,
          EXPLORATION_NOISE: 1.0,
          REGENERATION_WEIGHT: 2.0
        };
      } else if (presetName === 'conservative') {
        params = {
          BASE_LEARNING_RATE: 0.02,
          NOVELTY_BONUS: 0.8,
          REVISIT_PENALTY: 0.40,
          TEMPORAL_PENALTY: 0.03,
          OMEGA: 70,
          SPATIAL_RANGE: 6,
          TEMPORAL_DECAY: 0.008,
          MEMORY_CAPACITY: 20,
          RUPTURE_THRESHOLD: 80,
          RUPTURE_MULTIPLIER: 0.50,
          GOAL_WEIGHT_BASE: 0.5,
          INTEL_GOAL_MULT: 0.5,
          EXPLORATION_NOISE: 3.0,
          REGENERATION_WEIGHT: 0.5
        };
      }
      
      // Apply parameters
      for (let key in params) {
        window[key] = params[key];
        
        // Map parameter names to slider IDs
        const sliderMap = {
          'BASE_LEARNING_RATE': 'slider-base-learning',
          'NOVELTY_BONUS': 'slider-novelty',
          'REVISIT_PENALTY': 'slider-revisit',
          'TEMPORAL_PENALTY': 'slider-temporal-penalty',
          'OMEGA': 'slider-omega',
          'SPATIAL_RANGE': 'slider-spatial',
          'TEMPORAL_DECAY': 'slider-temporal-decay',
          'MEMORY_CAPACITY': 'slider-memory-cap',
          'RUPTURE_THRESHOLD': 'slider-threshold',
          'RUPTURE_MULTIPLIER': 'slider-rupture-mult',
          'GOAL_WEIGHT_BASE': 'slider-goal-weight',
          'INTEL_GOAL_MULT': 'slider-intel-goal',
          'EXPLORATION_NOISE': 'slider-explore-noise',
          'REGENERATION_WEIGHT': 'slider-regen-weight'
        };
        
        const sliderId = sliderMap[key];
        const slider = document.getElementById(sliderId);
        if (slider) {
          slider.value = params[key];
          updateParam(key, params[key]);
        }
      }
      
      resetSimulation();
    }
    
    // ===================================================================
    // MAZE GENERATION (UNCHANGED)
    // ===================================================================
    
    function generateMaze() {
      const maze = Array(MAZE_SIZE).fill(0).map(() => Array(MAZE_SIZE).fill(1));
      
      const stack = [[1, 1]];
      maze[1][1] = 0;
      
      while (stack.length > 0) {
        const [x, y] = stack[stack.length - 1];
        const neighbors = [];
        
        [[0, 2], [2, 0], [0, -2], [-2, 0]].forEach(([dx, dy]) => {
          const nx = x + dx;
          const ny = y + dy;
          if (nx > 0 && nx < MAZE_SIZE - 1 && ny > 0 && ny < MAZE_SIZE - 1 && 
              maze[ny][nx] === 1) {
            neighbors.push([nx, ny, x + dx/2, y + dy/2]);
          }
        });
        
        if (neighbors.length > 0) {
          const [nx, ny, wx, wy] = neighbors[Math.floor(Math.random() * neighbors.length)];
          maze[ny][nx] = 0;
          maze[wy][wx] = 0;
          stack.push([nx, ny]);
        } else {
          stack.pop();
        }
      }
      
      maze[1][1] = 2;
      maze[MAZE_SIZE - 2][MAZE_SIZE - 2] = 3;
      
      return maze;
    }
    
    // ===================================================================
    // CRR AGENT (ORIGINAL VERSION WITH TUNABLE PARAMETERS)
    // ===================================================================
    
    class CRRAgent {
      constructor(maze) {
        this.maze = maze;
        this.spatialMemory = {};
        this.coherenceField = {};
        this.regenerationField = { dx: 0, dy: 0 };
        
        this.totalEpisodes = 0;
        this.successes = 0;
        this.episodeSteps = [];
        this.bestRun = Infinity;
        
        this.reset();
      }
      
      reset() {
        this.x = 1;
        this.y = 1;
        this.globalCoherence = 0;
        this.steps = 0;
        this.path = [[1, 1]];
        this.ruptureCount = 0;
        this.visited = new Set();
        this.regenerationField = { dx: 0, dy: 0 };
      }
      
      getKey(x, y) {
        return `${x},${y}`;
      }
      
      calculateLearningDensity(reward) {
        let L = BASE_LEARNING_RATE;
        
        L += reward * 0.5;
        
        const key = this.getKey(this.x, this.y);
        if (!this.visited.has(key)) {
          L += NOVELTY_BONUS;
          this.visited.add(key);
        } else {
          L -= REVISIT_PENALTY;
        }
        
        const goalDist = Math.abs(this.x - GOAL_X) + Math.abs(this.y - GOAL_Y);
        if (goalDist === 0) L += 60;
        
        const moves = this.getValidMoves();
        if (moves.length === 1 && this.path.length > 3) {
          L -= 0.8;
        }
        
        const explorationRate = this.visited.size / (MAZE_SIZE * MAZE_SIZE);
        L += explorationRate * 0.3;
        
        L -= TEMPORAL_PENALTY;
        
        return L;
      }
      
      calculateRegeneration() {
        let R = { dx: 0, dy: 0 };
        
        for (let key in this.spatialMemory) {
          const [mx, my] = key.split(',').map(Number);
          const memories = this.spatialMemory[key];
          if (!memories || memories.length === 0) continue;
          
          const dx = mx - this.x;
          const dy = my - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > SPATIAL_RANGE || dist === 0) continue;
          
          for (let memory of memories) {
            if (memory.step >= this.steps) continue;
            
            const Œît = this.steps - memory.step;
            const temporalDecay = Math.exp(-TEMPORAL_DECAY * Œît);
            const coherenceWeight = Math.exp(Math.min(memory.coherence / OMEGA, 10));
            const œÜ = memory.fieldSignal;
            const spatialDecay = 1 / (1 + dist * 0.5);
            
            const influence = œÜ * coherenceWeight * temporalDecay * spatialDecay;
            
            if (dist > 0) {
              if (œÜ > 5) {
                R.dx += (dx / dist) * influence * 0.15;
                R.dy += (dy / dist) * influence * 0.15;
              } else if (œÜ < -1) {
                R.dx -= (dx / dist) * influence * 0.08;
                R.dy -= (dy / dist) * influence * 0.08;
              }
            }
          }
        }
        
        this.regenerationField = R;
        return R;
      }
      
      getValidMoves() {
        const moves = [];
        [[0, 1], [1, 0], [0, -1], [-1, 0]].forEach(([dx, dy]) => {
          const nx = this.x + dx;
          const ny = this.y + dy;
          if (nx >= 0 && ny >= 0 && nx < MAZE_SIZE && ny < MAZE_SIZE &&
              this.maze[ny] && this.maze[ny][nx] !== 1) {
            moves.push([dx, dy]);
          }
        });
        return moves;
      }
      
      step() {
        this.steps++;
        
        const R = this.calculateRegeneration();
        const moves = this.getValidMoves();
        if (moves.length === 0) return 'stuck';
        
        const intelligence = Math.tanh(this.globalCoherence / OMEGA);
        
        let bestMove = moves[0];
        let bestScore = -Infinity;
        
        for (let [dx, dy] of moves) {
          const nx = this.x + dx;
          const ny = this.y + dy;
          const nkey = this.getKey(nx, ny);
          
          let score = 0;
          
          const goalDist = Math.abs(nx - GOAL_X) + Math.abs(ny - GOAL_Y);
          score -= goalDist * (GOAL_WEIGHT_BASE + intelligence * INTEL_GOAL_MULT);
          
          if (this.visited.has(nkey)) {
            score -= 6 * (1 + intelligence * 1.5);
          }
          
          score += (R.dx * dx + R.dy * dy) * REGENERATION_WEIGHT;
          
          score += Math.random() * EXPLORATION_NOISE * (1 - intelligence * 0.85);
          
          if (score > bestScore) {
            bestScore = score;
            bestMove = [dx, dy];
          }
        }
        
        this.x += bestMove[0];
        this.y += bestMove[1];
        this.path.push([this.x, this.y]);
        
        let reward = -0.02;
        if (this.maze[this.y] && this.maze[this.y][this.x] === 3) {
          reward = 100;
        }
        
        const L = this.calculateLearningDensity(reward);
        this.globalCoherence += L;
        
        const key = this.getKey(this.x, this.y);
        if (!this.coherenceField[key]) this.coherenceField[key] = 0;
        this.coherenceField[key] += L;
        
        if (!this.spatialMemory[key]) this.spatialMemory[key] = [];
        this.spatialMemory[key].push({
          step: this.steps,
          fieldSignal: L,
          coherence: this.coherenceField[key]
        });
        
        if (this.spatialMemory[key].length > MEMORY_CAPACITY) {
          this.spatialMemory[key].shift();
        }
        
        if (this.globalCoherence > RUPTURE_THRESHOLD) {
          this.ruptureCount++;
          triggerRupture();
          this.globalCoherence *= RUPTURE_MULTIPLIER;
        }
        
        coherenceHistory.push(this.globalCoherence);
        if (coherenceHistory.length > 200) coherenceHistory.shift();
        
        if (reward === 100) {
          this.successes++;
          this.episodeSteps.push(this.steps);
          this.bestRun = Math.min(this.bestRun, this.steps);
          return 'success';
        }
        
        if (this.steps > 500) {
          this.episodeSteps.push(500);
          return 'timeout';
        }
        
        return 'continue';
      }
      
      startEpisode() {
        this.reset();
        this.totalEpisodes++;
        coherenceHistory = [];
      }
      
      getStats() {
        const recent = this.episodeSteps.slice(-10);
        const avgSteps = recent.length > 0 
          ? Math.round(recent.reduce((a, b) => a + b, 0) / recent.length)
          : 0;
        
        const rate = this.totalEpisodes > 0 
          ? ((this.successes / this.totalEpisodes) * 100).toFixed(1)
          : 0;
        
        return {
          episodes: this.totalEpisodes,
          steps: this.steps,
          successes: this.successes,
          rate,
          avgSteps,
          bestRun: this.bestRun === Infinity ? 0 : this.bestRun,
          coherence: this.globalCoherence.toFixed(1),
          ruptures: this.ruptureCount,
          intelligence: Math.tanh(this.globalCoherence / OMEGA).toFixed(2)
        };
      }
    }
    
    // ===================================================================
    // VISUALIZATION (UNCHANGED FROM ORIGINAL)
    // ===================================================================
    
    function draw() {
      ctx.fillStyle = '#0a0a15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let key in agent.coherenceField) {
        const [x, y] = key.split(',').map(Number);
        const coherence = agent.coherenceField[key];
        const intensity = Math.min(Math.abs(coherence) / 30, 1);
        
        const gradient = ctx.createRadialGradient(
          x * CELL_SIZE + CELL_SIZE / 2, 
          y * CELL_SIZE + CELL_SIZE / 2, 
          0,
          x * CELL_SIZE + CELL_SIZE / 2, 
          y * CELL_SIZE + CELL_SIZE / 2, 
          CELL_SIZE * 1.5
        );
        gradient.addColorStop(0, `rgba(167, 139, 250, ${intensity * 0.6})`);
        gradient.addColorStop(1, 'rgba(167, 139, 250, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(
          x * CELL_SIZE - CELL_SIZE, 
          y * CELL_SIZE - CELL_SIZE, 
          CELL_SIZE * 3, 
          CELL_SIZE * 3
        );
      }
      
      for (let y = 0; y < MAZE_SIZE; y++) {
        for (let x = 0; x < MAZE_SIZE; x++) {
          const cell = maze[y][x];
          let color = 'rgba(26, 26, 46, 0.5)';
          
          if (cell === 1) color = '#2d2d44';
          else if (cell === 2) color = '#10b981';
          else if (cell === 3) color = '#f59e0b';
          
          ctx.fillStyle = color;
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
        }
      }
      
      for (let key in agent.spatialMemory) {
        const [x, y] = key.split(',').map(Number);
        const memories = agent.spatialMemory[key];
        
        if (memories && memories.length > 0) {
          const avgSignal = memories.reduce((s, m) => s + m.fieldSignal, 0) / memories.length;
          if (avgSignal > 1) {
            ctx.fillStyle = 'rgba(251, 191, 36, 0.6)';
            ctx.beginPath();
            ctx.arc(
              x * CELL_SIZE + CELL_SIZE / 2, 
              y * CELL_SIZE + CELL_SIZE / 2, 
              3, 0, Math.PI * 2
            );
            ctx.fill();
          }
        }
      }
      
      const agentX = agent.x * CELL_SIZE + CELL_SIZE / 2;
      const agentY = agent.y * CELL_SIZE + CELL_SIZE / 2;
      const influences = [];
      
      for (let key in agent.spatialMemory) {
        const [mx, my] = key.split(',').map(Number);
        const memories = agent.spatialMemory[key];
        if (!memories || memories.length === 0) continue;
        
        const dx = mx - agent.x;
        const dy = my - agent.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > SPATIAL_RANGE || dist === 0) continue;
        
        let totalInfluence = 0;
        for (let m of memories) {
          if (m.step >= agent.steps) continue;
          const Œît = agent.steps - m.step;
          const temp = Math.exp(-TEMPORAL_DECAY * Œît);
          const coh = Math.exp(Math.min(m.coherence / OMEGA, 10));
          const spatial = 1 / (1 + dist * 0.5);
          totalInfluence += m.fieldSignal * coh * temp * spatial;
        }
        
        if (Math.abs(totalInfluence) > 0.5) {
          influences.push({
            x: mx * CELL_SIZE + CELL_SIZE / 2,
            y: my * CELL_SIZE + CELL_SIZE / 2,
            influence: totalInfluence
          });
        }
      }
      
      influences.forEach(inf => {
        const strength = Math.min(Math.abs(inf.influence) / 10, 1);
        
        if (inf.influence > 0) {
          ctx.strokeStyle = `rgba(236, 72, 153, ${strength * 0.9})`;
          ctx.lineWidth = 2 + strength * 2;
          ctx.shadowColor = '#ec4899';
          ctx.shadowBlur = 8 * strength;
          
          ctx.beginPath();
          ctx.moveTo(inf.x, inf.y);
          ctx.lineTo(agentX, agentY);
          ctx.stroke();
          
          const angle = Math.atan2(agentY - inf.y, agentX - inf.x);
          const headSize = 8 + strength * 4;
          ctx.beginPath();
          ctx.moveTo(agentX, agentY);
          ctx.lineTo(
            agentX - headSize * Math.cos(angle - Math.PI / 6), 
            agentY - headSize * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            agentX - headSize * Math.cos(angle + Math.PI / 6), 
            agentY - headSize * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = `rgba(236, 72, 153, ${strength * 0.9})`;
          ctx.fill();
          
          ctx.shadowBlur = 0;
        }
      });
      
      if (agent.path.length > 1) {
        ctx.strokeStyle = 'rgba(167, 139, 250, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(
          agent.path[0][0] * CELL_SIZE + CELL_SIZE / 2, 
          agent.path[0][1] * CELL_SIZE + CELL_SIZE / 2
        );
        for (let [x, y] of agent.path) {
          ctx.lineTo(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2);
        }
        ctx.stroke();
      }
      
      if (ruptureEffect > 0) {
        const radius = CELL_SIZE * 2 * ruptureEffect;
        const grad = ctx.createRadialGradient(
          agent.x * CELL_SIZE + CELL_SIZE / 2,
          agent.y * CELL_SIZE + CELL_SIZE / 2,
          CELL_SIZE / 2,
          agent.x * CELL_SIZE + CELL_SIZE / 2,
          agent.y * CELL_SIZE + CELL_SIZE / 2,
          radius
        );
        grad.addColorStop(0, `rgba(236, 72, 153, ${ruptureEffect * 0.8})`);
        grad.addColorStop(0.5, `rgba(236, 72, 153, ${ruptureEffect * 0.4})`);
        grad.addColorStop(1, 'rgba(236, 72, 153, 0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(
          agent.x * CELL_SIZE + CELL_SIZE / 2,
          agent.y * CELL_SIZE + CELL_SIZE / 2,
          radius, 0, Math.PI * 2
        );
        ctx.fill();
        
        ruptureEffect *= 0.92;
        if (ruptureEffect < 0.01) ruptureEffect = 0;
      }
      
      ctx.fillStyle = '#a78bfa';
      ctx.shadowColor = '#a78bfa';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(
        agent.x * CELL_SIZE + CELL_SIZE / 2, 
        agent.y * CELL_SIZE + CELL_SIZE / 2, 
        CELL_SIZE / 2.2, 0, Math.PI * 2
      );
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    function drawGraph() {
      graphCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);
      
      if (coherenceHistory.length < 2) return;
      
      const maxC = Math.max(...coherenceHistory, RUPTURE_THRESHOLD);
      
      const threshY = graphCanvas.height - (RUPTURE_THRESHOLD / maxC) * graphCanvas.height;
      graphCtx.strokeStyle = 'rgba(236, 72, 153, 0.5)';
      graphCtx.lineWidth = 1;
      graphCtx.setLineDash([5, 5]);
      graphCtx.beginPath();
      graphCtx.moveTo(0, threshY);
      graphCtx.lineTo(graphCanvas.width, threshY);
      graphCtx.stroke();
      graphCtx.setLineDash([]);
      
      graphCtx.strokeStyle = '#a78bfa';
      graphCtx.lineWidth = 2;
      graphCtx.beginPath();
      
      const step = graphCanvas.width / (coherenceHistory.length - 1);
      coherenceHistory.forEach((c, i) => {
        const x = i * step;
        const y = graphCanvas.height - (c / maxC) * graphCanvas.height;
        if (i === 0) graphCtx.moveTo(x, y);
        else graphCtx.lineTo(x, y);
      });
      graphCtx.stroke();
    }
    
    function updateStats() {
      const stats = agent.getStats();
      
      document.getElementById('episodes').textContent = stats.episodes;
      document.getElementById('steps').textContent = stats.steps;
      document.getElementById('successes').textContent = stats.successes;
      document.getElementById('rate').textContent = stats.rate + '%';
      document.getElementById('avg').textContent = stats.avgSteps || 'N/A';
      document.getElementById('best').textContent = stats.bestRun || 'N/A';
      document.getElementById('coherence').textContent = stats.coherence;
      document.getElementById('ruptures').textContent = stats.ruptures;
      document.getElementById('intelligence').textContent = stats.intelligence;
    }
    
    // ===================================================================
    // CONTROLS
    // ===================================================================
    
    function setDifficulty(level) {
      currentDifficulty = level;
      
      document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('diff-' + level).classList.add('active');
      
      if (level === 'easy') {
        MAZE_SIZE = 25;
        CELL_SIZE = 20;
      } else if (level === 'medium') {
        MAZE_SIZE = 35;
        CELL_SIZE = 14;
      } else {
        MAZE_SIZE = 45;
        CELL_SIZE = 11;
      }
      
      GOAL_X = MAZE_SIZE - 2;
      GOAL_Y = MAZE_SIZE - 2;
      canvas.width = MAZE_SIZE * CELL_SIZE;
      canvas.height = MAZE_SIZE * CELL_SIZE;
      
      resetSimulation();
    }
    
    function toggleSimulation() {
      isRunning = !isRunning;
      document.getElementById('startBtn').textContent = isRunning ? 'Pause Agent' : 'Start Agent';
    }
    
    function resetSimulation() {
      isRunning = false;
      if (animationId) cancelAnimationFrame(animationId);
      
      initSimulation();
      updateStats();
      draw();
      drawGraph();
      
      document.getElementById('startBtn').textContent = 'Start Agent';
      animate();
    }
    
    function speedUp() {
      speed = speed === 1 ? 3 : speed === 3 ? 10 : 1;
      frameSkip = speed === 1 ? 2 : speed === 3 ? 1 : 1;
      document.getElementById('speedLabel').textContent = speed + 'x';
    }
    
    function triggerRupture() {
      ruptureEffect = 1.0;
    }
    
    function initSimulation() {
      canvas.width = MAZE_SIZE * CELL_SIZE;
      canvas.height = MAZE_SIZE * CELL_SIZE;
      maze = generateMaze();
      agent = new CRRAgent(maze);
      agent.startEpisode();
    }
    
    let frameCount = 0;
    
    function animate() {
      if (!isRunning) {
        draw();
        drawGraph();
        animationId = requestAnimationFrame(animate);
        return;
      }
      
      frameCount++;
      
      if (frameCount % frameSkip === 0) {
        for (let i = 0; i < speed; i++) {
          const result = agent.step();
          if (result === 'success' || result === 'timeout' || result === 'stuck') {
            agent.startEpisode();
          }
        }
        
        if (frameCount % 10 === 0) updateStats();
      }
      
      draw();
      drawGraph();
      animationId = requestAnimationFrame(animate);
    }
    
    // ===================================================================
    // INIT
    // ===================================================================
    
    initSimulation();
    draw();
    drawGraph();
    animate();
  </script>
</body>
</html>