<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Winter Forest | Living Landscape</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a1a;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'EB Garamond', Georgia, serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    .calendar-overlay {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px 30px;
      background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 60%, transparent 100%);
      color: rgba(255, 255, 255, 0.85);
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      pointer-events: none;
    }
    
    .datetime {
      text-align: left;
    }
    
    .datetime .time {
      font-size: 2.8rem;
      font-weight: 400;
      letter-spacing: 0.02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    
    .datetime .date {
      font-size: 1.1rem;
      font-weight: 400;
      opacity: 0.8;
      margin-top: 2px;
      font-style: italic;
    }
    
    .events {
      text-align: right;
      display: flex;
      gap: 35px;
    }
    
    .event {
      text-align: center;
    }
    
    .event .countdown {
      font-size: 1.6rem;
      font-weight: 500;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    
    .event .label {
      font-size: 0.85rem;
      opacity: 0.75;
      margin-top: 2px;
      font-style: italic;
    }
    
    .event.imminent .countdown {
      color: #ffd700;
    }
    
    .event.past .countdown {
      color: rgba(255,255,255,0.5);
    }
    
    .christmas-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #ffd700;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
      opacity: 0;
      transition: opacity 2s ease-in-out;
      pointer-events: none;
      z-index: 100;
    }
    
    .christmas-message.visible {
      opacity: 1;
    }
    
    .christmas-message h1 {
      font-size: 4rem;
      font-weight: 400;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
    }
    
    .christmas-message p {
      font-size: 1.5rem;
      font-style: italic;
      opacity: 0.9;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="calendar-overlay">
  <div class="datetime">
    <div class="time" id="currentTime">00:00</div>
    <div class="date" id="currentDate">Loading...</div>
  </div>
  <div class="events" id="events"></div>
</div>

<div class="christmas-message" id="christmasMessage">
  <h1>Merry Christmas</h1>
  <p>Peace on Earth, Goodwill to All</p>
</div>

<script>
// ============================================================================
// CRR WINTER FOREST - Christmas Edition with Midnight Sleigh
// ============================================================================

const CONFIG = {
  networkDepth: 7,
  branchCount: [2, 4],
  starlingCount: 400,
  spatialCellSize: 60,
  textureGrain: 0.03
};

// ============================================================================
// CRR CORE SYSTEM
// ============================================================================
class CRRSystem {
  constructor(omega, rate = 0.1) {
    this.omega = omega;
    this.coherence = 0;
    this.rate = rate;
    this.state = 'coherence';
    this.amplitude = 0;
  }
  
  update(dt, inputSignal = 1) {
    const effectiveRate = this.rate * inputSignal;
    
    if (this.state === 'coherence') {
      this.coherence += effectiveRate * dt;
      this.amplitude = this.coherence / this.omega;
      if (this.coherence >= this.omega) this.state = 'rupture';
    } else if (this.state === 'rupture') {
      this.amplitude = 1;
      this.state = 'regeneration';
    } else {
      const expWeight = Math.exp(Math.min(this.coherence / this.omega, 3));
      this.coherence *= Math.exp(-2 * dt * expWeight);
      this.amplitude = this.coherence / this.omega;
      if (this.coherence < 0.01) { this.coherence = 0; this.state = 'coherence'; }
    }
    return this.amplitude;
  }
}

// ============================================================================
// SLEIGH BELL AUDIO SYSTEM
// ============================================================================
class SleighBells {
  constructor() {
    this.audioCtx = null;
    this.isPlaying = false;
    this.bellIntervals = [];
  }
  
  init() {
    if (this.audioCtx) return;
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  
  playBell(time, pitch, volume) {
    if (!this.audioCtx) return;
    
    const osc1 = this.audioCtx.createOscillator();
    const osc2 = this.audioCtx.createOscillator();
    const osc3 = this.audioCtx.createOscillator();
    const gain = this.audioCtx.createGain();
    const filter = this.audioCtx.createBiquadFilter();
    
    // Bell harmonics
    osc1.frequency.value = pitch;
    osc2.frequency.value = pitch * 2.4;
    osc3.frequency.value = pitch * 5.2;
    
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc3.type = 'sine';
    
    filter.type = 'highpass';
    filter.frequency.value = 800;
    
    const mix1 = this.audioCtx.createGain();
    const mix2 = this.audioCtx.createGain();
    const mix3 = this.audioCtx.createGain();
    
    mix1.gain.value = 0.5 * volume;
    mix2.gain.value = 0.3 * volume;
    mix3.gain.value = 0.2 * volume;
    
    osc1.connect(mix1);
    osc2.connect(mix2);
    osc3.connect(mix3);
    
    mix1.connect(filter);
    mix2.connect(filter);
    mix3.connect(filter);
    
    filter.connect(gain);
    gain.connect(this.audioCtx.destination);
    
    // Bell envelope - quick attack, medium decay
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.15 * volume, time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
    
    osc1.start(time);
    osc2.start(time);
    osc3.start(time);
    
    osc1.stop(time + 0.5);
    osc2.stop(time + 0.5);
    osc3.stop(time + 0.5);
  }
  
  playJingle() {
    if (!this.audioCtx || this.isPlaying) return;
    this.isPlaying = true;
    
    // Resume audio context if suspended
    if (this.audioCtx.state === 'suspended') {
      this.audioCtx.resume();
    }
    
    const now = this.audioCtx.currentTime;
    
    // Sleigh bell pattern - jingly rhythm
    const bellPitches = [2400, 2600, 2800, 3000, 2200, 2500];
    const pattern = [
      { time: 0, pitch: 0, vol: 0.8 },
      { time: 0.15, pitch: 1, vol: 0.5 },
      { time: 0.25, pitch: 2, vol: 0.6 },
      { time: 0.4, pitch: 0, vol: 0.7 },
      { time: 0.55, pitch: 3, vol: 0.5 },
      { time: 0.7, pitch: 1, vol: 0.8 },
      { time: 0.85, pitch: 4, vol: 0.4 },
      { time: 1.0, pitch: 2, vol: 0.6 },
      { time: 1.15, pitch: 0, vol: 0.7 },
      { time: 1.3, pitch: 5, vol: 0.5 },
    ];
    
    // Play the pattern repeatedly
    for (let repeat = 0; repeat < 20; repeat++) {
      pattern.forEach(note => {
        const t = now + repeat * 1.5 + note.time;
        // Add slight randomness for natural feel
        const pitchVar = bellPitches[note.pitch] * (0.98 + Math.random() * 0.04);
        this.playBell(t, pitchVar, note.vol * 0.4);
      });
    }
    
    // Stop after 30 seconds
    setTimeout(() => {
      this.isPlaying = false;
    }, 30000);
  }
  
  stop() {
    this.isPlaying = false;
    if (this.audioCtx) {
      this.audioCtx.close();
      this.audioCtx = null;
    }
  }
}

// ============================================================================
// GLOBAL STATE
// ============================================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

let W, H, horizonY, forestY;
let layersReady = false;
let time = 0;
let dayTime = 0;

let silverLayer, blueLayer, goldLayer, frostLayer, textureLayer;
let silverBranches = [], blueBranches = [], goldBranches = [], frostBranches = [];

let perchSpots = [];
let starlings = [];
let snowflakes = [];
let mistPatches = [];
let branchGlows = [];
let allBranches = [];

let spatialHash = {};

const flockCRR = new CRRSystem(1 / Math.PI, 0.3);
const treePulseCRR = new CRRSystem(1 / Math.PI, 0.15);
const mistCRR = new CRRSystem(0.5, 0.08);

let currentColors = null;
let lastColorUpdate = 0;

// Sleigh system
let sleigh = null;
let sleighActive = false;
let sleighTriggered = false;
let midnightMessageShown = false;
const sleighBells = new SleighBells();

const TREE_COLORS = {
  silver: { base: { r: 140, g: 150, b: 175 }, bright: { r: 190, g: 200, b: 225 } },
  blue: { base: { r: 100, g: 130, b: 180 }, bright: { r: 150, g: 180, b: 230 } },
  gold: { base: { r: 170, g: 155, b: 115 }, bright: { r: 220, g: 200, b: 150 } },
  frost: { base: { r: 160, g: 140, b: 165 }, bright: { r: 200, g: 180, b: 210 } }
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
const PI = Math.PI, PI2 = PI * 2;
const sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt;
const abs = Math.abs, min = Math.min, max = Math.max;
const floor = Math.floor, random = Math.random;

function lerp(a, b, t) { return a + (b - a) * t; }
function lerpColor(c1, c2, t) {
  return { r: lerp(c1.r, c2.r, t), g: lerp(c1.g, c2.g, t), b: lerp(c1.b, c2.b, t) };
}
function rgba(c, a) { return `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`; }

function getSpatialKey(x, y) {
  return `${floor(x / CONFIG.spatialCellSize)},${floor(y / CONFIG.spatialCellSize)}`;
}

function updateSpatialHash() {
  spatialHash = {};
  for (let i = 0; i < starlings.length; i++) {
    const bird = starlings[i];
    if (bird.state !== 'flying') continue;
    const key = getSpatialKey(bird.x, bird.y);
    if (!spatialHash[key]) spatialHash[key] = [];
    spatialHash[key].push(i);
  }
}

function getNearbyBirds(x, y, radius) {
  const nearby = [];
  const cellRadius = Math.ceil(radius / CONFIG.spatialCellSize);
  const centerCellX = floor(x / CONFIG.spatialCellSize);
  const centerCellY = floor(y / CONFIG.spatialCellSize);
  
  for (let dx = -cellRadius; dx <= cellRadius; dx++) {
    for (let dy = -cellRadius; dy <= cellRadius; dy++) {
      const key = `${centerCellX + dx},${centerCellY + dy}`;
      if (spatialHash[key]) nearby.push(...spatialHash[key]);
    }
  }
  return nearby;
}

// ============================================================================
// SLEIGH SYSTEM
// ============================================================================
function initSleigh() {
  sleigh = {
    x: -W * 0.2,
    y: H * 0.15,
    speed: W * 0.06, // Cross screen in ~20 seconds
    bobPhase: 0,
    scale: H * 0.001,
    trail: []
  };
  sleighActive = true;
  
  // Initialize and play bells
  sleighBells.init();
  sleighBells.playJingle();
  
  // Show Christmas message
  const msg = document.getElementById('christmasMessage');
  msg.classList.add('visible');
  setTimeout(() => msg.classList.remove('visible'), 8000);
}

function updateSleigh(dt) {
  if (!sleighActive || !sleigh) return;
  
  sleigh.x += sleigh.speed * dt;
  sleigh.bobPhase += dt * 2;
  sleigh.y = H * 0.15 + sin(sleigh.bobPhase) * H * 0.02 + sin(sleigh.bobPhase * 0.7) * H * 0.01;
  
  // Add trail sparkles
  if (random() < 0.4) {
    sleigh.trail.push({
      x: sleigh.x - 20 + random() * 40,
      y: sleigh.y + random() * 20,
      life: 1,
      size: 1 + random() * 2,
      vx: -20 - random() * 30,
      vy: (random() - 0.5) * 20
    });
  }
  
  // Update trail
  for (let i = sleigh.trail.length - 1; i >= 0; i--) {
    const p = sleigh.trail[i];
    p.life -= dt * 0.8;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 15 * dt; // Gentle fall
    if (p.life <= 0) sleigh.trail.splice(i, 1);
  }
  
  // Deactivate when off screen
  if (sleigh.x > W * 1.3) {
    sleighActive = false;
    sleigh = null;
  }
}

function drawSleigh() {
  if (!sleighActive || !sleigh) return;
  
  const s = sleigh.scale;
  const x = sleigh.x;
  const y = sleigh.y;
  
  ctx.save();
  
  // Draw magic trail first
  sleigh.trail.forEach(p => {
    const alpha = p.life * 0.8;
    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
    grad.addColorStop(0, `rgba(255, 223, 100, ${alpha})`);
    grad.addColorStop(0.5, `rgba(255, 200, 50, ${alpha * 0.5})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * 3, 0, PI2);
    ctx.fill();
  });
  
  // Silhouette color
  ctx.fillStyle = 'rgba(20, 25, 35, 0.9)';
  ctx.strokeStyle = 'rgba(20, 25, 35, 0.9)';
  ctx.lineWidth = 2;
  
  // Draw reindeer (8 of them in pairs)
  const reindeerSpacing = s * 35;
  for (let i = 0; i < 8; i++) {
    const row = floor(i / 2);
    const col = i % 2;
    const rx = x - 80 - row * reindeerSpacing;
    const ry = y + (col === 0 ? -12 : 12) * s + sin(sleigh.bobPhase * 3 + i) * 3;
    
    drawReindeer(rx, ry, s, sleigh.bobPhase + i * 0.3);
  }
  
  // Draw reins
  ctx.strokeStyle = 'rgba(40, 35, 30, 0.7)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(x - 30, y);
  for (let i = 0; i < 8; i++) {
    const row = floor(i / 2);
    const col = i % 2;
    const rx = x - 80 - row * reindeerSpacing;
    const ry = y + (col === 0 ? -12 : 12) * s + sin(sleigh.bobPhase * 3 + i) * 3;
    ctx.lineTo(rx + 15 * s, ry);
  }
  ctx.stroke();
  
  // Draw sleigh body
  ctx.fillStyle = 'rgba(25, 20, 30, 0.95)';
  
  // Sleigh base
  ctx.beginPath();
  ctx.moveTo(x - 25, y + 15);
  ctx.quadraticCurveTo(x - 35, y + 25, x - 20, y + 30);
  ctx.lineTo(x + 50, y + 30);
  ctx.quadraticCurveTo(x + 65, y + 25, x + 60, y + 10);
  ctx.quadraticCurveTo(x + 55, y - 5, x + 40, y - 10);
  ctx.lineTo(x - 15, y - 10);
  ctx.quadraticCurveTo(x - 30, y - 5, x - 25, y + 15);
  ctx.fill();
  
  // Sleigh runner
  ctx.beginPath();
  ctx.moveTo(x - 30, y + 32);
  ctx.quadraticCurveTo(x - 40, y + 38, x - 35, y + 40);
  ctx.lineTo(x + 55, y + 40);
  ctx.quadraticCurveTo(x + 70, y + 38, x + 65, y + 32);
  ctx.lineWidth = 3;
  ctx.stroke();
  
  // Santa silhouette
  ctx.fillStyle = 'rgba(20, 15, 25, 0.95)';
  
  // Body
  ctx.beginPath();
  ctx.ellipse(x + 15, y + 5, 18, 15, 0, 0, PI2);
  ctx.fill();
  
  // Head
  ctx.beginPath();
  ctx.arc(x + 15, y - 18, 12, 0, PI2);
  ctx.fill();
  
  // Hat
  ctx.beginPath();
  ctx.moveTo(x + 3, y - 22);
  ctx.lineTo(x + 10, y - 45);
  ctx.quadraticCurveTo(x + 25, y - 42, x + 28, y - 25);
  ctx.lineTo(x + 27, y - 22);
  ctx.fill();
  
  // Hat pom-pom
  ctx.beginPath();
  ctx.arc(x + 12, y - 46, 4, 0, PI2);
  ctx.fill();
  
  // Arm waving
  const armAngle = sin(sleigh.bobPhase * 2) * 0.3;
  ctx.save();
  ctx.translate(x + 25, y - 5);
  ctx.rotate(-0.5 + armAngle);
  ctx.fillRect(0, -3, 20, 6);
  // Mitten
  ctx.beginPath();
  ctx.arc(20, 0, 5, 0, PI2);
  ctx.fill();
  ctx.restore();
  
  // Sack of presents
  ctx.fillStyle = 'rgba(30, 20, 25, 0.9)';
  ctx.beginPath();
  ctx.ellipse(x + 42, y + 5, 12, 18, 0.2, 0, PI2);
  ctx.fill();
  
  // Star glow around sleigh
  const glowIntensity = 0.3 + sin(sleigh.bobPhase * 4) * 0.1;
  const glow = ctx.createRadialGradient(x + 15, y, 0, x + 15, y, 100);
  glow.addColorStop(0, `rgba(255, 230, 150, ${glowIntensity * 0.3})`);
  glow.addColorStop(0.5, `rgba(255, 210, 100, ${glowIntensity * 0.1})`);
  glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow;
  ctx.fillRect(x - 100, y - 80, 230, 160);
  
  ctx.restore();
}

function drawReindeer(x, y, s, phase) {
  ctx.save();
  ctx.translate(x, y);
  
  const legPhase = sin(phase * 4);
  
  // Body
  ctx.beginPath();
  ctx.ellipse(0, 0, 18 * s, 10 * s, 0, 0, PI2);
  ctx.fill();
  
  // Neck and head
  ctx.beginPath();
  ctx.moveTo(15 * s, -5 * s);
  ctx.quadraticCurveTo(22 * s, -12 * s, 28 * s, -10 * s);
  ctx.quadraticCurveTo(35 * s, -8 * s, 32 * s, -5 * s);
  ctx.quadraticCurveTo(28 * s, -2 * s, 20 * s, 0);
  ctx.fill();
  
  // Antlers
  ctx.lineWidth = 2 * s;
  ctx.lineCap = 'round';
  
  // Left antler
  ctx.beginPath();
  ctx.moveTo(26 * s, -12 * s);
  ctx.lineTo(22 * s, -22 * s);
  ctx.moveTo(24 * s, -17 * s);
  ctx.lineTo(20 * s, -20 * s);
  ctx.moveTo(23 * s, -20 * s);
  ctx.lineTo(26 * s, -24 * s);
  ctx.stroke();
  
  // Right antler
  ctx.beginPath();
  ctx.moveTo(30 * s, -12 * s);
  ctx.lineTo(34 * s, -22 * s);
  ctx.moveTo(32 * s, -17 * s);
  ctx.lineTo(36 * s, -20 * s);
  ctx.moveTo(33 * s, -20 * s);
  ctx.lineTo(30 * s, -24 * s);
  ctx.stroke();
  
  // Legs (animated)
  ctx.lineWidth = 3 * s;
  
  // Front legs
  ctx.beginPath();
  ctx.moveTo(10 * s, 8 * s);
  ctx.lineTo(12 * s + legPhase * 4 * s, 22 * s);
  ctx.moveTo(6 * s, 8 * s);
  ctx.lineTo(4 * s - legPhase * 4 * s, 22 * s);
  ctx.stroke();
  
  // Back legs
  ctx.beginPath();
  ctx.moveTo(-10 * s, 8 * s);
  ctx.lineTo(-8 * s - legPhase * 4 * s, 22 * s);
  ctx.moveTo(-14 * s, 8 * s);
  ctx.lineTo(-16 * s + legPhase * 4 * s, 22 * s);
  ctx.stroke();
  
  // Rudolph's nose (first reindeer only)
  if (x > W * 0.5) { // Lead reindeer
    ctx.fillStyle = 'rgba(200, 50, 50, 0.9)';
    ctx.beginPath();
    ctx.arc(34 * s, -6 * s, 3 * s, 0, PI2);
    ctx.fill();
    
    // Nose glow
    const noseGlow = ctx.createRadialGradient(34 * s, -6 * s, 0, 34 * s, -6 * s, 15 * s);
    noseGlow.addColorStop(0, 'rgba(255, 100, 100, 0.4)');
    noseGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = noseGlow;
    ctx.beginPath();
    ctx.arc(34 * s, -6 * s, 15 * s, 0, PI2);
    ctx.fill();
  }
  
  ctx.restore();
}

function checkMidnight() {
  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  
  // Check for midnight (00:00 - 00:05 window)
  const isChristmasMidnight = now.getMonth() === 11 && now.getDate() === 25 && hours === 0 && minutes < 5;
  
  // Also allow testing with a URL parameter ?test=sleigh
  const urlParams = new URLSearchParams(window.location.search);
  const testSleigh = urlParams.get('test') === 'sleigh';
  
  if ((isChristmasMidnight || testSleigh) && !sleighTriggered) {
    sleighTriggered = true;
    initSleigh();
  }
}

// ============================================================================
// CALENDAR SYSTEM
// ============================================================================
const CHRISTMAS_EVENTS = [
  { name: 'Christmas Day', date: new Date('2025-12-25T00:00:00') },
  { name: 'Boxing Day', date: new Date('2025-12-26T00:00:00') },
  { name: 'New Year\'s Eve', date: new Date('2025-12-31T23:59:59') },
  { name: 'New Year', date: new Date('2026-01-01T00:00:00') },
  { name: 'Epiphany', date: new Date('2026-01-06T00:00:00') }
];

function updateCalendar() {
  const now = new Date();
  
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const ampm = hours >= 12 ? 'pm' : 'am';
  const displayHours = hours % 12 || 12;
  document.getElementById('currentTime').textContent = 
    `${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
  
  const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  document.getElementById('currentDate').textContent = now.toLocaleDateString('en-GB', options);
  
  const eventsContainer = document.getElementById('events');
  eventsContainer.innerHTML = '';
  
  let shown = 0;
  for (const event of CHRISTMAS_EVENTS) {
    if (shown >= 3) break;
    
    const diff = event.date - now;
    const isPast = diff < 0;
    const isToday = diff >= 0 && diff < 24 * 60 * 60 * 1000;
    
    if (isPast && abs(diff) > 24 * 60 * 60 * 1000) continue;
    
    const eventDiv = document.createElement('div');
    eventDiv.className = 'event' + (isToday ? ' imminent' : '') + (isPast ? ' past' : '');
    
    let countdownText;
    if (isPast) {
      countdownText = 'Now!';
    } else if (isToday) {
      const hrs = floor(diff / (1000 * 60 * 60));
      const mins = floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      countdownText = `${hrs}h ${mins}m`;
    } else {
      const days = floor(diff / (1000 * 60 * 60 * 24));
      const hrs = floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      countdownText = days > 0 ? `${days}d ${hrs}h` : `${hrs}h`;
    }
    
    eventDiv.innerHTML = `<div class="countdown">${countdownText}</div><div class="label">${event.name}</div>`;
    eventsContainer.appendChild(eventDiv);
    shown++;
  }
}

// ============================================================================
// TIME & COLOR SYSTEM
// ============================================================================
function updateDayTime() {
  const now = new Date();
  dayTime = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
}

function getTimeColors() {
  if (time - lastColorUpdate < 0.1 && currentColors) return currentColors;
  lastColorUpdate = time;
  
  const sunrise = 7.5, sunset = 16.5;
  
  const night = {
    skyTop: { r: 15, g: 20, b: 35 }, skyMid: { r: 25, g: 30, b: 50 },
    skyHorizon: { r: 35, g: 40, b: 60 }, ground: { r: 45, g: 50, b: 60 }, ambient: 0.15
  };
  const dawn = {
    skyTop: { r: 70, g: 80, b: 110 }, skyMid: { r: 180, g: 140, b: 120 },
    skyHorizon: { r: 240, g: 180, b: 140 }, ground: { r: 160, g: 155, b: 150 }, ambient: 0.5
  };
  const day = {
    skyTop: { r: 168, g: 181, b: 196 }, skyMid: { r: 196, g: 197, b: 190 },
    skyHorizon: { r: 240, g: 228, b: 208 }, ground: { r: 215, g: 212, b: 208 }, ambient: 1.0
  };
  const dusk = {
    skyTop: { r: 60, g: 70, b: 100 }, skyMid: { r: 160, g: 100, b: 90 },
    skyHorizon: { r: 220, g: 140, b: 100 }, ground: { r: 140, g: 130, b: 125 }, ambient: 0.4
  };
  
  let result;
  if (dayTime < sunrise - 1) result = night;
  else if (dayTime < sunrise + 0.5) result = blendPalettes(night, dawn, (dayTime - (sunrise - 1)) / 1.5);
  else if (dayTime < sunrise + 2) result = blendPalettes(dawn, day, (dayTime - (sunrise + 0.5)) / 1.5);
  else if (dayTime < sunset - 2) result = day;
  else if (dayTime < sunset - 0.5) result = blendPalettes(day, dusk, (dayTime - (sunset - 2)) / 1.5);
  else if (dayTime < sunset + 1) result = blendPalettes(dusk, night, (dayTime - (sunset - 0.5)) / 1.5);
  else result = night;
  
  currentColors = result;
  return result;
}

function blendPalettes(p1, p2, t) {
  return {
    skyTop: lerpColor(p1.skyTop, p2.skyTop, t),
    skyMid: lerpColor(p1.skyMid, p2.skyMid, t),
    skyHorizon: lerpColor(p1.skyHorizon, p2.skyHorizon, t),
    ground: lerpColor(p1.ground, p2.ground, t),
    ambient: lerp(p1.ambient, p2.ambient, t)
  };
}

function getSunPosition() {
  const sunrise = 7.5, sunset = 16.5, noon = 12;
  let sunY, intensity;
  
  if (dayTime < sunrise || dayTime > sunset) {
    sunY = horizonY + H * 0.3; intensity = 0;
  } else if (dayTime < noon) {
    const p = (dayTime - sunrise) / (noon - sunrise);
    sunY = horizonY - H * 0.08 - sin(p * PI / 2) * H * 0.15;
    intensity = p;
  } else {
    const p = (dayTime - noon) / (sunset - noon);
    sunY = horizonY - H * 0.08 - cos(p * PI / 2) * H * 0.15;
    intensity = 1 - p;
  }
  return { x: W * 0.5, y: sunY, intensity };
}

// ============================================================================
// CANVAS SETUP
// ============================================================================
function initCanvas() {
  const dpr = min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);
  
  horizonY = H * 0.55;
  forestY = H * 0.75;
  
  silverLayer = document.createElement('canvas');
  blueLayer = document.createElement('canvas');
  goldLayer = document.createElement('canvas');
  frostLayer = document.createElement('canvas');
  textureLayer = document.createElement('canvas');
  
  [silverLayer, blueLayer, goldLayer, frostLayer, textureLayer].forEach(c => {
    c.width = W; c.height = H;
  });
}

// ============================================================================
// TREE GENERATION
// ============================================================================
function generateBranch(x1, y1, x2, y2, depth, maxDepth, branches, createPerches = false) {
  if (depth > maxDepth) return;
  
  const midX = (x1 + x2) / 2 + (random() - 0.5) * H * 0.015;
  const midY = (y1 + y2) / 2 + (random() - 0.5) * H * 0.015;
  
  const branch = { x1, y1, cx: midX, cy: midY, x2, y2, depth };
  branches.push(branch);
  
  if (createPerches) {
    const angle = Math.atan2(y2 - y1, x2 - x1);
    if (depth >= 2 && depth <= 5 && abs(angle + PI/2) > 0.3) {
      for (let t = 0.3; t <= 0.7; t += 0.2) {
        const mt = 1 - t;
        perchSpots.push({
          x: mt*mt*x1 + 2*mt*t*midX + t*t*x2,
          y: mt*mt*y1 + 2*mt*t*midY + t*t*y2,
          branch: branch, occupied: false
        });
      }
    }
  }
  
  if (depth < maxDepth) {
    const numBranches = CONFIG.branchCount[0] + floor(random() * (CONFIG.branchCount[1] - CONFIG.branchCount[0] + 1));
    const len = sqrt((x2-x1)**2 + (y2-y1)**2) * (0.5 + random() * 0.3);
    const baseAngle = Math.atan2(y2 - y1, x2 - x1);
    
    for (let i = 0; i < numBranches; i++) {
      const newAngle = baseAngle + (random() - 0.5) * 1.2;
      generateBranch(x2, y2, x2 + cos(newAngle) * len, y2 + sin(newAngle) * len, depth + 1, maxDepth, branches, createPerches);
    }
  }
}

function generateTreeLayer(numTrees, heightMult, depthMod, xOffset, yOffset, branches, createPerches = false) {
  for (let t = 0; t < numTrees; t++) {
    const baseX = (W / (numTrees + 1)) * (t + 1) + (random() - 0.5) * W * 0.05 + xOffset;
    const baseY = forestY + yOffset + random() * H * 0.015;
    const height = H * heightMult * (0.7 + random() * 0.35);
    const lean = (random() - 0.5) * height * 0.1;
    
    const dirs = [
      { angle: -PI/2 - 0.1, len: height * 0.35 },
      { angle: -PI/2, len: height * 0.4 },
      { angle: -PI/2 + 0.1, len: height * 0.35 }
    ];
    
    dirs.forEach(d => {
      generateBranch(baseX, baseY, baseX + lean + cos(d.angle) * d.len, baseY + sin(d.angle) * d.len, 0, CONFIG.networkDepth + depthMod, branches, createPerches);
    });
    
    for (let i = 0; i < 4; i++) {
      const branchY = baseY - height * (0.15 + i * 0.18);
      const branchX = baseX + lean * (i * 0.25);
      const side = (i % 2 === 0) ? -1 : 1;
      const branchLen = height * (0.1 + random() * 0.08);
      const angle = -PI/2 + side * (0.4 + random() * 0.5);
      generateBranch(branchX, branchY, branchX + cos(angle) * branchLen, branchY + sin(angle) * branchLen, 1, CONFIG.networkDepth + depthMod - 1, branches, createPerches);
    }
  }
}

function generateForest() {
  silverBranches = []; blueBranches = []; goldBranches = []; frostBranches = [];
  perchSpots = [];
  
  generateTreeLayer(12, 0.28, 0, 0, 0, silverBranches, true);
  generateTreeLayer(14, 0.24, -1, W * 0.025, -H * 0.01, blueBranches);
  generateTreeLayer(15, 0.22, 0, -W * 0.02, -H * 0.015, goldBranches);
  generateTreeLayer(16, 0.18, -1, W * 0.015, -H * 0.025, frostBranches);
  
  allBranches = [...silverBranches, ...blueBranches, ...goldBranches];
}

function renderTreeLayerToCanvas(layerCanvas, branches, colors) {
  const lctx = layerCanvas.getContext('2d');
  lctx.clearRect(0, 0, W, H);
  
  branches.forEach(b => {
    const fade = Math.pow(0.75, b.depth);
    const width = max(0.5, 2.2 * fade);
    
    lctx.strokeStyle = rgba(colors.base, 0.12 * fade);
    lctx.lineWidth = width * 4;
    lctx.lineCap = 'round';
    lctx.beginPath();
    lctx.moveTo(b.x1, b.y1);
    lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    lctx.stroke();
    
    lctx.strokeStyle = rgba(colors.base, 0.5 * fade);
    lctx.lineWidth = width;
    lctx.beginPath();
    lctx.moveTo(b.x1, b.y1);
    lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    lctx.stroke();
    
    lctx.strokeStyle = rgba(colors.bright, 0.3 * fade);
    lctx.lineWidth = width * 0.4;
    lctx.beginPath();
    lctx.moveTo(b.x1, b.y1);
    lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    lctx.stroke();
  });
}

function renderAllTreeLayers() {
  renderTreeLayerToCanvas(silverLayer, silverBranches, TREE_COLORS.silver);
  renderTreeLayerToCanvas(blueLayer, blueBranches, TREE_COLORS.blue);
  renderTreeLayerToCanvas(goldLayer, goldBranches, TREE_COLORS.gold);
  renderTreeLayerToCanvas(frostLayer, frostBranches, TREE_COLORS.frost);
}

function renderTextureLayer() {
  const lctx = textureLayer.getContext('2d');
  const imageData = lctx.createImageData(W, H);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
    const noise = (random() - 0.5) * 25;
    data[i] = 135 + noise;
    data[i + 1] = 130 + noise;
    data[i + 2] = 125 + noise;
    data[i + 3] = CONFIG.textureGrain * 255;
  }
  
  lctx.putImageData(imageData, 0, 0);
}

// ============================================================================
// STARLING SYSTEM (abbreviated for space - same as before)
// ============================================================================
function initStarlings() {
  starlings = [];
  const cx = W * 0.5, cy = horizonY - H * 0.18;
  
  for (let i = 0; i < CONFIG.starlingCount; i++) {
    const angle = random() * PI2;
    const dist = random() * W * 0.1;
    
    starlings.push({
      x: cx + cos(angle) * dist, y: cy + sin(angle) * dist * 0.4,
      vx: (random() - 0.5) * 50, vy: (random() - 0.5) * 30,
      size: 1.2 + random() * 0.8, state: 'flying',
      perchSpot: null, perchTime: 0, stateTimer: 0,
      wingPhase: random() * PI2, wingSpeed: 15 + random() * 5
    });
  }
}

function updateStarlings(dt) {
  flockCRR.update(dt, 1 + sin(time * 0.1) * 0.3);
  const flockCoherence = flockCRR.amplitude;
  const isRupturing = flockCRR.state === 'rupture';
  
  const baseFreq = 0.12 + flockCoherence * 0.08;
  const attractorX = W * 0.5 + sin(time * baseFreq) * W * 0.22 + sin(time * baseFreq * 1.6 + 1) * W * 0.1;
  const attractorY = horizonY - H * 0.16 + sin(time * baseFreq * 0.7) * H * 0.07;
  
  const splitStrength = isRupturing ? 1.5 : 0.8;
  const attractor2X = attractorX + sin(time * 0.35) * W * 0.12 * splitStrength;
  const attractor2Y = attractorY + cos(time * 0.28) * H * 0.06 * splitStrength;
  
  const scareChance = isRupturing ? 0.01 : 0.0003;
  const scareEvent = random() < scareChance;
  const scareX = scareEvent ? random() * W : 0;
  const scareY = scareEvent ? random() * horizonY * 0.5 : 0;
  
  const perchedCount = starlings.filter(b => b.state === 'perched').length;
  const massLaunch = (perchedCount > CONFIG.starlingCount * 0.35 && random() < 0.003) || isRupturing;
  
  updateSpatialHash();
  
  for (let i = 0; i < starlings.length; i++) {
    const bird = starlings[i];
    bird.stateTimer += dt;
    bird.wingPhase += bird.wingSpeed * dt;
    
    if (bird.state === 'perched') {
      bird.perchTime += dt;
      const takeoffChance = bird.perchTime > 4 ? 0.008 : 0.001;
      if (random() < takeoffChance || massLaunch || scareEvent) {
        bird.state = 'takeoff'; bird.stateTimer = 0;
        bird.vy = -40 - random() * 25; bird.vx = (random() - 0.5) * 50;
        if (bird.perchSpot) bird.perchSpot.occupied = false;
        bird.perchSpot = null;
      }
      continue;
    }
    
    if (bird.state === 'takeoff') {
      bird.vy -= 60 * dt;
      bird.x += bird.vx * dt; bird.y += bird.vy * dt;
      if (bird.stateTimer > 0.4) bird.state = 'flying';
      continue;
    }
    
    if (bird.state === 'landing') {
      const spot = bird.perchSpot;
      const dx = spot.x - bird.x, dy = spot.y - bird.y;
      const dist = sqrt(dx * dx + dy * dy);
      if (dist < 2) {
        bird.state = 'perched'; bird.x = spot.x; bird.y = spot.y;
        bird.perchTime = 0; bird.vx = 0; bird.vy = 0;
      } else {
        bird.vx = dx * 4; bird.vy = dy * 4;
        bird.x += bird.vx * dt; bird.y += bird.vy * dt;
      }
      continue;
    }
    
    let sepX = 0, sepY = 0, alignX = 0, alignY = 0, cohX = 0, cohY = 0, neighborCount = 0;
    const nearbyIndices = getNearbyBirds(bird.x, bird.y, 80);
    
    for (let j = 0; j < nearbyIndices.length; j++) {
      const idx = nearbyIndices[j];
      if (idx === i) continue;
      const other = starlings[idx];
      if (other.state !== 'flying') continue;
      
      const dx = other.x - bird.x, dy = other.y - bird.y;
      const distSq = dx * dx + dy * dy;
      if (distSq > 6400) continue;
      
      const dist = sqrt(distSq);
      if (dist < 20 && dist > 0) {
        const factor = (20 - dist) / 20;
        sepX -= (dx / dist) * factor; sepY -= (dy / dist) * factor;
      }
      if (dist < 60) {
        alignX += other.vx; alignY += other.vy;
        cohX += other.x; cohY += other.y;
        neighborCount++;
      }
    }
    
    const cohesionStrength = 0.008 + flockCoherence * 0.012;
    const alignmentStrength = 0.06 + flockCoherence * 0.04;
    
    if (neighborCount > 0) {
      bird.vx += sepX * 2.5; bird.vy += sepY * 2.5;
      alignX /= neighborCount; alignY /= neighborCount;
      bird.vx += (alignX - bird.vx) * alignmentStrength;
      bird.vy += (alignY - bird.vy) * alignmentStrength;
      cohX = cohX / neighborCount - bird.x; cohY = cohY / neighborCount - bird.y;
      bird.vx += cohX * cohesionStrength; bird.vy += cohY * cohesionStrength;
    }
    
    const toAttr1X = attractorX - bird.x, toAttr1Y = attractorY - bird.y;
    const attr1Dist = sqrt(toAttr1X * toAttr1X + toAttr1Y * toAttr1Y);
    const toAttr2X = attractor2X - bird.x, toAttr2Y = attractor2Y - bird.y;
    const attr2Dist = sqrt(toAttr2X * toAttr2X + toAttr2Y * toAttr2Y);
    
    if (attr1Dist < attr2Dist || random() > 0.3) {
      bird.vx += (toAttr1X / max(attr1Dist, 1)) * 0.5;
      bird.vy += (toAttr1Y / max(attr1Dist, 1)) * 0.5;
    } else {
      bird.vx += (toAttr2X / max(attr2Dist, 1)) * 0.4;
      bird.vy += (toAttr2Y / max(attr2Dist, 1)) * 0.4;
    }
    
    if (scareEvent) {
      const scareDx = bird.x - scareX, scareDy = bird.y - scareY;
      const scareDist = sqrt(scareDx * scareDx + scareDy * scareDy);
      if (scareDist < W * 0.35 && scareDist > 0) {
        bird.vx += (scareDx / scareDist) * 40; bird.vy += (scareDy / scareDist) * 40;
      }
    }
    
    if (bird.x < W * 0.03) bird.vx += 4;
    if (bird.x > W * 0.97) bird.vx -= 4;
    if (bird.y < H * 0.06) bird.vy += 3;
    if (bird.y > forestY - H * 0.03) bird.vy -= 3;
    
    const speed = sqrt(bird.vx * bird.vx + bird.vy * bird.vy);
    if (speed > 100) { bird.vx = (bird.vx / speed) * 100; bird.vy = (bird.vy / speed) * 100; }
    else if (speed < 25 && speed > 0) { bird.vx = (bird.vx / speed) * 25; bird.vy = (bird.vy / speed) * 25; }
    
    bird.x += bird.vx * dt; bird.y += bird.vy * dt;
    
    if (bird.y > forestY - H * 0.12 && speed < 55 && random() < 0.004) {
      let bestSpot = null, bestDist = Infinity;
      for (let p = 0; p < perchSpots.length; p++) {
        const spot = perchSpots[p];
        if (spot.occupied) continue;
        const d = sqrt((bird.x - spot.x) ** 2 + (bird.y - spot.y) ** 2);
        if (d < H * 0.12 && d < bestDist) { bestDist = d; bestSpot = spot; }
      }
      if (bestSpot) {
        bird.state = 'landing'; bird.perchSpot = bestSpot;
        bestSpot.occupied = true; bird.stateTimer = 0;
      }
    }
  }
}

function drawStarling(bird, ambient) {
  const isFlying = bird.state === 'flying' || bird.state === 'takeoff' || bird.state === 'landing';
  
  let mistFade = 1;
  if (bird.y > forestY - H * 0.08) mistFade = max(0.3, 1 - (bird.y - (forestY - H * 0.08)) / (H * 0.1));
  
  const alpha = (0.6 + ambient * 0.25) * mistFade;
  ctx.fillStyle = `rgba(35, 40, 50, ${alpha})`;
  
  ctx.save();
  ctx.translate(bird.x, bird.y);
  
  if (isFlying) {
    const angle = Math.atan2(bird.vy, bird.vx);
    ctx.rotate(angle);
    
    const speed = sqrt(bird.vx * bird.vx + bird.vy * bird.vy);
    const bodyStretch = min(speed / 50, 1.8);
    const flapAmount = sin(bird.wingPhase) * (0.4 + speed / 200);
    const wingSpan = bird.size * 3;
    
    ctx.beginPath();
    ctx.ellipse(0, 0, bird.size * bodyStretch, bird.size * 0.45, 0, 0, PI2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(-bird.size * 0.3, 0);
    ctx.quadraticCurveTo(-bird.size * 0.5, -wingSpan * 0.5 * (1 + flapAmount), -bird.size * 0.2, -wingSpan * (0.8 + flapAmount * 0.3));
    ctx.quadraticCurveTo(bird.size * 0.2, -wingSpan * 0.3 * (1 + flapAmount), bird.size * 0.3, 0);
    ctx.moveTo(-bird.size * 0.3, 0);
    ctx.quadraticCurveTo(-bird.size * 0.5, wingSpan * 0.5 * (1 + flapAmount), -bird.size * 0.2, wingSpan * (0.8 + flapAmount * 0.3));
    ctx.quadraticCurveTo(bird.size * 0.2, wingSpan * 0.3 * (1 + flapAmount), bird.size * 0.3, 0);
    ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(-bird.size * bodyStretch, 0);
    ctx.lineTo(-bird.size * bodyStretch - bird.size * 0.8, -bird.size * 0.3);
    ctx.lineTo(-bird.size * bodyStretch - bird.size * 0.8, bird.size * 0.3);
    ctx.closePath();
    ctx.fill();
  } else {
    ctx.beginPath();
    ctx.ellipse(0, 0, bird.size * 0.9, bird.size * 1.1, 0, 0, PI2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, -bird.size * 0.9, bird.size * 0.5, 0, PI2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(bird.size * 0.4, -bird.size * 0.9);
    ctx.lineTo(bird.size * 0.9, -bird.size * 0.85);
    ctx.lineTo(bird.size * 0.4, -bird.size * 0.75);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.restore();
}

// ============================================================================
// OTHER SYSTEMS (mist, snow, branch glows - same as before)
// ============================================================================
function updateBranchGlows(dt, ambient) {
  treePulseCRR.update(dt);
  const spawnRate = treePulseCRR.state === 'rupture' ? 0.5 : 0.08;
  if (random() < spawnRate && allBranches.length > 0) {
    const branch = allBranches[floor(random() * allBranches.length)];
    branchGlows.push({ branch, progress: 0, speed: 0.6 + random() * 0.5, intensity: 0.3 + random() * 0.4 });
  }
  
  const nightBoost = 1 + (1 - ambient) * 2;
  
  for (let i = branchGlows.length - 1; i >= 0; i--) {
    const glow = branchGlows[i];
    glow.progress += glow.speed * dt;
    if (glow.progress > 1.2) { branchGlows.splice(i, 1); continue; }
    
    const branch = glow.branch;
    const fade = Math.pow(0.75, branch.depth);
    
    let intensity;
    if (glow.progress < 0.25) intensity = glow.progress / 0.25;
    else if (glow.progress < 0.6) intensity = 1;
    else intensity = max(0, 1 - (glow.progress - 0.6) / 0.6);
    intensity *= glow.intensity * fade * nightBoost;
    
    if (intensity > 0.03) {
      const width = 1.5 * fade;
      ctx.strokeStyle = `rgba(255, 250, 240, ${intensity * 0.12})`;
      ctx.lineWidth = width * 10; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(branch.x1, branch.y1);
      ctx.quadraticCurveTo(branch.cx, branch.cy, branch.x2, branch.y2); ctx.stroke();
      
      ctx.strokeStyle = `rgba(255, 252, 245, ${intensity * 0.25})`;
      ctx.lineWidth = width * 5;
      ctx.beginPath(); ctx.moveTo(branch.x1, branch.y1);
      ctx.quadraticCurveTo(branch.cx, branch.cy, branch.x2, branch.y2); ctx.stroke();
      
      ctx.strokeStyle = `rgba(255, 255, 250, ${intensity * 0.45})`;
      ctx.lineWidth = width * 2;
      ctx.beginPath(); ctx.moveTo(branch.x1, branch.y1);
      ctx.quadraticCurveTo(branch.cx, branch.cy, branch.x2, branch.y2); ctx.stroke();
    }
  }
}

function initMist() {
  mistPatches = [];
  for (let i = 0; i < 18; i++) {
    mistPatches.push({
      x: random() * W * 1.4 - W * 0.2, y: forestY + random() * H * 0.1 - H * 0.03,
      width: W * (0.2 + random() * 0.3), height: H * (0.05 + random() * 0.06),
      speed: 2 + random() * 5, baseOpacity: 0.08 + random() * 0.1,
      phase: random() * PI2, vDrift: 0.3 + random() * 0.5
    });
  }
}

function drawMist(dt, colors) {
  mistCRR.update(dt);
  const mistIntensity = 0.7 + mistCRR.amplitude * 0.5;
  const mistColor = lerpColor({ r: 230, g: 228, b: 225 }, colors.ground, 0.25);
  
  for (let i = 0; i < mistPatches.length; i++) {
    const m = mistPatches[i];
    m.x += m.speed * dt;
    if (m.x > W + m.width * 0.5) m.x = -m.width;
    
    const yOffset = sin(time * 0.2 + m.phase) * H * 0.01 * m.vDrift;
    const currentY = m.y + yOffset;
    const opacity = m.baseOpacity * mistIntensity;
    
    const grad = ctx.createRadialGradient(m.x + m.width * 0.5, currentY, 0, m.x + m.width * 0.5, currentY, m.width * 0.5);
    grad.addColorStop(0, `rgba(${mistColor.r|0}, ${mistColor.g|0}, ${mistColor.b|0}, ${opacity})`);
    grad.addColorStop(0.5, `rgba(${mistColor.r|0}, ${mistColor.g|0}, ${mistColor.b|0}, ${opacity * 0.5})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(m.x + m.width * 0.5, currentY, m.width * 0.5, m.height * 0.5, 0, 0, PI2);
    ctx.fill();
  }
}

function initSnow() {
  snowflakes = [];
  const count = floor((W * H) / 8000);
  for (let i = 0; i < count; i++) {
    snowflakes.push({
      x: random() * W, y: random() * H, size: 0.5 + random() * 1.8,
      speed: 10 + random() * 18, drift: (random() - 0.5) * 0.35,
      opacity: 0.2 + random() * 0.35, phase: random() * PI2
    });
  }
}

function drawSnow(dt, ambient) {
  const snowAlpha = 0.3 + ambient * 0.5;
  ctx.fillStyle = '#fff';
  
  for (let i = 0; i < snowflakes.length; i++) {
    const f = snowflakes[i];
    f.y += f.speed * dt;
    f.x += sin(time * 0.15 + f.phase) * f.drift * dt * 35;
    if (f.y > H + 5) { f.y = -5; f.x = random() * W; }
    if (f.x < -5) f.x = W + 5;
    if (f.x > W + 5) f.x = -5;
    
    const depthFade = f.y < horizonY ? 0.35 : 1;
    ctx.globalAlpha = f.opacity * depthFade * snowAlpha;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size * depthFade, 0, PI2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ============================================================================
// LANDSCAPE DRAWING
// ============================================================================
function drawSky(colors, sun) {
  const skyGrad = ctx.createLinearGradient(0, 0, 0, horizonY);
  skyGrad.addColorStop(0, rgba(colors.skyTop, 1));
  skyGrad.addColorStop(0.5, rgba(colors.skyMid, 1));
  skyGrad.addColorStop(1, rgba(colors.skyHorizon, 1));
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, horizonY + 20);
  
  if (sun.intensity > 0.1) {
    const grad1 = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, H * 0.45);
    grad1.addColorStop(0, `rgba(255, 248, 230, ${0.35 * sun.intensity})`);
    grad1.addColorStop(0.3, `rgba(255, 240, 210, ${0.15 * sun.intensity})`);
    grad1.addColorStop(1, 'transparent');
    ctx.fillStyle = grad1;
    ctx.fillRect(0, 0, W, H);
    
    const grad2 = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, H * 0.12);
    grad2.addColorStop(0, `rgba(255, 255, 248, ${0.85 * sun.intensity})`);
    grad2.addColorStop(0.5, `rgba(255, 250, 235, ${0.4 * sun.intensity})`);
    grad2.addColorStop(1, 'transparent');
    ctx.fillStyle = grad2;
    ctx.fillRect(0, 0, W, H);
  } else {
    const moonX = W * 0.7, moonY = H * 0.18;
    const moonGrad = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, H * 0.08);
    moonGrad.addColorStop(0, 'rgba(220, 225, 235, 0.25)');
    moonGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = moonGrad;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = 'rgba(235, 240, 250, 0.9)';
    ctx.beginPath();
    ctx.arc(moonX, moonY, H * 0.022, 0, PI2);
    ctx.fill();
    
    ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * (1 - colors.ambient)})`;
    for (let i = 0; i < 60; i++) {
      const sx = (sin(i * 127.1) * 0.5 + 0.5) * W;
      const sy = (cos(i * 311.7) * 0.4 + 0.25) * horizonY;
      const twinkle = sin(time * 2.5 + i * 1.7) * 0.3 + 0.7;
      ctx.globalAlpha = twinkle * (1 - colors.ambient) * 0.6;
      ctx.beginPath();
      ctx.arc(sx, sy, 0.7, 0, PI2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

function drawLandscape(colors) {
  ctx.fillStyle = `rgba(${colors.ground.r * 0.65 | 0}, ${colors.ground.g * 0.65 | 0}, ${colors.ground.b * 0.7 | 0}, 0.4)`;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  for (let x = 0; x <= W; x += 25) {
    const hill = sin(x * 0.0025) * H * 0.035 + sin(x * 0.006 + 2) * H * 0.02;
    ctx.lineTo(x, horizonY - H * 0.04 + hill);
  }
  ctx.lineTo(W, horizonY + 15); ctx.lineTo(0, horizonY + 15); ctx.fill();
  
  const snowGrad = ctx.createLinearGradient(0, horizonY, 0, H);
  snowGrad.addColorStop(0, rgba(colors.ground, 1));
  snowGrad.addColorStop(0.4, rgba(lerpColor(colors.ground, { r: 255, g: 255, b: 255 }, 0.08), 1));
  snowGrad.addColorStop(1, rgba(lerpColor(colors.ground, { r: 170, g: 165, b: 160 }, 0.15), 1));
  ctx.fillStyle = snowGrad;
  ctx.fillRect(0, horizonY - 5, W, H - horizonY + 5);
  
  ctx.beginPath();
  ctx.moveTo(0, forestY + H * 0.07);
  for (let x = 0; x <= W; x += 35) {
    const wave = sin(x * 0.004) * 7 + sin(x * 0.01 + 1) * 4;
    ctx.lineTo(x, forestY + H * 0.07 + wave);
  }
  ctx.lineTo(W, H); ctx.lineTo(0, H);
  ctx.fillStyle = `rgba(${colors.ground.r + 15 | 0}, ${colors.ground.g + 12 | 0}, ${colors.ground.b + 10 | 0}, 0.35)`;
  ctx.fill();
}

function drawVignette(ambient) {
  const strength = 0.12 + (1 - ambient) * 0.18;
  const vigGrad = ctx.createRadialGradient(W * 0.5, H * 0.4, H * 0.35, W * 0.5, H * 0.5, H * 0.95);
  vigGrad.addColorStop(0, 'transparent');
  vigGrad.addColorStop(0.65, `rgba(25, 22, 18, ${strength * 0.4})`);
  vigGrad.addColorStop(1, `rgba(8, 6, 4, ${strength})`);
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, W, H);
}

// ============================================================================
// MAIN ANIMATION LOOP
// ============================================================================
let lastTime = performance.now();
let calendarUpdateTime = 0;

function animate(currentTime) {
  requestAnimationFrame(animate);
  
  if (!layersReady) return;
  
  const dt = min((currentTime - lastTime) / 1000, 0.05);
  lastTime = currentTime;
  time += dt;
  
  if (floor(time) !== floor(time - dt)) updateDayTime();
  
  if (time - calendarUpdateTime > 1) {
    updateCalendar();
    checkMidnight();
    calendarUpdateTime = time;
  }
  
  const colors = getTimeColors();
  const sun = getSunPosition();
  
  updateStarlings(dt);
  updateSleigh(dt);
  
  // RENDER
  drawSky(colors, sun);
  
  // Draw sleigh (behind landscape if in distance)
  if (sleighActive) drawSleigh();
  
  drawLandscape(colors);
  
  for (let i = 0; i < starlings.length; i++) {
    const bird = starlings[i];
    if (bird.state === 'flying' && bird.y < forestY - H * 0.05) drawStarling(bird, colors.ambient);
  }
  
  const treeAlpha = 0.45 + colors.ambient * 0.35;
  ctx.globalAlpha = treeAlpha * 0.5; ctx.drawImage(frostLayer, 0, 0);
  ctx.globalAlpha = treeAlpha * 0.6; ctx.drawImage(blueLayer, 0, 0);
  ctx.globalAlpha = treeAlpha * 0.65; ctx.drawImage(goldLayer, 0, 0);
  ctx.globalAlpha = treeAlpha * 0.85; ctx.drawImage(silverLayer, 0, 0);
  ctx.globalAlpha = 1;
  
  updateBranchGlows(dt, colors.ambient);
  
  for (let i = 0; i < starlings.length; i++) {
    const bird = starlings[i];
    if (bird.state !== 'flying' || bird.y >= forestY - H * 0.05) drawStarling(bird, colors.ambient);
  }
  
  drawMist(dt, colors);
  drawSnow(dt, colors.ambient);
  
  ctx.globalCompositeOperation = 'overlay';
  ctx.globalAlpha = 0.28;
  ctx.drawImage(textureLayer, 0, 0);
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
  
  drawVignette(colors.ambient);
}

// ============================================================================
// INITIALIZATION
// ============================================================================
function init() {
  initCanvas();
  generateForest();
  renderAllTreeLayers();
  renderTextureLayer();
  initStarlings();
  initMist();
  initSnow();
  updateDayTime();
  updateCalendar();
  layersReady = true;
}

// Enable audio on first user interaction (required by browsers)
document.addEventListener('click', () => {
  sleighBells.init();
}, { once: true });

window.addEventListener('resize', init);
init();
requestAnimationFrame(animate);

</script>
</body>
</html>
