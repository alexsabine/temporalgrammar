<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Winter Forest | Living Landscape</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a1a;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'EB Garamond', Georgia, serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(to bottom, #1a1d24 0%, #252830 50%, #2a2d35 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.8s ease-out;
    }
    .loading-screen.fade-out { opacity: 0; pointer-events: none; }
    .loading-screen.hidden { display: none; }
    
    .loading-content { text-align: center; color: rgba(255, 255, 255, 0.85); }
    .loading-title { font-size: 2.5rem; font-weight: 400; letter-spacing: 0.15em; margin-bottom: 0.5rem; color: rgba(255, 255, 255, 0.9); }
    .loading-subtitle { font-size: 1.1rem; font-style: italic; opacity: 0.6; margin-bottom: 3rem; }
    
    .loading-indicator { display: flex; gap: 8px; justify-content: center; margin-bottom: 2rem; }
    .snow-dot {
      width: 6px; height: 6px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      animation: snowfall 1.5s ease-in-out infinite;
    }
    .snow-dot:nth-child(2) { animation-delay: 0.2s; }
    .snow-dot:nth-child(3) { animation-delay: 0.4s; }
    .snow-dot:nth-child(4) { animation-delay: 0.6s; }
    .snow-dot:nth-child(5) { animation-delay: 0.8s; }
    
    @keyframes snowfall {
      0%, 100% { transform: translateY(-10px); opacity: 0.3; }
      50% { transform: translateY(10px); opacity: 1; }
    }
    
    .loading-quote { font-size: 1rem; font-style: italic; opacity: 0.5; max-width: 400px; line-height: 1.6; }
    
    /* Calendar Overlay */
    .calendar-overlay {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 20px 30px;
      background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 60%, transparent 100%);
      color: rgba(255, 255, 255, 0.85);
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in;
    }
    .calendar-overlay.visible { opacity: 1; }
    
    .datetime { text-align: left; }
    .datetime .time { font-size: 2.8rem; font-weight: 400; letter-spacing: 0.02em; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .datetime .date { font-size: 1.1rem; opacity: 0.8; margin-top: 2px; font-style: italic; }
    
    .events { text-align: right; display: flex; gap: 35px; }
    .event { text-align: center; }
    .event .countdown { font-size: 1.6rem; font-weight: 500; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .event .label { font-size: 0.85rem; opacity: 0.75; margin-top: 2px; font-style: italic; }
    .event.imminent .countdown { color: #ffd700; }
    .event.past .countdown { color: rgba(255,255,255,0.5); }
    
    .christmas-message {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      text-align: center; color: #ffd700;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
      opacity: 0; transition: opacity 2s ease-in-out;
      pointer-events: none; z-index: 100;
    }
    .christmas-message.visible { opacity: 1; }
    .christmas-message h1 { font-size: 4rem; font-weight: 400; letter-spacing: 0.1em; margin-bottom: 0.5rem; }
    .christmas-message p { font-size: 1.5rem; font-style: italic; opacity: 0.9; }
    
    /* Weather Indicator */
    .weather-indicator {
      position: fixed;
      top: 20px; right: 20px;
      padding: 10px 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.85rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in;
      text-align: right;
      backdrop-filter: blur(5px);
    }
    .weather-indicator.visible { opacity: 1; }
    .weather-indicator .location { font-weight: 500; color: rgba(255, 255, 255, 0.9); }
    .weather-indicator .conditions { font-style: italic; opacity: 0.8; margin-top: 3px; }
    .weather-indicator .temp { font-size: 1.1rem; margin-top: 2px; }
  </style>
</head>
<body>

<div class="loading-screen" id="loadingScreen">
  <div class="loading-content">
    <h1 class="loading-title">Winter Forest</h1>
    <p class="loading-subtitle">A Living Landscape</p>
    <div class="loading-indicator">
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
    </div>
    <p class="loading-quote">"The snow fell softly through the winter air,<br>and all the world grew quiet, waiting there."</p>
  </div>
</div>

<canvas id="canvas"></canvas>

<div class="calendar-overlay" id="calendarOverlay">
  <div class="datetime">
    <div class="time" id="currentTime">00:00</div>
    <div class="date" id="currentDate">Loading...</div>
  </div>
  <div class="events" id="events"></div>
</div>

<div class="christmas-message" id="christmasMessage">
  <h1>Merry Christmas</h1>
  <p>Peace on Earth, Goodwill to All</p>
</div>

<div class="weather-indicator" id="weatherIndicator">
  <div class="location" id="weatherLocation">Detecting location...</div>
  <div class="conditions" id="weatherConditions"></div>
  <div class="temp" id="weatherTemp"></div>
  <div class="moon-info" id="moonInfo" style="font-size: 10px; margin-top: 4px; opacity: 0.8;"></div>
</div>

<script>
// ============================================================================
// CRR WINTER FOREST - Final Version with Real Weather & Moon Phases
// ============================================================================

const CONFIG = {
  networkDepth: 6,
  branchCount: [2, 4],
  starlingCount: 350,
  spatialCellSize: 60
};

// ============================================================================
// CRR & AUDIO SYSTEMS
// ============================================================================
class CRRSystem {
  constructor(omega, rate = 0.1) {
    this.omega = omega; this.coherence = 0; this.rate = rate;
    this.state = 'coherence'; this.amplitude = 0;
  }
  update(dt, inputSignal = 1) {
    if (this.state === 'coherence') {
      this.coherence += this.rate * inputSignal * dt;
      this.amplitude = this.coherence / this.omega;
      if (this.coherence >= this.omega) this.state = 'rupture';
    } else if (this.state === 'rupture') {
      this.amplitude = 1; this.state = 'regeneration';
    } else {
      this.coherence *= Math.exp(-2 * dt * Math.exp(Math.min(this.coherence / this.omega, 3)));
      this.amplitude = this.coherence / this.omega;
      if (this.coherence < 0.01) { this.coherence = 0; this.state = 'coherence'; }
    }
    return this.amplitude;
  }
}

class AudioSystem {
  constructor() { this.ctx = null; this.isInit = false; }
  
  init() {
    if (this.isInit) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.isInit = true;
  }
  
  playBell(time, pitch, vol) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.frequency.value = pitch; osc.type = 'sine';
    osc.connect(gain); gain.connect(this.ctx.destination);
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.08 * vol, time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
    osc.start(time); osc.stop(time + 0.4);
  }
  
  playJingle() {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();
    const now = this.ctx.currentTime;
    const pitches = [2400, 2600, 2800, 3000];
    for (let r = 0; r < 20; r++) {
      [0, 0.15, 0.3, 0.45, 0.6, 0.75].forEach((t, i) => {
        this.playBell(now + r * 1 + t, pitches[i % 4] * (0.98 + Math.random() * 0.04), 0.5);
      });
    }
  }
}

const audio = new AudioSystem();

// ============================================================================
// GLOBALS
// ============================================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

let W, H, horizonY, forestY, time = 0, dayTime = 0;
let isLoaded = false;

let treeLayers = { silver: null, blue: null, gold: null, frost: null };
let textureLayer = null;

let perchSpots = [], starlings = [], snowflakes = [], mistPatches = [];
let spatialHash = {};

let predator = null, predatorCooldown = 15;

const flockCRR = new CRRSystem(1 / Math.PI, 0.3);
const mistCRR = new CRRSystem(0.5, 0.08);
const weatherCRR = new CRRSystem(0.8, 0.02);

let sleigh = null, sleighActive = false, sleighTriggered = false;

let currentColors = null, lastColorUpdate = 0;

// Forest lamps
let forestLamps = [];

// Path and Lowry figures
let pathPoints = [];
let lowryFigures = [];

// Stars (persistent array for twinkling)
let stars = [];

// Moon phase (0 = new, 0.5 = full, 1 = new again)
let moonPhase = 0;

// Weather state
let weatherState = {
  snowIntensity: 1.0,
  mistIntensity: 1.0,
  windStrength: 1.0,
  targetSnow: 1.0,
  targetMist: 1.0,
  targetWind: 1.0,
  realWeatherEnabled: false,
  realWeatherData: null,
  locationName: '',
  latitude: 51.5, // Default to London
  longitude: -0.1
};

const TREE_COLORS = {
  silver: { base: { r: 140, g: 150, b: 175 }, bright: { r: 190, g: 200, b: 225 } },
  blue: { base: { r: 100, g: 130, b: 180 }, bright: { r: 150, g: 180, b: 230 } },
  gold: { base: { r: 170, g: 155, b: 115 }, bright: { r: 220, g: 200, b: 150 } },
  frost: { base: { r: 160, g: 140, b: 165 }, bright: { r: 200, g: 180, b: 210 } }
};

const TREE_CONFIG = {
  silver: { num: 10, height: 0.28, depth: 0, xOff: 0, yOff: 0, perch: true },
  blue: { num: 12, height: 0.24, depth: -1, xOff: 0.025, yOff: -0.01, perch: false },
  gold: { num: 12, height: 0.22, depth: 0, xOff: -0.02, yOff: -0.015, perch: false },
  frost: { num: 14, height: 0.18, depth: -1, xOff: 0.015, yOff: -0.025, perch: false }
};

// ============================================================================
// UTILITIES
// ============================================================================
const { sin, cos, sqrt, abs, min, max, floor, random, PI } = Math;
const PI2 = PI * 2;

function lerp(a, b, t) { return a + (b - a) * t; }
function lerpColor(c1, c2, t) { return { r: lerp(c1.r, c2.r, t), g: lerp(c1.g, c2.g, t), b: lerp(c1.b, c2.b, t) }; }
function rgba(c, a) { return `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`; }

function getSpatialKey(x, y) { return (floor(x / CONFIG.spatialCellSize) << 16) | (floor(y / CONFIG.spatialCellSize) & 0xFFFF); }

function updateSpatialHash() {
  spatialHash = {};
  for (let i = 0; i < starlings.length; i++) {
    const b = starlings[i];
    if (b.state !== 'flying') continue;
    const key = getSpatialKey(b.x, b.y);
    (spatialHash[key] || (spatialHash[key] = [])).push(i);
  }
}

function getNearbyBirds(x, y) {
  const nearby = [];
  const cx = floor(x / CONFIG.spatialCellSize), cy = floor(y / CONFIG.spatialCellSize);
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      const key = ((cx + dx) << 16) | ((cy + dy) & 0xFFFF);
      const cell = spatialHash[key];
      if (cell) {
        for (let i = 0, len = cell.length; i < len; i++) {
          nearby.push(cell[i]);
        }
      }
    }
  }
  return nearby;
}

// ============================================================================
// MOON PHASE CALCULATION
// ============================================================================
function calculateMoonPhase(date = new Date()) {
  // Calculate moon phase using a simplified lunation algorithm
  // Based on the synodic month (~29.53 days)
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  // Calculate Julian date
  let a = floor((14 - month) / 12);
  let y = year + 4800 - a;
  let m = month + 12 * a - 3;
  let jd = day + floor((153 * m + 2) / 5) + 365 * y + floor(y / 4) - floor(y / 100) + floor(y / 400) - 32045;
  
  // Calculate days since known new moon (January 6, 2000 was a new moon)
  const knownNewMoon = 2451550.1; // Julian date of Jan 6, 2000 new moon
  const synodicMonth = 29.530588853; // Average length of lunar month in days
  
  const daysSinceNewMoon = jd - knownNewMoon;
  const lunarAge = daysSinceNewMoon % synodicMonth;
  
  // Return phase as 0-1 (0 = new moon, 0.5 = full moon, 1 = new moon again)
  return lunarAge / synodicMonth;
}

function getMoonIllumination(phase) {
  // Convert phase to illumination percentage
  // 0 or 1 = new moon (0% illuminated)
  // 0.5 = full moon (100% illuminated)
  return (1 - cos(phase * PI2)) / 2;
}

// ============================================================================
// STARS
// ============================================================================
function initStars() {
  stars = [];
  const numStars = 150;
  for (let i = 0; i < numStars; i++) {
    stars.push({
      x: random() * W,
      y: random() * horizonY * 0.85,
      size: 0.5 + random() * 1.2,
      brightness: 0.3 + random() * 0.7,
      twinklePhase: random() * PI2,
      twinkleSpeed: 1.5 + random() * 3
    });
  }
}

function drawStars(ambient) {
  // Stars only visible when dark (ambient < 0.4)
  if (ambient > 0.45) return;
  
  const starVisibility = 1 - (ambient / 0.45);
  
  ctx.fillStyle = '#fff';
  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    const twinkle = 0.6 + sin(time * s.twinkleSpeed + s.twinklePhase) * 0.4;
    const alpha = s.brightness * twinkle * starVisibility * 0.9;
    
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, PI2);
    ctx.fill();
    
    // Add subtle glow to brighter stars
    if (s.brightness > 0.6) {
      ctx.globalAlpha = alpha * 0.3;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size * 2.5, 0, PI2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

// ============================================================================
// FOREST LAMPS - Ornate Victorian Street Lamps
// ============================================================================
function initForestLamps() {
  forestLamps = [];
  
  // Place ornate Victorian lamps along the path
  const lampConfigs = [
    { xRatio: 0.18, scale: 0.42, brightness: 0.85 },
    { xRatio: 0.45, scale: 0.45, brightness: 0.9 },
    { xRatio: 0.72, scale: 0.43, brightness: 0.82 },
  ];
  
  const pathY = H * 0.79;
  
  lampConfigs.forEach((cfg, idx) => {
    const waveY = sin(cfg.xRatio * W * 0.008) * 3 + sin(cfg.xRatio * W * 0.02 + 1) * 2;
    forestLamps.push({
      x: W * cfg.xRatio,
      y: pathY - 2 + waveY, // Just above the path, following its contour
      scale: cfg.scale,
      brightness: cfg.brightness,
      phase: random() * PI2,
      crr: new CRRSystem(0.3 + random() * 0.2, 0.12 + random() * 0.08)
    });
  });
}

function drawForestLamps(ambient) {
  if (ambient > 0.5) return;
  if (!forestLamps || forestLamps.length === 0) return;
  
  const lampIntensity = 1 - (ambient / 0.5);
  
  forestLamps.forEach((lamp, idx) => {
    lamp.crr.update(0.016, 0.8 + sin(time * 0.5 + idx) * 0.2);
    
    // Enhanced flicker - more variation
    const baseFlicker = 0.82 + lamp.crr.amplitude * 0.18;
    const microFlicker = 1 + sin(time * 15 + idx * 7) * 0.03 + sin(time * 23 + idx * 13) * 0.02;
    const flicker = baseFlicker * microFlicker;
    const intensity = lamp.brightness * flicker * lampIntensity;
    
    const x = lamp.x;
    const baseY = lamp.y;
    const s = lamp.scale;
    const postHeight = 90 * s;
    const topY = baseY - postHeight;
    
    const ironColor = `rgba(25, 22, 18, ${0.85 + ambient * 0.1})`;
    const ironLight = `rgba(45, 40, 35, ${0.5 + ambient * 0.3})`;
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // === SCENE ILLUMINATION (drawn first, behind lamp) ===
    if (intensity > 0.1) {
      const lanternY = topY + 4 * s;
      
      // Large scene illumination - affects ground and nearby area
      const sceneGlow = ctx.createRadialGradient(x, lanternY, 0, x, lanternY, 120 * s);
      sceneGlow.addColorStop(0, `rgba(255, 220, 160, ${intensity * 0.08})`);
      sceneGlow.addColorStop(0.3, `rgba(255, 200, 130, ${intensity * 0.05})`);
      sceneGlow.addColorStop(0.6, `rgba(255, 180, 100, ${intensity * 0.025})`);
      sceneGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = sceneGlow;
      ctx.beginPath();
      ctx.arc(x, lanternY, 120 * s, 0, PI2);
      ctx.fill();
      
      // Ground illumination pool - wider and softer
      const groundGlow = ctx.createRadialGradient(x, baseY, 0, x, baseY, 60 * s);
      groundGlow.addColorStop(0, `rgba(255, 215, 150, ${intensity * 0.2})`);
      groundGlow.addColorStop(0.4, `rgba(255, 200, 130, ${intensity * 0.1})`);
      groundGlow.addColorStop(0.7, `rgba(255, 180, 100, ${intensity * 0.04})`);
      groundGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = groundGlow;
      ctx.beginPath();
      ctx.ellipse(x, baseY + 3, 60 * s, 20 * s, 0, 0, PI2);
      ctx.fill();
    }
    
    // === ORNATE BASE ===
    ctx.fillStyle = ironColor;
    // Base plinth
    ctx.beginPath();
    ctx.moveTo(x - 8 * s, baseY);
    ctx.lineTo(x - 6 * s, baseY - 4 * s);
    ctx.lineTo(x + 6 * s, baseY - 4 * s);
    ctx.lineTo(x + 8 * s, baseY);
    ctx.closePath();
    ctx.fill();
    
    // Decorative base collar
    ctx.beginPath();
    ctx.ellipse(x, baseY - 4 * s, 5 * s, 2 * s, 0, 0, PI2);
    ctx.fill();
    
    // === MAIN POST with decorative elements ===
    ctx.strokeStyle = ironColor;
    ctx.lineWidth = 3 * s;
    ctx.beginPath();
    ctx.moveTo(x, baseY - 4 * s);
    ctx.lineTo(x, topY + 20 * s);
    ctx.stroke();
    
    // Post highlight
    ctx.strokeStyle = ironLight;
    ctx.lineWidth = 1 * s;
    ctx.beginPath();
    ctx.moveTo(x + 1 * s, baseY - 4 * s);
    ctx.lineTo(x + 1 * s, topY + 20 * s);
    ctx.stroke();
    
    // Decorative rings on post
    ctx.fillStyle = ironColor;
    [0.25, 0.5, 0.75].forEach(t => {
      const ringY = baseY - 4 * s - (postHeight - 24 * s) * t;
      ctx.beginPath();
      ctx.ellipse(x, ringY, 3.5 * s, 1.2 * s, 0, 0, PI2);
      ctx.fill();
    });
    
    // === ORNATE BRACKET ===
    const bracketY = topY + 18 * s;
    ctx.strokeStyle = ironColor;
    ctx.lineWidth = 2 * s;
    
    // Main bracket curve
    ctx.beginPath();
    ctx.moveTo(x, bracketY);
    ctx.quadraticCurveTo(x + 4 * s, bracketY - 8 * s, x, bracketY - 12 * s);
    ctx.stroke();
    
    // Decorative scrollwork
    ctx.lineWidth = 1.5 * s;
    ctx.beginPath();
    ctx.moveTo(x - 2 * s, bracketY - 2 * s);
    ctx.quadraticCurveTo(x - 6 * s, bracketY - 6 * s, x - 3 * s, bracketY - 10 * s);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 2 * s, bracketY - 2 * s);
    ctx.quadraticCurveTo(x + 6 * s, bracketY - 6 * s, x + 3 * s, bracketY - 10 * s);
    ctx.stroke();
    
    // Small decorative curls
    ctx.lineWidth = 1 * s;
    ctx.beginPath();
    ctx.arc(x - 5 * s, bracketY - 5 * s, 2 * s, 0, PI, false);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x + 5 * s, bracketY - 5 * s, 2 * s, 0, PI, false);
    ctx.stroke();
    
    // === LANTERN HOUSING ===
    const lanternY = topY + 4 * s;
    const lanternW = 8 * s;
    const lanternH = 14 * s;
    
    // Lantern top (crown)
    ctx.fillStyle = ironColor;
    ctx.beginPath();
    ctx.moveTo(x - lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.lineTo(x - lanternW * 0.2, lanternY - lanternH * 0.6);
    ctx.lineTo(x, lanternY - lanternH * 0.7);
    ctx.lineTo(x + lanternW * 0.2, lanternY - lanternH * 0.6);
    ctx.lineTo(x + lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.closePath();
    ctx.fill();
    
    // Finial spike
    ctx.beginPath();
    ctx.moveTo(x - 1.5 * s, lanternY - lanternH * 0.7);
    ctx.lineTo(x, lanternY - lanternH * 0.7 - 6 * s);
    ctx.lineTo(x + 1.5 * s, lanternY - lanternH * 0.7);
    ctx.closePath();
    ctx.fill();
    
    // Lantern body frame
    ctx.strokeStyle = ironColor;
    ctx.lineWidth = 1.5 * s;
    ctx.beginPath();
    ctx.moveTo(x - lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.lineTo(x - lanternW * 0.4, lanternY + lanternH * 0.3);
    ctx.lineTo(x - lanternW * 0.2, lanternY + lanternH * 0.45);
    ctx.lineTo(x + lanternW * 0.2, lanternY + lanternH * 0.45);
    ctx.lineTo(x + lanternW * 0.4, lanternY + lanternH * 0.3);
    ctx.lineTo(x + lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.stroke();
    
    // Vertical bars
    ctx.lineWidth = 1 * s;
    [-0.2, 0, 0.2].forEach(off => {
      ctx.beginPath();
      ctx.moveTo(x + lanternW * off, lanternY - lanternH * 0.5);
      ctx.lineTo(x + lanternW * off * 0.6, lanternY + lanternH * 0.45);
      ctx.stroke();
    });
    
    // === LIGHT GLOW EFFECTS (enhanced) ===
    if (intensity > 0.05) {
      // Glass panel glow - brighter
      ctx.fillStyle = `rgba(255, 245, 210, ${intensity * 0.65})`;
      ctx.beginPath();
      ctx.moveTo(x - lanternW * 0.35, lanternY - lanternH * 0.25);
      ctx.lineTo(x - lanternW * 0.35, lanternY + lanternH * 0.25);
      ctx.lineTo(x + lanternW * 0.35, lanternY + lanternH * 0.25);
      ctx.lineTo(x + lanternW * 0.35, lanternY - lanternH * 0.25);
      ctx.closePath();
      ctx.fill();
      
      // Inner flame core - bright flickering center
      const flameGrad = ctx.createRadialGradient(x, lanternY, 0, x, lanternY, lanternW * 0.6);
      flameGrad.addColorStop(0, `rgba(255, 255, 240, ${intensity * 0.95})`);
      flameGrad.addColorStop(0.3, `rgba(255, 240, 200, ${intensity * 0.8})`);
      flameGrad.addColorStop(0.6, `rgba(255, 210, 150, ${intensity * 0.5})`);
      flameGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.arc(x, lanternY, lanternW * 0.6, 0, PI2);
      ctx.fill();
      
      // Inner warm glow - enhanced
      const innerGlow = ctx.createRadialGradient(x, lanternY, 0, x, lanternY, 30 * s);
      innerGlow.addColorStop(0, `rgba(255, 240, 200, ${intensity * 0.55})`);
      innerGlow.addColorStop(0.4, `rgba(255, 220, 160, ${intensity * 0.3})`);
      innerGlow.addColorStop(0.7, `rgba(255, 200, 130, ${intensity * 0.15})`);
      innerGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = innerGlow;
      ctx.beginPath();
      ctx.arc(x, lanternY, 30 * s, 0, PI2);
      ctx.fill();
      
      // Mid-range glow
      const midGlow = ctx.createRadialGradient(x, lanternY, 15 * s, x, lanternY, 55 * s);
      midGlow.addColorStop(0, `rgba(255, 215, 150, ${intensity * 0.2})`);
      midGlow.addColorStop(0.5, `rgba(255, 200, 120, ${intensity * 0.1})`);
      midGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = midGlow;
      ctx.beginPath();
      ctx.arc(x, lanternY, 55 * s, 0, PI2);
      ctx.fill();
      
      // Outer atmospheric glow - larger
      const outerGlow = ctx.createRadialGradient(x, lanternY, 30 * s, x, lanternY, 85 * s);
      outerGlow.addColorStop(0, `rgba(255, 200, 130, ${intensity * 0.12})`);
      outerGlow.addColorStop(0.6, `rgba(255, 180, 100, ${intensity * 0.05})`);
      outerGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = outerGlow;
      ctx.beginPath();
      ctx.arc(x, lanternY, 85 * s, 0, PI2);
      ctx.fill();
    }
  });
}

// ============================================================================
// PATH & LOWRY FIGURES
// ============================================================================

function initPath() {
  // Create a winding path through the forest
  pathPoints = [];
  const pathY = H * 0.79; // Base Y for path
  
  // Generate path control points
  for (let i = 0; i <= 10; i++) {
    pathPoints.push({
      x: (i / 10) * W,
      y: pathY + sin(i * 0.8) * H * 0.015 + sin(i * 1.7) * H * 0.008
    });
  }
}

function initLowryFigures() {
  lowryFigures = [];
  const numFigures = 12 + floor(random() * 6);
  
  for (let i = 0; i < numFigures; i++) {
    const t = random(); // Position along path (0-1)
    lowryFigures.push({
      t: t,
      speed: (0.003 + random() * 0.006) * (random() > 0.5 ? 1 : -1), // Direction
      height: 12 + random() * 8, // Varying heights
      phase: random() * PI2,
      type: floor(random() * 6), // Different figure types
      color: random() > 0.7 ? 'dark' : (random() > 0.5 ? 'grey' : 'muted'),
      hasHat: random() > 0.6,
      hasUmbrella: random() > 0.85,
      isChild: random() > 0.88,
      lean: (random() - 0.5) * 0.15, // Slight lean
      armSwing: random() * 0.5 + 0.3
    });
  }
  
  // Sort by position for proper depth
  lowryFigures.sort((a, b) => getPathY(a.t) - getPathY(b.t));
}

function getPathY(t) {
  // Interpolate Y position along path
  if (!pathPoints || pathPoints.length === 0) return H * 0.79;
  if (pathPoints.length === 1) return pathPoints[0].y;
  const idx = t * (pathPoints.length - 1);
  const i = max(0, min(floor(idx), pathPoints.length - 2));
  const frac = idx - floor(idx);
  return lerp(pathPoints[i].y, pathPoints[i + 1].y, frac);
}

function getPathX(t) {
  return t * W;
}

function updateLowryFigures(dt) {
  if (!lowryFigures || lowryFigures.length === 0) return;
  
  lowryFigures.forEach(fig => {
    fig.t += fig.speed * dt;
    fig.phase += dt * 4;
    
    // Wrap around
    if (fig.t > 1.1) fig.t = -0.1;
    if (fig.t < -0.1) fig.t = 1.1;
  });
  
  // Re-sort occasionally for depth
  if (random() < 0.01) {
    lowryFigures.sort((a, b) => getPathY(a.t) - getPathY(b.t));
  }
}

function drawPath(colors) {
  if (!colors || !colors.ground) return;
  
  const pathY = H * 0.79;
  
  // Path surface (subtle, worn)
  ctx.fillStyle = `rgba(${colors.ground.r - 15 | 0}, ${colors.ground.g - 12 | 0}, ${colors.ground.b - 10 | 0}, 0.35)`;
  ctx.beginPath();
  ctx.moveTo(-10, pathY + H * 0.025);
  
  // Top edge of path
  for (let i = 0; i <= W; i += 20) {
    const wave = sin(i * 0.008) * 3 + sin(i * 0.02 + 1) * 2;
    ctx.lineTo(i, pathY - H * 0.008 + wave);
  }
  
  // Bottom edge
  for (let i = W; i >= 0; i -= 20) {
    const wave = sin(i * 0.008 + 2) * 3 + sin(i * 0.02) * 2;
    ctx.lineTo(i, pathY + H * 0.025 + wave);
  }
  ctx.closePath();
  ctx.fill();
  
  // Path edges (subtle darker lines)
  ctx.strokeStyle = `rgba(${colors.ground.r - 30 | 0}, ${colors.ground.g - 25 | 0}, ${colors.ground.b - 20 | 0}, 0.2)`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, pathY - H * 0.006);
  for (let i = 0; i <= W; i += 30) {
    ctx.lineTo(i, pathY - H * 0.006 + sin(i * 0.01) * 2);
  }
  ctx.stroke();
}

function drawLowryFigures(ambient) {
  if (!lowryFigures || lowryFigures.length === 0) return;
  
  const visibility = min(1, max(0.3, ambient + 0.2));
  
  lowryFigures.forEach(fig => {
    if (fig.t < -0.05 || fig.t > 1.05) return;
    
    const x = getPathX(fig.t);
    const baseY = getPathY(fig.t);
    const h = fig.isChild ? fig.height * 0.6 : fig.height;
    const walkCycle = sin(fig.phase) * fig.armSwing;
    const direction = fig.speed > 0 ? 1 : -1;
    
    // Figure colors (muted, Lowry-esque)
    let bodyColor, legColor;
    if (fig.color === 'dark') {
      bodyColor = `rgba(25, 25, 30, ${visibility * 0.85})`;
      legColor = `rgba(20, 20, 25, ${visibility * 0.85})`;
    } else if (fig.color === 'grey') {
      bodyColor = `rgba(60, 58, 55, ${visibility * 0.8})`;
      legColor = `rgba(40, 38, 35, ${visibility * 0.8})`;
    } else {
      bodyColor = `rgba(75, 65, 60, ${visibility * 0.75})`;
      legColor = `rgba(50, 45, 42, ${visibility * 0.75})`;
    }
    
    ctx.save();
    ctx.translate(x, baseY);
    ctx.scale(direction, 1);
    ctx.rotate(fig.lean);
    
    // === LOWRY MATCHSTICK FIGURE ===
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Legs (thin, walking motion)
    ctx.strokeStyle = legColor;
    ctx.lineWidth = h * 0.08;
    
    // Back leg
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.4);
    ctx.lineTo(-h * 0.08 - walkCycle * h * 0.12, 0);
    ctx.stroke();
    
    // Front leg
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.4);
    ctx.lineTo(h * 0.08 + walkCycle * h * 0.12, 0);
    ctx.stroke();
    
    // Body (slightly hunched, Lowry style)
    ctx.strokeStyle = bodyColor;
    ctx.lineWidth = h * 0.12;
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.4);
    ctx.quadraticCurveTo(h * 0.03, -h * 0.6, h * 0.02, -h * 0.8);
    ctx.stroke();
    
    // Arms (swinging)
    ctx.lineWidth = h * 0.06;
    
    // Back arm
    ctx.beginPath();
    ctx.moveTo(h * 0.02, -h * 0.7);
    ctx.lineTo(-h * 0.1 - walkCycle * h * 0.15, -h * 0.45);
    ctx.stroke();
    
    // Front arm
    ctx.beginPath();
    ctx.moveTo(h * 0.02, -h * 0.7);
    ctx.lineTo(h * 0.12 + walkCycle * h * 0.15, -h * 0.5);
    ctx.stroke();
    
    // Head (small, round)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(h * 0.02, -h * 0.88, h * 0.1, 0, PI2);
    ctx.fill();
    
    // Hat (if applicable)
    if (fig.hasHat && !fig.isChild) {
      ctx.fillStyle = legColor;
      // Flat cap or bowler
      if (fig.type % 2 === 0) {
        // Flat cap
        ctx.beginPath();
        ctx.ellipse(h * 0.02, -h * 0.95, h * 0.12, h * 0.04, 0.1, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-h * 0.08, -h * 0.95);
        ctx.quadraticCurveTo(h * 0.02, -h * 1.02, h * 0.12, -h * 0.95);
        ctx.fill();
      } else {
        // Bowler
        ctx.beginPath();
        ctx.ellipse(h * 0.02, -h * 0.96, h * 0.13, h * 0.03, 0, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(h * 0.02, -h * 1.02, h * 0.08, 0, PI2);
        ctx.fill();
      }
    }
    
    // Umbrella (if applicable)
    if (fig.hasUmbrella) {
      ctx.strokeStyle = legColor;
      ctx.lineWidth = h * 0.04;
      ctx.beginPath();
      ctx.moveTo(h * 0.15, -h * 0.55);
      ctx.lineTo(h * 0.25, -h * 0.9);
      ctx.stroke();
      // Umbrella handle
      ctx.beginPath();
      ctx.arc(h * 0.15, -h * 0.52, h * 0.03, 0, PI);
      ctx.stroke();
    }
    
    ctx.restore();
  });
}

function drawLowryFiguresShadows(ambient) {
  if (ambient > 0.7) return;
  if (!lowryFigures || lowryFigures.length === 0) return;
  
  const shadowAlpha = (1 - ambient) * 0.15;
  
  lowryFigures.forEach(fig => {
    if (fig.t < -0.05 || fig.t > 1.05) return;
    
    const x = getPathX(fig.t);
    const baseY = getPathY(fig.t);
    const h = fig.isChild ? fig.height * 0.6 : fig.height;
    
    // Simple shadow blob
    ctx.fillStyle = `rgba(20, 18, 15, ${shadowAlpha})`;
    ctx.beginPath();
    ctx.ellipse(x + h * 0.3, baseY + 2, h * 0.4, h * 0.1, 0.2, 0, PI2);
    ctx.fill();
  });
}

// ============================================================================
// LOADING SYSTEM
// ============================================================================
async function loadAllAssets() {
  // Split initialization into chunks to allow UI updates
  await new Promise(r => setTimeout(r, 10));
  
  // Generate trees in parallel-ish manner
  generateAllTrees();
  await new Promise(r => setTimeout(r, 5));
  
  // Lighter-weight texture
  createTexture();
  
  // Initialize other systems
  initStarlings();
  initMist();
  initSnow();
  initStars();
  initPath();
  initForestLamps();
  initLowryFigures();
  moonPhase = calculateMoonPhase();
}

function hideLoadingScreen() {
  const loadingScreen = document.getElementById('loadingScreen');
  const calendarOverlay = document.getElementById('calendarOverlay');
  
  loadingScreen.classList.add('fade-out');
  
  setTimeout(() => {
    loadingScreen.classList.add('hidden');
    calendarOverlay.classList.add('visible');
    isLoaded = true;
  }, 800);
}

// ============================================================================
// TREE GENERATION
// ============================================================================
function generateBranchesForLayer(layerName) {
  const cfg = TREE_CONFIG[layerName];
  const branches = [];
  
  function addBranch(x1, y1, x2, y2, depth, maxDepth) {
    if (depth > maxDepth) return;
    const midX = (x1 + x2) / 2 + (random() - 0.5) * H * 0.015;
    const midY = (y1 + y2) / 2 + (random() - 0.5) * H * 0.015;
    branches.push({ x1, y1, cx: midX, cy: midY, x2, y2, depth });
    
    if (cfg.perch && depth >= 2 && depth <= 5 && abs(Math.atan2(y2 - y1, x2 - x1) + PI/2) > 0.3) {
      for (let t = 0.3; t <= 0.7; t += 0.2) {
        const mt = 1 - t;
        perchSpots.push({ x: mt*mt*x1 + 2*mt*t*midX + t*t*x2, y: mt*mt*y1 + 2*mt*t*midY + t*t*y2, occupied: false });
      }
    }
    
    if (depth < maxDepth) {
      const num = CONFIG.branchCount[0] + floor(random() * (CONFIG.branchCount[1] - CONFIG.branchCount[0] + 1));
      const len = sqrt((x2-x1)**2 + (y2-y1)**2) * (0.5 + random() * 0.3);
      const base = Math.atan2(y2 - y1, x2 - x1);
      for (let i = 0; i < num; i++) {
        const a = base + (random() - 0.5) * 1.2;
        addBranch(x2, y2, x2 + cos(a) * len, y2 + sin(a) * len, depth + 1, maxDepth);
      }
    }
  }
  
  for (let t = 0; t < cfg.num; t++) {
    const baseX = (W / (cfg.num + 1)) * (t + 1) + (random() - 0.5) * W * 0.05 + cfg.xOff * W;
    const baseY = forestY + cfg.yOff * H + random() * H * 0.015;
    const height = H * cfg.height * (0.7 + random() * 0.35);
    const lean = (random() - 0.5) * height * 0.1;
    
    [[-0.1, 0.35], [0, 0.4], [0.1, 0.35]].forEach(([a, l]) => {
      addBranch(baseX, baseY, baseX + lean + cos(-PI/2 + a) * height * l, baseY + sin(-PI/2 + a) * height * l, 0, CONFIG.networkDepth + cfg.depth);
    });
    
    for (let i = 0; i < 4; i++) {
      const by = baseY - height * (0.15 + i * 0.18);
      const bx = baseX + lean * (i * 0.25);
      const side = (i % 2 === 0) ? -1 : 1;
      const bl = height * (0.1 + random() * 0.08);
      const ang = -PI/2 + side * (0.4 + random() * 0.5);
      addBranch(bx, by, bx + cos(ang) * bl, by + sin(ang) * bl, 1, CONFIG.networkDepth + cfg.depth - 1);
    }
  }
  return branches;
}

function renderBranchesToCanvas(branches, colors) {
  const layer = document.createElement('canvas');
  layer.width = W; layer.height = H;
  const lctx = layer.getContext('2d');
  lctx.lineCap = 'round';
  
  // Group branches by depth for batching
  const byDepth = {};
  branches.forEach(b => {
    if (!byDepth[b.depth]) byDepth[b.depth] = [];
    byDepth[b.depth].push(b);
  });
  
  // Render each depth level with batched paths
  Object.keys(byDepth).forEach(depth => {
    const depthBranches = byDepth[depth];
    const fade = Math.pow(0.75, depth);
    const width = max(0.5, 2.2 * fade);
    
    // Shadow pass
    lctx.strokeStyle = rgba(colors.base, 0.12 * fade);
    lctx.lineWidth = width * 4;
    lctx.beginPath();
    depthBranches.forEach(b => {
      lctx.moveTo(b.x1, b.y1);
      lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    });
    lctx.stroke();
    
    // Main pass
    lctx.strokeStyle = rgba(colors.base, 0.5 * fade);
    lctx.lineWidth = width;
    lctx.beginPath();
    depthBranches.forEach(b => {
      lctx.moveTo(b.x1, b.y1);
      lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    });
    lctx.stroke();
    
    // Highlight pass
    lctx.strokeStyle = rgba(colors.bright, 0.3 * fade);
    lctx.lineWidth = width * 0.4;
    lctx.beginPath();
    depthBranches.forEach(b => {
      lctx.moveTo(b.x1, b.y1);
      lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    });
    lctx.stroke();
  });
  
  return layer;
}

function generateAllTrees() {
  perchSpots = [];
  ['frost', 'gold', 'blue', 'silver'].forEach(name => {
    const branches = generateBranchesForLayer(name);
    treeLayers[name] = renderBranchesToCanvas(branches, TREE_COLORS[name]);
  });
}

function createTexture() {
  textureLayer = document.createElement('canvas');
  textureLayer.width = W; textureLayer.height = H;
  const lctx = textureLayer.getContext('2d');
  lctx.globalAlpha = 0.035;
  // Reduced from 5000 to 2000, slightly larger particles
  for (let i = 0; i < 2000; i++) {
    const gray = 100 + random() * 80;
    lctx.fillStyle = `rgb(${gray|0},${gray * 0.96|0},${gray * 0.92|0})`;
    lctx.fillRect(random() * W, random() * H, 3 + random() * 5, 3 + random() * 5);
  }
}

// ============================================================================
// TIME & COLORS
// ============================================================================
function updateDayTime() {
  const now = new Date();
  dayTime = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
  // Update moon phase once per day cycle
  moonPhase = calculateMoonPhase(now);
}

function getTimeColors() {
  if (time - lastColorUpdate < 0.1 && currentColors) return currentColors;
  lastColorUpdate = time;
  
  const sunrise = 7.5, sunset = 16.5;
  const night = { skyTop: { r: 15, g: 20, b: 35 }, skyMid: { r: 25, g: 30, b: 50 }, skyHorizon: { r: 35, g: 40, b: 60 }, ground: { r: 45, g: 50, b: 60 }, ambient: 0.15 };
  const dawn = { skyTop: { r: 70, g: 80, b: 110 }, skyMid: { r: 180, g: 140, b: 120 }, skyHorizon: { r: 240, g: 180, b: 140 }, ground: { r: 160, g: 155, b: 150 }, ambient: 0.5 };
  const day = { skyTop: { r: 168, g: 181, b: 196 }, skyMid: { r: 196, g: 197, b: 190 }, skyHorizon: { r: 240, g: 228, b: 208 }, ground: { r: 215, g: 212, b: 208 }, ambient: 1.0 };
  const dusk = { skyTop: { r: 60, g: 70, b: 100 }, skyMid: { r: 160, g: 100, b: 90 }, skyHorizon: { r: 220, g: 140, b: 100 }, ground: { r: 140, g: 130, b: 125 }, ambient: 0.4 };
  
  let result;
  if (dayTime < sunrise - 1) result = night;
  else if (dayTime < sunrise + 0.5) result = blendPalettes(night, dawn, (dayTime - (sunrise - 1)) / 1.5);
  else if (dayTime < sunrise + 2) result = blendPalettes(dawn, day, (dayTime - (sunrise + 0.5)) / 1.5);
  else if (dayTime < sunset - 2) result = day;
  else if (dayTime < sunset - 0.5) result = blendPalettes(day, dusk, (dayTime - (sunset - 2)) / 1.5);
  else if (dayTime < sunset + 1) result = blendPalettes(dusk, night, (dayTime - (sunset - 0.5)) / 1.5);
  else result = night;
  
  currentColors = result;
  return result;
}

function blendPalettes(p1, p2, t) {
  return { skyTop: lerpColor(p1.skyTop, p2.skyTop, t), skyMid: lerpColor(p1.skyMid, p2.skyMid, t),
    skyHorizon: lerpColor(p1.skyHorizon, p2.skyHorizon, t), ground: lerpColor(p1.ground, p2.ground, t),
    ambient: lerp(p1.ambient, p2.ambient, t) };
}

function getSunPosition() {
  const sunrise = 7.5, sunset = 16.5, noon = 12;
  if (dayTime < sunrise || dayTime > sunset) return { x: W * 0.5, y: horizonY + H * 0.3, intensity: 0 };
  if (dayTime < noon) { const p = (dayTime - sunrise) / (noon - sunrise); return { x: W * 0.5, y: horizonY - H * 0.08 - sin(p * PI / 2) * H * 0.15, intensity: p }; }
  const p = (dayTime - noon) / (sunset - noon);
  return { x: W * 0.5, y: horizonY - H * 0.08 - cos(p * PI / 2) * H * 0.15, intensity: 1 - p };
}

// ============================================================================
// CANVAS SETUP
// ============================================================================
function initCanvas() {
  const dpr = min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);
  horizonY = H * 0.55; forestY = H * 0.75;
}

// ============================================================================
// WEATHER SYSTEM
// ============================================================================
function getWeatherDescription(code) {
  const descriptions = {
    0: 'Clear sky',
    1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',
    45: 'Foggy', 48: 'Depositing rime fog',
    51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle',
    61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain',
    71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow',
    77: 'Snow grains',
    80: 'Slight rain showers', 81: 'Moderate showers', 82: 'Violent showers',
    85: 'Slight snow showers', 86: 'Heavy snow showers',
    95: 'Thunderstorm', 96: 'Thunderstorm with hail', 99: 'Thunderstorm with heavy hail'
  };
  return descriptions[code] || 'Variable conditions';
}

function updateWeatherIndicator(w) {
  const indicator = document.getElementById('weatherIndicator');
  const locationEl = document.getElementById('weatherLocation');
  const conditionsEl = document.getElementById('weatherConditions');
  const tempEl = document.getElementById('weatherTemp');
  const moonEl = document.getElementById('moonInfo');
  
  locationEl.textContent = weatherState.locationName || 'Your location';
  conditionsEl.textContent = getWeatherDescription(w.weatherCode);
  tempEl.textContent = `${w.temperature.toFixed(1)}Â°C Â· Wind ${w.windSpeed.toFixed(0)} km/h`;
  
  // Display moon phase info
  const illumination = getMoonIllumination(moonPhase);
  const phaseName = moonPhase < 0.03 ? 'New Moon' :
                    moonPhase < 0.22 ? 'Waxing Crescent' :
                    moonPhase < 0.28 ? 'First Quarter' :
                    moonPhase < 0.47 ? 'Waxing Gibbous' :
                    moonPhase < 0.53 ? 'Full Moon' :
                    moonPhase < 0.72 ? 'Waning Gibbous' :
                    moonPhase < 0.78 ? 'Last Quarter' :
                    moonPhase < 0.97 ? 'Waning Crescent' : 'New Moon';
  moonEl.textContent = `ðŸŒ™ ${phaseName} (${(illumination * 100).toFixed(0)}% illuminated)`;
  
  indicator.classList.add('visible');
}

async function fetchRealWeather() {
  try {
    const position = await new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported'));
        return;
      }
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        timeout: 10000,
        maximumAge: 300000
      });
    });
    
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    weatherState.latitude = lat;
    weatherState.longitude = lon;
    
    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,precipitation,rain,snowfall,cloud_cover,wind_speed_10m,visibility,weather_code&timezone=auto`;
    
    const response = await fetch(weatherUrl);
    if (!response.ok) throw new Error('Weather fetch failed');
    
    const data = await response.json();
    const current = data.current;
    
    let locationName = '';
    try {
      const geoUrl = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`;
      const geoResponse = await fetch(geoUrl, {
        headers: { 'User-Agent': 'CRR-Winter-Forest/1.0' }
      });
      if (geoResponse.ok) {
        const geoData = await geoResponse.json();
        locationName = geoData.address?.city || geoData.address?.town || geoData.address?.village || geoData.address?.county || '';
      }
    } catch (e) { /* ignore */ }
    
    weatherState.realWeatherData = {
      temperature: current.temperature_2m,
      humidity: current.relative_humidity_2m,
      precipitation: current.precipitation,
      rain: current.rain,
      snowfall: current.snowfall,
      cloudCover: current.cloud_cover,
      windSpeed: current.wind_speed_10m,
      visibility: current.visibility,
      weatherCode: current.weather_code
    };
    weatherState.locationName = locationName;
    weatherState.realWeatherEnabled = true;
    
    applyRealWeather();
    
    console.log('Real weather loaded:', weatherState.realWeatherData, 'Location:', locationName);
    
  } catch (error) {
    console.log('Could not fetch real weather, using simulated:', error.message);
    weatherState.realWeatherEnabled = false;
    
    // Still show moon phase info even without weather
    const indicator = document.getElementById('weatherIndicator');
    const locationEl = document.getElementById('weatherLocation');
    const moonEl = document.getElementById('moonInfo');
    
    locationEl.textContent = 'Weather unavailable';
    
    const illumination = getMoonIllumination(moonPhase);
    const phaseName = moonPhase < 0.03 ? 'New Moon' :
                      moonPhase < 0.22 ? 'Waxing Crescent' :
                      moonPhase < 0.28 ? 'First Quarter' :
                      moonPhase < 0.47 ? 'Waxing Gibbous' :
                      moonPhase < 0.53 ? 'Full Moon' :
                      moonPhase < 0.72 ? 'Waning Gibbous' :
                      moonPhase < 0.78 ? 'Last Quarter' :
                      moonPhase < 0.97 ? 'Waning Crescent' : 'New Moon';
    moonEl.textContent = `ðŸŒ™ ${phaseName} (${(illumination * 100).toFixed(0)}% illuminated)`;
    
    indicator.classList.add('visible');
  }
}

function applyRealWeather() {
  if (!weatherState.realWeatherData) return;
  
  const w = weatherState.realWeatherData;
  updateWeatherIndicator(w);
  
  // Map real weather to simulation
  let snowFactor = 0.6;
  if (w.snowfall > 0) {
    snowFactor = 0.8 + min(w.snowfall / 5, 0.8);
  } else if (w.precipitation > 0 && w.temperature < 2) {
    snowFactor = 0.7 + min(w.precipitation / 10, 0.5);
  } else if (w.temperature < 0) {
    snowFactor = 0.9;
  }
  weatherState.targetSnow = snowFactor;
  
  weatherState.targetWind = 0.3 + min(w.windSpeed / 30, 1.2);
  
  let mistFactor = 0.5;
  if (w.visibility < 10000) {
    mistFactor = 0.6 + (1 - w.visibility / 10000) * 0.8;
  }
  if (w.humidity > 80) {
    mistFactor += (w.humidity - 80) / 100;
  }
  if (w.cloudCover > 70) {
    mistFactor += 0.1;
  }
  weatherState.targetMist = min(mistFactor, 1.4);
  
  if (w.weatherCode >= 71 && w.weatherCode <= 77) {
    weatherState.targetSnow = max(weatherState.targetSnow, 1.0 + (w.weatherCode - 71) * 0.1);
  }
  if (w.weatherCode >= 85 && w.weatherCode <= 86) {
    weatherState.targetSnow = max(weatherState.targetSnow, 1.2);
  }
  if (w.weatherCode >= 45 && w.weatherCode <= 48) {
    weatherState.targetMist = max(weatherState.targetMist, 1.3);
  }
}

function updateWeather(dt) {
  weatherCRR.update(dt, 0.5 + sin(time * 0.03) * 0.3);
  
  if (weatherState.realWeatherEnabled && floor(time / 600) !== floor((time - dt) / 600)) {
    fetchRealWeather();
  }
  
  const variationRate = weatherState.realWeatherEnabled ? 0.0002 : 0.001;
  if (random() < variationRate) {
    weatherState.targetSnow = max(0.4, weatherState.targetSnow + (random() - 0.5) * 0.3);
  }
  if (random() < variationRate * 0.8) {
    weatherState.targetMist = max(0.4, weatherState.targetMist + (random() - 0.5) * 0.3);
  }
  if (random() < variationRate * 1.2) {
    weatherState.targetWind = max(0.3, weatherState.targetWind + (random() - 0.5) * 0.3);
  }
  
  weatherState.snowIntensity = lerp(weatherState.snowIntensity, weatherState.targetSnow, 0.002);
  weatherState.mistIntensity = lerp(weatherState.mistIntensity, weatherState.targetMist, 0.001);
  weatherState.windStrength = lerp(weatherState.windStrength, weatherState.targetWind, 0.003);
  
  const weatherPulse = weatherCRR.amplitude;
  weatherState.snowIntensity += (weatherPulse - 0.5) * 0.02;
  weatherState.snowIntensity = max(0.4, min(1.5, weatherState.snowIntensity));
}

// ============================================================================
// PREDATOR
// ============================================================================
function spawnPredator() {
  const side = random() > 0.5;
  predator = { x: side ? -50 : W + 50, y: horizonY - H * 0.1 + random() * H * 0.15,
    vx: side ? 180 + random() * 60 : -180 - random() * 60, vy: (random() - 0.5) * 40,
    wingPhase: 0, size: 3 + random() * 1.5 };
}

function updatePredator(dt) {
  predatorCooldown -= dt;
  if (!predator && predatorCooldown <= 0 && random() < 0.002) {
    spawnPredator();
    predatorCooldown = 30 + random() * 60;
  }
  if (!predator) return;
  
  predator.wingPhase += dt * 8;
  let targetX = predator.x + predator.vx, targetY = predator.y, closestDist = Infinity;
  for (let i = 0; i < starlings.length; i += 10) {
    const b = starlings[i];
    if (b.state !== 'flying') continue;
    const d = sqrt((b.x - predator.x) ** 2 + (b.y - predator.y) ** 2);
    if (d < closestDist && d > 50) { closestDist = d; targetX = b.x; targetY = b.y; }
  }
  
  const dx = targetX - predator.x, dy = targetY - predator.y, dist = sqrt(dx * dx + dy * dy);
  if (dist > 0) { predator.vx += (dx / dist) * 50 * dt; predator.vy += (dy / dist) * 30 * dt; }
  
  const speed = sqrt(predator.vx ** 2 + predator.vy ** 2);
  if (speed > 250) { predator.vx = (predator.vx / speed) * 250; predator.vy = (predator.vy / speed) * 250; }
  
  predator.x += predator.vx * dt; predator.y += predator.vy * dt;
  if (predator.y < H * 0.05) predator.vy += 100 * dt;
  if (predator.y > horizonY) predator.vy -= 100 * dt;
  if (predator.x < -100 || predator.x > W + 100) predator = null;
}

function drawPredator(ambient) {
  if (!predator) return;
  const p = predator, angle = Math.atan2(p.vy, p.vx), wf = sin(p.wingPhase) * 0.6;
  
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(angle);
  ctx.fillStyle = `rgba(25, 20, 15, ${0.7 + ambient * 0.2})`;
  
  ctx.beginPath(); ctx.ellipse(0, 0, p.size * 2.5, p.size * 0.8, 0, 0, PI2); ctx.fill();
  
  const ws = p.size * 6;
  ctx.beginPath();
  ctx.moveTo(-p.size, 0);
  ctx.quadraticCurveTo(-p.size * 0.5, -ws * 0.4 * (1 + wf), p.size * 0.5, -ws * (0.7 + wf * 0.2));
  ctx.lineTo(p.size, -ws * 0.3 * (1 + wf));
  ctx.quadraticCurveTo(p.size * 0.3, -ws * 0.1, 0, 0);
  ctx.moveTo(-p.size, 0);
  ctx.quadraticCurveTo(-p.size * 0.5, ws * 0.4 * (1 + wf), p.size * 0.5, ws * (0.7 + wf * 0.2));
  ctx.lineTo(p.size, ws * 0.3 * (1 + wf));
  ctx.quadraticCurveTo(p.size * 0.3, ws * 0.1, 0, 0);
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(-p.size * 2.5, 0);
  ctx.lineTo(-p.size * 4, -p.size * 0.6);
  ctx.lineTo(-p.size * 4, p.size * 0.6);
  ctx.closePath(); ctx.fill();
  
  ctx.beginPath(); ctx.arc(p.size * 2, 0, p.size * 0.7, 0, PI2); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(p.size * 2.6, -p.size * 0.2);
  ctx.lineTo(p.size * 3.5, 0);
  ctx.lineTo(p.size * 3.2, p.size * 0.3);
  ctx.lineTo(p.size * 2.6, p.size * 0.2);
  ctx.fill();
  
  ctx.restore();
}

function getPredatorInfluence(bx, by) {
  if (!predator) return null;
  const dx = bx - predator.x, dy = by - predator.y, dist = sqrt(dx * dx + dy * dy);
  if (dist < 200) { const s = (200 - dist) / 200; return { dx: dx / dist * s * 80, dy: dy / dist * s * 80 }; }
  return null;
}

// ============================================================================
// STARLINGS
// ============================================================================
function initStarlings() {
  starlings = [];
  const cx = W * 0.5, cy = horizonY - H * 0.18;
  for (let i = 0; i < CONFIG.starlingCount; i++) {
    const a = random() * PI2, d = random() * W * 0.1;
    starlings.push({ x: cx + cos(a) * d, y: cy + sin(a) * d * 0.4, vx: (random() - 0.5) * 50, vy: (random() - 0.5) * 30,
      size: 1.2 + random() * 0.8, state: 'flying', perchSpot: null, perchTime: 0, stateTimer: 0,
      wingPhase: random() * PI2, wingSpeed: 15 + random() * 5 });
  }
}

function updateStarlings(dt) {
  flockCRR.update(dt, 1 + sin(time * 0.1) * 0.3);
  const fc = flockCRR.amplitude, isRup = flockCRR.state === 'rupture';
  
  const bf = 0.12 + fc * 0.08;
  const ax = W * 0.5 + sin(time * bf) * W * 0.22 + sin(time * bf * 1.6 + 1) * W * 0.1;
  const ay = horizonY - H * 0.16 + sin(time * bf * 0.7) * H * 0.07;
  const ss = isRup ? 1.5 : 0.8;
  const a2x = ax + sin(time * 0.35) * W * 0.12 * ss, a2y = ay + cos(time * 0.28) * H * 0.06 * ss;
  
  const scare = random() < (isRup ? 0.01 : 0.0003);
  const sx = scare ? random() * W : 0, sy = scare ? random() * horizonY * 0.5 : 0;
  const perched = starlings.filter(b => b.state === 'perched').length;
  const launch = (perched > CONFIG.starlingCount * 0.35 && random() < 0.003) || isRup;
  
  updateSpatialHash();
  
  for (let i = 0; i < starlings.length; i++) {
    const b = starlings[i];
    b.stateTimer += dt; b.wingPhase += b.wingSpeed * dt;
    
    if (b.state === 'perched') {
      b.perchTime += dt;
      if (random() < (b.perchTime > 4 ? 0.008 : 0.001) || launch || scare || predator) {
        b.state = 'takeoff'; b.stateTimer = 0; b.vy = -40 - random() * 25; b.vx = (random() - 0.5) * 50;
        if (b.perchSpot) b.perchSpot.occupied = false; b.perchSpot = null;
      }
      continue;
    }
    
    if (b.state === 'takeoff') {
      b.vy -= 60 * dt; b.x += b.vx * dt; b.y += b.vy * dt;
      if (b.stateTimer > 0.4) b.state = 'flying';
      continue;
    }
    
    if (b.state === 'landing') {
      const spot = b.perchSpot, dx = spot.x - b.x, dy = spot.y - b.y, dist = sqrt(dx * dx + dy * dy);
      if (dist < 2) { b.state = 'perched'; b.x = spot.x; b.y = spot.y; b.perchTime = 0; b.vx = 0; b.vy = 0; }
      else { b.vx = dx * 4; b.vy = dy * 4; b.x += b.vx * dt; b.y += b.vy * dt; }
      continue;
    }
    
    let sepX = 0, sepY = 0, alignX = 0, alignY = 0, cohX = 0, cohY = 0, nc = 0;
    const nearby = getNearbyBirds(b.x, b.y);
    
    for (let j = 0; j < nearby.length; j++) {
      const idx = nearby[j]; if (idx === i) continue;
      const o = starlings[idx]; if (o.state !== 'flying') continue;
      const dx = o.x - b.x, dy = o.y - b.y, distSq = dx * dx + dy * dy;
      if (distSq > 3600) continue;
      const dist = sqrt(distSq);
      if (dist < 20 && dist > 0) { const f = (20 - dist) / 20; sepX -= (dx / dist) * f; sepY -= (dy / dist) * f; }
      if (dist < 60) { alignX += o.vx; alignY += o.vy; cohX += o.x; cohY += o.y; nc++; }
    }
    
    if (nc > 0) {
      b.vx += sepX * 2.5; b.vy += sepY * 2.5;
      b.vx += (alignX / nc - b.vx) * (0.06 + fc * 0.04); b.vy += (alignY / nc - b.vy) * (0.06 + fc * 0.04);
      b.vx += (cohX / nc - b.x) * (0.008 + fc * 0.012); b.vy += (cohY / nc - b.y) * (0.008 + fc * 0.012);
    }
    
    const t1x = ax - b.x, t1y = ay - b.y, d1 = sqrt(t1x*t1x + t1y*t1y);
    const t2x = a2x - b.x, t2y = a2y - b.y, d2 = sqrt(t2x*t2x + t2y*t2y);
    if (d1 < d2 || random() > 0.3) { b.vx += (t1x / max(d1, 1)) * 0.5; b.vy += (t1y / max(d1, 1)) * 0.5; }
    else { b.vx += (t2x / max(d2, 1)) * 0.4; b.vy += (t2y / max(d2, 1)) * 0.4; }
    
    const pred = getPredatorInfluence(b.x, b.y);
    if (pred) { b.vx += pred.dx; b.vy += pred.dy; }
    
    if (scare) { const sdx = b.x - sx, sdy = b.y - sy, sd = sqrt(sdx*sdx + sdy*sdy);
      if (sd < W * 0.35 && sd > 0) { b.vx += (sdx / sd) * 40; b.vy += (sdy / sd) * 40; } }
    
    if (b.x < W * 0.03) b.vx += 4; if (b.x > W * 0.97) b.vx -= 4;
    if (b.y < H * 0.06) b.vy += 3; if (b.y > forestY - H * 0.03) b.vy -= 3;
    
    const spd = sqrt(b.vx * b.vx + b.vy * b.vy);
    if (spd > 100) { b.vx = (b.vx / spd) * 100; b.vy = (b.vy / spd) * 100; }
    else if (spd < 25 && spd > 0) { b.vx = (b.vx / spd) * 25; b.vy = (b.vy / spd) * 25; }
    
    b.x += b.vx * dt; b.y += b.vy * dt;
    
    if (!predator && b.y > forestY - H * 0.12 && spd < 55 && random() < 0.004 && perchSpots.length > 0) {
      let best = null, bestD = Infinity;
      for (let p = 0; p < perchSpots.length; p++) {
        const spot = perchSpots[p]; if (spot.occupied) continue;
        const d = sqrt((b.x - spot.x)**2 + (b.y - spot.y)**2);
        if (d < H * 0.12 && d < bestD) { bestD = d; best = spot; }
      }
      if (best) { b.state = 'landing'; b.perchSpot = best; best.occupied = true; b.stateTimer = 0; }
    }
  }
}

function drawStarling(b, ambient) {
  const flying = b.state === 'flying' || b.state === 'takeoff' || b.state === 'landing';
  let mist = 1;
  if (b.y > forestY - H * 0.08) mist = max(0.3, 1 - (b.y - (forestY - H * 0.08)) / (H * 0.1));
  
  ctx.fillStyle = `rgba(35, 40, 50, ${(0.6 + ambient * 0.25) * mist})`;
  ctx.save(); ctx.translate(b.x, b.y);
  
  if (flying) {
    ctx.rotate(Math.atan2(b.vy, b.vx));
    const spd = sqrt(b.vx * b.vx + b.vy * b.vy), stretch = min(spd / 50, 1.8);
    const flap = sin(b.wingPhase) * (0.4 + spd / 200), ws = b.size * 3;
    
    ctx.beginPath(); ctx.ellipse(0, 0, b.size * stretch, b.size * 0.45, 0, 0, PI2); ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(-b.size * 0.3, 0);
    ctx.quadraticCurveTo(-b.size * 0.5, -ws * 0.5 * (1 + flap), -b.size * 0.2, -ws * (0.8 + flap * 0.3));
    ctx.quadraticCurveTo(b.size * 0.2, -ws * 0.3 * (1 + flap), b.size * 0.3, 0);
    ctx.moveTo(-b.size * 0.3, 0);
    ctx.quadraticCurveTo(-b.size * 0.5, ws * 0.5 * (1 + flap), -b.size * 0.2, ws * (0.8 + flap * 0.3));
    ctx.quadraticCurveTo(b.size * 0.2, ws * 0.3 * (1 + flap), b.size * 0.3, 0);
    ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(-b.size * stretch, 0);
    ctx.lineTo(-b.size * stretch - b.size * 0.8, -b.size * 0.3);
    ctx.lineTo(-b.size * stretch - b.size * 0.8, b.size * 0.3);
    ctx.closePath(); ctx.fill();
  } else {
    ctx.beginPath(); ctx.ellipse(0, 0, b.size * 0.9, b.size * 1.1, 0, 0, PI2); ctx.fill();
    ctx.beginPath(); ctx.arc(0, -b.size * 0.9, b.size * 0.5, 0, PI2); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(b.size * 0.4, -b.size * 0.9);
    ctx.lineTo(b.size * 0.9, -b.size * 0.85);
    ctx.lineTo(b.size * 0.4, -b.size * 0.75);
    ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

// ============================================================================
// MIST & SNOW
// ============================================================================
function initMist() {
  mistPatches = [];
  for (let i = 0; i < 18; i++) {
    mistPatches.push({ x: random() * W * 1.4 - W * 0.2, y: forestY + random() * H * 0.1 - H * 0.03,
      width: W * (0.2 + random() * 0.3), height: H * (0.05 + random() * 0.06),
      speed: 2 + random() * 5, baseOpacity: 0.08 + random() * 0.1,
      phase: random() * PI2, vDrift: 0.3 + random() * 0.5 });
  }
}

function drawMist(dt, colors) {
  mistCRR.update(dt);
  const intensity = (0.7 + mistCRR.amplitude * 0.5) * weatherState.mistIntensity;
  if (intensity < 0.01) return; // Skip if invisible
  
  const mc = lerpColor({ r: 230, g: 228, b: 225 }, colors.ground, 0.25);
  const mcStr = `${mc.r|0},${mc.g|0},${mc.b|0}`;
  const windStr = weatherState.windStrength;
  const t = time * 0.2;
  
  for (let i = 0, len = mistPatches.length; i < len; i++) {
    const m = mistPatches[i];
    m.x += m.speed * dt * windStr;
    if (m.x > W + m.width * 0.5) m.x = -m.width;
    
    const cy = m.y + sin(t + m.phase) * H * 0.01 * m.vDrift;
    const op = m.baseOpacity * intensity;
    if (op < 0.01) continue; // Skip nearly invisible patches
    
    const cx = m.x + m.width * 0.5;
    const rad = m.width * 0.5;
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, rad);
    grad.addColorStop(0, `rgba(${mcStr},${op})`);
    grad.addColorStop(0.5, `rgba(${mcStr},${op * 0.5})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.ellipse(m.x + m.width * 0.5, cy, m.width * 0.5, m.height * 0.5, 0, 0, PI2); ctx.fill();
  }
}

function initSnow() {
  snowflakes = [];
  // Slightly fewer particles
  const count = floor((W * H) / 6500);
  for (let i = 0; i < count; i++) {
    snowflakes.push({ x: random() * W, y: random() * H, size: 0.5 + random() * 2.0,
      speed: 10 + random() * 20, drift: (random() - 0.5) * 0.4,
      opacity: 0.2 + random() * 0.4, phase: random() * PI2 });
  }
}

function drawSnow(dt, ambient) {
  const baseAlpha = (0.3 + ambient * 0.5) * weatherState.snowIntensity;
  const windDrift = weatherState.windStrength * 0.6;
  const snowIntensity = weatherState.snowIntensity;
  const t = time * 0.15;
  
  ctx.fillStyle = '#fff';
  
  // Update and draw in single pass
  for (let i = 0, len = snowflakes.length; i < len; i++) {
    const f = snowflakes[i];
    f.y += f.speed * dt * snowIntensity;
    f.x += (sin(t + f.phase) * f.drift + windDrift * 0.5) * dt * 35;
    
    if (f.y > H + 5) { f.y = -5; f.x = random() * W; }
    if (f.x < -5) f.x = W + 5;
    else if (f.x > W + 5) f.x = -5;
    
    const df = f.y < horizonY ? 0.35 : 1;
    const finalAlpha = f.opacity * df * baseAlpha;
    
    if (finalAlpha > 0.02) {
      ctx.globalAlpha = finalAlpha;
      const size = f.size * df;
      // Use fillRect for tiny particles (faster than arc)
      if (size < 1.2) {
        ctx.fillRect(f.x - size * 0.5, f.y - size * 0.5, size, size);
      } else {
        ctx.beginPath();
        ctx.arc(f.x, f.y, size, 0, PI2);
        ctx.fill();
      }
    }
  }
  ctx.globalAlpha = 1;
}

// ============================================================================
// SLEIGH
// ============================================================================
function initSleigh() {
  sleigh = { x: -W * 0.2, y: H * 0.15, speed: W * 0.06, bobPhase: 0, scale: H * 0.001, trail: [] };
  sleighActive = true; audio.init(); audio.playJingle();
  document.getElementById('christmasMessage').classList.add('visible');
  setTimeout(() => document.getElementById('christmasMessage').classList.remove('visible'), 8000);
}

function updateSleigh(dt) {
  if (!sleighActive || !sleigh) return;
  sleigh.x += sleigh.speed * dt; sleigh.bobPhase += dt * 2;
  sleigh.y = H * 0.15 + sin(sleigh.bobPhase) * H * 0.02 + sin(sleigh.bobPhase * 0.7) * H * 0.01;
  if (random() < 0.4) sleigh.trail.push({ x: sleigh.x - 20 + random() * 40, y: sleigh.y + random() * 20, life: 1, size: 1 + random() * 2, vx: -20 - random() * 30, vy: (random() - 0.5) * 20 });
  for (let i = sleigh.trail.length - 1; i >= 0; i--) { const p = sleigh.trail[i]; p.life -= dt * 0.8; p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 15 * dt; if (p.life <= 0) sleigh.trail.splice(i, 1); }
  if (sleigh.x > W * 1.3) { sleighActive = false; sleigh = null; }
}

function drawSleigh() {
  if (!sleighActive || !sleigh) return;
  const s = sleigh.scale, x = sleigh.x, y = sleigh.y;
  ctx.save();
  sleigh.trail.forEach(p => { const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
    grad.addColorStop(0, `rgba(255, 223, 100, ${p.life * 0.8})`); grad.addColorStop(0.5, `rgba(255, 200, 50, ${p.life * 0.4})`); grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 3, 0, PI2); ctx.fill(); });
  
  ctx.fillStyle = 'rgba(20, 25, 35, 0.9)'; ctx.strokeStyle = 'rgba(20, 25, 35, 0.9)';
  const rs = s * 35;
  for (let i = 0; i < 8; i++) { const row = floor(i / 2), col = i % 2;
    const rx = x - 80 - row * rs, ry = y + (col === 0 ? -12 : 12) * s + sin(sleigh.bobPhase * 3 + i) * 3;
    ctx.save(); ctx.translate(rx, ry); const leg = sin((sleigh.bobPhase + i * 0.3) * 4);
    ctx.beginPath(); ctx.ellipse(0, 0, 18 * s, 10 * s, 0, 0, PI2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(15 * s, -5 * s); ctx.quadraticCurveTo(22 * s, -12 * s, 28 * s, -10 * s); ctx.quadraticCurveTo(35 * s, -8 * s, 32 * s, -5 * s); ctx.quadraticCurveTo(28 * s, -2 * s, 20 * s, 0); ctx.fill();
    ctx.lineWidth = 2 * s; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(26 * s, -12 * s); ctx.lineTo(22 * s, -22 * s); ctx.moveTo(24 * s, -17 * s); ctx.lineTo(20 * s, -20 * s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(30 * s, -12 * s); ctx.lineTo(34 * s, -22 * s); ctx.moveTo(32 * s, -17 * s); ctx.lineTo(36 * s, -20 * s); ctx.stroke();
    ctx.lineWidth = 3 * s;
    ctx.beginPath(); ctx.moveTo(10 * s, 8 * s); ctx.lineTo(12 * s + leg * 4 * s, 22 * s); ctx.moveTo(6 * s, 8 * s); ctx.lineTo(4 * s - leg * 4 * s, 22 * s); ctx.moveTo(-10 * s, 8 * s); ctx.lineTo(-8 * s - leg * 4 * s, 22 * s); ctx.moveTo(-14 * s, 8 * s); ctx.lineTo(-16 * s + leg * 4 * s, 22 * s); ctx.stroke();
    if (i === 0) { ctx.fillStyle = 'rgba(200, 50, 50, 0.9)'; ctx.beginPath(); ctx.arc(34 * s, -6 * s, 3 * s, 0, PI2); ctx.fill();
      const ng = ctx.createRadialGradient(34 * s, -6 * s, 0, 34 * s, -6 * s, 15 * s); ng.addColorStop(0, 'rgba(255, 100, 100, 0.4)'); ng.addColorStop(1, 'transparent'); ctx.fillStyle = ng; ctx.beginPath(); ctx.arc(34 * s, -6 * s, 15 * s, 0, PI2); ctx.fill(); ctx.fillStyle = 'rgba(20, 25, 35, 0.9)'; }
    ctx.restore(); }
  
  ctx.strokeStyle = 'rgba(40, 35, 30, 0.7)'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(x - 30, y);
  for (let i = 0; i < 8; i++) { const row = floor(i / 2), col = i % 2; ctx.lineTo(x - 80 - row * rs + 15 * s, y + (col === 0 ? -12 : 12) * s + sin(sleigh.bobPhase * 3 + i) * 3); } ctx.stroke();
  
  ctx.fillStyle = 'rgba(25, 20, 30, 0.95)';
  ctx.beginPath(); ctx.moveTo(x - 25, y + 15); ctx.quadraticCurveTo(x - 35, y + 25, x - 20, y + 30); ctx.lineTo(x + 50, y + 30); ctx.quadraticCurveTo(x + 65, y + 25, x + 60, y + 10); ctx.quadraticCurveTo(x + 55, y - 5, x + 40, y - 10); ctx.lineTo(x - 15, y - 10); ctx.quadraticCurveTo(x - 30, y - 5, x - 25, y + 15); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x - 30, y + 32); ctx.quadraticCurveTo(x - 40, y + 38, x - 35, y + 40); ctx.lineTo(x + 55, y + 40); ctx.quadraticCurveTo(x + 70, y + 38, x + 65, y + 32); ctx.lineWidth = 3; ctx.stroke();
  
  ctx.fillStyle = 'rgba(20, 15, 25, 0.95)';
  ctx.beginPath(); ctx.ellipse(x + 15, y + 5, 18, 15, 0, 0, PI2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + 15, y - 18, 12, 0, PI2); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x + 3, y - 22); ctx.lineTo(x + 10, y - 45); ctx.quadraticCurveTo(x + 25, y - 42, x + 28, y - 25); ctx.lineTo(x + 27, y - 22); ctx.fill();
  ctx.beginPath(); ctx.arc(x + 12, y - 46, 4, 0, PI2); ctx.fill();
  ctx.save(); ctx.translate(x + 25, y - 5); ctx.rotate(-0.5 + sin(sleigh.bobPhase * 2) * 0.3); ctx.fillRect(0, -3, 20, 6); ctx.beginPath(); ctx.arc(20, 0, 5, 0, PI2); ctx.fill(); ctx.restore();
  ctx.fillStyle = 'rgba(30, 20, 25, 0.9)'; ctx.beginPath(); ctx.ellipse(x + 42, y + 5, 12, 18, 0.2, 0, PI2); ctx.fill();
  const gi = 0.3 + sin(sleigh.bobPhase * 4) * 0.1; const glow = ctx.createRadialGradient(x + 15, y, 0, x + 15, y, 100);
  glow.addColorStop(0, `rgba(255, 230, 150, ${gi * 0.3})`); glow.addColorStop(0.5, `rgba(255, 210, 100, ${gi * 0.1})`); glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow; ctx.fillRect(x - 100, y - 80, 230, 160);
  ctx.restore();
}

function checkMidnight() {
  const now = new Date();
  const isMidnight = now.getMonth() === 11 && now.getDate() === 25 && now.getHours() === 0 && now.getMinutes() < 5;
  const test = new URLSearchParams(window.location.search).get('test') === 'sleigh';
  if ((isMidnight || test) && !sleighTriggered) { sleighTriggered = true; initSleigh(); }
}

// ============================================================================
// CALENDAR
// ============================================================================
const EVENTS = [
  { name: 'Christmas Day', date: new Date('2025-12-25T00:00:00') },
  { name: 'Boxing Day', date: new Date('2025-12-26T00:00:00') },
  { name: 'New Year\'s Eve', date: new Date('2025-12-31T23:59:59') },
  { name: 'New Year', date: new Date('2026-01-01T00:00:00') },
  { name: 'Epiphany', date: new Date('2026-01-06T00:00:00') }
];

function updateCalendar() {
  const now = new Date(), h = now.getHours(), m = now.getMinutes();
  document.getElementById('currentTime').textContent = `${h % 12 || 12}:${m.toString().padStart(2, '0')} ${h >= 12 ? 'pm' : 'am'}`;
  document.getElementById('currentDate').textContent = now.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
  
  const cont = document.getElementById('events'); cont.innerHTML = '';
  let shown = 0;
  for (const e of EVENTS) { if (shown >= 3) break;
    const diff = e.date - now, past = diff < 0;
    if (past && abs(diff) > 86400000) continue;
    const div = document.createElement('div');
    div.className = 'event' + (diff >= 0 && diff < 86400000 ? ' imminent' : '') + (past ? ' past' : '');
    let txt; if (past) txt = 'Now!';
    else if (diff < 86400000) txt = `${floor(diff / 3600000)}h ${floor((diff % 3600000) / 60000)}m`;
    else { const d = floor(diff / 86400000); txt = `${d}d ${floor((diff % 86400000) / 3600000)}h`; }
    div.innerHTML = `<div class="countdown">${txt}</div><div class="label">${e.name}</div>`;
    cont.appendChild(div); shown++;
  }
}

// ============================================================================
// LANDSCAPE
// ============================================================================
function drawSky(colors, sun) {
  const grad = ctx.createLinearGradient(0, 0, 0, horizonY);
  grad.addColorStop(0, rgba(colors.skyTop, 1)); grad.addColorStop(0.5, rgba(colors.skyMid, 1)); grad.addColorStop(1, rgba(colors.skyHorizon, 1));
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, horizonY + 20);
  
  if (sun.intensity > 0.1) {
    // Daytime sun
    const g1 = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, H * 0.45);
    g1.addColorStop(0, `rgba(255, 248, 230, ${0.35 * sun.intensity})`); g1.addColorStop(0.3, `rgba(255, 240, 210, ${0.15 * sun.intensity})`); g1.addColorStop(1, 'transparent');
    ctx.fillStyle = g1; ctx.fillRect(0, 0, W, H);
    const g2 = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, H * 0.12);
    g2.addColorStop(0, `rgba(255, 255, 248, ${0.85 * sun.intensity})`); g2.addColorStop(0.5, `rgba(255, 250, 235, ${0.4 * sun.intensity})`); g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2; ctx.fillRect(0, 0, W, H);
  } else {
    // Nighttime - draw stars and moon
    drawStars(colors.ambient);
    
    // === REALISTIC MOON (only illuminated portion visible) ===
    const mx = W * 0.75, my = H * 0.14;
    const moonRadius = H * 0.032;
    const illumination = getMoonIllumination(moonPhase);
    const isWaxing = moonPhase < 0.5;
    const phaseAngle = moonPhase < 0.5 ? moonPhase * 2 : (1 - moonPhase) * 2;
    
    // Outer atmospheric glow (scales with illumination)
    const outerGlowSize = moonRadius * (3 + illumination * 3);
    const outerGlow = ctx.createRadialGradient(mx, my, moonRadius * 0.5, mx, my, outerGlowSize);
    outerGlow.addColorStop(0, `rgba(210, 215, 235, ${0.06 + illumination * 0.14})`);
    outerGlow.addColorStop(0.4, `rgba(190, 200, 225, ${0.03 + illumination * 0.07})`);
    outerGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(mx, my, outerGlowSize, 0, PI2);
    ctx.fill();
    
    // Create clipping path for the illuminated portion only
    ctx.save();
    ctx.beginPath();
    
    if (illumination > 0.99) {
      // Full moon - show entire disc
      ctx.arc(mx, my, moonRadius, 0, PI2);
    } else if (illumination < 0.01) {
      // New moon - show nothing (or very faint earthshine)
      ctx.arc(mx, my, moonRadius * 0.1, 0, PI2); // Tiny clip for earthshine
    } else {
      // Partial phase - clip to illuminated crescent/gibbous
      if (isWaxing) {
        // Waxing: illuminated on right side
        ctx.arc(mx, my, moonRadius, -PI/2, PI/2, false);
        if (phaseAngle < 0.5) {
          // Waxing crescent - close path via LEFT side of ellipse (counterclockwise)
          ctx.ellipse(mx, my, moonRadius * (1 - phaseAngle * 2), moonRadius, 0, PI/2, -PI/2, true);
        } else {
          // Waxing gibbous - convex edge on left
          ctx.ellipse(mx, my, moonRadius * (phaseAngle * 2 - 1), moonRadius, 0, PI/2, -PI/2, true);
        }
      } else {
        // Waning: illuminated on left side
        ctx.arc(mx, my, moonRadius, PI/2, -PI/2, false);
        if (phaseAngle < 0.5) {
          // Waning gibbous - convex edge on right (counterclockwise = right side)
          ctx.ellipse(mx, my, moonRadius * (1 - phaseAngle * 2), moonRadius, 0, -PI/2, PI/2, true);
        } else {
          // Waning crescent - close path via RIGHT side of ellipse (clockwise)
          ctx.ellipse(mx, my, moonRadius * (phaseAngle * 2 - 1), moonRadius, 0, -PI/2, PI/2, false);
        }
      }
    }
    ctx.clip();
    
    // Moon surface gradient (only in illuminated area)
    const moonGrad = ctx.createRadialGradient(
      mx + (isWaxing ? -moonRadius * 0.2 : moonRadius * 0.2), my - moonRadius * 0.2, 0,
      mx, my, moonRadius * 1.1
    );
    moonGrad.addColorStop(0, 'rgba(252, 250, 248, 1)');
    moonGrad.addColorStop(0.4, 'rgba(242, 240, 235, 1)');
    moonGrad.addColorStop(0.7, 'rgba(228, 225, 220, 1)');
    moonGrad.addColorStop(1, 'rgba(210, 208, 205, 1)');
    ctx.fillStyle = moonGrad;
    ctx.beginPath();
    ctx.arc(mx, my, moonRadius, 0, PI2);
    ctx.fill();
    
    // Maria (dark patches)
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = 'rgba(130, 125, 120, 1)';
    
    // Mare Imbrium
    ctx.beginPath();
    ctx.ellipse(mx - moonRadius * 0.25, my - moonRadius * 0.2, moonRadius * 0.3, moonRadius * 0.25, -0.3, 0, PI2);
    ctx.fill();
    
    // Mare Serenitatis
    ctx.beginPath();
    ctx.ellipse(mx + moonRadius * 0.15, my - moonRadius * 0.25, moonRadius * 0.18, moonRadius * 0.15, 0.2, 0, PI2);
    ctx.fill();
    
    // Mare Tranquillitatis
    ctx.beginPath();
    ctx.ellipse(mx + moonRadius * 0.28, my + moonRadius * 0.05, moonRadius * 0.2, moonRadius * 0.22, 0.4, 0, PI2);
    ctx.fill();
    
    // Oceanus Procellarum
    ctx.beginPath();
    ctx.ellipse(mx - moonRadius * 0.38, my + moonRadius * 0.08, moonRadius * 0.22, moonRadius * 0.35, -0.2, 0, PI2);
    ctx.fill();
    
    // Mare Nubium
    ctx.beginPath();
    ctx.ellipse(mx - moonRadius * 0.12, my + moonRadius * 0.38, moonRadius * 0.18, moonRadius * 0.1, 0.1, 0, PI2);
    ctx.fill();
    
    ctx.globalAlpha = 1;
    
    // Subtle crater details
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = 'rgba(170, 165, 160, 1)';
    [[0.35, -0.35, 0.05], [-0.2, 0.45, 0.04], [0.45, 0.25, 0.035], [-0.5, -0.2, 0.04]].forEach(([ox, oy, r]) => {
      ctx.beginPath();
      ctx.arc(mx + ox * moonRadius, my + oy * moonRadius, r * moonRadius, 0, PI2);
      ctx.fill();
    });
    
    // Bright crater (Aristarchus)
    ctx.fillStyle = 'rgba(255, 253, 250, 1)';
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.arc(mx - moonRadius * 0.52, my - moonRadius * 0.12, moonRadius * 0.03, 0, PI2);
    ctx.fill();
    
    ctx.globalAlpha = 1;
    
    // Limb darkening
    const limbGrad = ctx.createRadialGradient(mx, my, moonRadius * 0.5, mx, my, moonRadius);
    limbGrad.addColorStop(0, 'transparent');
    limbGrad.addColorStop(0.75, 'transparent');
    limbGrad.addColorStop(1, 'rgba(100, 95, 90, 0.25)');
    ctx.fillStyle = limbGrad;
    ctx.beginPath();
    ctx.arc(mx, my, moonRadius, 0, PI2);
    ctx.fill();
    
    // Soft terminator edge (gradient at the shadow boundary)
    if (illumination > 0.02 && illumination < 0.98) {
      const termGrad = ctx.createLinearGradient(
        isWaxing ? mx - moonRadius * 0.3 : mx + moonRadius * 0.3, my,
        isWaxing ? mx + moonRadius * 0.1 : mx - moonRadius * 0.1, my
      );
      termGrad.addColorStop(0, 'rgba(180, 175, 170, 0.2)');
      termGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = termGrad;
      ctx.beginPath();
      ctx.arc(mx, my, moonRadius, 0, PI2);
      ctx.fill();
    }
    
    ctx.restore();
    
    // Faint earthshine on unilluminated portion (only visible during crescent phases)
    if (illumination > 0.05 && illumination < 0.4) {
      ctx.save();
      ctx.globalAlpha = (0.4 - illumination) * 0.12;
      
      // Clip to the dark side (opposite of lit side)
      ctx.beginPath();
      if (isWaxing) {
        // Waxing: dark side is on LEFT
        ctx.arc(mx, my, moonRadius * 0.98, PI/2, -PI/2, false);
        if (phaseAngle < 0.5) {
          // Close via RIGHT side of ellipse (clockwise)
          ctx.ellipse(mx, my, moonRadius * (1 - phaseAngle * 2) * 0.98, moonRadius * 0.98, 0, -PI/2, PI/2, false);
        }
      } else {
        // Waning: dark side is on RIGHT
        ctx.arc(mx, my, moonRadius * 0.98, -PI/2, PI/2, false);
        if (phaseAngle < 0.5) {
          // Close via LEFT side of ellipse (counterclockwise)
          ctx.ellipse(mx, my, moonRadius * (1 - phaseAngle * 2) * 0.98, moonRadius * 0.98, 0, PI/2, -PI/2, true);
        }
      }
      ctx.clip();
      
      // Very faint blue-grey earthshine
      ctx.fillStyle = 'rgba(140, 150, 170, 1)';
      ctx.beginPath();
      ctx.arc(mx, my, moonRadius, 0, PI2);
      ctx.fill();
      
      ctx.restore();
    }
  }
}

function drawLandscape(colors) {
  ctx.fillStyle = `rgba(${colors.ground.r * 0.65 | 0}, ${colors.ground.g * 0.65 | 0}, ${colors.ground.b * 0.7 | 0}, 0.4)`;
  ctx.beginPath(); ctx.moveTo(0, horizonY);
  for (let x = 0; x <= W; x += 25) ctx.lineTo(x, horizonY - H * 0.04 + sin(x * 0.0025) * H * 0.035 + sin(x * 0.006 + 2) * H * 0.02);
  ctx.lineTo(W, horizonY + 15); ctx.lineTo(0, horizonY + 15); ctx.fill();
  
  const sg = ctx.createLinearGradient(0, horizonY, 0, H);
  sg.addColorStop(0, rgba(colors.ground, 1)); sg.addColorStop(0.4, rgba(lerpColor(colors.ground, { r: 255, g: 255, b: 255 }, 0.08), 1));
  sg.addColorStop(1, rgba(lerpColor(colors.ground, { r: 170, g: 165, b: 160 }, 0.15), 1));
  ctx.fillStyle = sg; ctx.fillRect(0, horizonY - 5, W, H - horizonY + 5);
  
  ctx.beginPath(); ctx.moveTo(0, forestY + H * 0.07);
  for (let x = 0; x <= W; x += 35) ctx.lineTo(x, forestY + H * 0.07 + sin(x * 0.004) * 7 + sin(x * 0.01 + 1) * 4);
  ctx.lineTo(W, H); ctx.lineTo(0, H);
  ctx.fillStyle = `rgba(${colors.ground.r + 15 | 0}, ${colors.ground.g + 12 | 0}, ${colors.ground.b + 10 | 0}, 0.35)`; ctx.fill();
}

// Cache for vignette
let vignetteCache = null;
let vignetteCacheAmbient = -1;

function drawVignette(ambient) {
  // Round ambient to avoid recreating gradient too often
  const roundedAmbient = Math.round(ambient * 20) / 20;
  
  if (!vignetteCache || roundedAmbient !== vignetteCacheAmbient) {
    const str = 0.12 + (1 - roundedAmbient) * 0.18;
    vignetteCache = ctx.createRadialGradient(W * 0.5, H * 0.4, H * 0.35, W * 0.5, H * 0.5, H * 0.95);
    vignetteCache.addColorStop(0, 'transparent');
    vignetteCache.addColorStop(0.65, `rgba(25, 22, 18, ${str * 0.4})`);
    vignetteCache.addColorStop(1, `rgba(8, 6, 4, ${str})`);
    vignetteCacheAmbient = roundedAmbient;
  }
  
  ctx.fillStyle = vignetteCache;
  ctx.fillRect(0, 0, W, H);
}

// ============================================================================
// MAIN LOOP
// ============================================================================
let lastTime = performance.now(), calendarTime = 0;

function animate(now) {
  requestAnimationFrame(animate);
  
  if (!isLoaded) return;
  
  const dt = min((now - lastTime) / 1000, 0.05);
  lastTime = now; time += dt;
  
  if (floor(time) !== floor(time - dt)) updateDayTime();
  if (time - calendarTime > 1) { updateCalendar(); checkMidnight(); calendarTime = time; }
  
  updateWeather(dt);
  
  const colors = getTimeColors();
  const sun = getSunPosition();
  
  updateStarlings(dt);
  updatePredator(dt);
  updateSleigh(dt);
  updateLowryFigures(dt);
  
  // RENDER
  drawSky(colors, sun);
  if (sleighActive) drawSleigh();
  
  drawLandscape(colors);
  
  // Draw path through the forest
  drawPath(colors);
  
  for (let i = 0; i < starlings.length; i++) { const b = starlings[i]; if (b.state === 'flying' && b.y < forestY - H * 0.05) drawStarling(b, colors.ambient); }
  
  drawPredator(colors.ambient);
  
  const baseAlpha = 0.45 + colors.ambient * 0.35;
  ctx.globalAlpha = baseAlpha * 0.5; ctx.drawImage(treeLayers.frost, 0, 0);
  ctx.globalAlpha = baseAlpha * 0.6; ctx.drawImage(treeLayers.gold, 0, 0);
  ctx.globalAlpha = baseAlpha * 0.65; ctx.drawImage(treeLayers.blue, 0, 0);
  ctx.globalAlpha = baseAlpha * 0.85; ctx.drawImage(treeLayers.silver, 0, 0);
  ctx.globalAlpha = 1;
  
  // Draw Lowry figure shadows first
  drawLowryFiguresShadows(colors.ambient);
  
  // Draw forest lamps (after trees, before foreground birds)
  drawForestLamps(colors.ambient);
  
  // Draw Lowry figures on the path
  drawLowryFigures(colors.ambient);
  
  for (let i = 0; i < starlings.length; i++) { const b = starlings[i]; if (b.state !== 'flying' || b.y >= forestY - H * 0.05) drawStarling(b, colors.ambient); }
  
  drawMist(dt, colors);
  drawSnow(dt, colors.ambient);
  
  ctx.globalCompositeOperation = 'overlay';
  ctx.globalAlpha = 0.28;
  ctx.drawImage(textureLayer, 0, 0);
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
  
  drawVignette(colors.ambient);
}

// ============================================================================
// INIT
// ============================================================================
async function init() {
  initCanvas();
  updateDayTime();
  updateCalendar();
  
  requestAnimationFrame(animate);
  
  await loadAllAssets();
  
  fetchRealWeather();
  
  hideLoadingScreen();
}

document.addEventListener('click', () => audio.init(), { once: true });
document.addEventListener('keydown', () => audio.init(), { once: true });

window.addEventListener('resize', () => {
  initCanvas();
  vignetteCache = null; // Reset vignette cache
  vignetteCacheAmbient = -1;
  generateAllTrees();
  createTexture();
  initSnow();
  initStars();
  initPath();
  initForestLamps();
  initLowryFigures();
});

init();

</script>
</body>
</html>
