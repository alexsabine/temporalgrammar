<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Stellar Lifecycle</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #fff; font-family: Georgia, 'Times New Roman', serif; color: #1a1a1a; min-height: 100vh; }
    .container { display: flex; height: 100vh; }
    canvas { display: block; background: #000; }
    .panel { width: 340px; padding: 20px; background: #fff; border-left: 1px solid #ccc; overflow-y: auto; }
    .title { font-size: 18px; letter-spacing: 2px; text-align: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #1a1a1a; text-transform: uppercase; }
    .phase-display { text-align: center; padding: 15px; margin-bottom: 20px; background: #f5f5f5; border: 1px solid #ddd; }
    .phase-name { font-size: 20px; color: #8b4513; letter-spacing: 1px; }
    .phase-time { font-size: 12px; color: #666; margin-top: 5px; font-style: italic; }
    .timeline { height: 8px; background: #e0e0e0; margin: 15px 0; }
    .timeline-progress { height: 100%; background: linear-gradient(90deg, #4a6fa5, #6b8e6b, #c9a227, #b8860b, #8b0000, #4a0080); transition: width 0.1s; }
    .section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #e0e0e0; }
    .section-title { font-size: 11px; letter-spacing: 2px; color: #666; margin-bottom: 10px; text-transform: uppercase; }
    .metric { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; }
    .metric-label { color: #555; }
    .metric-value { color: #1a1a1a; }
    .metric-value.highlight { color: #8b4513; }
    .crr-state { background: #fafafa; border: 1px solid #ddd; padding: 12px; margin-bottom: 15px; }
    .crr-ratio { font-size: 24px; text-align: center; color: #1a1a1a; margin: 10px 0; }
    .crr-ratio.critical { color: #8b0000; }
    .crr-ratio.stable { color: #2e7d32; }
    .crr-bar { height: 12px; background: #e0e0e0; margin: 10px 0; position: relative; }
    .crr-bar-fill { height: 100%; background: linear-gradient(90deg, #2e7d32, #c9a227, #8b0000); transition: width 0.2s; }
    .crr-bar-threshold { position: absolute; top: -3px; bottom: -3px; width: 2px; background: #1a1a1a; }
    .fate-display { text-align: center; padding: 12px; background: #f0f0f5; border: 1px solid #ccc; margin: 15px 0; }
    .fate-name { font-size: 14px; color: #4a0080; letter-spacing: 1px; }
    .mass-select { display: flex; gap: 8px; margin: 15px 0; }
    .mass-select button { flex: 1; padding: 12px 6px; background: #fff; border: 1px solid #ccc; color: #333; cursor: pointer; font-family: Georgia, serif; font-size: 11px; transition: all 0.2s; }
    .mass-select button:hover { background: #f5f5f5; border-color: #999; }
    .mass-select button.selected { background: #1a1a1a; color: #fff; border-color: #1a1a1a; }
    .controls { display: flex; gap: 10px; margin-top: 15px; }
    .controls button { flex: 1; padding: 12px; background: #fff; border: 1px solid #1a1a1a; color: #1a1a1a; cursor: pointer; font-family: Georgia, serif; font-size: 12px; letter-spacing: 1px; transition: all 0.2s; }
    .controls button:hover { background: #1a1a1a; color: #fff; }
    .explainer { margin-top: 20px; border: 1px solid #ccc; }
    .explainer-header { padding: 12px 15px; background: #f5f5f5; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 12px; letter-spacing: 1px; text-transform: uppercase; user-select: none; }
    .explainer-header:hover { background: #eee; }
    .explainer-arrow { transition: transform 0.3s; }
    .explainer.open .explainer-arrow { transform: rotate(180deg); }
    .explainer-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
    .explainer.open .explainer-content { max-height: 1200px; }
    .explainer-inner { padding: 15px; font-size: 12px; line-height: 1.7; }
    .equation-box { background: #f9f9f9; border: 1px solid #e0e0e0; padding: 12px; margin: 12px 0; font-family: 'Times New Roman', serif; font-size: 14px; text-align: center; }
    .equation-box .main { font-size: 18px; margin-bottom: 5px; }
    .equation-box .desc { font-size: 11px; color: #666; font-family: Georgia, serif; }
    .physics-table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 11px; }
    .physics-table th, .physics-table td { padding: 6px 8px; border: 1px solid #ddd; text-align: left; }
    .physics-table th { background: #f5f5f5; font-weight: normal; text-transform: uppercase; font-size: 10px; letter-spacing: 1px; }
    .note-box { background: #fffff0; border-left: 3px solid #c9a227; padding: 10px 12px; margin: 12px 0; font-size: 11px; font-style: italic; }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="c"></canvas>
    <div class="panel">
      <div class="title">CRR Stellar Lifecycle</div>
      <div class="phase-display">
        <div class="phase-name" id="phaseName">Molecular Cloud</div>
        <div class="phase-time" id="phaseTime">Age: 0 years</div>
      </div>
      <div class="timeline"><div class="timeline-progress" id="progress" style="width: 0%"></div></div>
      <div class="crr-state">
        <div class="section-title">CRR Rupture Ratio</div>
        <div class="crr-ratio" id="crrRatio">0.00</div>
        <div style="text-align: center; font-size: 11px; color: #666;">C / (Ω · e<sup>π</sup>)</div>
        <div class="crr-bar">
          <div class="crr-bar-fill" id="crrBar" style="width: 0%"></div>
          <div class="crr-bar-threshold" style="left: 50%"></div>
        </div>
        <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888;">
          <span>Stable</span><span>Threshold (1.0)</span><span>Rupture</span>
        </div>
      </div>
      <div class="section">
        <div class="section-title">CRR Parameters</div>
        <div class="metric"><span class="metric-label">Coherence C</span><span class="metric-value" id="mC">0</span></div>
        <div class="metric"><span class="metric-label">Omega Ω</span><span class="metric-value" id="mO">0</span></div>
        <div class="metric"><span class="metric-label">Threshold Ω·e<sup>π</sup></span><span class="metric-value" id="mT">0</span></div>
      </div>
      <div class="section">
        <div class="section-title">Stellar Properties</div>
        <div class="metric"><span class="metric-label">Mass</span><span class="metric-value" id="sMass">—</span></div>
        <div class="metric"><span class="metric-label">Radius</span><span class="metric-value" id="sRadius">—</span></div>
        <div class="metric"><span class="metric-label">Temperature</span><span class="metric-value highlight" id="sTemp">—</span></div>
        <div class="metric"><span class="metric-label">Luminosity</span><span class="metric-value" id="sLum">—</span></div>
      </div>
      <div class="fate-display">
        <div class="section-title">Stellar Fate (from Ω)</div>
        <div class="fate-name" id="fateName">White Dwarf</div>
      </div>
      <div class="section">
        <div class="section-title">Initial Mass</div>
        <div class="mass-select">
          <button id="m1" class="selected">0.5 M☉<br><small>White Dwarf</small></button>
          <button id="m2">1.0 M☉<br><small>White Dwarf</small></button>
          <button id="m3">10 M☉<br><small>Neutron Star</small></button>
          <button id="m4">30 M☉<br><small>Black Hole</small></button>
        </div>
      </div>
      <div class="controls">
        <button id="btnPlay">❚❚ Pause</button>
        <button id="btnReset">↺ Restart</button>
      </div>
      <div class="explainer" id="explainer">
        <div class="explainer-header" onclick="toggleExplainer()">
          <span>Mathematical Framework</span>
          <span class="explainer-arrow">▼</span>
        </div>
        <div class="explainer-content">
          <div class="explainer-inner">
            <p><strong>Coherence-Rupture-Regeneration (CRR)</strong> provides a unified framework for stellar evolution.</p>
            <div class="equation-box">
              <div class="main">C(t) = ∫ L(x,τ) dτ</div>
              <div class="desc">Coherence accumulates from energy generation rate L</div>
            </div>
            <div class="equation-box">
              <div class="main">δ(now) when C > Ω · e<sup>π</sup></div>
              <div class="desc">Rupture occurs when coherence exceeds threshold (e<sup>π</sup> ≈ 23.14)</div>
            </div>
            <div class="equation-box">
              <div class="main">Ω(M) = (1/π) / √M</div>
              <div class="desc">Higher mass → lower Ω → lower threshold → more violent death</div>
            </div>
            <table class="physics-table">
              <tr><th>Mass</th><th>Ω</th><th>Threshold</th><th>Fate</th></tr>
              <tr><td>0.5 M☉</td><td>0.450</td><td>10.42</td><td>White Dwarf</td></tr>
              <tr><td>1.0 M☉</td><td>0.318</td><td>7.37</td><td>White Dwarf</td></tr>
              <tr><td>10 M☉</td><td>0.101</td><td>2.33</td><td>Neutron Star</td></tr>
              <tr><td>30 M☉</td><td>0.058</td><td>1.34</td><td>Black Hole</td></tr>
            </table>
            <div class="note-box"><strong>CRR-FEP Connection:</strong> Ω = σ² (precision parameter). Lower Ω = higher precision = more violent phase transitions.</div>
            <div class="note-box" style="border-left-color: #4a0080;"><strong>Hawking Evaporation:</strong> Black holes slowly evaporate over ~10⁶⁷ years — the ultimate slow CRR rupture.</div>
            <p style="margin-top: 15px;"><strong>Stellar Physics from CRR:</strong></p>
            <table class="physics-table">
              <tr><th>Property</th><th>Formula</th><th>CRR Interpretation</th></tr>
              <tr><td>Luminosity</td><td>L = M<sup>3.5</sup></td><td>dC/dt (coherence release rate)</td></tr>
              <tr><td>Radius</td><td>R = M<sup>0.8</sup></td><td>Coherence volume</td></tr>
              <tr><td>Temperature</td><td>T = 5778·M<sup>0.5</sup></td><td>C/Ω (local intensity)</td></tr>
              <tr><td>Lifetime</td><td>t = 10¹⁰·M<sup>−2.5</sup></td><td>Time to reach threshold</td></tr>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/**
 * ═══════════════════════════════════════════════════════════════════════════════════
 * CRR STELLAR LIFECYCLE - COMPLETE DOCUMENTED IMPLEMENTATION
 * ═══════════════════════════════════════════════════════════════════════════════════
 * 
 * This simulation demonstrates stellar evolution through the CRR framework.
 * Every calculation derives from three core equations:
 * 
 *   1. COHERENCE ACCUMULATION:  C(t) = ∫ L(x,τ) dτ
 *   2. RUPTURE CONDITION:       δ(now) when C > Ω · e^π  
 *   3. REGENERATION:            R = ∫ φ · exp(C/Ω) · Θ dτ
 * 
 * The key insight: Initial mass determines Ω, which determines fate.
 * ═══════════════════════════════════════════════════════════════════════════════════
 */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth - 340; canvas.height = window.innerHeight; }
resize();
window.onresize = resize;

/*******************************************************************************
 * SECTION 1: CRR FUNDAMENTAL CONSTANTS
 * 
 * These constants emerge from CRR theory and appear across multiple domains:
 * - Black hole physics (scrambling time)
 * - Neural dynamics (hierarchical gain ≈ 23x)
 * - Stellar transitions
 ******************************************************************************/

const CRR = {
  /**
   * e^π ≈ 23.14 - The Universal Rupture Threshold
   * 
   * When C/Ω exceeds this value, rupture (δ) is triggered.
   * This constant appears identically in:
   *   - Sekino-Susskind scrambling: t = β·ln(S) where exp term ≈ e^π
   *   - Cortical hierarchy: ~23x gain per level
   *   - CRR threshold: C_crit = Ω·e^π
   */
  E_PI: Math.exp(Math.PI),  // 23.1407...
  
  /**
   * Ω_base = 1/π ≈ 0.318 - Base Precision (Z₂ symmetry)
   * 
   * For binary/discrete phase transitions (Z₂ symmetry class).
   * Continuous rotational systems (SO(2)) use Ω = 1/(2π).
   * Stars use Z₂ because phase transitions are discrete events.
   */
  OMEGA_BASE: 1 / Math.PI   // 0.3183...
};

/*******************************************************************************
 * SECTION 2: CRR → STELLAR PHYSICS MAPPING
 * 
 * The fundamental CRR-stellar correspondence:
 * 
 *   Ω(M) = Ω_base / √M
 * 
 * This derives from:
 *   - Gravitational binding energy: E ∝ M²/R
 *   - Pressure support: P ∝ T⁴ (radiation) or P ∝ ρT (gas)
 *   - Net effect: stability (Ω) decreases with √M
 * 
 * Physical consequences:
 *   - Low mass → High Ω → High threshold → Gentle death (white dwarf)
 *   - High mass → Low Ω → Low threshold → Violent death (supernova)
 ******************************************************************************/

const StellarCRR = {
  
  /**
   * Ω(M) = (1/π) / √M
   * 
   * The precision parameter determines how "stable" the star is.
   * Lower Ω means the system reaches rupture threshold more easily.
   */
  omega: function(M) {
    return CRR.OMEGA_BASE / Math.sqrt(M);
  },
  
  /**
   * Rupture Threshold = Ω · e^π
   * 
   * When coherence C exceeds this value, phase transition (rupture) occurs.
   * 
   * Example thresholds:
   *   0.5 M☉: 0.450 × 23.14 = 10.42 (high - stable)
   *   30 M☉:  0.058 × 23.14 = 1.34  (low - unstable)
   */
  threshold: function(M) {
    return this.omega(M) * CRR.E_PI;
  },
  
  /**
   * Luminosity L = M^3.5 (mass-luminosity relation)
   * 
   * CRR Interpretation: L represents dC/dt - the rate of coherence release.
   * The 3.5 exponent comes from CNO cycle efficiency in massive stars.
   * 
   * This is why massive stars die young: they release C faster AND have
   * lower thresholds, so they reach rupture much sooner.
   */
  luminosity: function(M) {
    return Math.pow(M, 3.5);
  },
  
  /**
   * Radius R = M^0.8 (mass-radius relation)
   * 
   * CRR Interpretation: R represents the coherence volume - the spatial
   * extent over which the system maintains integrated structure.
   */
  radius: function(M) {
    return Math.pow(M, 0.8);
  },
  
  /**
   * Temperature T = 5778 × M^0.5 K (mass-temperature relation)
   * 
   * CRR Interpretation: T ∝ C/Ω (local coherence intensity).
   * Higher mass → lower Ω → higher T for same C.
   * 5778 K is the Sun's effective temperature (baseline).
   */
  temperature: function(M) {
    return 5778 * Math.pow(M, 0.5);
  },
  
  /**
   * Lifetime t = 10^10 × M^(-2.5) years
   * 
   * CRR Derivation:
   *   - Time to threshold = Threshold / (dC/dt) ∝ (Ω·e^π) / L
   *   - Ω ∝ 1/√M, L ∝ M^3.5
   *   - Therefore: t ∝ (1/√M) / M^3.5 = M^(-4) ... but actual is M^(-2.5)
   *   - The difference accounts for fuel mass scaling with M
   *   - Net effect: t ∝ M / L ∝ M / M^3.5 = M^(-2.5)
   * 
   * Result: Massive stars live fast and die young.
   *   0.5 M☉:  56.6 billion years
   *   1.0 M☉:  10 billion years (Sun)
   *   10 M☉:   31.6 million years
   *   30 M☉:   2 million years
   */
  lifetime: function(M) {
    return 1e10 * Math.pow(M, -2.5);
  },
  
  /**
   * Determine stellar fate from initial Ω
   * 
   * The threshold value directly determines death mechanism:
   *   Threshold > 4:   High Ω → Gentle ruptures → White Dwarf
   *   Threshold 1.5-4: Medium Ω → Violent rupture → Neutron Star
   *   Threshold < 1.5: Low Ω → Catastrophic rupture → Black Hole
   * 
   * These boundaries correspond to:
   *   M < 8 M☉:   White dwarf path
   *   8-25 M☉:    Neutron star path  
   *   M > 25 M☉:  Black hole path
   */
  fate: function(M) {
    const thresh = this.threshold(M);
    if (thresh > 4) return 'WHITE_DWF';
    if (thresh > 1.5) return 'NEUTRON';
    return 'BLACK_HOLE';
  }
};

/*******************************************************************************
 * SECTION 3: COHERENCE DYNAMICS BY PHASE
 * 
 * C(t) evolves differently in each stellar phase:
 * 
 *   dC/dt = L(t) - λC  where:
 *     L = energy generation rate (coherence source)
 *     λ = dissipation rate (radiation, mass loss)
 * 
 * Key states:
 *   - Accumulating: dC/dt > 0 (approaching rupture)
 *   - Equilibrium:  dC/dt ≈ 0 (main sequence balance)
 *   - Rupture:      C > Ω·e^π (phase transition triggered)
 *   - Frozen:       C constant (degenerate matter)
 ******************************************************************************/

function getCoherence(phase, progress, mass) {
  const omega = StellarCRR.omega(mass);
  const threshold = omega * CRR.E_PI;
  
  switch (phase) {
    
    // ═══════════════════════════════════════════════════════════════════════
    // PRE-STELLAR PHASES: C accumulating toward first rupture (fusion ignition)
    // ═══════════════════════════════════════════════════════════════════════
    
    case 'NEBULA':
      // L = gravitational contraction energy (slow)
      // C rises from 0 toward ~0.3 × threshold
      // Jeans instability triggered when C/threshold ≈ 0.3
      return progress * threshold * 0.3;
      
    case 'COLLAPSE':
      // L increases as collapse accelerates (runaway)
      // C rises from 0.3 → 0.8 × threshold
      // Core forming, heating rapidly
      return threshold * (0.3 + progress * 0.5);
      
    case 'PROTOSTAR':
      // L from Kelvin-Helmholtz contraction (gravitational heating)
      // C rises from 0.8 → 1.0 × threshold
      // Approaching hydrogen ignition rupture
      return threshold * (0.8 + progress * 0.2);
    
    // ═══════════════════════════════════════════════════════════════════════
    // MAIN SEQUENCE: Equilibrium state (C regulated at ~0.7 × threshold)
    // ═══════════════════════════════════════════════════════════════════════
    
    case 'MAIN_SEQ':
      // CRITICAL CRR INSIGHT: Stable burning = negative feedback on C
      // 
      // If C rises → fusion rate increases → more radiation pressure
      // → core expands → temperature drops → C decreases
      // 
      // If C drops → fusion rate decreases → less pressure support
      // → core contracts → temperature rises → C increases
      // 
      // Result: C oscillates around ~0.7 × threshold (stable equilibrium)
      // This is why main sequence is the longest phase!
      return threshold * 0.7;
    
    // ═══════════════════════════════════════════════════════════════════════
    // POST-MAIN-SEQUENCE: Equilibrium breaking, C rising toward rupture
    // ═══════════════════════════════════════════════════════════════════════
    
    case 'SUBGIANT':
      // Core hydrogen exhausted, shell burning begins
      // Equilibrium breaking: C starts rising above stable point
      // C: 0.7 → 1.2 × threshold
      return threshold * (0.7 + progress * 0.5);
      
    case 'RED_GIANT':
      // Shell burning intensifies, envelope expands
      // C continues rising: 1.2 → 2.0 × threshold
      // Approaching next rupture (helium flash or supernova)
      return threshold * (1.2 + progress * 0.8);
    
    // ═══════════════════════════════════════════════════════════════════════
    // RUPTURE EVENTS: C exceeds threshold → phase transition
    // ═══════════════════════════════════════════════════════════════════════
    
    case 'HE_FLASH':
      // RUPTURE! C peaks at ~2× threshold
      // For M < 2M☉: degenerate helium ignites explosively
      // C then drops as new equilibrium found
      return threshold * 2.0 * (1 - progress * 0.3);
      
    case 'AGB':
      // Thermal pulses: series of mini-ruptures
      // C oscillates with each pulse: 1.7 → 2.5 × threshold
      return threshold * (1.7 + progress * 0.8);
      
    case 'PN':
      // Envelope ejection rupture
      // C dropping as material expelled: 0.5 → 0.2 × threshold
      return threshold * 0.5 * (1 - progress * 0.6);
      
    case 'SUPERNOVA':
      // CATASTROPHIC RUPTURE!
      // C spikes to 3 → 100+ × threshold
      // Core collapse releases ~10^46 J in seconds
      // This is the "ultimate rupture" for massive stars
      return threshold * (3 + progress * 97);
    
    // ═══════════════════════════════════════════════════════════════════════
    // REMNANT STATES: C frozen in degenerate matter
    // ═══════════════════════════════════════════════════════════════════════
    
    case 'WHITE_DWF':
      // Electron degenerate matter
      // Effective Ω → very high (extreme stability)
      // C frozen at low value, only cooling remains
      // Cooling timescale: ~10^10 years
      return threshold * 0.3;
      
    case 'NEUTRON':
      // Neutron degenerate matter  
      // Effective Ω extremely high (hyper-stable)
      // C frozen, slow spindown over 10^15 years
      return threshold * 0.5;
      
    case 'BLACK_HOLE':
      // Singularity: Ω → 0 at center, C → ∞ (mathematical limit)
      // Only Hawking radiation leaks C, over 10^67 years
      // This is the slowest possible CRR rupture
      return threshold * 1000;  // Effectively infinite
      
    default:
      return threshold * 0.5;
  }
}

/*******************************************************************************
 * SECTION 4: PHASE DEFINITIONS
 * 
 * Each phase transition is a CRR rupture event (δ).
 * The star "dies" to its current state and "regenerates" at new structure.
 ******************************************************************************/

const PHASES = {
  NEBULA:     { name: 'Molecular Cloud', duration: 72 },
  COLLAPSE:   { name: 'Gravitational Collapse', duration: 45 },
  PROTOSTAR:  { name: 'Protostar', duration: 45 },
  MAIN_SEQ:   { name: 'Main Sequence', duration: 360 },
  SUBGIANT:   { name: 'Subgiant', duration: 45 },
  RED_GIANT:  { name: 'Red Giant', duration: 90 },
  HE_FLASH:   { name: 'Helium Flash', duration: 18 },
  AGB:        { name: 'Asymptotic Giant Branch', duration: 45 },
  PN:         { name: 'Planetary Nebula', duration: 45 },
  WHITE_DWF:  { name: 'White Dwarf', duration: 135 },
  SUPERNOVA:  { name: 'Core-Collapse Supernova', duration: 63 },
  NEUTRON:    { name: 'Neutron Star', duration: 180 },
  BLACK_HOLE: { name: 'Black Hole', duration: 180 }
};

/**
 * Phase sequence determined by initial Ω (via mass)
 * 
 * High Ω path (low mass): Many gentle ruptures
 *   Nebula → Collapse → Protostar → MS → Subgiant → RG → He Flash → AGB → PN → WD
 * 
 * Low Ω path (high mass): Fewer but violent ruptures
 *   Nebula → Collapse → Protostar → MS → Subgiant → RG → Supernova → NS/BH
 */
function getSequence(fate) {
  const common = ['NEBULA', 'COLLAPSE', 'PROTOSTAR', 'MAIN_SEQ', 'SUBGIANT', 'RED_GIANT'];
  if (fate === 'WHITE_DWF') return [...common, 'HE_FLASH', 'AGB', 'PN', 'WHITE_DWF'];
  if (fate === 'NEUTRON') return [...common, 'SUPERNOVA', 'NEUTRON'];
  return [...common, 'SUPERNOVA', 'BLACK_HOLE'];
}

/*******************************************************************************
 * SECTION 5: SIMULATION STATE
 ******************************************************************************/

let running = true, frame = 0, mass = 0.5;
let phaseIndex = 0, phaseFrame = 0, particles = [], sequence = [];

function init() {
  frame = phaseIndex = phaseFrame = 0;
  sequence = getSequence(StellarCRR.fate(mass));
  particles = [];
  for (let i = 0; i < 250; i++) {
    const a = Math.random() * Math.PI * 2, r = 0.2 + Math.random() * 1.8;
    particles.push({ x: Math.cos(a)*r, y: Math.sin(a)*r, vx: 0, vy: 0,
      size: 1 + Math.random()*3, brightness: 0.3 + Math.random()*0.7, hue: 200 + Math.random()*40 });
  }
}

/*******************************************************************************
 * SECTION 6: PHYSICS & RENDERING HELPERS
 ******************************************************************************/

function tempToRGB(T) {
  T = T / 100; let r, g, b;
  if (T <= 66) { r = 255; g = Math.max(0, Math.min(255, 99.4708*Math.log(T) - 161.1196));
    b = T <= 19 ? 0 : Math.max(0, Math.min(255, 138.5177*Math.log(T-10) - 305.0448)); }
  else { r = Math.max(0, Math.min(255, 329.698*Math.pow(T-60, -0.1332)));
    g = Math.max(0, Math.min(255, 288.122*Math.pow(T-60, -0.0755))); b = 255; }
  return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
}

function getStellarProps(phase, progress, mass) {
  const scale = Math.min(canvas.width, canvas.height) * 0.28;
  const baseR = StellarCRR.radius(mass), baseT = StellarCRR.temperature(mass), baseL = StellarCRR.luminosity(mass);
  
  const props = {
    'NEBULA':     { temp: 15+progress*35, radius: 10000*(1-progress*0.3), lum: 0, dR: scale*(1.4-progress*0.2) },
    'COLLAPSE':   { temp: 50+progress*9950, radius: 7000*(1-progress*0.95), lum: 0.001*progress, dR: scale*(1.2-progress*0.85) },
    'PROTOSTAR':  { temp: 10000+progress*baseT*0.5, radius: 5*baseR*(1-progress*0.8), lum: baseL*progress*0.5, dR: scale*(0.35-progress*0.15) },
    'MAIN_SEQ':   { temp: baseT, radius: baseR, lum: baseL, dR: scale*0.18*Math.pow(mass,0.25) },
    'SUBGIANT':   { temp: baseT*(1-progress*0.25), radius: baseR*(1+progress*3), lum: baseL*(1+progress*2), dR: scale*0.18*Math.pow(mass,0.25)*(1+progress*2) },
    'RED_GIANT':  { temp: 4000-progress*1000, radius: baseR*(4+progress*50), lum: baseL*(3+progress*100), dR: scale*(0.5+progress*0.6) },
    'HE_FLASH':   { temp: 3500+Math.sin(progress*Math.PI*6)*5000, radius: baseR*50, lum: baseL*100, dR: scale*1.1*(1+Math.sin(progress*Math.PI*4)*0.08) },
    'AGB':        { temp: 3000, radius: baseR*(50+progress*100), lum: baseL*(100+progress*500), dR: scale*(1.1+progress*0.3) },
    'PN':         { temp: 30000+progress*70000, radius: 0.02*(1-progress*0.5), lum: 100*(1-progress*0.9), dR: scale*0.04*(1-progress*0.3) },
    'WHITE_DWF':  { temp: 100000*(1-progress*0.6), radius: 0.01, lum: 0.001, dR: scale*0.03 },
    'SUPERNOVA':  { temp: 1e9*(1-progress*0.99), radius: 0.001, lum: 1e10*(1-progress), dR: scale*0.1*(1-progress*0.9) },
    'NEUTRON':    { temp: 1e6, radius: 0.00001, lum: 0.0001, dR: scale*0.025 },
    'BLACK_HOLE': { temp: 0, radius: 0.00001*mass, lum: 0, dR: scale*0.05 }
  };
  return props[phase] || { temp: 5778, radius: 1, lum: 1, dR: scale*0.2 };
}

/*******************************************************************************
 * SECTION 7: UPDATE LOOP
 ******************************************************************************/

function update() {
  frame++; phaseFrame++;
  const phase = PHASES[sequence[phaseIndex]];
  if (phaseFrame >= phase.duration) {
    phaseIndex++;
    if (phaseIndex < sequence.length) {
      phaseFrame = 0;
      const newP = sequence[phaseIndex];
      if (newP === 'SUPERNOVA') for (let i = 0; i < 350; i++) {
        const a = Math.random()*Math.PI*2, s = 0.015+Math.random()*0.04;
        particles.push({ x:0, y:0, vx:Math.cos(a)*s*(0.5+Math.random()), vy:Math.sin(a)*s*(0.5+Math.random()),
          size:1+Math.random()*3, brightness:1, hue:30+Math.random()*30 });
      }
      if (newP === 'PN') for (let i = 0; i < 150; i++) {
        const a = Math.random()*Math.PI*2, s = 0.003+Math.random()*0.008;
        particles.push({ x:Math.cos(a)*0.1, y:Math.sin(a)*0.1, vx:Math.cos(a)*s, vy:Math.sin(a)*s,
          size:1+Math.random()*2, brightness:0.5+Math.random()*0.5, hue:160+Math.random()*60 });
      }
    } else phaseIndex = sequence.length - 1;
  }
  
  const pName = sequence[phaseIndex];
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i], d = Math.sqrt(p.x*p.x + p.y*p.y);
    if (['NEBULA','COLLAPSE','PROTOSTAR'].includes(pName) && d > 0.01) {
      const str = pName === 'COLLAPSE' ? 0.0006 : 0.0002;
      p.vx -= (p.x/d)*str; p.vy -= (p.y/d)*str; p.vx *= 0.99; p.vy *= 0.99;
    } else if (['PN','SUPERNOVA'].includes(pName) && d > 0.01) {
      const str = pName === 'SUPERNOVA' ? 0.002 : 0.0008;
      p.vx += (p.x/d)*str; p.vy += (p.y/d)*str;
      p.brightness *= pName === 'SUPERNOVA' ? 0.995 : 0.998;
    }
    p.x += p.vx; p.y += p.vy;
    if (d > 3.5 || p.brightness < 0.02) particles.splice(i, 1);
  }
}

/*******************************************************************************
 * SECTION 8: RENDERING
 ******************************************************************************/

function render() {
  const W = canvas.width, H = canvas.height, cx = W/2, cy = H/2;
  const scale = Math.min(W,H)*0.28, t = frame*0.015;
  
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 120; i++) {
    ctx.globalAlpha = 0.15 + (i%4)*0.1;
    ctx.beginPath(); ctx.arc((i*7919)%W, (i*4973)%H, 0.4+(i%2)*0.3, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  const pName = sequence[phaseIndex], phase = PHASES[pName];
  const progress = Math.min(1, phaseFrame/phase.duration);
  const omega = StellarCRR.omega(mass), threshold = omega * CRR.E_PI;
  const C = getCoherence(pName, progress, mass), ratio = C / threshold;
  const props = getStellarProps(pName, progress, mass);
  const color = tempToRGB(Math.max(100, Math.min(50000, props.temp)));
  
  // Particles
  for (const p of particles) {
    ctx.beginPath(); ctx.arc(cx+p.x*scale, cy+p.y*scale, p.size, 0, Math.PI*2);
    ctx.fillStyle = `hsla(${p.hue},70%,60%,${p.brightness*0.6})`; ctx.fill();
  }
  
  // Glow
  if (pName !== 'BLACK_HOLE') {
    const glow = ctx.createRadialGradient(cx,cy,props.dR*0.3,cx,cy,props.dR*2.5);
    glow.addColorStop(0, `rgba(${color.r},${color.g},${color.b},0.25)`);
    glow.addColorStop(0.5, `rgba(${color.r},${color.g},${color.b},0.08)`);
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow; ctx.fillRect(0,0,W,H);
  }
  
  // Render by phase type
  if (pName === 'BLACK_HOLE') renderBlackHole(cx, cy, props.dR, scale);
  else if (pName === 'NEUTRON') renderNeutronStar(cx, cy, props.dR, scale, frame);
  else if (pName === 'NEBULA' || pName === 'COLLAPSE') renderNebula(cx, cy, props.dR, color, progress, pName==='COLLAPSE', t);
  else if (pName === 'SUPERNOVA') renderSupernova(cx, cy, props.dR, scale, progress);
  else renderStar(cx, cy, props.dR, color, pName, t);
  
  updateUI(pName, progress, C, omega, threshold, ratio, props);
}

function renderStar(cx, cy, r, col, pName, t) {
  const grad = ctx.createRadialGradient(cx-r*0.2, cy-r*0.2, 0, cx, cy, r);
  grad.addColorStop(0, `rgb(${Math.min(255,col.r+40)},${Math.min(255,col.g+40)},${Math.min(255,col.b+40)})`);
  grad.addColorStop(0.3, `rgb(${col.r},${col.g},${col.b})`);
  grad.addColorStop(0.75, `rgb(${col.r*0.7|0},${col.g*0.5|0},${col.b*0.4|0})`);
  grad.addColorStop(1, `rgb(${col.r*0.3|0},${col.g*0.15|0},${col.b*0.1|0})`);
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fillStyle = grad; ctx.fill();
  
  if (['MAIN_SEQ','SUBGIANT','RED_GIANT','AGB'].includes(pName)) {
    ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,r-1,0,Math.PI*2); ctx.clip();
    ctx.globalCompositeOperation = 'screen';
    for (let i = 0; i < 25; i++) {
      const a = (i/25)*Math.PI*2+t, n = Math.sin(i*12.9898+t*2)*0.5+0.5;
      const px = cx+Math.cos(a)*r*(0.2+n*0.7), py = cy+Math.sin(a)*r*(0.2+n*0.7);
      const sg = ctx.createRadialGradient(px,py,0,px,py,r*(0.08+n*0.12));
      sg.addColorStop(0, `rgba(${Math.min(255,col.r+30)},${Math.min(255,col.g+30)},${Math.min(255,col.b+20)},0.35)`);
      sg.addColorStop(1, 'transparent');
      ctx.fillStyle = sg; ctx.beginPath(); ctx.arc(px,py,r*(0.08+n*0.12),0,Math.PI*2); ctx.fill();
    }
    ctx.restore(); ctx.globalCompositeOperation = 'source-over';
  }
}

function renderNebula(cx, cy, r, col, progress, isCollapse, t) {
  for (let i = 0; i < 20; i++) {
    const a = (i/20)*Math.PI*2+t*0.08, n = Math.abs(Math.sin(i*5.7+t));
    const px = cx+Math.cos(a)*r*(0.3+n*0.7)*(0.9+n*0.2);
    const py = cy+Math.sin(a)*r*(0.3+n*0.7)*(0.9+n*0.2);
    const gr = ctx.createRadialGradient(px,py,0,px,py,r*(0.25+n*0.25));
    gr.addColorStop(0,'rgba(100,120,200,0.25)'); gr.addColorStop(0.5,'rgba(80,100,180,0.12)'); gr.addColorStop(1,'transparent');
    ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(px,py,r*(0.25+n*0.25),0,Math.PI*2); ctx.fill();
  }
  if (isCollapse) {
    const cg = ctx.createRadialGradient(cx,cy,0,cx,cy,r*0.35);
    cg.addColorStop(0,`rgba(255,200,150,${progress*0.85})`); cg.addColorStop(1,'transparent');
    ctx.fillStyle = cg; ctx.beginPath(); ctx.arc(cx,cy,r*0.35,0,Math.PI*2); ctx.fill();
  }
}

function renderBlackHole(cx, cy, r, scale) {
  ctx.save(); ctx.translate(cx,cy); ctx.rotate(0.35);
  for (let ring = 6; ring > 0; ring--) {
    const rR = r*(2+ring*0.9), gr = ctx.createRadialGradient(0,0,rR*0.6,0,0,rR*1.4);
    const b = 0.12+(6-ring)*0.06;
    gr.addColorStop(0,'transparent');
    gr.addColorStop(0.4,`rgba(255,${140+ring*15},${40+ring*8},${b})`);
    gr.addColorStop(0.6,`rgba(255,${120+ring*12},${30+ring*5},${b*0.8})`);
    gr.addColorStop(1,'transparent');
    ctx.beginPath(); ctx.ellipse(0,0,rR,rR*0.28,0,0,Math.PI*2); ctx.fillStyle = gr; ctx.fill();
  }
  ctx.restore();
  ctx.beginPath(); ctx.arc(cx,cy,r*1.6,0,Math.PI*2); ctx.strokeStyle='rgba(255,180,80,0.35)'; ctx.lineWidth=2; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,r*1.15,0,Math.PI*2); ctx.strokeStyle='rgba(255,140,50,0.6)'; ctx.lineWidth=3; ctx.stroke();
}

function renderNeutronStar(cx, cy, r, scale, frame) {
  const pulse = Math.sin(frame*0.3)*0.5+0.5;
  const gr = ctx.createRadialGradient(cx,cy,0,cx,cy,r*2);
  gr.addColorStop(0,`rgba(200,200,255,${0.9+pulse*0.1})`); gr.addColorStop(0.3,`rgba(150,150,255,${0.5+pulse*0.3})`); gr.addColorStop(1,'transparent');
  ctx.beginPath(); ctx.arc(cx,cy,r*2,0,Math.PI*2); ctx.fillStyle = gr; ctx.fill();
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle='#dde'; ctx.fill();
  ctx.save(); ctx.translate(cx,cy); ctx.rotate(frame*0.08);
  const bg = ctx.createLinearGradient(0,-scale,0,scale);
  bg.addColorStop(0,`rgba(180,180,255,${0.25+pulse*0.15})`); bg.addColorStop(0.4,'transparent');
  bg.addColorStop(0.6,'transparent'); bg.addColorStop(1,`rgba(180,180,255,${0.25+pulse*0.15})`);
  ctx.fillStyle = bg; ctx.fillRect(-r*0.4,-scale*1.2,r*0.8,scale*2.4); ctx.restore();
}

function renderSupernova(cx, cy, r, scale, progress) {
  const flash = Math.pow(1-progress,2), shockR = r+progress*scale*1.8;
  ctx.beginPath(); ctx.arc(cx,cy,shockR,0,Math.PI*2);
  ctx.strokeStyle=`rgba(255,200,100,${flash*0.6})`; ctx.lineWidth=8*flash+2; ctx.stroke();
  const fg = ctx.createRadialGradient(cx,cy,0,cx,cy,r*(4-progress*3));
  fg.addColorStop(0,`rgba(255,255,255,${flash})`); fg.addColorStop(0.25,`rgba(255,230,150,${flash*0.7})`); fg.addColorStop(1,'transparent');
  ctx.fillStyle = fg; ctx.fillRect(0,0,canvas.width,canvas.height);
  if (progress > 0.3) { ctx.beginPath(); ctx.arc(cx,cy,r*(1-progress*0.8),0,Math.PI*2);
    ctx.fillStyle=`rgba(200,200,255,${(progress-0.3)/0.7})`; ctx.fill(); }
}

/*******************************************************************************
 * SECTION 9: UI UPDATE
 ******************************************************************************/

function updateUI(pName, progress, C, omega, threshold, ratio, props) {
  document.getElementById('phaseName').textContent = PHASES[pName].name;
  
  const lifetime = StellarCRR.lifetime(mass);
  const times = { 'NEBULA':50000,'COLLAPSE':50000,'PROTOSTAR':1e6,'MAIN_SEQ':lifetime*0.9,'SUBGIANT':lifetime*0.05,
    'RED_GIANT':lifetime*0.04,'HE_FLASH':1000,'AGB':lifetime*0.01,'PN':50000,'WHITE_DWF':1e10,'SUPERNOVA':1,'NEUTRON':1e12,'BLACK_HOLE':1e15 };
  
  let age = 0;
  for (let i = 0; i < phaseIndex; i++) age += times[sequence[i]] || 0;
  age += (times[pName] || 1e6) * progress;
  
  let ageStr;
  if (age < 1e3) ageStr = Math.round(age).toLocaleString() + ' years';
  else if (age < 1e6) ageStr = (age/1e3).toFixed(1) + ' thousand years';
  else if (age < 1e9) ageStr = (age/1e6).toFixed(2) + ' million years';
  else if (age < 1e12) ageStr = (age/1e9).toFixed(2) + ' billion years';
  else if (age < 1e15) ageStr = (age/1e12).toFixed(1) + ' trillion years';
  else ageStr = (age/1e15).toFixed(1) + ' quadrillion years';
  
  if (pName === 'BLACK_HOLE') ageStr += ' (evaporates ~10⁶⁷ yr)';
  else if (pName === 'NEUTRON') ageStr += ' (pulsar)';
  else if (pName === 'WHITE_DWF') ageStr += ' (cooling)';
  document.getElementById('phaseTime').textContent = 'Age: ' + ageStr;
  
  document.getElementById('crrRatio').textContent = ratio > 10 ? ratio.toFixed(0) : ratio.toFixed(2);
  document.getElementById('crrRatio').className = 'crr-ratio ' + (ratio > 1 ? 'critical' : 'stable');
  document.getElementById('crrBar').style.width = Math.min(100, ratio*50) + '%';
  document.getElementById('mC').textContent = C > 100 ? C.toExponential(1) : C.toFixed(2);
  document.getElementById('mO').textContent = omega.toFixed(4);
  document.getElementById('mT').textContent = threshold.toFixed(2);
  
  let cMass = mass;
  if (pName === 'WHITE_DWF') cMass = 0.6;
  if (pName === 'NEUTRON') cMass = 1.4;
  if (pName === 'BLACK_HOLE') cMass = mass * 0.35;
  document.getElementById('sMass').textContent = cMass.toFixed(2) + ' M☉';
  document.getElementById('sRadius').textContent = props.radius > 100 ? props.radius.toExponential(1)+' R☉' : props.radius.toFixed(2)+' R☉';
  document.getElementById('sTemp').textContent = props.temp > 1e6 ? (props.temp/1e6).toFixed(0)+' MK' : Math.round(props.temp).toLocaleString()+' K';
  document.getElementById('sLum').textContent = props.lum > 1000 ? props.lum.toExponential(1)+' L☉' : props.lum.toFixed(2)+' L☉';
  
  let total = 0, curr = 0;
  for (let i = 0; i < sequence.length; i++) { total += PHASES[sequence[i]].duration; if (i < phaseIndex) curr += PHASES[sequence[i]].duration; }
  document.getElementById('progress').style.width = ((curr+phaseFrame)/total*100) + '%';
  document.getElementById('fateName').textContent = PHASES[StellarCRR.fate(mass)].name;
}

/*******************************************************************************
 * SECTION 10: MAIN LOOP & CONTROLS
 ******************************************************************************/

function loop() { if (running) update(); render(); requestAnimationFrame(loop); }
function toggleExplainer() { document.getElementById('explainer').classList.toggle('open'); }

document.getElementById('btnPlay').onclick = function() { running = !running; this.textContent = running ? '❚❚ Pause' : '▶ Play'; };
document.getElementById('btnReset').onclick = function() { init(); running = true; document.getElementById('btnPlay').textContent = '❚❚ Pause'; };

function selectMass(m, btn) {
  mass = m;
  document.querySelectorAll('.mass-select button').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
  init(); running = true; document.getElementById('btnPlay').textContent = '❚❚ Pause';
}

document.getElementById('m1').onclick = function() { selectMass(0.5, this); };
document.getElementById('m2').onclick = function() { selectMass(1.0, this); };
document.getElementById('m3').onclick = function() { selectMass(10, this); };
document.getElementById('m4').onclick = function() { selectMass(30, this); };

init();
loop();
</script>
</body>
</html>
