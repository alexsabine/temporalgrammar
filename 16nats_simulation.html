<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16 Nats Identity: CRR Cortical Hierarchy Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Georgia, 'Times New Roman', serif;
            background: #ffffff;
            color: #1a1a1a;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px 0 30px;
            border-bottom: 2px solid #1a1a1a;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 28px;
            font-weight: normal;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .identity-display {
            font-size: 32px;
            font-style: italic;
            margin: 15px 0;
        }
        
        .subtitle {
            font-size: 14px;
            color: #555;
            letter-spacing: 0.5px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 320px 1fr 280px;
            gap: 25px;
        }
        
        .panel {
            background: #fafafa;
            border: 1px solid #ccc;
            padding: 20px;
        }
        
        .panel-title {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #666;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Hierarchy Panel */
        .hierarchy-container {
            position: relative;
        }
        
        .level {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            height: 36px;
        }
        
        .level-number {
            width: 24px;
            font-size: 11px;
            color: #888;
            text-align: right;
            padding-right: 8px;
        }
        
        .level-node {
            flex: 1;
            height: 28px;
            background: #e8e8e8;
            border: 1px solid #999;
            display: flex;
            align-items: center;
            padding: 0 10px;
            position: relative;
            overflow: hidden;
            transition: all 0.15s ease;
        }
        
        .level-node.active {
            background: #2a5a8a;
            border-color: #1a3a5a;
        }
        
        .level-node.completed {
            background: #3a7a5a;
            border-color: #2a5a3a;
        }
        
        .level-node.system1 {
            border-left: 3px solid #c44;
        }
        
        .level-node.system2 {
            border-left: 3px solid #44c;
        }
        
        .level-node.transition {
            border-left: 3px solid #a8a;
        }
        
        .level-name {
            font-size: 11px;
            color: #333;
            z-index: 2;
            position: relative;
            white-space: nowrap;
        }
        
        .level-node.active .level-name,
        .level-node.completed .level-name {
            color: #fff;
        }
        
        .level-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #5a9ad8 0%, #3a7ab8 100%);
            opacity: 0.8;
            transition: width 0.05s ease;
        }
        
        .level-info {
            width: 80px;
            font-size: 9px;
            text-align: right;
            color: #666;
            font-family: 'Courier New', monospace;
        }
        
        /* Main Visualization */
        .visualization-panel {
            min-height: 580px;
        }
        
        .viz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .crr-state {
            display: flex;
            gap: 20px;
        }
        
        .state-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .state-dot {
            width: 12px;
            height: 12px;
            border: 1px solid #666;
            background: #ddd;
        }
        
        .state-dot.active {
            background: #2a8a5a;
            border-color: #1a5a3a;
        }
        
        .state-dot.rupture {
            background: #c44;
            border-color: #944;
        }
        
        .state-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #555;
        }
        
        .canvas-container {
            background: #fff;
            border: 1px solid #bbb;
            height: 400px;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
        
        .info-readout {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .readout-box {
            background: #fff;
            border: 1px solid #ccc;
            padding: 12px;
            text-align: center;
        }
        
        .readout-value {
            font-size: 24px;
            font-family: 'Courier New', monospace;
            color: #1a1a1a;
            margin-bottom: 4px;
        }
        
        .readout-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #777;
        }
        
        /* Parameters Panel */
        .param-group {
            margin-bottom: 20px;
        }
        
        .param-label {
            font-size: 11px;
            color: #555;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }
        
        .param-value {
            font-family: 'Courier New', monospace;
            color: #1a1a1a;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: #ddd;
            outline: none;
            border: 1px solid #bbb;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #444;
            cursor: pointer;
            border: none;
        }
        
        .equations-box {
            background: #fff;
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
        }
        
        .equation {
            font-size: 12px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            color: #333;
        }
        
        .equation-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 3px;
            font-family: Georgia, serif;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 10px 15px;
            font-family: Georgia, serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid #666;
            background: #fff;
            color: #333;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        button:hover {
            background: #333;
            color: #fff;
        }
        
        button.primary {
            background: #2a5a8a;
            color: #fff;
            border-color: #1a3a5a;
        }
        
        button.primary:hover {
            background: #1a3a5a;
        }
        
        .threshold-indicator {
            margin-top: 15px;
            padding: 12px;
            background: #fff;
            border: 1px solid #ccc;
        }
        
        .threshold-bar {
            height: 20px;
            background: #eee;
            border: 1px solid #bbb;
            position: relative;
            margin-top: 8px;
        }
        
        .threshold-fill {
            height: 100%;
            background: linear-gradient(90deg, #3a7ab8 0%, #5a9ad8 100%);
            transition: width 0.1s ease;
        }
        
        .threshold-mark {
            position: absolute;
            top: -5px;
            bottom: -5px;
            width: 2px;
            background: #c44;
        }
        
        .threshold-label {
            position: absolute;
            top: -18px;
            font-size: 9px;
            color: #c44;
            transform: translateX(-50%);
        }
        
        .system-gradient {
            display: flex;
            height: 8px;
            margin-top: 10px;
            border: 1px solid #ccc;
        }
        
        .system-gradient-s1 {
            flex: 1;
            background: linear-gradient(90deg, #fcc 0%, #fdd 100%);
        }
        
        .system-gradient-trans {
            flex: 1;
            background: linear-gradient(90deg, #fdd 0%, #ddf 100%);
        }
        
        .system-gradient-s2 {
            flex: 1;
            background: linear-gradient(90deg, #ddf 0%, #ccf 100%);
        }
        
        footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            font-size: 11px;
            color: #888;
        }
        
        .math-note {
            font-style: italic;
            margin-top: 10px;
        }
        
        .omega-display {
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            font-size: 10px;
        }
        
        .omega-current {
            font-size: 14px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .omega-bar {
            height: 12px;
            background: linear-gradient(90deg, #fcc 0%, #fdd 25%, #eee 50%, #ddf 75%, #ccf 100%);
            border: 1px solid #bbb;
            position: relative;
        }
        
        .omega-marker {
            position: absolute;
            top: -3px;
            bottom: -3px;
            width: 3px;
            background: #333;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>The 16 Nats Identity</h1>
            <div class="identity-display">π<sup>14</sup> ≈ 2<sup>e<sup>π</sup></sup></div>
            <div class="subtitle">Coherence-Rupture-Regeneration Framework | Level-Dependent Ω (System 1 → System 2)</div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Hierarchy -->
            <div class="panel">
                <div class="panel-title">Cortical Hierarchy (Felleman & Van Essen)</div>
                <div class="hierarchy-container" id="hierarchy">
                    <!-- Levels will be generated by JS -->
                </div>
                <div style="margin-top: 15px; font-size: 9px; color: #666;">
                    <span style="color: #c44;">■</span> System 1 (fast) &nbsp;
                    <span style="color: #a8a;">■</span> Transition &nbsp;
                    <span style="color: #44c;">■</span> System 2 (slow)
                </div>
            </div>
            
            <!-- Center Panel: Main Visualization -->
            <div class="panel visualization-panel">
                <div class="viz-header">
                    <div class="panel-title" style="margin-bottom: 0; border: none; padding: 0;">Signal Propagation & Information Accumulation</div>
                    <div class="crr-state">
                        <div class="state-indicator">
                            <div class="state-dot" id="coherence-dot"></div>
                            <span class="state-label">Coherence</span>
                        </div>
                        <div class="state-indicator">
                            <div class="state-dot" id="rupture-dot"></div>
                            <span class="state-label">Rupture</span>
                        </div>
                        <div class="state-indicator">
                            <div class="state-dot" id="regen-dot"></div>
                            <span class="state-label">Regeneration</span>
                        </div>
                    </div>
                </div>
                
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                </div>
                
                <div class="info-readout">
                    <div class="readout-box">
                        <div class="readout-value" id="readout-level">1</div>
                        <div class="readout-label">Active Level</div>
                    </div>
                    <div class="readout-box">
                        <div class="readout-value" id="readout-info">0.00</div>
                        <div class="readout-label">Information (nats)</div>
                    </div>
                    <div class="readout-box">
                        <div class="readout-value" id="readout-omega">0.10</div>
                        <div class="readout-label">Ω (current level)</div>
                    </div>
                    <div class="readout-box">
                        <div class="readout-value" id="readout-gain">1.00</div>
                        <div class="readout-label">exp(C/Ω) hier.</div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Parameters -->
            <div class="panel">
                <div class="panel-title">CRR Parameters</div>
                
                <div class="omega-display">
                    <div class="omega-current">
                        Level <span id="current-level-display">1</span> Ω = <span id="current-omega-display">0.100</span>
                    </div>
                    <div class="omega-bar">
                        <div class="omega-marker" id="omega-marker" style="left: 0%"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 8px; color: #888;">
                        <span>System 1</span>
                        <span>System 2</span>
                    </div>
                </div>
                
                <div class="param-group" style="margin-top: 15px;">
                    <div class="param-label">
                        <span>Global Ω Modifier</span>
                        <span class="param-value" id="modifier-value">1.00×</span>
                    </div>
                    <input type="range" id="modifier-slider" min="0.5" max="2.0" step="0.01" value="1.0">
                    <div style="display: flex; justify-content: space-between; font-size: 9px; color: #888; margin-top: 4px;">
                        <span>← More S1</span>
                        <span>More S2 →</span>
                    </div>
                </div>
                
                <div class="param-group">
                    <div class="param-label">
                        <span>Signal Rate</span>
                        <span class="param-value" id="rate-value">1.0×</span>
                    </div>
                    <input type="range" id="rate-slider" min="0.2" max="3" step="0.1" value="1">
                </div>
                
                <div class="param-group">
                    <div class="param-label">
                        <span>Noise Level</span>
                        <span class="param-value" id="noise-value">0.05</span>
                    </div>
                    <input type="range" id="noise-slider" min="0" max="0.2" step="0.01" value="0.05">
                </div>
                
                <div class="threshold-indicator">
                    <div class="param-label">
                        <span>Cumulative Information</span>
                        <span class="param-value"><span id="info-current">0.00</span> / 16.03 nats</span>
                    </div>
                    <div class="threshold-bar">
                        <div class="threshold-fill" id="info-fill" style="width: 0%"></div>
                        <div class="threshold-mark" style="left: calc(100% - 2px)">
                            <div class="threshold-label">e<sup>π</sup></div>
                        </div>
                    </div>
                </div>
                
                <div class="threshold-indicator">
                    <div class="param-label">
                        <span>Hierarchical Gain exp(C/Ω)</span>
                        <span class="param-value"><span id="gain-current">1.00</span> / 23.14</span>
                    </div>
                    <div class="threshold-bar">
                        <div class="threshold-fill" id="gain-fill" style="width: 0%"></div>
                        <div class="threshold-mark" style="left: calc(100% - 2px)">
                            <div class="threshold-label">e<sup>π</sup></div>
                        </div>
                    </div>
                </div>
                
                <div class="equations-box">
                    <div class="equation-label">Level-Dependent Ω</div>
                    <div class="equation">Ω(n) = 0.1 × 1.132<sup>n</sup></div>
                    
                    <div class="equation-label">Rupture Condition</div>
                    <div class="equation">δ(now) when C ≥ Ω(n)</div>
                    
                    <div class="equation-label">Critical Threshold</div>
                    <div class="equation">I<sub>crit</sub> = 14·ln(π) ≈ 16 nats</div>
                    
                    <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #ddd; font-size: 9px; color: #555;">
                        Early levels (1-4): Low Ω, fast ruptures<br>
                        Late levels (12-14): High Ω, slow integration
                    </div>
                </div>
                
                <div class="controls">
                    <button id="btn-reset">Reset</button>
                    <button id="btn-toggle" class="primary">Start</button>
                </div>
            </div>
        </div>
        
        <footer>
            <div>Based on Felleman & Van Essen (1991) cortical hierarchy | Murray et al. (2014) temporal dynamics</div>
            <div class="math-note">Ω increases geometrically up the hierarchy: System 1 (fast, precise) → System 2 (slow, integrative)</div>
        </footer>
    </div>
    
    <script>
        // ============================================================
        // MATHEMATICAL CONSTANTS
        // ============================================================
        const PI = Math.PI;
        const E = Math.E;
        const LN_PI = Math.log(PI);           // ≈ 1.1447
        const CRITICAL_INFO = 14 * LN_PI;      // ≈ 16.026 nats
        const E_PI = Math.pow(E, PI);          // ≈ 23.1407
        
        // Level-dependent Ω parameters (derived from Murray et al. 2014)
        const OMEGA_MIN = 0.10;                // Level 1 (Retina) - System 1
        const OMEGA_MAX = 0.50;                // Level 14 (Hippocampus) - System 2
        const OMEGA_SCALE = Math.pow(OMEGA_MAX / OMEGA_MIN, 1/13);  // ≈ 1.1318
        
        // Get Ω for a specific level (0-indexed)
        function getBaseOmega(level) {
            return OMEGA_MIN * Math.pow(OMEGA_SCALE, level);
        }
        
        // Get system type for a level
        function getSystemType(level) {
            const omega = getBaseOmega(level);
            if (omega < 0.15) return 'system1';
            if (omega < 0.35) return 'transition';
            return 'system2';
        }
        
        // Hierarchy levels (Felleman & Van Essen 1991)
        const HIERARCHY = [
            { level: 1, name: 'Retina', abbr: 'RET' },
            { level: 2, name: 'LGN', abbr: 'LGN' },
            { level: 3, name: 'V1', abbr: 'V1' },
            { level: 4, name: 'V2', abbr: 'V2' },
            { level: 5, name: 'V3 / VP', abbr: 'V3' },
            { level: 6, name: 'V4', abbr: 'V4' },
            { level: 7, name: 'MT / V5', abbr: 'MT' },
            { level: 8, name: 'MST', abbr: 'MST' },
            { level: 9, name: 'IT', abbr: 'IT' },
            { level: 10, name: 'TEO', abbr: 'TEO' },
            { level: 11, name: 'TE', abbr: 'TE' },
            { level: 12, name: 'Parahippocampal', abbr: 'PH' },
            { level: 13, name: 'Entorhinal', abbr: 'EC' },
            { level: 14, name: 'Hippocampus', abbr: 'HPC' }
        ];
        
        // ============================================================
        // STATE
        // ============================================================
        let state = {
            running: false,
            omegaModifier: 1.0,        // Global modifier for all Ω values
            signalRate: 1.0,
            noiseLevel: 0.05,
            
            // Hierarchical state
            activeLevel: 0,            // 0-13 (displayed as 1-14)
            levelCoherence: 0,         // Current level's coherence (0 to Ω, then resets)
            completedLevels: 0,        // Number of levels fully processed
            
            // CRR state
            crrState: 'coherence',     // 'coherence', 'rupture', 'regeneration'
            ruptureCooldown: 0,
            
            // Derived values
            cumulativeInfo: 0,
            hierarchicalGain: 1,
            currentOmega: OMEGA_MIN,
            
            // History for waveforms
            history: [],
            time: 0,
            
            // Signals for animation
            signals: []
        };
        
        // Get effective Ω for current level (with modifier)
        function getCurrentOmega() {
            return getBaseOmega(state.activeLevel) * state.omegaModifier;
        }
        
        // ============================================================
        // DOM ELEMENTS
        // ============================================================
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const hierarchyContainer = document.getElementById('hierarchy');
        
        // ============================================================
        // INITIALIZATION
        // ============================================================
        function init() {
            setupCanvas();
            buildHierarchy();
            setupControls();
            updateOmegaDisplay();
            render();
        }
        
        function setupCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        function buildHierarchy() {
            hierarchyContainer.innerHTML = '';
            HIERARCHY.forEach((h, i) => {
                const omega = getBaseOmega(i);
                const systemType = getSystemType(i);
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level';
                levelDiv.innerHTML = `
                    <div class="level-number">${h.level}</div>
                    <div class="level-node ${systemType}" id="level-node-${i}">
                        <div class="level-fill" id="level-fill-${i}" style="width: 0%"></div>
                        <span class="level-name">${h.name}</span>
                    </div>
                    <div class="level-info" id="level-info-${i}">Ω=${omega.toFixed(2)}</div>
                `;
                hierarchyContainer.appendChild(levelDiv);
            });
        }
        
        function setupControls() {
            // Modifier slider
            const modifierSlider = document.getElementById('modifier-slider');
            modifierSlider.addEventListener('input', (e) => {
                state.omegaModifier = parseFloat(e.target.value);
                document.getElementById('modifier-value').textContent = state.omegaModifier.toFixed(2) + '×';
                updateOmegaDisplay();
            });
            
            // Rate slider
            const rateSlider = document.getElementById('rate-slider');
            rateSlider.addEventListener('input', (e) => {
                state.signalRate = parseFloat(e.target.value);
                document.getElementById('rate-value').textContent = state.signalRate.toFixed(1) + '×';
            });
            
            // Noise slider
            const noiseSlider = document.getElementById('noise-slider');
            noiseSlider.addEventListener('input', (e) => {
                state.noiseLevel = parseFloat(e.target.value);
                document.getElementById('noise-value').textContent = state.noiseLevel.toFixed(2);
            });
            
            // Buttons
            document.getElementById('btn-toggle').addEventListener('click', toggleSimulation);
            document.getElementById('btn-reset').addEventListener('click', resetSimulation);
        }
        
        function updateOmegaDisplay() {
            const omega = getCurrentOmega();
            const level = state.activeLevel + 1;
            document.getElementById('current-level-display').textContent = level;
            document.getElementById('current-omega-display').textContent = omega.toFixed(3);
            
            // Position marker on gradient bar (0.1 to 0.5 range)
            const percent = ((omega - 0.05) / 0.5) * 100;
            document.getElementById('omega-marker').style.left = Math.min(100, Math.max(0, percent)) + '%';
        }
        
        function toggleSimulation() {
            state.running = !state.running;
            document.getElementById('btn-toggle').textContent = state.running ? 'Pause' : 'Start';
            if (state.running) {
                lastTime = performance.now();
                requestAnimationFrame(update);
            }
        }
        
        function resetSimulation() {
            state.running = false;
            state.activeLevel = 0;
            state.levelCoherence = 0;
            state.completedLevels = 0;
            state.crrState = 'coherence';
            state.ruptureCooldown = 0;
            state.cumulativeInfo = 0;
            state.hierarchicalGain = 1;
            state.currentOmega = getCurrentOmega();
            state.history = [];
            state.signals = [];
            state.time = 0;
            document.getElementById('btn-toggle').textContent = 'Start';
            updateOmegaDisplay();
            render();
        }
        
        // ============================================================
        // SIMULATION UPDATE
        // ============================================================
        let lastTime = 0;
        
        function update(timestamp) {
            if (!state.running) return;
            
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05) * state.signalRate;
            lastTime = timestamp;
            state.time += dt;
            
            // Update current Ω
            state.currentOmega = getCurrentOmega();
            
            // Update CRR dynamics
            updateCRR(dt);
            
            // Compute derived values
            computeDerivedValues();
            
            // Update signals
            updateSignals(dt);
            
            // Record history (for waveform display)
            recordHistory();
            
            // Update omega display
            updateOmegaDisplay();
            
            // Render
            render();
            
            requestAnimationFrame(update);
        }
        
        function updateCRR(dt) {
            // Handle rupture cooldown
            if (state.ruptureCooldown > 0) {
                state.ruptureCooldown -= dt;
                if (state.ruptureCooldown <= 0) {
                    state.crrState = 'regeneration';
                    setTimeout(() => {
                        if (state.running) state.crrState = 'coherence';
                    }, 150);
                }
                return;
            }
            
            // Coherence accumulation with noise
            const noise = (Math.random() - 0.5) * state.noiseLevel * 2;
            const luminance = Math.max(0.1, 0.8 + noise);
            
            // FIXED RATE - independent of Ω
            // This means LOW Ω levels (System 1) rupture faster
            // HIGH Ω levels (System 2) take longer
            const fixedRate = 0.12;  // nats per second
            state.levelCoherence += dt * luminance * fixedRate;
            
            // Check rupture condition: C_level ≥ Ω(current level)
            if (state.levelCoherence >= state.currentOmega) {
                triggerRupture();
            }
        }
        
        function triggerRupture() {
            state.crrState = 'rupture';
            state.ruptureCooldown = 0.12;
            
            // Spawn signal packet
            if (state.activeLevel < 13) {
                state.signals.push({
                    fromLevel: state.activeLevel,
                    toLevel: state.activeLevel + 1,
                    progress: 0
                });
            }
            
            // Mark level as completed
            state.completedLevels = state.activeLevel + 1;
            
            // Advance to next level (or cycle if at top)
            if (state.activeLevel < 13) {
                state.activeLevel++;
            } else {
                // Reached hippocampus - system cycles
                setTimeout(() => {
                    if (state.running) {
                        state.activeLevel = 0;
                        state.completedLevels = 0;
                    }
                }, 500);
            }
            
            // Reset level coherence for new level
            state.levelCoherence = 0;
        }
        
        function computeDerivedValues() {
            // Cumulative information: completed levels × ln(π) + partial
            const partialInfo = (state.levelCoherence / state.currentOmega) * LN_PI;
            state.cumulativeInfo = state.completedLevels * LN_PI + partialInfo;
            
            // Hierarchical gain: exp((effective_level / 14) × π)
            const effectiveLevel = state.completedLevels + (state.levelCoherence / state.currentOmega);
            const hierarchicalRatio = (effectiveLevel / 14) * PI;
            state.hierarchicalGain = Math.exp(hierarchicalRatio);
        }
        
        function updateSignals(dt) {
            state.signals = state.signals.filter(sig => {
                sig.progress += dt * 4;
                return sig.progress < 1;
            });
        }
        
        function recordHistory() {
            if (state.history.length > 600) state.history.shift();
            state.history.push({
                time: state.time,
                info: state.cumulativeInfo,
                levelCoherence: state.levelCoherence,
                omega: state.currentOmega,
                level: state.activeLevel,
                crrState: state.crrState,
                hierarchicalGain: state.hierarchicalGain
            });
        }
        
        // ============================================================
        // RENDERING
        // ============================================================
        function render() {
            renderCanvas();
            renderHierarchy();
            renderReadouts();
            renderCRRState();
        }
        
        function renderCanvas() {
            const w = canvas.width;
            const h = canvas.height;
            
            // Clear
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, w, h);
            
            // Grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x < w; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = 0; y < h; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
            
            // ============================================================
            // Ω BY LEVEL (Top left - new panel)
            // ============================================================
            const omegaX = 30;
            const omegaY = 30;
            const omegaW = w * 0.25;
            const omegaH = h * 0.3;
            
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(omegaX, omegaY, omegaW, omegaH);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(omegaX, omegaY, omegaW, omegaH);
            
            ctx.fillStyle = '#666';
            ctx.font = '11px Georgia';
            ctx.fillText('Ω by Level (System 1 → 2)', omegaX + 5, omegaY - 8);
            
            // Draw Ω bars for each level
            const barH = (omegaH - 20) / 14;
            for (let i = 0; i < 14; i++) {
                const y = omegaY + 10 + i * barH;
                const omega = getBaseOmega(i) * state.omegaModifier;
                const barWidth = (omega / 0.6) * (omegaW - 40);
                
                // Background
                ctx.fillStyle = '#eee';
                ctx.fillRect(omegaX + 25, y, omegaW - 40, barH - 2);
                
                // Fill based on system type
                const systemType = getSystemType(i);
                if (systemType === 'system1') ctx.fillStyle = '#e88';
                else if (systemType === 'transition') ctx.fillStyle = '#a8a';
                else ctx.fillStyle = '#88e';
                
                // Highlight active level
                if (i === state.activeLevel) {
                    ctx.fillStyle = '#4a4';
                }
                
                ctx.fillRect(omegaX + 25, y, barWidth, barH - 2);
                
                // Level number
                ctx.fillStyle = '#888';
                ctx.font = '8px Courier New';
                ctx.fillText((i+1).toString(), omegaX + 8, y + barH - 4);
            }
            
            // ============================================================
            // CUMULATIVE INFORMATION WAVEFORM (Blue - Step Function)
            // ============================================================
            if (state.history.length > 1) {
                const waveX = omegaX + omegaW + 20;
                const waveY = 30;
                const waveW = w * 0.35;
                const waveH = h * 0.3;
                
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(waveX, waveY, waveW, waveH);
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(waveX, waveY, waveW, waveH);
                
                ctx.fillStyle = '#666';
                ctx.font = '11px Georgia';
                ctx.fillText('Cumulative Information (step function)', waveX + 5, waveY - 8);
                
                // 16 nats threshold
                const thresholdY = waveY + waveH * (1 - 16/18);
                ctx.strokeStyle = '#c44';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(waveX, thresholdY);
                ctx.lineTo(waveX + waveW, thresholdY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#c44';
                ctx.font = '9px Georgia';
                ctx.fillText('16.03 nats', waveX + waveW - 55, thresholdY - 4);
                
                // Draw cumulative info
                ctx.strokeStyle = '#2a5a8a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                state.history.forEach((h, i) => {
                    const x = waveX + (i / state.history.length) * waveW;
                    const y = waveY + waveH * (1 - h.info / 18);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
            
            // ============================================================
            // LEVEL COHERENCE WAVEFORM (Green - Sawtooth, variable period)
            // ============================================================
            if (state.history.length > 1) {
                const sawX = 30;
                const sawY = h * 0.42;
                const sawW = w * 0.55;
                const sawH = h * 0.18;
                
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(sawX, sawY, sawW, sawH);
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(sawX, sawY, sawW, sawH);
                
                ctx.fillStyle = '#666';
                ctx.font = '11px Georgia';
                ctx.fillText('Level Coherence C (sawtooth with variable period)', sawX + 5, sawY - 8);
                
                // Draw sawtooth (green)
                ctx.strokeStyle = '#3a7a3a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                state.history.forEach((h, i) => {
                    const x = sawX + (i / state.history.length) * sawW;
                    const normalized = Math.min(h.levelCoherence / h.omega, 1);
                    const y = sawY + sawH * (1 - normalized * 0.85);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Note about variable period
                ctx.fillStyle = '#666';
                ctx.font = '9px Georgia';
                ctx.fillText('Period increases at higher levels (larger Ω threshold)', sawX + 5, sawY + sawH - 5);
            }
            
            // ============================================================
            // HIERARCHICAL GAIN exp(C/Ω) (Right side)
            // ============================================================
            const gainX = w * 0.62;
            const gainY = 30;
            const gainW = w * 0.35;
            const gainH = h * 0.3;
            
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(gainX, gainY, gainW, gainH);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(gainX, gainY, gainW, gainH);
            
            ctx.fillStyle = '#666';
            ctx.font = '11px Georgia';
            ctx.fillText('Hierarchical Gain exp(C/Ω)', gainX + 5, gainY - 8);
            
            if (state.history.length > 1) {
                const epiY = gainY + gainH * 0.1;
                ctx.strokeStyle = '#c44';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(gainX, epiY);
                ctx.lineTo(gainX + gainW, epiY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#c44';
                ctx.font = '9px Georgia';
                ctx.fillText('e^π ≈ 23.14', gainX + gainW - 55, epiY - 4);
                
                ctx.strokeStyle = '#8a2a5a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                state.history.forEach((h, i) => {
                    const x = gainX + (i / state.history.length) * gainW;
                    const normalized = (h.hierarchicalGain - 1) / (E_PI - 1);
                    const y = gainY + gainH * (1 - Math.min(normalized, 1) * 0.9);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
            
            // ============================================================
            // HIERARCHY SCHEMATIC
            // ============================================================
            const schemaX = w * 0.62;
            const schemaY = h * 0.42;
            const schemaW = w * 0.35;
            const schemaH = h * 0.53;
            const levelHeight = schemaH / 14;
            
            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(schemaX, schemaY, schemaW, schemaH);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(schemaX, schemaY, schemaW, schemaH);
            
            ctx.fillStyle = '#666';
            ctx.font = '11px Georgia';
            ctx.fillText('Hierarchy State', schemaX + 5, schemaY - 8);
            
            // Draw levels
            HIERARCHY.forEach((h, i) => {
                const y = schemaY + i * levelHeight;
                const isActive = i === state.activeLevel;
                const isCompleted = i < state.completedLevels;
                const omega = getBaseOmega(i) * state.omegaModifier;
                const systemType = getSystemType(i);
                
                // System type color band
                let bandColor = '#fcc';
                if (systemType === 'transition') bandColor = '#ecd';
                if (systemType === 'system2') bandColor = '#ccf';
                ctx.fillStyle = bandColor;
                ctx.fillRect(schemaX + 2, y + 2, 4, levelHeight - 4);
                
                // Level background
                ctx.fillStyle = isActive ? '#e8f0f8' : (isCompleted ? '#e8f8e8' : '#fff');
                ctx.fillRect(schemaX + 8, y + 2, schemaW - 16, levelHeight - 4);
                
                // Level fill for active level
                if (isActive) {
                    const fillWidth = (state.levelCoherence / omega) * (schemaW - 20);
                    ctx.fillStyle = '#5a9ad8';
                    ctx.fillRect(schemaX + 10, y + 4, Math.min(fillWidth, schemaW - 24), levelHeight - 8);
                } else if (isCompleted) {
                    ctx.fillStyle = '#7aba7a';
                    ctx.fillRect(schemaX + 10, y + 4, schemaW - 24, levelHeight - 8);
                }
                
                // Level border
                ctx.strokeStyle = isActive ? '#2a5a8a' : (isCompleted ? '#3a7a3a' : '#bbb');
                ctx.lineWidth = isActive ? 2 : 1;
                ctx.strokeRect(schemaX + 8, y + 2, schemaW - 16, levelHeight - 4);
                
                // Level label
                ctx.fillStyle = (isActive || isCompleted) ? '#333' : '#888';
                ctx.font = '9px Georgia';
                ctx.fillText(h.abbr, schemaX + 14, y + levelHeight/2 + 3);
                
                // Ω value
                ctx.fillStyle = '#666';
                ctx.font = '8px Courier New';
                ctx.textAlign = 'right';
                ctx.fillText('Ω=' + omega.toFixed(2), schemaX + schemaW - 12, y + levelHeight/2 + 3);
                ctx.textAlign = 'left';
            });
            
            // Draw signal packets
            state.signals.forEach(sig => {
                const fromY = schemaY + sig.fromLevel * levelHeight + levelHeight/2;
                const toY = schemaY + sig.toLevel * levelHeight + levelHeight/2;
                const y = fromY + (toY - fromY) * sig.progress;
                const x = schemaX + schemaW/2;
                
                ctx.fillStyle = '#4a9';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // ============================================================
            // MATH SUMMARY BOX
            // ============================================================
            const mathX = 30;
            const mathY = h * 0.65;
            const mathW = w * 0.55;
            const mathH = h * 0.3;
            
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(mathX, mathY, mathW, mathH);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(mathX, mathY, mathW, mathH);
            
            ctx.fillStyle = '#333';
            ctx.font = '11px Georgia';
            const lineH = 16;
            let ly = mathY + 18;
            
            // System mode based on current level
            const systemType = getSystemType(state.activeLevel);
            let systemLabel = 'System 1 (fast, precise)';
            if (systemType === 'transition') systemLabel = 'Transition (S1 → S2)';
            if (systemType === 'system2') systemLabel = 'System 2 (slow, integrative)';
            
            ctx.fillText(`Processing Mode: ${systemLabel}`, mathX + 10, ly);
            ly += lineH + 4;
            
            ctx.font = '10px Courier New';
            ctx.fillStyle = '#444';
            
            const omega = state.currentOmega;
            const precision = 1 / omega;
            ctx.fillText(`Level ${state.activeLevel + 1}/14    Ω = ${omega.toFixed(3)}    Precision = ${precision.toFixed(2)}`, mathX + 10, ly);
            ly += lineH;
            
            const timePerLevel = omega / 0.12;
            ctx.fillText(`Level Coherence: ${state.levelCoherence.toFixed(3)} / ${omega.toFixed(3)}    (~${timePerLevel.toFixed(1)}s to rupture)`, mathX + 10, ly);
            ly += lineH;
            
            ctx.fillText(`Cumulative Info: ${state.cumulativeInfo.toFixed(2)} / 16.03 nats`, mathX + 10, ly);
            ly += lineH;
            
            ctx.fillText(`Hierarchical Gain: exp(C/Ω) = ${state.hierarchicalGain.toFixed(2)} / 23.14`, mathX + 10, ly);
            ly += lineH + 4;
            
            ctx.font = '9px Georgia';
            ctx.fillStyle = '#666';
            ctx.fillText(`Level-dependent Ω: Retina (Ω=0.10, fast) → Hippocampus (Ω=0.50, slow)`, mathX + 10, ly);
            ly += lineH;
            ctx.fillText(`Murray et al. (2014): Timescales increase ~7x across cortical hierarchy`, mathX + 10, ly);
        }
        
        function renderHierarchy() {
            HIERARCHY.forEach((h, i) => {
                const node = document.getElementById(`level-node-${i}`);
                const fill = document.getElementById(`level-fill-${i}`);
                const info = document.getElementById(`level-info-${i}`);
                
                const isActive = i === state.activeLevel;
                const isCompleted = i < state.completedLevels;
                const omega = getBaseOmega(i) * state.omegaModifier;
                
                // Fill percentage
                let fillPercent = 0;
                if (isCompleted) {
                    fillPercent = 100;
                } else if (isActive) {
                    fillPercent = (state.levelCoherence / omega) * 100;
                }
                fill.style.width = fillPercent + '%';
                
                // Info text - show Ω and time
                const timeToRupture = omega / 0.12;
                info.textContent = `Ω=${omega.toFixed(2)} ~${timeToRupture.toFixed(1)}s`;
                
                // Node classes
                node.classList.remove('active', 'completed');
                if (isActive) {
                    node.classList.add('active');
                } else if (isCompleted) {
                    node.classList.add('completed');
                }
            });
        }
        
        function renderReadouts() {
            document.getElementById('readout-level').textContent = state.activeLevel + 1;
            document.getElementById('readout-info').textContent = state.cumulativeInfo.toFixed(2);
            document.getElementById('readout-omega').textContent = state.currentOmega.toFixed(3);
            document.getElementById('readout-gain').textContent = state.hierarchicalGain.toFixed(2);
            
            // Info bar
            document.getElementById('info-current').textContent = state.cumulativeInfo.toFixed(2);
            document.getElementById('info-fill').style.width = Math.min(state.cumulativeInfo / CRITICAL_INFO * 100, 100) + '%';
            
            // Gain bar
            document.getElementById('gain-current').textContent = state.hierarchicalGain.toFixed(2);
            const gainFill = Math.min((state.hierarchicalGain - 1) / (E_PI - 1) * 100, 100);
            document.getElementById('gain-fill').style.width = gainFill + '%';
        }
        
        function renderCRRState() {
            const coherenceDot = document.getElementById('coherence-dot');
            const ruptureDot = document.getElementById('rupture-dot');
            const regenDot = document.getElementById('regen-dot');
            
            coherenceDot.classList.remove('active', 'rupture');
            ruptureDot.classList.remove('active', 'rupture');
            regenDot.classList.remove('active', 'rupture');
            
            if (state.crrState === 'coherence') {
                coherenceDot.classList.add('active');
            } else if (state.crrState === 'rupture') {
                ruptureDot.classList.add('rupture');
            } else if (state.crrState === 'regeneration') {
                regenDot.classList.add('active');
            }
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            setupCanvas();
            render();
        });
        
        // Initialize
        init();
    </script>
</body>
</html>
