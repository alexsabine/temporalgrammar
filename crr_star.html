<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Star: Sirius A — Ultimate Fidelity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000005;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 15px 0 25px;
            border-bottom: 1px solid #1a1a3a;
        }
        
        h1 {
            font-size: 1.6em;
            font-weight: 300;
            color: #cad9ff;
            letter-spacing: 4px;
            margin-bottom: 6px;
        }
        
        .subtitle {
            color: #6a7a9a;
            font-size: 0.8em;
            letter-spacing: 2px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-top: 25px;
        }
        
        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        /* Star Display */
        .star-container {
            background: radial-gradient(ellipse at center, #000012 0%, #000005 100%);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        .star-field {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .background-star {
            position: absolute;
            background: white;
            border-radius: 50%;
        }
        
        #sirius-canvas {
            position: relative;
            z-index: 10;
            cursor: grab;
        }
        
        #sirius-canvas:active {
            cursor: grabbing;
        }
        
        .star-info {
            text-align: center;
            margin-top: 15px;
            z-index: 10;
        }
        
        .star-name {
            font-size: 1.3em;
            color: #cad9ff;
            letter-spacing: 3px;
            margin-bottom: 4px;
        }
        
        .star-designation {
            color: #5a6a8a;
            font-size: 0.7em;
            letter-spacing: 1px;
        }
        
        /* Controls */
        .controls-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 20;
            pointer-events: none;
        }
        
        .controls-overlay > * {
            pointer-events: auto;
        }
        
        .distance-display {
            color: #4a5a7a;
            font-size: 0.7em;
            letter-spacing: 1px;
            background: rgba(5, 5, 15, 0.9);
            padding: 10px 16px;
            border-radius: 20px;
            border: 1px solid #1a1a3a;
        }
        
        .distance-value {
            color: #7affaa;
            font-weight: bold;
        }
        
        .crr-state-display {
            background: rgba(5, 5, 15, 0.9);
            border: 1px solid #2a2a4a;
            border-radius: 20px;
            padding: 10px 16px;
            color: #6a7a9a;
            font-size: 0.65em;
            letter-spacing: 1px;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 20;
            background: rgba(5, 5, 15, 0.9);
            padding: 10px 18px;
            border-radius: 30px;
            border: 1px solid #2a2a4a;
        }
        
        .zoom-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid #3a4a6a;
            background: transparent;
            color: #8a9aba;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background: #1a1a2a;
            border-color: #5a6a8a;
            color: #cad9ff;
        }
        
        .zoom-slider {
            width: 140px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a3a 0%, #3a4a6a 100%);
            border-radius: 2px;
            outline: none;
        }
        
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #cad9ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(202, 217, 255, 0.5);
        }
        
        .zoom-label {
            color: #5a6a8a;
            font-size: 0.65em;
            min-width: 80px;
            text-align: center;
        }
        
        /* Calculations Panel */
        .calculations {
            background: #080810;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #1a1a3a;
        }
        
        .calc-header {
            color: #8a9aba;
            font-size: 0.7em;
            letter-spacing: 2px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1a1a3a;
        }
        
        .crr-equation {
            background: #0a0a14;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-family: 'Times New Roman', serif;
            font-size: 1em;
            text-align: center;
            color: #a0b0d0;
            border-left: 3px solid #3a4a7a;
        }
        
        .crr-component {
            background: #050508;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .component-label {
            color: #6a7a9a;
            font-size: 0.75em;
        }
        
        .component-value {
            color: #cad9ff;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .live-value {
            color: #7affaa;
            transition: color 0.1s;
        }
        
        /* Systems Grid */
        .systems-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 25px;
        }
        
        @media (max-width: 1000px) {
            .systems-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .system-panel {
            background: #080810;
            border-radius: 12px;
            padding: 18px;
            border: 1px solid #1a1a3a;
        }
        
        .system-title {
            color: #8a9aba;
            font-size: 0.65em;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }
        
        .system-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #101018;
            font-size: 0.75em;
        }
        
        .system-row:last-child {
            border-bottom: none;
        }
        
        .system-label {
            color: #5a6a8a;
        }
        
        .system-value {
            color: #a0b0c0;
        }
        
        .symmetry-z2 { color: #ff9a7a; }
        .symmetry-so2 { color: #7affda; }
        
        /* Timeline */
        .timeline-container {
            grid-column: 1 / -1;
            background: #080810;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #1a1a3a;
            margin-top: 10px;
        }
        
        .timeline-title {
            color: #8a9aba;
            font-size: 0.65em;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }
        
        .timeline {
            position: relative;
            height: 100px;
        }
        
        .timeline-bar {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                #ff6a4a 0%, #ffaa4a 20%, #4affaa 40%,
                #4a9aff 60%, #aa6aff 80%, #ff6aaa 100%
            );
            transform: translateY(-50%);
        }
        
        .timeline-point {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid;
            background: #080810;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .timeline-point:hover {
            transform: translate(-50%, -50%) scale(1.4);
            box-shadow: 0 0 15px currentColor;
        }
        
        .point-label {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 20px;
            font-size: 0.6em;
            color: #5a6a8a;
            white-space: nowrap;
            text-align: center;
        }
        
        .point-time {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 20px;
            font-size: 0.55em;
            color: #3a4a6a;
        }
        
        /* Real-time Panel */
        .realtime-panel {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #080810 0%, #0a0a18 100%);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #2a2a4a;
            margin-top: 10px;
        }
        
        .realtime-title {
            color: #7affaa;
            font-size: 0.65em;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }
        
        .realtime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }
        
        .realtime-item {
            background: #050508;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .realtime-label {
            color: #4a5a7a;
            font-size: 0.6em;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        
        .realtime-value {
            color: #7affaa;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .realtime-unit {
            color: #3a4a6a;
            font-size: 0.6em;
            margin-top: 2px;
        }
        
        /* Footer */
        footer {
            text-align: center;
            padding: 25px;
            color: #3a4a6a;
            font-size: 0.65em;
            margin-top: 25px;
            border-top: 1px solid #1a1a3a;
        }
        
        footer a {
            color: #5a7aaa;
            text-decoration: none;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000005;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-text {
            color: #6a7a9a;
            font-size: 0.8em;
            letter-spacing: 3px;
            margin-top: 20px;
        }
        
        .loading-star {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #cad9ff 0%, #4a5a8a 50%, transparent 70%);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading">
        <div class="loading-star"></div>
        <div class="loading-text">INITIALIZING STELLAR SIMULATION</div>
    </div>
    
    <div class="container">
        <header>
            <h1>CRR STAR</h1>
            <div class="subtitle">SIRIUS A — COHERENCE FROM CORE TO CORTEX</div>
        </header>
        
        <div class="main-content">
            <!-- Star Display -->
            <div class="star-container">
                <div class="star-field" id="starField"></div>
                
                <div class="controls-overlay">
                    <div class="distance-display">
                        DISTANCE: <span class="distance-value" id="distance-display">8.6 ly</span>
                    </div>
                    <div class="crr-state-display" id="crr-state">
                        <span style="color: #7affaa;">●</span> CRR ACTIVE
                    </div>
                </div>
                
                <canvas id="sirius-canvas" width="340" height="340"></canvas>
                
                <div class="star-info">
                    <div class="star-name">SIRIUS A</div>
                    <div class="star-designation">α CMa · A1V · 9,940 K · 25.4 L☉</div>
                </div>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-out">−</button>
                    <input type="range" class="zoom-slider" id="zoom-slider" min="0" max="100" value="0">
                    <button class="zoom-btn" id="zoom-in">+</button>
                    <div class="zoom-label" id="zoom-label">Earth View</div>
                </div>
            </div>
            
            <!-- CRR Calculations -->
            <div class="calculations">
                <div class="calc-header">CRR FRAMEWORK</div>
                
                <div class="crr-equation">C(x,t) = ∫ L(x,τ) dτ</div>
                <div class="crr-component">
                    <span class="component-label">Coherence</span>
                    <span class="component-value live-value" id="coherence-live">0.0000</span>
                </div>
                
                <div class="crr-equation">δ(now) — Rupture</div>
                <div class="crr-component">
                    <span class="component-label">Total Ruptures</span>
                    <span class="component-value live-value" id="rupture-count">0</span>
                </div>
                
                <div class="crr-equation">R = ∫ φ · exp(C/Ω) · Θ dτ</div>
                <div class="crr-component">
                    <span class="component-label">Memory Weight</span>
                    <span class="component-value live-value" id="memory-weight">1.0000</span>
                </div>
                
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #1a1a3a;">
                    <div class="crr-component">
                        <span class="component-label">Ω (Z₂) = 1/π</span>
                        <span class="component-value">0.31831</span>
                    </div>
                    <div class="crr-component">
                        <span class="component-label">Ω (SO(2)) = 1/2π</span>
                        <span class="component-value">0.15915</span>
                    </div>
                    <div class="crr-component">
                        <span class="component-label">e<sup>π</sup></span>
                        <span class="component-value">23.1407</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Systems Grid -->
        <div class="systems-grid">
            <div class="system-panel">
                <div class="system-title">STELLAR CRR DYNAMICS</div>
                <div class="system-row">
                    <span class="system-label">Core Fusion</span>
                    <span class="system-value">τ = 10⁻¹⁵s · <span class="symmetry-z2">Z₂</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">Radiative Diffusion</span>
                    <span class="system-value">τ = 10⁻¹⁰s · <span class="symmetry-so2">SO(2)</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">Convective Cells</span>
                    <span class="system-value">τ = 7 days · <span class="symmetry-so2">SO(2)</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">P-mode Oscillations</span>
                    <span class="system-value">τ = 46 min · <span class="symmetry-so2">SO(2)</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">Photon Escape</span>
                    <span class="system-value">~10,000 years</span>
                </div>
            </div>
            
            <div class="system-panel">
                <div class="system-title">OBSERVER CRR CHAIN</div>
                <div class="system-row">
                    <span class="system-label">Atmospheric Seeing</span>
                    <span class="system-value">τ = 3.14ms · <span class="symmetry-so2">SO(2)</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">Retinal Integration</span>
                    <span class="system-value">τ = 100ms · <span class="symmetry-z2">Z₂</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">V1 Gamma</span>
                    <span class="system-value">40 Hz · <span class="symmetry-so2">SO(2)</span></span>
                </div>
                <div class="system-row">
                    <span class="system-label">Cortical Gain</span>
                    <span class="system-value">e<sup>π</sup> ≈ 23.14 / level</span>
                </div>
                <div class="system-row">
                    <span class="system-label">Display Refresh</span>
                    <span class="system-value">60 Hz · <span class="symmetry-z2">Z₂</span></span>
                </div>
            </div>
        </div>
        
        <!-- Timeline -->
        <div class="timeline-container">
            <div class="timeline-title">COHERENCE CHAIN: FUSION → PERCEPTION</div>
            <div class="timeline">
                <div class="timeline-bar"></div>
                <div class="timeline-point" style="left: 0%; border-color: #ff6a4a; color: #ff6a4a;">
                    <div class="point-time">10⁻¹⁵s</div>
                    <div class="point-label">Fusion</div>
                </div>
                <div class="timeline-point" style="left: 17%; border-color: #ff8a4a; color: #ff8a4a;">
                    <div class="point-time">10⁴ yr</div>
                    <div class="point-label">Escape</div>
                </div>
                <div class="timeline-point" style="left: 34%; border-color: #ffda4a; color: #ffda4a;">
                    <div class="point-time">8.6 yr</div>
                    <div class="point-label">Transit</div>
                </div>
                <div class="timeline-point" style="left: 51%; border-color: #4affaa; color: #4affaa;">
                    <div class="point-time">3ms</div>
                    <div class="point-label">Atmosphere</div>
                </div>
                <div class="timeline-point" style="left: 68%; border-color: #4adaff; color: #4adaff;">
                    <div class="point-time">100ms</div>
                    <div class="point-label">Retina</div>
                </div>
                <div class="timeline-point" style="left: 85%; border-color: #aa6aff; color: #aa6aff;">
                    <div class="point-time">25ms</div>
                    <div class="point-label">V1 Cortex</div>
                </div>
            </div>
        </div>
        
        <!-- Real-time Panel -->
        <div class="realtime-panel">
            <div class="realtime-title">◉ LIVE CRR DYNAMICS</div>
            <div class="realtime-grid">
                <div class="realtime-item">
                    <div class="realtime-label">DISPLAY δ</div>
                    <div class="realtime-value" id="display-ruptures">0</div>
                    <div class="realtime-unit">frames</div>
                </div>
                <div class="realtime-item">
                    <div class="realtime-label">ATMOSPHERIC δ</div>
                    <div class="realtime-value" id="atm-ruptures">0</div>
                    <div class="realtime-unit">cells</div>
                </div>
                <div class="realtime-item">
                    <div class="realtime-label">RETINAL C</div>
                    <div class="realtime-value" id="retinal-cycles">0</div>
                    <div class="realtime-unit">integrations</div>
                </div>
                <div class="realtime-item">
                    <div class="realtime-label">V1 GAMMA</div>
                    <div class="realtime-value" id="gamma-cycles">0</div>
                    <div class="realtime-unit">cycles</div>
                </div>
                <div class="realtime-item">
                    <div class="realtime-label">SCINTILLATION</div>
                    <div class="realtime-value" id="current-brightness">100%</div>
                    <div class="realtime-unit">intensity</div>
                </div>
                <div class="realtime-item">
                    <div class="realtime-label">SESSION C(t)</div>
                    <div class="realtime-value" id="session-coherence">0.00</div>
                    <div class="realtime-unit">accumulated</div>
                </div>
            </div>
        </div>
        
        <footer>
            CRR Framework © 2025 Alexander Sabine · <a href="https://cohere.org.uk">cohere.org.uk</a><br>
            <span style="color: #2a3a5a;">Asteroseismology sonification based on actual stellar oscillation modes</span>
        </footer>
    </div>
    
    <script>
        // ============================================
        // CRR CONSTANTS
        // ============================================
        const OMEGA_Z2 = 1 / Math.PI;
        const OMEGA_SO2 = 1 / (2 * Math.PI);
        const EXP_PI = Math.exp(Math.PI);
        
        const TAU_DISPLAY = 1/60;
        const TAU_ATM = 0.00314;
        const TAU_RETINAL = 0.1;
        const TAU_GAMMA = 0.025;
        
        // ============================================
        // STELLAR PHYSICS CONSTANTS
        // ============================================
        const SIRIUS = {
            temperature: 9940,          // K
            radius_solar: 1.711,
            mass_solar: 2.063,
            luminosity_solar: 25.4,
            distance_ly: 8.6,
            // Oscillation periods (asteroseismology)
            p_mode_period: 2760,        // seconds (~46 min for fundamental)
            convective_turnover: 604800, // ~7 days in seconds
            // Derived
            rgb: { r: 202, g: 218, b: 255 }
        };
        
        const SOLAR_RADIUS_KM = 696340;
        const LY_TO_KM = 9.461e12;
        const SIRIUS_RADIUS_KM = SIRIUS.radius_solar * SOLAR_RADIUS_KM;
        
        // ============================================
        // VISUAL RENDERING
        // ============================================
        const canvas = document.getElementById('sirius-canvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let startTime = Date.now();
        let zoomLevel = 0;
        let targetZoom = 0;
        let lastFrameTime = 0;
        
        // Counters
        let displayRuptures = 0;
        let atmRuptures = 0;
        let retinalCycles = 0;
        let gammaCycles = 0;
        let sessionCoherence = 0;
        
        // Scintillation
        let scintillationPhase = Math.random() * Math.PI * 2;
        let currentBrightness = 1.0;
        
        // Granulation cells (persistent for animation)
        let granulationCells = [];
        const NUM_GRANULATION_CELLS = 150;
        
        function initGranulationCells() {
            granulationCells = [];
            for (let i = 0; i < NUM_GRANULATION_CELLS; i++) {
                granulationCells.push({
                    angle: Math.random() * Math.PI * 2,
                    radius: Math.random(),  // 0-1, fraction of stellar radius
                    size: 0.03 + Math.random() * 0.05,
                    brightness: Math.random(),
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.0001 + Math.random() * 0.0002,
                    lifePhase: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Prominences
        let prominences = [];
        const NUM_PROMINENCES = 5;
        
        function initProminences() {
            prominences = [];
            for (let i = 0; i < NUM_PROMINENCES; i++) {
                prominences.push({
                    angle: Math.random() * Math.PI * 2,
                    height: 0.1 + Math.random() * 0.2,
                    width: 0.05 + Math.random() * 0.1,
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.001 + Math.random() * 0.002,
                    active: Math.random() > 0.5
                });
            }
        }
        
        function createStarField() {
            const field = document.getElementById('starField');
            for (let i = 0; i < 60; i++) {
                const star = document.createElement('div');
                star.className = 'background-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                const size = Math.random() * 1.5 + 0.5;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.opacity = Math.random() * 0.4 + 0.1;
                field.appendChild(star);
            }
        }
        
        // ============================================
        // SCINTILLATION MODEL
        // ============================================
        function computeScintillation(t, zoomFactor) {
            // Kolmogorov turbulence - multiple frequency components
            const f1 = 318;
            const f2 = 159;
            const f3 = 50;
            const f4 = 15;
            
            // Scintillation decreases with zoom (leaving atmosphere)
            const sigmaI = 0.12 * (1 - zoomFactor * 0.95);
            
            const variation = 
                0.4 * Math.sin(2 * Math.PI * f1 * t + scintillationPhase) +
                0.3 * Math.sin(2 * Math.PI * f2 * t + scintillationPhase * 1.3) +
                0.2 * Math.sin(2 * Math.PI * f3 * t + scintillationPhase * 0.7) +
                0.1 * Math.sin(2 * Math.PI * f4 * t + scintillationPhase * 2.1);
            
            return 1.0 + sigmaI * variation;
        }
        
        // ============================================
        // STELLAR RENDERING
        // ============================================
        function drawSirius(brightness, t) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            const zoomFactor = Math.pow(zoomLevel / 100, 2);
            
            // Apparent size calculation
            const baseSize = 4;
            const maxSize = 140;
            const apparentSize = baseSize + (maxSize - baseSize) * zoomFactor;
            
            // Different rendering modes based on zoom
            if (zoomFactor < 0.1) {
                drawDistantStar(cx, cy, apparentSize, brightness, zoomFactor, t);
            } else if (zoomFactor < 0.4) {
                drawApproachingStar(cx, cy, apparentSize, brightness, zoomFactor, t);
            } else {
                drawCloseStar(cx, cy, apparentSize, brightness, zoomFactor, t);
            }
        }
        
        function drawDistantStar(cx, cy, size, brightness, zoomFactor, t) {
            // Point source with atmospheric effects
            const glowLayers = [
                { radius: 100, alpha: 0.02 },
                { radius: 70, alpha: 0.04 },
                { radius: 50, alpha: 0.06 },
                { radius: 35, alpha: 0.1 },
                { radius: 20, alpha: 0.2 },
                { radius: 10, alpha: 0.5 },
                { radius: size, alpha: 0.9 }
            ];
            
            glowLayers.forEach(layer => {
                const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, layer.radius * brightness);
                gradient.addColorStop(0, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${layer.alpha * brightness})`);
                gradient.addColorStop(0.6, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${layer.alpha * 0.2 * brightness})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cx, cy, layer.radius * brightness, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Diffraction spikes
            drawDiffractionSpikes(cx, cy, brightness, 60, 0.15);
            
            // Core
            const coreGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, size * 1.5);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${brightness})`);
            coreGradient.addColorStop(0.3, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${brightness})`);
            coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawApproachingStar(cx, cy, size, brightness, zoomFactor, t) {
            // Transition phase - growing disk with fading spikes
            
            // Outer glow
            const outerGlow = ctx.createRadialGradient(cx, cy, size * 0.5, cx, cy, size * 2);
            outerGlow.addColorStop(0, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${0.3 * brightness})`);
            outerGlow.addColorStop(0.5, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${0.1 * brightness})`);
            outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(cx, cy, size * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Main disk with limb darkening
            drawStellarDisk(cx, cy, size, brightness, zoomFactor, t);
            
            // Fading diffraction spikes
            const spikeOpacity = 0.15 * (1 - zoomFactor * 2);
            if (spikeOpacity > 0.01) {
                drawDiffractionSpikes(cx, cy, brightness, 80, spikeOpacity);
            }
        }
        
        function drawCloseStar(cx, cy, size, brightness, zoomFactor, t) {
            // Full stellar disk with surface detail
            
            // Corona
            drawCorona(cx, cy, size, brightness, t);
            
            // Chromosphere (thin colored layer)
            drawChromosphere(cx, cy, size, brightness, zoomFactor);
            
            // Photosphere (main visible surface)
            drawStellarDisk(cx, cy, size, brightness, zoomFactor, t);
            
            // Granulation
            if (zoomFactor > 0.5) {
                drawGranulation(cx, cy, size, brightness, zoomFactor, t);
            }
            
            // Prominences
            if (zoomFactor > 0.6) {
                drawProminences(cx, cy, size, brightness, t);
            }
        }
        
        function drawStellarDisk(cx, cy, radius, brightness, zoomFactor, t) {
            // Limb darkening using Eddington approximation
            // I(θ)/I(0) = 0.4 + 0.6*cos(θ)
            
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            
            // Core (very hot)
            gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness})`);
            gradient.addColorStop(0.1, `rgba(255, 252, 255, ${brightness})`);
            
            // Main photosphere
            gradient.addColorStop(0.3, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${brightness})`);
            gradient.addColorStop(0.6, `rgba(${Math.floor(SIRIUS.rgb.r * 0.9)}, ${Math.floor(SIRIUS.rgb.g * 0.92)}, ${SIRIUS.rgb.b}, ${brightness})`);
            
            // Limb darkening
            gradient.addColorStop(0.85, `rgba(${Math.floor(SIRIUS.rgb.r * 0.7)}, ${Math.floor(SIRIUS.rgb.g * 0.75)}, ${Math.floor(SIRIUS.rgb.b * 0.85)}, ${brightness})`);
            gradient.addColorStop(0.95, `rgba(${Math.floor(SIRIUS.rgb.r * 0.4)}, ${Math.floor(SIRIUS.rgb.g * 0.5)}, ${Math.floor(SIRIUS.rgb.b * 0.7)}, ${brightness * 0.8})`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // P-mode oscillation effect (subtle pulsing)
            const pModePhase = (t % SIRIUS.p_mode_period) / SIRIUS.p_mode_period;
            const pModeAmp = Math.sin(pModePhase * 2 * Math.PI) * 0.005;
            
            if (zoomFactor > 0.3 && Math.abs(pModeAmp) > 0.001) {
                const pulseGradient = ctx.createRadialGradient(cx, cy, radius * 0.8, cx, cy, radius);
                pulseGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                pulseGradient.addColorStop(0.5, `rgba(255, 255, 255, ${Math.abs(pModeAmp) * brightness * 5})`);
                pulseGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = pulseGradient;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawGranulation(cx, cy, radius, brightness, zoomFactor, t) {
            const granIntensity = Math.min(1, (zoomFactor - 0.5) * 2);
            
            ctx.save();
            
            // Clip to stellar disk
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.95, 0, Math.PI * 2);
            ctx.clip();
            
            granulationCells.forEach((cell, i) => {
                // Update cell position (convective motion)
                cell.angle += cell.speed * (1 + Math.sin(t * 0.1 + cell.phase) * 0.3);
                cell.lifePhase += 0.002;
                
                // Cell brightness varies with lifecycle
                const lifeBrightness = 0.5 + 0.5 * Math.sin(cell.lifePhase);
                
                const cellDist = cell.radius * radius * 0.9;
                const cellX = cx + Math.cos(cell.angle) * cellDist;
                const cellY = cy + Math.sin(cell.angle) * cellDist;
                
                const cellRadius = cell.size * radius;
                
                // Hot rising center, cooler sinking edges (convective pattern)
                const cellGradient = ctx.createRadialGradient(
                    cellX, cellY, 0,
                    cellX, cellY, cellRadius
                );
                
                const alpha = 0.08 * granIntensity * lifeBrightness * brightness;
                cellGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                cellGradient.addColorStop(0.4, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${alpha * 0.5})`);
                cellGradient.addColorStop(0.8, `rgba(${Math.floor(SIRIUS.rgb.r * 0.6)}, ${Math.floor(SIRIUS.rgb.g * 0.7)}, ${Math.floor(SIRIUS.rgb.b * 0.8)}, ${alpha * 0.3})`);
                cellGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = cellGradient;
                ctx.beginPath();
                ctx.arc(cellX, cellY, cellRadius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
            
            // Intergranular lanes (dark network between cells)
            if (granIntensity > 0.5) {
                const laneAlpha = (granIntensity - 0.5) * 0.1 * brightness;
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.95, 0, Math.PI * 2);
                ctx.clip();
                
                // Create subtle dark network
                ctx.strokeStyle = `rgba(0, 0, 50, ${laneAlpha})`;
                ctx.lineWidth = 0.5;
                
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const r1 = radius * (0.3 + Math.random() * 0.5);
                    const r2 = radius * (0.3 + Math.random() * 0.5);
                    
                    ctx.beginPath();
                    ctx.moveTo(cx + Math.cos(angle) * r1, cy + Math.sin(angle) * r1);
                    ctx.quadraticCurveTo(
                        cx + Math.cos(angle + 0.2) * radius * 0.6,
                        cy + Math.sin(angle + 0.2) * radius * 0.6,
                        cx + Math.cos(angle + 0.4) * r2,
                        cy + Math.sin(angle + 0.4) * r2
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        function drawChromosphere(cx, cy, radius, brightness, zoomFactor) {
            if (zoomFactor < 0.4) return;
            
            const chromoIntensity = Math.min(1, (zoomFactor - 0.4) * 2);
            
            // Thin pinkish layer at the limb (H-alpha emission)
            const chromoGradient = ctx.createRadialGradient(cx, cy, radius * 0.92, cx, cy, radius * 1.02);
            chromoGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            chromoGradient.addColorStop(0.3, `rgba(255, 150, 180, ${0.1 * chromoIntensity * brightness})`);
            chromoGradient.addColorStop(0.7, `rgba(255, 120, 160, ${0.15 * chromoIntensity * brightness})`);
            chromoGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = chromoGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 1.02, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ============================================
        // CRR-EMERGENT CORONA & PROMINENCES
        // ============================================
        
        // Magnetic field line class with CRR dynamics
        class MagneticFieldLine {
            constructor(footpointAngle, polarity) {
                this.footpointAngle = footpointAngle;
                this.polarity = polarity; // +1 or -1
                this.maxHeight = 0.05 + Math.random() * 0.15;
                this.arcWidth = 0.1 + Math.random() * 0.2;
                
                // CRR state
                this.coherence = Math.random() * 0.5; // C(t)
                this.omega = OMEGA_SO2; // SO(2) - continuous magnetic topology
                this.lastRupture = 0;
                this.state = 'coherent'; // coherent, rupturing, regenerating
                this.stateTimer = 0;
                
                // Visual properties
                this.opacity = 0;
                this.targetOpacity = 0;
            }
            
            update(dt, t) {
                // CRR dynamics for magnetic field evolution
                
                if (this.state === 'coherent') {
                    // Accumulate coherence: C(t) = ∫L(x,τ)dτ
                    const L = 0.0001 + Math.random() * 0.0002; // Magnetic stress accumulation rate
                    this.coherence += L * dt;
                    
                    // Check for rupture: when C exceeds threshold
                    // Threshold modulated by exp(C/Ω)
                    const ruptureThreshold = this.omega * (1 + Math.random() * 0.5);
                    const memoryWeight = Math.exp(this.coherence / this.omega);
                    
                    if (this.coherence > ruptureThreshold || memoryWeight > 3) {
                        this.state = 'rupturing';
                        this.stateTimer = 0;
                        this.lastRupture = t;
                    }
                    
                    this.targetOpacity = Math.min(0.6, this.coherence * 2);
                    
                } else if (this.state === 'rupturing') {
                    // Rupture: δ(now) - rapid release
                    this.stateTimer += dt;
                    
                    // Rupture lasts ~0.5-2 seconds
                    const ruptureDuration = 0.5 + this.maxHeight * 5;
                    
                    if (this.stateTimer > ruptureDuration) {
                        this.state = 'regenerating';
                        this.stateTimer = 0;
                        this.coherence = 0;
                    }
                    
                    // Bright flash during rupture
                    const ruptureProgress = this.stateTimer / ruptureDuration;
                    this.targetOpacity = 0.8 * (1 - ruptureProgress);
                    
                } else if (this.state === 'regenerating') {
                    // Regeneration: R = ∫φ·exp(C/Ω)·Θ dτ
                    this.stateTimer += dt;
                    
                    // Regeneration takes longer than rupture
                    const regenDuration = 2 + Math.random() * 3;
                    
                    if (this.stateTimer > regenDuration) {
                        this.state = 'coherent';
                        this.stateTimer = 0;
                        // New random properties after regeneration
                        this.maxHeight = 0.05 + Math.random() * 0.15;
                        this.arcWidth = 0.1 + Math.random() * 0.2;
                    }
                    
                    this.targetOpacity = 0.1 * (this.stateTimer / regenDuration);
                }
                
                // Smooth opacity transitions
                this.opacity += (this.targetOpacity - this.opacity) * 0.05;
            }
        }
        
        // Prominence with Z₂ CRR dynamics (binary: quiescent/eruptive)
        class Prominence {
            constructor(angle) {
                this.angle = angle;
                this.baseAngle = angle;
                
                // Physical properties
                this.maxHeight = 0.08 + Math.random() * 0.12;
                this.width = 0.02 + Math.random() * 0.03;
                this.curvature = (Math.random() - 0.5) * 0.4;
                
                // CRR state - Z₂ symmetry (binary state)
                this.omega = OMEGA_Z2;
                this.coherence = Math.random();
                this.state = Math.random() > 0.7 ? 'active' : 'quiescent';
                this.stateTimer = Math.random() * 10;
                
                // Current visual state
                this.currentHeight = 0;
                this.targetHeight = 0;
                this.opacity = 0;
                
                // Plasma flow along the loop
                this.plasmaPhase = Math.random() * Math.PI * 2;
            }
            
            update(dt, t) {
                // Z₂ CRR: binary flip between quiescent and active
                
                this.coherence += dt * 0.05;
                this.stateTimer += dt;
                this.plasmaPhase += dt * 0.5;
                
                // Memory weight determines transition probability
                const memoryWeight = Math.exp(this.coherence / this.omega);
                
                if (this.state === 'quiescent') {
                    // Quiescent: building magnetic tension
                    this.targetHeight = this.maxHeight * 0.1;
                    
                    // Z₂ rupture: binary flip to active
                    const transitionProb = 0.001 * memoryWeight;
                    if (Math.random() < transitionProb * dt) {
                        this.state = 'erupting';
                        this.stateTimer = 0;
                        this.coherence = 0;
                    }
                    
                } else if (this.state === 'erupting') {
                    // Rapid rise phase
                    const eruptDuration = 1.5;
                    const progress = Math.min(1, this.stateTimer / eruptDuration);
                    
                    // Easing function for natural motion
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    this.targetHeight = this.maxHeight * easeOut;
                    
                    if (this.stateTimer > eruptDuration) {
                        this.state = 'active';
                        this.stateTimer = 0;
                    }
                    
                } else if (this.state === 'active') {
                    // Sustained prominence
                    this.targetHeight = this.maxHeight * (0.8 + 0.2 * Math.sin(t * 0.3));
                    
                    // Eventually collapse back
                    const collapseProb = 0.002 * memoryWeight;
                    if (Math.random() < collapseProb * dt || this.stateTimer > 15) {
                        this.state = 'collapsing';
                        this.stateTimer = 0;
                        this.coherence = 0;
                    }
                    
                } else if (this.state === 'collapsing') {
                    // Fall back to surface
                    const collapseDuration = 2;
                    const progress = Math.min(1, this.stateTimer / collapseDuration);
                    const easeIn = progress * progress;
                    this.targetHeight = this.maxHeight * (1 - easeIn);
                    
                    if (this.stateTimer > collapseDuration) {
                        this.state = 'quiescent';
                        this.stateTimer = 0;
                        // Regenerate with new properties
                        this.maxHeight = 0.08 + Math.random() * 0.12;
                        this.curvature = (Math.random() - 0.5) * 0.4;
                    }
                }
                
                // Smooth height transitions
                this.currentHeight += (this.targetHeight - this.currentHeight) * 0.03;
                this.opacity = Math.min(1, this.currentHeight / this.maxHeight);
                
                // Gentle drift in position
                this.angle = this.baseAngle + Math.sin(t * 0.05) * 0.02;
            }
        }
        
        // Initialize CRR-driven structures
        let magneticFieldLines = [];
        let crrProminences = [];
        
        function initMagneticStructures() {
            // Magnetic field lines (corona structure)
            magneticFieldLines = [];
            const numLines = 12;
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2 + Math.random() * 0.2;
                const polarity = i % 2 === 0 ? 1 : -1;
                magneticFieldLines.push(new MagneticFieldLine(angle, polarity));
            }
            
            // Prominences
            crrProminences = [];
            const numProms = 4;
            for (let i = 0; i < numProms; i++) {
                const angle = (i / numProms) * Math.PI * 2 + Math.random() * 0.5;
                crrProminences.push(new Prominence(angle));
            }
        }
        
        function drawCorona(cx, cy, radius, brightness, t) {
            const zoomFactor = Math.pow(zoomLevel / 100, 2);
            
            // Only show corona when close enough
            if (zoomFactor < 0.3) return;
            
            const coronaVisibility = Math.min(1, (zoomFactor - 0.3) * 2);
            
            // Soft, diffuse corona glow (no hard edges)
            const coronaRadius = radius * 1.4;
            
            const coronaGradient = ctx.createRadialGradient(cx, cy, radius * 0.98, cx, cy, coronaRadius);
            coronaGradient.addColorStop(0, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${0.12 * brightness * coronaVisibility})`);
            coronaGradient.addColorStop(0.3, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${0.06 * brightness * coronaVisibility})`);
            coronaGradient.addColorStop(0.6, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${0.02 * brightness * coronaVisibility})`);
            coronaGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = coronaGradient;
            ctx.beginPath();
            ctx.arc(cx, cy, coronaRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Update and draw magnetic field structures
            const dt = 16.67; // Approximate frame time in ms
            
            magneticFieldLines.forEach(line => {
                line.update(dt, t);
                
                if (line.opacity < 0.01) return;
                
                // Draw as soft, curved coronal loop
                const baseAngle = line.footpointAngle;
                const arcSpan = line.arcWidth;
                const height = line.maxHeight * radius * (line.state === 'rupturing' ? 1.5 : 1);
                
                // Foot points
                const foot1Angle = baseAngle - arcSpan / 2;
                const foot2Angle = baseAngle + arcSpan / 2;
                
                const foot1X = cx + Math.cos(foot1Angle) * radius;
                const foot1Y = cy + Math.sin(foot1Angle) * radius;
                const foot2X = cx + Math.cos(foot2Angle) * radius;
                const foot2Y = cy + Math.sin(foot2Angle) * radius;
                
                // Apex of the loop
                const apexAngle = baseAngle;
                const apexDist = radius + height;
                const apexX = cx + Math.cos(apexAngle) * apexDist;
                const apexY = cy + Math.sin(apexAngle) * apexDist;
                
                // Draw as gradient-filled arc
                const loopGradient = ctx.createRadialGradient(
                    cx, cy, radius,
                    cx, cy, radius + height
                );
                
                const baseAlpha = line.opacity * coronaVisibility * brightness;
                const color = line.state === 'rupturing' 
                    ? `rgba(255, 220, 240, ${baseAlpha})`
                    : `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${baseAlpha * 0.5})`;
                
                loopGradient.addColorStop(0, color);
                loopGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.save();
                ctx.strokeStyle = loopGradient;
                ctx.lineWidth = 2 + line.opacity * 3;
                ctx.lineCap = 'round';
                ctx.globalAlpha = coronaVisibility;
                
                // Smooth bezier curve for the loop
                ctx.beginPath();
                ctx.moveTo(foot1X, foot1Y);
                ctx.quadraticCurveTo(apexX, apexY, foot2X, foot2Y);
                ctx.stroke();
                
                ctx.restore();
            });
        }
        
        function drawProminences(cx, cy, radius, brightness, t) {
            const zoomFactor = Math.pow(zoomLevel / 100, 2);
            
            if (zoomFactor < 0.5) return;
            
            const promVisibility = Math.min(1, (zoomFactor - 0.5) * 2);
            const dt = 16.67;
            
            ctx.save();
            
            crrProminences.forEach(prom => {
                prom.update(dt / 1000, t);
                
                if (prom.currentHeight < 0.01 || prom.opacity < 0.05) return;
                
                const height = prom.currentHeight * radius;
                const width = prom.width * radius;
                
                // Base point on stellar limb
                const baseX = cx + Math.cos(prom.angle) * radius * 0.99;
                const baseY = cy + Math.sin(prom.angle) * radius * 0.99;
                
                // Apex with curvature
                const curveOffset = prom.curvature;
                const apexAngle = prom.angle + curveOffset * (prom.currentHeight / prom.maxHeight);
                const apexX = cx + Math.cos(apexAngle) * (radius + height);
                const apexY = cy + Math.sin(apexAngle) * (radius + height);
                
                // Second foot point (for loop prominences)
                const foot2Angle = prom.angle + curveOffset * 2;
                const foot2X = cx + Math.cos(foot2Angle) * radius * 0.99;
                const foot2Y = cy + Math.sin(foot2Angle) * radius * 0.99;
                
                // Prominence color - H-alpha red/pink
                const alpha = prom.opacity * promVisibility * brightness * 0.7;
                
                // Draw as filled loop shape
                const promGradient = ctx.createRadialGradient(
                    baseX, baseY, 0,
                    apexX, apexY, height
                );
                
                promGradient.addColorStop(0, `rgba(255, 120, 140, ${alpha})`);
                promGradient.addColorStop(0.5, `rgba(255, 90, 120, ${alpha * 0.7})`);
                promGradient.addColorStop(1, `rgba(255, 60, 100, ${alpha * 0.2})`);
                
                // Draw prominence as thick, soft curve
                ctx.strokeStyle = promGradient;
                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                
                // Control points for natural arch shape
                const ctrl1X = cx + Math.cos(prom.angle - curveOffset * 0.3) * (radius + height * 0.6);
                const ctrl1Y = cy + Math.sin(prom.angle - curveOffset * 0.3) * (radius + height * 0.6);
                const ctrl2X = cx + Math.cos(prom.angle + curveOffset * 0.7) * (radius + height * 0.8);
                const ctrl2Y = cy + Math.sin(prom.angle + curveOffset * 0.7) * (radius + height * 0.8);
                
                ctx.bezierCurveTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, foot2X, foot2Y);
                ctx.stroke();
                
                // Plasma flow visualization (bright blobs moving along loop)
                if (prom.state === 'active' && prom.opacity > 0.3) {
                    const numBlobs = 3;
                    for (let i = 0; i < numBlobs; i++) {
                        const blobPhase = (prom.plasmaPhase + i * Math.PI * 2 / numBlobs) % (Math.PI * 2);
                        const blobT = (Math.sin(blobPhase) + 1) / 2; // 0 to 1 along curve
                        
                        // Interpolate position along bezier
                        const blobX = bezierPoint(baseX, ctrl1X, ctrl2X, foot2X, blobT);
                        const blobY = bezierPoint(baseY, ctrl1Y, ctrl2Y, foot2Y, blobT);
                        
                        const blobGlow = ctx.createRadialGradient(blobX, blobY, 0, blobX, blobY, width * 0.8);
                        blobGlow.addColorStop(0, `rgba(255, 180, 200, ${alpha * 0.5})`);
                        blobGlow.addColorStop(0.5, `rgba(255, 140, 170, ${alpha * 0.2})`);
                        blobGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        
                        ctx.fillStyle = blobGlow;
                        ctx.beginPath();
                        ctx.arc(blobX, blobY, width * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
            ctx.restore();
        }
        
        // Bezier interpolation helper
        function bezierPoint(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
        }
        
        function drawDiffractionSpikes(cx, cy, brightness, length, opacity) {
            ctx.save();
            ctx.strokeStyle = `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${opacity * brightness})`;
            ctx.lineWidth = 1;
            
            const angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
            
            angles.forEach((angle, i) => {
                const gradient = ctx.createLinearGradient(
                    cx, cy,
                    cx + Math.cos(angle) * length,
                    cy + Math.sin(angle) * length
                );
                gradient.addColorStop(0, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${opacity * brightness})`);
                gradient.addColorStop(0.3, `rgba(${SIRIUS.rgb.r}, ${SIRIUS.rgb.g}, ${SIRIUS.rgb.b}, ${opacity * 0.5 * brightness})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.strokeStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle) * length, cy + Math.sin(angle) * length);
                ctx.stroke();
            });
            
            ctx.restore();
        }
        
        // ============================================
        // ZOOM & DISTANCE
        // ============================================
        function getApparentDistance(zoom) {
            const minDist = SIRIUS_RADIUS_KM * 5;
            const maxDist = SIRIUS.distance_ly * LY_TO_KM;
            const zoomFactor = Math.pow(zoom / 100, 2);
            return maxDist * Math.pow(minDist / maxDist, zoomFactor);
        }
        
        function formatDistance(distanceKm) {
            const ly = distanceKm / LY_TO_KM;
            const au = distanceKm / 1.496e8;
            const solarRadii = distanceKm / SOLAR_RADIUS_KM;
            const siriusRadii = distanceKm / SIRIUS_RADIUS_KM;
            
            if (ly > 0.1) return ly.toFixed(2) + ' ly';
            if (au > 100) return Math.floor(au).toLocaleString() + ' AU';
            if (au > 1) return au.toFixed(1) + ' AU';
            if (solarRadii > 50) return Math.floor(solarRadii).toLocaleString() + ' R☉';
            if (siriusRadii > 10) return siriusRadii.toFixed(0) + ' R*';
            return siriusRadii.toFixed(1) + ' R*';
        }
        
        function getZoomLabel(zoom) {
            if (zoom < 5) return 'Earth View';
            if (zoom < 20) return 'Interstellar';
            if (zoom < 40) return 'Approaching';
            if (zoom < 60) return 'Near Star';
            if (zoom < 80) return 'Photosphere';
            return 'Surface Detail';
        }
        
        function updateZoomDisplay() {
            const distance = getApparentDistance(zoomLevel);
            document.getElementById('distance-display').textContent = formatDistance(distance);
            document.getElementById('zoom-label').textContent = getZoomLabel(zoomLevel);
            document.getElementById('zoom-slider').value = zoomLevel;
        }
        
        // ============================================
        // CRR CALCULATIONS
        // ============================================
        function updateDisplays() {
            document.getElementById('display-ruptures').textContent = displayRuptures.toLocaleString();
            document.getElementById('atm-ruptures').textContent = atmRuptures.toLocaleString();
            document.getElementById('retinal-cycles').textContent = retinalCycles.toLocaleString();
            document.getElementById('gamma-cycles').textContent = gammaCycles.toLocaleString();
            document.getElementById('current-brightness').textContent = (currentBrightness * 100).toFixed(1) + '%';
            document.getElementById('session-coherence').textContent = sessionCoherence.toFixed(2);
            
            document.getElementById('coherence-live').textContent = sessionCoherence.toFixed(4);
            
            const memWeight = Math.exp(Math.min(sessionCoherence / OMEGA_SO2, 10));
            document.getElementById('memory-weight').textContent = memWeight.toFixed(4);
            
            document.getElementById('rupture-count').textContent = 
                (displayRuptures + atmRuptures + retinalCycles + gammaCycles).toLocaleString();
        }
        
        // ============================================
        // MAIN ANIMATION LOOP
        // ============================================
        function animate(timestamp) {
            const t = (Date.now() - startTime) / 1000;
            const dt = timestamp - (lastFrameTime || timestamp);
            lastFrameTime = timestamp;
            
            // Smooth zoom
            zoomLevel += (targetZoom - zoomLevel) * 0.06;
            updateZoomDisplay();
            
            const zoomFactor = Math.pow(zoomLevel / 100, 2);
            
            // CRR accumulation
            sessionCoherence += dt / 1000;
            displayRuptures = Math.floor(t / TAU_DISPLAY);
            atmRuptures = Math.floor(t / TAU_ATM);
            retinalCycles = Math.floor(t / TAU_RETINAL);
            gammaCycles = Math.floor(t / TAU_GAMMA);
            
            // Scintillation
            currentBrightness = computeScintillation(t, zoomFactor);
            
            // Render
            drawSirius(currentBrightness, t);
            
            // Update displays
            updateDisplays();
            
            requestAnimationFrame(animate);
        }
        
        // ============================================
        // CONTROLS
        // ============================================
        function setupControls() {
            const slider = document.getElementById('zoom-slider');
            const zoomIn = document.getElementById('zoom-in');
            const zoomOut = document.getElementById('zoom-out');
            
            slider.addEventListener('input', (e) => {
                targetZoom = parseFloat(e.target.value);
            });
            
            zoomIn.addEventListener('click', () => {
                targetZoom = Math.min(100, targetZoom + 10);
            });
            
            zoomOut.addEventListener('click', () => {
                targetZoom = Math.max(0, targetZoom - 10);
            });
            
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === '=') {
                    targetZoom = Math.min(100, targetZoom + 5);
                } else if (e.key === 'ArrowDown' || e.key === '-') {
                    targetZoom = Math.max(0, targetZoom - 5);
                } else if (e.key === 'Home') {
                    targetZoom = 0;
                } else if (e.key === 'End') {
                    targetZoom = 100;
                }
            });
            
            // Mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -5 : 5;
                targetZoom = Math.max(0, Math.min(100, targetZoom + delta));
            });
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            createStarField();
            initGranulationCells();
            initMagneticStructures();
            setupControls();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);
            
            requestAnimationFrame(animate);
            
            console.log('CRR Star v3 initialized');
            console.log('Magnetic structures with CRR dynamics');
        }
        
        init();
    </script>
</body>
</html>
