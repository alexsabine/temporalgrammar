<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Inference & CRR — Learning Through Rupture</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400;1,500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-cream: #faf8f4;
            --bg-warm: #f4f1ea;
            --bg-panel: #ffffff;
            --bg-code: #2c2c2c;
            --text-dark: #1a1a1a;
            --text-body: #333333;
            --text-muted: #666666;
            --accent-piaget: #8b4513;
            --accent-piaget-light: #f5ebe0;
            --accent-fep: #234e70;
            --accent-fep-light: #e8f0f5;
            --accent-crr: #6a1b9a;
            --accent-crr-light: #f3e5f5;
            --border-color: #d4d0c8;
            --surprise-color: #c62828;
            --success-color: #2e7d32;
            --rupture-color: #d32f2f;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Crimson Pro', Georgia, serif;
            background: var(--bg-cream);
            color: var(--text-body);
            line-height: 1.75;
            font-size: 17px;
        }
        
        header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 2rem 2rem;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            font-weight: 400;
            color: var(--text-dark);
            margin-bottom: 0.4rem;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--text-muted);
            font-style: italic;
        }
        
        .instruction-note {
            display: inline-block;
            margin-top: 1rem;
            padding: 0.4rem 1rem;
            background: var(--accent-fep-light);
            border: 1px solid var(--accent-fep);
            font-size: 0.85rem;
            color: var(--accent-fep);
        }
        
        .main-container {
            max-width: 1250px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        
        .stage-section {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        @media (max-width: 1000px) {
            .stage-section { grid-template-columns: 1fr; }
        }
        
        .stage-container {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
        }
        
        .stage-header {
            padding: 0.8rem 1.25rem;
            background: var(--bg-warm);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stage-title { font-weight: 500; color: var(--text-dark); font-size: 0.95rem; }
        .stage-controls { display: flex; gap: 0.4rem; }
        
        .btn {
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 0.85rem;
            padding: 0.4rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--bg-panel);
            color: var(--text-body);
            cursor: pointer;
        }
        
        .btn:hover { background: var(--bg-warm); }
        
        .btn-primary {
            background: var(--accent-fep);
            color: white;
            border-color: var(--accent-fep);
        }
        
        #canvas { 
            display: block; 
            width: 100%; 
            height: 480px; 
            cursor: pointer;
        }
        
        .commentary-panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        
        .commentary-header {
            padding: 0.8rem 1.25rem;
            background: var(--bg-warm);
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .commentary-content {
            flex: 1;
            padding: 1.25rem;
            overflow-y: auto;
            max-height: 480px;
        }
        
        /* CRR Display */
        .crr-display {
            background: linear-gradient(135deg, var(--accent-crr-light), #ede7f6);
            border: 1px solid var(--accent-crr);
            padding: 0.85rem;
            margin-bottom: 0.85rem;
        }
        
        .crr-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.6rem;
        }
        
        .crr-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-crr);
            font-weight: 600;
        }
        
        .crr-stage {
            font-size: 0.7rem;
            padding: 0.15rem 0.5rem;
            background: var(--accent-crr);
            color: white;
            border-radius: 2px;
        }
        
        .crr-stage.rupture {
            background: var(--rupture-color);
            animation: rupturePulse 0.3s infinite;
        }
        
        .crr-stage.regeneration {
            background: var(--success-color);
        }
        
        @keyframes rupturePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .coherence-container {
            margin-bottom: 0.4rem;
        }
        
        .coherence-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
        }
        
        .coherence-bar {
            height: 10px;
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(106,27,154,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .coherence-fill {
            height: 100%;
            background: linear-gradient(90deg, #7b1fa2, #9c27b0, #ab47bc);
            transition: width 0.5s ease-out;
        }
        
        .coherence-fill.critical {
            background: linear-gradient(90deg, #c62828, #d32f2f, #e53935);
            animation: criticalPulse 0.5s infinite;
        }
        
        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .omega-marker {
            position: absolute;
            right: 0;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: var(--rupture-color);
        }
        
        .omega-label {
            position: absolute;
            right: -6px;
            top: -14px;
            font-size: 0.6rem;
            color: var(--rupture-color);
            font-weight: 600;
        }
        
        .crr-math {
            font-size: 0.7rem;
            color: var(--accent-crr);
            font-style: italic;
            text-align: center;
            padding-top: 0.4rem;
            border-top: 1px solid rgba(106,27,154,0.2);
        }
        
        .developmental-stage {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-top: 0.6rem;
            padding-top: 0.6rem;
            border-top: 1px solid rgba(106,27,154,0.2);
        }
        
        .stage-indicator {
            display: flex;
            gap: 0.2rem;
        }
        
        .stage-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(106,27,154,0.2);
        }
        
        .stage-dot.completed { background: var(--accent-crr); }
        .stage-dot.current { background: var(--accent-crr); animation: currentPulse 1s infinite; }
        
        @keyframes currentPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        .stage-name {
            font-size: 0.75rem;
            color: var(--accent-crr);
            font-style: italic;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.85rem;
            padding: 0.6rem 0.85rem;
            background: var(--bg-warm);
            border: 1px solid var(--border-color);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-color);
        }
        
        .status-dot.idle { background: var(--text-muted); }
        .status-dot.exploring { background: #ff9800; animation: pulse 1s infinite; }
        .status-dot.surprise { background: var(--surprise-color); animation: pulse 0.5s infinite; }
        .status-dot.learning { background: var(--accent-fep); animation: pulse 0.8s infinite; }
        .status-dot.success { background: var(--success-color); }
        .status-dot.rupture { background: var(--rupture-color); animation: pulse 0.3s infinite; }
        .status-dot.regenerating { background: var(--accent-crr); animation: pulse 0.6s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }
        
        .status-text { font-size: 0.8rem; color: var(--text-muted); font-style: italic; }
        
        .commentary-text {
            font-size: 0.95rem;
            line-height: 1.7;
            margin-bottom: 1rem;
            text-align: justify;
        }
        
        .framework-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.85rem;
        }
        
        .framework-comparison.triple {
            grid-template-columns: 1fr 1fr 1fr;
        }
        
        .framework-box {
            padding: 0.6rem;
            font-size: 0.85rem;
            border-left: 3px solid;
        }
        
        .framework-box.piaget { background: var(--accent-piaget-light); border-left-color: var(--accent-piaget); }
        .framework-box.fep { background: var(--accent-fep-light); border-left-color: var(--accent-fep); }
        .framework-box.crr { background: var(--accent-crr-light); border-left-color: var(--accent-crr); }
        
        .framework-label {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
            margin-bottom: 0.2rem;
        }
        
        .piaget .framework-label { color: var(--accent-piaget); }
        .fep .framework-label { color: var(--accent-fep); }
        .crr .framework-label { color: var(--accent-crr); }
        
        .framework-term { font-weight: 600; font-size: 0.85rem; font-style: italic; }
        .framework-desc { color: var(--text-muted); font-size: 0.7rem; margin-top: 0.1rem; }
        
        .math-note {
            background: var(--bg-code);
            color: #e0e0e0;
            padding: 0.6rem 0.85rem;
            font-size: 0.8rem;
            font-style: italic;
            margin-top: 0.85rem;
            border-left: 3px solid #666;
        }
        
        .math-note .label {
            color: #aaa;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            display: block;
            margin-bottom: 0.15rem;
            font-style: normal;
        }
        
        .model-display {
            background: var(--bg-warm);
            border: 1px solid var(--border-color);
            padding: 0.85rem;
            margin-top: 0.85rem;
        }
        
        .model-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }
        
        .belief-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.3rem;
            padding: 0.35rem 0.45rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            font-size: 0.8rem;
        }
        
        .belief-item.updating { background: var(--accent-fep-light); border-color: var(--accent-fep); }
        .belief-item.new { background: #e8f5e9; border-color: var(--success-color); }
        .belief-item.disrupted { background: #ffebee; border-color: var(--rupture-color); opacity: 0.6; }
        
        .belief-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        
        .belief-text { flex: 1; }
        .belief-name { font-weight: 500; font-size: 0.75rem; }
        .belief-details { font-size: 0.65rem; color: var(--text-muted); font-style: italic; }
        
        .confidence-bar { width: 30px; height: 3px; background: var(--border-color); }
        .confidence-fill { height: 100%; background: var(--success-color); transition: width 0.5s; }
        
        .prediction-display {
            margin-top: 0.6rem;
            padding: 0.5rem;
            background: #fff8e1;
            border: 1px solid #ffca28;
            font-size: 0.75rem;
        }
        
        .prediction-title {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #f57f17;
            margin-bottom: 0.25rem;
        }
        
        .error-display {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #ffebee;
            border: 1px solid var(--surprise-color);
            font-size: 0.75rem;
        }
        
        .error-display.low-error { background: #e8f5e9; border-color: var(--success-color); }
        
        .error-title {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--surprise-color);
            margin-bottom: 0.25rem;
        }
        
        .error-display.low-error .error-title { color: var(--success-color); }
        
        .explanation-section { margin-top: 2rem; }
        
        .explanation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1.25rem;
        }
        
        .explanation-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            padding: 1.25rem;
        }
        
        .card-header {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-bottom: 0.85rem;
            padding-bottom: 0.6rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .card-number {
            width: 24px;
            height: 24px;
            background: var(--accent-fep);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .card-number.crr { background: var(--accent-crr); }
        
        .card-title { font-size: 1rem; font-weight: 500; font-style: italic; }
        .card-body { font-size: 0.9rem; }
        .card-body p { margin-bottom: 0.7rem; text-align: justify; }
        .card-body p:last-child { margin-bottom: 0; }
        
        .highlight { background: var(--accent-fep-light); padding: 0.1em 0.2em; }
        .highlight-piaget { background: var(--accent-piaget-light); }
        .highlight-crr { background: var(--accent-crr-light); }
        
        footer {
            margin-top: 1.5rem;
            padding: 1rem 2rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-warm);
        }
        
        .rupture-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(211,47,47,0);
            pointer-events: none;
            z-index: 1000;
        }
        
        .rupture-overlay.active {
            animation: ruptureFlash 2s ease-out;
        }
        
        @keyframes ruptureFlash {
            0% { background: rgba(211,47,47,0); }
            10% { background: rgba(211,47,47,0.4); }
            30% { background: rgba(211,47,47,0.2); }
            50% { background: rgba(106,27,154,0.3); }
            70% { background: rgba(106,27,154,0.15); }
            100% { background: rgba(106,27,154,0); }
        }
    </style>
</head>
<body>
    <div class="rupture-overlay" id="ruptureOverlay"></div>
    
    <header>
        <h1>Active Inference & CRR</h1>
        <p class="subtitle">Learning through coherence, rupture, and regeneration</p>
        <span class="instruction-note">Click shapes to explore — watch coherence build toward rupture across five developmental stages</span>
    </header>
    
    <div class="main-container">
        <div class="stage-section">
            <div class="stage-container">
                <div class="stage-header">
                    <span class="stage-title">The Agent's World</span>
                    <div class="stage-controls">
                        <button class="btn" id="resetBtn">Reset</button>
                        <button class="btn btn-primary" id="randomBtn">Explore</button>
                    </div>
                </div>
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="commentary-panel">
                <div class="commentary-header">Understanding the Process</div>
                <div class="commentary-content">
                    
                    <div class="crr-display" id="crrDisplay">
                        <div class="crr-header">
                            <span class="crr-title">Coherence-Rupture-Regeneration</span>
                            <span class="crr-stage" id="crrStage">Coherence</span>
                        </div>
                        <div class="coherence-container">
                            <div class="coherence-label">
                                <span>C(t) = <span id="coherenceValue">0.00</span></span>
                                <span>Ω = <span id="omegaValue">1.00</span></span>
                            </div>
                            <div class="coherence-bar">
                                <div class="coherence-fill" id="coherenceFill" style="width: 0%"></div>
                                <div class="omega-marker"></div>
                                <span class="omega-label">Ω</span>
                            </div>
                        </div>
                        <div class="crr-math" id="crrMath">C(t) = ∫L(x,τ)dτ — coherence accumulates</div>
                        <div class="developmental-stage">
                            <div class="stage-indicator">
                                <div class="stage-dot current" id="stageDot1"></div>
                                <div class="stage-dot" id="stageDot2"></div>
                                <div class="stage-dot" id="stageDot3"></div>
                                <div class="stage-dot" id="stageDot4"></div>
                                <div class="stage-dot" id="stageDot5"></div>
                            </div>
                            <span class="stage-name" id="stageName">Stage I: Simple Forms</span>
                        </div>
                    </div>
                    
                    <div class="status-indicator">
                        <div class="status-dot idle" id="statusDot"></div>
                        <span class="status-text" id="statusText">Agent awaiting instruction...</span>
                    </div>
                    
                    <div id="commentaryText" class="commentary-text">
                        This agent learns through two processes: <em>Active Inference</em> (moment-to-moment prediction) and <em>CRR</em> (coherence building toward rupture). At higher stages, the shapes themselves embody CRR dynamics—self-similar patterns across scales.
                    </div>
                    
                    <div id="frameworkComparison" class="framework-comparison triple" style="display: none;">
                        <div class="framework-box piaget">
                            <div class="framework-label">Piaget</div>
                            <div class="framework-term" id="piagetTerm">—</div>
                            <div class="framework-desc" id="piagetDesc"></div>
                        </div>
                        <div class="framework-box fep">
                            <div class="framework-label">Active Inference</div>
                            <div class="framework-term" id="fepTerm">—</div>
                            <div class="framework-desc" id="fepDesc"></div>
                        </div>
                        <div class="framework-box crr">
                            <div class="framework-label">CRR</div>
                            <div class="framework-term" id="crrTerm">—</div>
                            <div class="framework-desc" id="crrDesc"></div>
                        </div>
                    </div>
                    
                    <div id="predictionDisplay" class="prediction-display" style="display: none;">
                        <div class="prediction-title">Agent's Prediction</div>
                        <div id="predictionContent"></div>
                    </div>
                    
                    <div id="errorDisplay" class="error-display" style="display: none;">
                        <div class="error-title">Prediction Error</div>
                        <div id="errorContent"></div>
                    </div>
                    
                    <div class="math-note" id="mathNote" style="display: none;">
                        <span class="label">Formal notation</span>
                        <span id="mathContent"></span>
                    </div>
                    
                    <div class="model-display">
                        <div class="model-title">Agent's Generative Model</div>
                        <div id="beliefsList">
                            <div class="belief-item" style="opacity: 0.5;">
                                <div class="belief-icon">?</div>
                                <div class="belief-text">
                                    <div class="belief-name">No schemas yet</div>
                                    <div class="belief-details">Click a shape to begin...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="explanation-section">
            <div class="explanation-grid">
                <div class="explanation-card">
                    <div class="card-header">
                        <div class="card-number">I</div>
                        <div class="card-title">Stages I-III</div>
                    </div>
                    <div class="card-body">
                        <p><strong>Simple Forms:</strong> Basic shapes—circles, triangles, squares.</p>
                        <p><strong>Compound:</strong> Nested and combined structures.</p>
                        <p><strong>Dynamic:</strong> Spirals, fractals, flow fields.</p>
                    </div>
                </div>
                
                <div class="explanation-card">
                    <div class="card-header">
                        <div class="card-number crr">II</div>
                        <div class="card-title">Stage IV: Emergent</div>
                    </div>
                    <div class="card-body">
                        <p>Shapes showing <span class="highlight-crr">collective behavior</span>: flocking, phase transitions, coupled oscillators.</p>
                        <p>Complexity emerges from simple rules—the hallmark of self-organization.</p>
                    </div>
                </div>
                
                <div class="explanation-card">
                    <div class="card-header">
                        <div class="card-number crr">III</div>
                        <div class="card-title">Stage V: Meta-CRR</div>
                    </div>
                    <div class="card-body">
                        <p>Shapes that <span class="highlight-crr">embody CRR itself</span>: they accumulate internal coherence, rupture, and regenerate.</p>
                        <p>Self-similarity across scales—the agent learns patterns that mirror its own learning.</p>
                    </div>
                </div>
                
                <div class="explanation-card">
                    <div class="card-header">
                        <div class="card-number">IV</div>
                        <div class="card-title">The Dual Process</div>
                    </div>
                    <div class="card-body">
                        <p><span class="highlight">FEP</span> operates moment-to-moment. <span class="highlight-crr">CRR</span> operates across developmental time.</p>
                        <p>Together: learning within stages, transitions between them.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>Active Inference × CRR: Self-similar learning across scales</p>
    </footer>
    
    <script>
    // ============================================================================
    // CANVAS SETUP
    // ============================================================================
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H;
    
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        W = rect.width;
        H = rect.height;
    }
    resizeCanvas();
    window.addEventListener('resize', () => { resizeCanvas(); initializeShapes(); });
    
    // ============================================================================
    // CRR SYSTEM
    // ============================================================================
    
    const CRR = {
        coherence: 0,
        omega: 1.0,
        stage: 1,
        maxStage: 5,
        phase: 'coherence',
        
        gains: {
            successfulPrediction: 0.07,
            newSchema: 0.10,
            fullExploration: 0.18
        },
        
        addCoherence(amount) {
            if (this.phase !== 'coherence') return;
            this.coherence += amount;
            this.updateDisplay();
            if (this.coherence >= this.omega) this.triggerRupture();
        },
        
        async triggerRupture() {
            if (this.stage >= this.maxStage) {
                // Final stage complete
                this.coherence = this.omega;
                this.updateDisplay();
                updateCommentary(
                    `MASTERY COMPLETE. The agent has traversed all five developmental stages, from simple forms to meta-patterns that embody CRR itself. The journey demonstrates how coherence accumulates through successful prediction until transformation becomes necessary—and how this pattern recurs at every scale of complexity.`,
                    { term: 'Formal Operations', desc: 'Abstract reasoning about abstract patterns' },
                    { term: 'Hierarchical Model', desc: 'Deep generative structure across scales' },
                    { term: 'Recursive CRR', desc: 'The pattern recognizes itself' },
                    'C(t) → ∞ as meta-learning stabilizes'
                );
                return;
            }
            
            this.phase = 'rupture';
            this.updateDisplay();
            document.getElementById('ruptureOverlay').classList.add('active');
            
            await delay(2000);
            
            this.phase = 'regeneration';
            this.updateDisplay();
            
            await delay(1500);
            
            this.stage++;
            this.coherence = 0;
            this.phase = 'coherence';
            
            document.getElementById('ruptureOverlay').classList.remove('active');
            await regenerateWorld();
            this.updateDisplay();
        },
        
        updateDisplay() {
            const fill = document.getElementById('coherenceFill');
            const valueEl = document.getElementById('coherenceValue');
            const stageEl = document.getElementById('crrStage');
            const mathEl = document.getElementById('crrMath');
            const stageNameEl = document.getElementById('stageName');
            
            const pct = Math.min((this.coherence / this.omega) * 100, 100);
            fill.style.width = pct + '%';
            valueEl.textContent = this.coherence.toFixed(2);
            
            fill.classList.toggle('critical', pct > 85 && this.phase === 'coherence');
            
            if (this.phase === 'rupture') {
                stageEl.textContent = 'RUPTURE δ(now)';
                stageEl.className = 'crr-stage rupture';
                mathEl.textContent = 'δ(now) — dimensionless transformation';
            } else if (this.phase === 'regeneration') {
                stageEl.textContent = 'Regenerating...';
                stageEl.className = 'crr-stage regeneration';
                mathEl.textContent = 'R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ';
            } else {
                stageEl.textContent = 'Coherence';
                stageEl.className = 'crr-stage';
                mathEl.textContent = 'C(t) = ∫L(x,τ)dτ — coherence accumulates';
            }
            
            for (let i = 1; i <= 5; i++) {
                const dot = document.getElementById('stageDot' + i);
                dot.className = 'stage-dot';
                if (i < this.stage) dot.classList.add('completed');
                if (i === this.stage) dot.classList.add('current');
            }
            
            const names = [
                'Stage I: Simple Forms',
                'Stage II: Compound Structures',
                'Stage III: Dynamic Patterns',
                'Stage IV: Emergent Systems',
                'Stage V: Meta-CRR Patterns'
            ];
            stageNameEl.textContent = names[this.stage - 1];
        },
        
        reset() {
            this.coherence = 0;
            this.stage = 1;
            this.phase = 'coherence';
            this.updateDisplay();
        }
    };
    
    // ============================================================================
    // SHAPE DEFINITIONS - ALL 5 STAGES
    // ============================================================================
    
    const SHAPE_TYPES = {
        // Stage 1: Simple
        circle: { name: 'Circle', stage: 1 },
        triangle: { name: 'Triangle', stage: 1 },
        square: { name: 'Square', stage: 1 },
        pentagon: { name: 'Pentagon', stage: 1 },
        hexagon: { name: 'Hexagon', stage: 1 },
        star: { name: 'Star', stage: 1 },
        
        // Stage 2: Compound
        ring: { name: 'Ring', stage: 2 },
        triangleInCircle: { name: 'Inscribed Triangle', stage: 2 },
        nestedSquares: { name: 'Nested Squares', stage: 2 },
        hexStar: { name: 'Hex-Star', stage: 2 },
        crescentMoon: { name: 'Crescent', stage: 2 },
        diamond: { name: 'Diamond', stage: 2 },
        
        // Stage 3: Dynamic
        spiral: { name: 'Spiral', stage: 3 },
        pulsingStar: { name: 'Pulsing Star', stage: 3 },
        fractalTriangle: { name: 'Fractal Triangle', stage: 3 },
        flowField: { name: 'Flow Field', stage: 3 },
        interference: { name: 'Interference', stage: 3 },
        mandala: { name: 'Mandala', stage: 3 },
        
        // Stage 4: Emergent Systems
        flock: { name: 'Flocking Swarm', stage: 4, emergent: true },
        phaseTransition: { name: 'Phase Transition', stage: 4, emergent: true },
        coupledOscillators: { name: 'Coupled Oscillators', stage: 4, emergent: true },
        reactionDiffusion: { name: 'Reaction-Diffusion', stage: 4, emergent: true },
        cellularAutomata: { name: 'Cellular Automata', stage: 4, emergent: true },
        bifurcation: { name: 'Bifurcation', stage: 4, emergent: true },
        
        // Stage 5: Meta-CRR (shapes that embody C→δ→R)
        crrOscillator: { name: 'CRR Oscillator', stage: 5, metaCRR: true },
        coherenceWave: { name: 'Coherence Wave', stage: 5, metaCRR: true },
        ruptureBloom: { name: 'Rupture Bloom', stage: 5, metaCRR: true },
        regenerativeSpiral: { name: 'Regenerative Spiral', stage: 5, metaCRR: true },
        nestedCRR: { name: 'Nested CRR', stage: 5, metaCRR: true },
        autopoieticRing: { name: 'Autopoietic Ring', stage: 5, metaCRR: true }
    };
    
    const COLORS = {
        red: { name: 'Red', hex: '#e53935' },
        blue: { name: 'Blue', hex: '#1e88e5' },
        green: { name: 'Green', hex: '#43a047' },
        yellow: { name: 'Yellow', hex: '#fdd835' },
        purple: { name: 'Purple', hex: '#8e24aa' },
        orange: { name: 'Orange', hex: '#fb8c00' },
        cyan: { name: 'Cyan', hex: '#00acc1' },
        pink: { name: 'Pink', hex: '#d81b60' },
        indigo: { name: 'Indigo', hex: '#3949ab' },
        teal: { name: 'Teal', hex: '#00897b' }
    };
    
    const SIZES = {
        small: { name: 'Small', radius: 25 },
        medium: { name: 'Medium', radius: 40 },
        large: { name: 'Large', radius: 55 }
    };
    
    // ============================================================================
    // WORLD STATE
    // ============================================================================
    
    let shapes = [];
    let agent = {
        x: 80, y: 240, targetX: 80, targetY: 240,
        size: 18, state: 'idle', currentTarget: null, breathePhase: 0
    };
    
    let generativeModel = { shapes: {}, colors: {}, sizes: {}, abstractions: [] };
    let time = 0, worldPhase = 0;
    
    // ============================================================================
    // STAGE CONFIGURATIONS
    // ============================================================================
    
    function getStageConfigs(stage) {
        const configs = {
            1: [
                { type: 'circle', color: 'red', size: 'medium' },
                { type: 'triangle', color: 'blue', size: 'large' },
                { type: 'square', color: 'green', size: 'small' },
                { type: 'pentagon', color: 'yellow', size: 'medium' },
                { type: 'circle', color: 'purple', size: 'small' },
                { type: 'star', color: 'orange', size: 'large' },
                { type: 'hexagon', color: 'cyan', size: 'small' },
                { type: 'triangle', color: 'pink', size: 'medium' }
            ],
            2: [
                { type: 'ring', color: 'cyan', size: 'large' },
                { type: 'triangleInCircle', color: 'purple', size: 'medium' },
                { type: 'nestedSquares', color: 'orange', size: 'large' },
                { type: 'hexStar', color: 'blue', size: 'medium' },
                { type: 'crescentMoon', color: 'yellow', size: 'large' },
                { type: 'diamond', color: 'pink', size: 'medium' },
                { type: 'ring', color: 'green', size: 'small' },
                { type: 'nestedSquares', color: 'red', size: 'small' }
            ],
            3: [
                { type: 'spiral', color: 'purple', size: 'large' },
                { type: 'pulsingStar', color: 'orange', size: 'medium' },
                { type: 'fractalTriangle', color: 'cyan', size: 'large' },
                { type: 'flowField', color: 'blue', size: 'large' },
                { type: 'interference', color: 'pink', size: 'medium' },
                { type: 'mandala', color: 'green', size: 'large' },
                { type: 'spiral', color: 'red', size: 'medium' },
                { type: 'pulsingStar', color: 'yellow', size: 'small' }
            ],
            4: [
                { type: 'flock', color: 'blue', size: 'large' },
                { type: 'phaseTransition', color: 'purple', size: 'large' },
                { type: 'coupledOscillators', color: 'orange', size: 'medium' },
                { type: 'reactionDiffusion', color: 'cyan', size: 'large' },
                { type: 'cellularAutomata', color: 'green', size: 'medium' },
                { type: 'bifurcation', color: 'red', size: 'large' },
                { type: 'flock', color: 'pink', size: 'medium' },
                { type: 'coupledOscillators', color: 'teal', size: 'small' }
            ],
            5: [
                { type: 'crrOscillator', color: 'purple', size: 'large' },
                { type: 'coherenceWave', color: 'indigo', size: 'large' },
                { type: 'ruptureBloom', color: 'red', size: 'large' },
                { type: 'regenerativeSpiral', color: 'green', size: 'large' },
                { type: 'nestedCRR', color: 'orange', size: 'large' },
                { type: 'autopoieticRing', color: 'cyan', size: 'large' },
                { type: 'crrOscillator', color: 'pink', size: 'medium' },
                { type: 'coherenceWave', color: 'teal', size: 'medium' }
            ]
        };
        return configs[stage] || configs[1];
    }
    
    function initializeShapes() {
        shapes = [];
        const configs = getStageConfigs(CRR.stage);
        
        const positions = [
            { x: W * 0.62, y: H * 0.22 },
            { x: W * 0.84, y: H * 0.42 },
            { x: W * 0.48, y: H * 0.48 },
            { x: W * 0.72, y: H * 0.68 },
            { x: W * 0.34, y: H * 0.28 },
            { x: W * 0.54, y: H * 0.78 },
            { x: W * 0.38, y: H * 0.58 },
            { x: W * 0.80, y: H * 0.16 }
        ];
        
        configs.forEach((config, i) => {
            // Each shape has its own internal CRR state for meta-shapes
            shapes.push({
                id: i,
                type: config.type,
                color: config.color,
                size: config.size,
                x: positions[i].x,
                y: positions[i].y,
                radius: SIZES[config.size].radius,
                explored: false,
                hovered: false,
                pulsePhase: Math.random() * Math.PI * 2,
                phase: Math.random() * Math.PI * 2,
                // Internal CRR for stage 5 shapes
                internalC: 0,
                internalPhase: 'coherence', // coherence, rupture, regeneration
                internalOmega: 1.0,
                particles: [], // For emergent shapes
                grid: null     // For cellular automata
            });
        });
        
        // Initialize particles for emergent shapes
        shapes.forEach(s => {
            if (SHAPE_TYPES[s.type].emergent) {
                initializeEmergentShape(s);
            }
            if (s.type === 'cellularAutomata') {
                initializeCellularAutomata(s);
            }
        });
    }
    
    function initializeEmergentShape(shape) {
        shape.particles = [];
        const count = shape.type === 'flock' ? 20 : 
                      shape.type === 'coupledOscillators' ? 8 : 15;
        
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * shape.radius * 0.8;
            shape.particles.push({
                x: Math.cos(angle) * dist,
                y: Math.sin(angle) * dist,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                phase: Math.random() * Math.PI * 2,
                state: Math.random() // For phase transitions
            });
        }
    }
    
    function initializeCellularAutomata(shape) {
        const size = 9;
        shape.grid = [];
        for (let i = 0; i < size; i++) {
            shape.grid[i] = [];
            for (let j = 0; j < size; j++) {
                shape.grid[i][j] = Math.random() > 0.5 ? 1 : 0;
            }
        }
    }
    
    async function regenerateWorld() {
        Object.values(generativeModel.shapes).forEach(s => {
            s.confidence *= 0.3;
            s.disrupted = true;
        });
        
        updateBeliefDisplay();
        
        const stageDesc = [
            '', 
            'Simple Forms',
            'Compound Structures',
            'Dynamic Patterns',
            'Emergent Systems—collective behavior arises from simple rules',
            'Meta-CRR Patterns—shapes that embody the very process of coherence, rupture, and regeneration'
        ];
        
        updateCommentary(
            `REGENERATION into Stage ${CRR.stage}: ${stageDesc[CRR.stage]}. The agent's existing schemas face unprecedented complexity. ${CRR.stage >= 4 ? 'These forms exhibit emergent behavior—prediction requires understanding dynamics, not just static properties.' : ''} ${CRR.stage === 5 ? 'At Stage V, the shapes themselves undergo C→δ→R cycles—self-similarity across scales.' : ''}`,
            { term: 'Stage Transition', desc: 'Qualitative cognitive reorganisation' },
            { term: 'Model Inadequacy', desc: 'Existing priors insufficient' },
            { term: 'Regeneration R', desc: 'exp(C/Ω) weights new structure' },
            'R = ∫φ(x,τ)exp(C/Ω)Θ(t-τ)dτ'
        );
        
        await delay(2000);
        initializeShapes();
        
        agent.x = 80;
        agent.y = H / 2;
        agent.targetX = 80;
        agent.targetY = H / 2;
        agent.state = 'idle';
        agent.currentTarget = null;
        
        updateStatus('idle', `Stage ${CRR.stage}: New complexity awaits...`);
    }
    
    // ============================================================================
    // DRAWING FUNCTIONS
    // ============================================================================
    
    function drawBackground() {
        const gradients = [
            ['#f5f5f5', '#e0e0e0'],                    // Stage 1
            ['#e8eaf6', '#c5cae9'],                    // Stage 2
            ['#ede7f6', '#b39ddb'],                    // Stage 3
            ['#e0f7fa', '#80deea', '#4dd0e1'],        // Stage 4
            ['#fce4ec', '#f8bbd9', '#ce93d8', '#b39ddb'] // Stage 5
        ];
        
        const colors = gradients[CRR.stage - 1] || gradients[0];
        const grad = ctx.createRadialGradient(W * 0.5, H * 0.5, 0, W * 0.5, H * 0.5, W);
        colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), c));
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
        
        // Grid
        ctx.strokeStyle = 'rgba(0,0,0,0.03)';
        ctx.lineWidth = 1;
        const gridSize = 50 - CRR.stage * 8;
        for (let x = 0; x < W; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
        }
        for (let y = 0; y < H; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
        }
        
        // Stage number
        ctx.fillStyle = `rgba(106,27,154,${0.05 + CRR.stage * 0.02})`;
        ctx.font = 'bold 100px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(CRR.stage, W - 70, H - 30);
    }
    
    function drawShape(shape) {
        ctx.save();
        ctx.translate(shape.x, shape.y);
        
        const pulse = shape.hovered ? Math.sin(shape.pulsePhase) * 3 : 0;
        const r = shape.radius + pulse;
        
        if (shape.hovered) {
            ctx.shadowColor = COLORS[shape.color].hex;
            ctx.shadowBlur = 20;
        }
        
        if (shape.explored) {
            ctx.strokeStyle = 'rgba(46, 125, 50, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, r + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        const info = SHAPE_TYPES[shape.type];
        const color = COLORS[shape.color].hex;
        
        if (info.stage === 1) {
            drawStage1Shape(shape.type, r, color);
        } else if (info.stage === 2) {
            drawStage2Shape(shape.type, r, color);
        } else if (info.stage === 3) {
            drawStage3Shape(shape.type, r, color, shape.phase + worldPhase);
        } else if (info.stage === 4) {
            drawStage4Shape(shape, r, color);
        } else if (info.stage === 5) {
            drawStage5Shape(shape, r, color);
        }
        
        ctx.restore();
    }
    
    // Stage 1: Simple shapes
    function drawStage1Shape(type, r, color) {
        ctx.fillStyle = color;
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        if (type === 'circle') ctx.arc(0, 0, r, 0, Math.PI * 2);
        else if (type === 'triangle') drawPolygon(r, 3);
        else if (type === 'square') drawPolygon(r, 4);
        else if (type === 'pentagon') drawPolygon(r, 5);
        else if (type === 'hexagon') drawPolygon(r, 6);
        else if (type === 'star') drawStar(r, 5);
        
        ctx.fill();
        ctx.stroke();
        
        // Highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(-r * 0.25, -r * 0.25, r * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Stage 2: Compound shapes
    function drawStage2Shape(type, r, color) {
        ctx.fillStyle = color;
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 2;
        
        if (type === 'ring') {
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2, true);
            ctx.fill(); ctx.stroke();
        } else if (type === 'triangleInCircle') {
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); drawPolygon(r * 0.7, 3); ctx.fill();
        } else if (type === 'nestedSquares') {
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate(i * Math.PI / 8);
                ctx.globalAlpha = 1 - i * 0.25;
                ctx.beginPath(); drawPolygon(r * (1 - i * 0.3), 4);
                if (i === 0) ctx.fill(); ctx.stroke();
                ctx.restore();
            }
        } else if (type === 'hexStar') {
            ctx.beginPath(); drawPolygon(r, 6); ctx.stroke();
            ctx.beginPath(); drawStar(r * 0.8, 6); ctx.fill();
        } else if (type === 'crescentMoon') {
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#f5f5f5';
            ctx.beginPath(); ctx.arc(r * 0.3, 0, r * 0.75, 0, Math.PI * 2); ctx.fill();
        } else if (type === 'diamond') {
            ctx.beginPath();
            ctx.moveTo(0, -r); ctx.lineTo(r * 0.6, 0);
            ctx.lineTo(0, r); ctx.lineTo(-r * 0.6, 0);
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }
    }
    
    // Stage 3: Dynamic shapes
    function drawStage3Shape(type, r, color, phase) {
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        if (type === 'spiral') {
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 720; i += 5) {
                const angle = (i * Math.PI / 180) + phase;
                const radius = (i / 720) * r;
                if (i === 0) ctx.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                else ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.stroke();
        } else if (type === 'pulsingStar') {
            const pulseR = r * (0.8 + 0.2 * Math.sin(phase * 2));
            ctx.beginPath(); drawStar(pulseR, 8); ctx.fill();
        } else if (type === 'fractalTriangle') {
            drawSierpinski(0, 0, r, 3, phase);
        } else if (type === 'flowField') {
            for (let x = -r; x < r; x += 12) {
                for (let y = -r; y < r; y += 12) {
                    if (x*x + y*y > r*r) continue;
                    const angle = Math.sin(x * 0.1 + phase) + Math.cos(y * 0.1 + phase);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
                    ctx.stroke();
                }
            }
        } else if (type === 'interference') {
            for (let i = 0; i < 5; i++) {
                ctx.globalAlpha = 0.3;
                const offset = Math.sin(phase + i) * 10;
                ctx.beginPath(); ctx.arc(offset, 0, r * (0.3 + i * 0.15), 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(-offset, 0, r * (0.3 + i * 0.15), 0, Math.PI * 2); ctx.stroke();
            }
            ctx.globalAlpha = 1;
        } else if (type === 'mandala') {
            const petals = 12;
            for (let i = 0; i < petals; i++) {
                ctx.save();
                ctx.rotate((i * Math.PI * 2 / petals) + phase * 0.5);
                ctx.beginPath();
                ctx.ellipse(r * 0.5, 0, r * 0.4, r * 0.15, 0, 0, Math.PI * 2);
                ctx.globalAlpha = 0.7;
                ctx.fill();
                ctx.restore();
            }
            ctx.globalAlpha = 1;
            ctx.beginPath(); ctx.arc(0, 0, r * 0.2, 0, Math.PI * 2); ctx.fill();
        }
    }
    
    // Stage 4: Emergent shapes
    function drawStage4Shape(shape, r, color) {
        const type = shape.type;
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        
        if (type === 'flock') {
            // Boids-like flocking
            updateFlock(shape);
            shape.particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(Math.atan2(p.vy, p.vx));
                ctx.beginPath();
                ctx.moveTo(6, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });
        } else if (type === 'phaseTransition') {
            // Particles transitioning between ordered/disordered
            const temp = (Math.sin(worldPhase * 0.5) + 1) / 2;
            shape.particles.forEach((p, i) => {
                const targetX = temp < 0.5 ? 
                    (i % 4 - 1.5) * r * 0.4 : 
                    (Math.random() - 0.5) * r * 1.5;
                const targetY = temp < 0.5 ? 
                    (Math.floor(i / 4) - 1.5) * r * 0.4 : 
                    (Math.random() - 0.5) * r * 1.5;
                p.x += (targetX - p.x) * 0.05;
                p.y += (targetY - p.y) * 0.05;
                
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Temperature indicator
            ctx.strokeStyle = temp < 0.5 ? '#2196f3' : '#f44336';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();
        } else if (type === 'coupledOscillators') {
            // Kuramoto-like coupled oscillators
            shape.particles.forEach((p, i) => {
                const angle = (i / shape.particles.length) * Math.PI * 2;
                const baseX = Math.cos(angle) * r * 0.6;
                const baseY = Math.sin(angle) * r * 0.6;
                
                // Coupling
                let coupling = 0;
                shape.particles.forEach((other, j) => {
                    if (i !== j) coupling += Math.sin(other.phase - p.phase) * 0.1;
                });
                p.phase += 0.05 + coupling;
                
                const oscX = baseX + Math.cos(p.phase) * 10;
                const oscY = baseY + Math.sin(p.phase) * 10;
                
                ctx.beginPath();
                ctx.arc(oscX, oscY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Connection lines
                ctx.strokeStyle = color;
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(oscX, oscY);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;
        } else if (type === 'reactionDiffusion') {
            // Turing pattern approximation
            const spots = 12;
            for (let i = 0; i < spots; i++) {
                const angle = (i / spots) * Math.PI * 2 + worldPhase * 0.2;
                const dist = r * (0.4 + 0.3 * Math.sin(i * 2.3 + worldPhase));
                const size = 8 + 4 * Math.sin(i * 1.7 + worldPhase * 0.5);
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();
        } else if (type === 'cellularAutomata') {
            // Game of Life style
            updateCellularAutomata(shape);
            const cellSize = r * 2 / shape.grid.length;
            shape.grid.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell) {
                        ctx.globalAlpha = 0.8;
                        ctx.fillRect(
                            (j - shape.grid.length / 2) * cellSize,
                            (i - shape.grid.length / 2) * cellSize,
                            cellSize - 1, cellSize - 1
                        );
                    }
                });
            });
            ctx.globalAlpha = 1;
        } else if (type === 'bifurcation') {
            // Bifurcation diagram visualization
            ctx.lineWidth = 1.5;
            const branches = Math.floor(3 + Math.sin(worldPhase) * 2);
            
            function drawBranch(x, y, length, angle, depth) {
                if (depth === 0 || length < 3) return;
                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                const spread = 0.4 + Math.sin(worldPhase + depth) * 0.2;
                drawBranch(endX, endY, length * 0.7, angle - spread, depth - 1);
                drawBranch(endX, endY, length * 0.7, angle + spread, depth - 1);
            }
            
            drawBranch(0, r * 0.5, r * 0.5, -Math.PI / 2, 5);
        }
    }
    
    // Stage 5: Meta-CRR shapes (shapes that embody C→δ→R)
    function drawStage5Shape(shape, r, color) {
        const type = shape.type;
        
        // Update internal CRR dynamics
        updateShapeInternalCRR(shape);
        
        const c = shape.internalC;
        const phase = shape.internalPhase;
        
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        
        if (type === 'crrOscillator') {
            // Shape that builds structure, ruptures, regenerates
            const intensity = c / shape.internalOmega;
            
            // Core that grows with coherence
            ctx.globalAlpha = 0.3 + intensity * 0.5;
            ctx.beginPath();
            ctx.arc(0, 0, r * (0.3 + intensity * 0.5), 0, Math.PI * 2);
            ctx.fill();
            
            // Orbiting elements that increase with coherence
            const orbiters = Math.floor(2 + intensity * 6);
            for (let i = 0; i < orbiters; i++) {
                const angle = (i / orbiters) * Math.PI * 2 + worldPhase;
                const dist = r * (0.5 + intensity * 0.3);
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 4 + intensity * 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Rupture flash
            if (phase === 'rupture') {
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#d32f2f';
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = color;
            }
            
            // Coherence ring indicator
            ctx.globalAlpha = 1;
            ctx.strokeStyle = phase === 'rupture' ? '#d32f2f' : color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, r, -Math.PI / 2, -Math.PI / 2 + (c / shape.internalOmega) * Math.PI * 2);
            ctx.stroke();
            
        } else if (type === 'coherenceWave') {
            // Waves that accumulate then collapse
            const rings = 3 + Math.floor(c * 4);
            for (let i = 0; i < rings; i++) {
                const ringR = r * (0.2 + (i / rings) * 0.8);
                ctx.globalAlpha = 0.3 + (c * 0.3);
                ctx.lineWidth = 2 + c * 2;
                ctx.beginPath();
                ctx.arc(0, 0, ringR, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            if (phase === 'rupture') {
                // Wave collapse
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#d32f2f';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * r * 1.3, Math.sin(angle) * r * 1.3);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            
        } else if (type === 'ruptureBloom') {
            // Flower that blooms, ruptures, seeds regenerate
            const petalCount = 5 + Math.floor(c * 8);
            const petalSize = 0.2 + c * 0.4;
            
            for (let i = 0; i < petalCount; i++) {
                ctx.save();
                ctx.rotate((i / petalCount) * Math.PI * 2 + worldPhase * 0.3);
                ctx.globalAlpha = 0.6 + c * 0.3;
                ctx.beginPath();
                ctx.ellipse(r * 0.4, 0, r * petalSize, r * 0.12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Center (seed)
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            if (phase === 'rupture') {
                // Petals scatter
                ctx.fillStyle = '#d32f2f';
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const dist = r * 0.9;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
        } else if (type === 'regenerativeSpiral') {
            // Spiral that builds, fractures, regrows
            ctx.lineWidth = 2 + c * 3;
            const turns = 1 + c * 3;
            
            ctx.beginPath();
            for (let i = 0; i < 360 * turns; i += 3) {
                const angle = (i * Math.PI / 180) + worldPhase;
                const radius = (i / (360 * turns)) * r;
                
                if (phase === 'rupture' && Math.random() > 0.7) continue; // Fracture effect
                
                if (i === 0) ctx.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                else ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.stroke();
            
            // Growth indicator
            ctx.fillStyle = phase === 'rupture' ? '#d32f2f' : '#4caf50';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (type === 'nestedCRR') {
            // Multiple nested systems each with their own CRR
            const levels = 3;
            for (let level = 0; level < levels; level++) {
                const levelC = (c + level * 0.3) % 1;
                const levelR = r * (1 - level * 0.25);
                
                ctx.globalAlpha = 0.4 + levelC * 0.4;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, levelR, 0, Math.PI * 2);
                ctx.stroke();
                
                // Coherence arc for each level
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, levelR, -Math.PI / 2, -Math.PI / 2 + levelC * Math.PI * 2);
                ctx.stroke();
            }
            
            if (phase === 'rupture') {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#d32f2f';
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
        } else if (type === 'autopoieticRing') {
            // Self-maintaining ring that produces its own components
            const segments = 12;
            const segmentAngle = Math.PI * 2 / segments;
            
            for (let i = 0; i < segments; i++) {
                const active = ((i / segments) < c) ? 1 : 0.3;
                const angle = i * segmentAngle + worldPhase * 0.2;
                
                ctx.globalAlpha = active;
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.7, angle, angle + segmentAngle * 0.8);
                ctx.lineWidth = 8;
                ctx.stroke();
                
                // Self-production: active segments spawn particles
                if (active > 0.5 && Math.random() > 0.95) {
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(
                        Math.cos(angle + segmentAngle / 2) * r * 0.7,
                        Math.sin(angle + segmentAngle / 2) * r * 0.7,
                        3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Boundary
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
    }
    
    function updateShapeInternalCRR(shape) {
        if (shape.internalPhase === 'coherence') {
            shape.internalC += 0.003;
            if (shape.internalC >= shape.internalOmega) {
                shape.internalPhase = 'rupture';
                shape.ruptureTimer = 30;
            }
        } else if (shape.internalPhase === 'rupture') {
            shape.ruptureTimer--;
            if (shape.ruptureTimer <= 0) {
                shape.internalPhase = 'regeneration';
                shape.regenTimer = 20;
            }
        } else if (shape.internalPhase === 'regeneration') {
            shape.regenTimer--;
            shape.internalC *= 0.9;
            if (shape.regenTimer <= 0) {
                shape.internalC = 0;
                shape.internalPhase = 'coherence';
            }
        }
    }
    
    // Helper functions
    function drawPolygon(r, sides) {
        ctx.moveTo(0, -r);
        for (let i = 1; i <= sides; i++) {
            const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
            ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
        ctx.closePath();
    }
    
    function drawStar(r, points) {
        const inner = r * 0.4;
        ctx.moveTo(0, -r);
        for (let i = 0; i < points * 2; i++) {
            const angle = (i * Math.PI / points) - Math.PI / 2;
            const rad = i % 2 === 0 ? r : inner;
            ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
        }
        ctx.closePath();
    }
    
    function drawSierpinski(x, y, size, depth, phase) {
        if (depth === 0) {
            ctx.beginPath();
            ctx.moveTo(x, y - size * 0.5);
            ctx.lineTo(x - size * 0.5, y + size * 0.5);
            ctx.lineTo(x + size * 0.5, y + size * 0.5);
            ctx.closePath();
            ctx.fill();
            return;
        }
        const s = size / 2;
        const o = Math.sin(phase + depth) * 2;
        drawSierpinski(x + o, y - s * 0.5, s, depth - 1, phase);
        drawSierpinski(x - s * 0.5 + o, y + s * 0.5, s, depth - 1, phase);
        drawSierpinski(x + s * 0.5 + o, y + s * 0.5, s, depth - 1, phase);
    }
    
    function updateFlock(shape) {
        const r = shape.radius;
        shape.particles.forEach(p => {
            // Simple boid rules
            let ax = 0, ay = 0;
            
            // Cohesion & alignment
            shape.particles.forEach(other => {
                if (other === p) return;
                const dx = other.x - p.x;
                const dy = other.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 30 && dist > 0) {
                    ax += dx * 0.01;
                    ay += dy * 0.01;
                    ax += other.vx * 0.05;
                    ay += other.vy * 0.05;
                }
                if (dist < 15 && dist > 0) {
                    ax -= dx * 0.02;
                    ay -= dy * 0.02;
                }
            });
            
            // Stay in bounds
            if (p.x < -r * 0.8) ax += 0.5;
            if (p.x > r * 0.8) ax -= 0.5;
            if (p.y < -r * 0.8) ay += 0.5;
            if (p.y > r * 0.8) ay -= 0.5;
            
            p.vx += ax;
            p.vy += ay;
            
            // Speed limit
            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            if (speed > 2) {
                p.vx = (p.vx / speed) * 2;
                p.vy = (p.vy / speed) * 2;
            }
            
            p.x += p.vx;
            p.y += p.vy;
        });
    }
    
    function updateCellularAutomata(shape) {
        if (Math.random() > 0.1) return; // Slow update
        
        const grid = shape.grid;
        const size = grid.length;
        const newGrid = grid.map(row => [...row]);
        
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                let neighbors = 0;
                for (let di = -1; di <= 1; di++) {
                    for (let dj = -1; dj <= 1; dj++) {
                        if (di === 0 && dj === 0) continue;
                        const ni = (i + di + size) % size;
                        const nj = (j + dj + size) % size;
                        neighbors += grid[ni][nj];
                    }
                }
                
                if (grid[i][j] === 1) {
                    newGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                } else {
                    newGrid[i][j] = (neighbors === 3) ? 1 : 0;
                }
            }
        }
        
        shape.grid = newGrid;
    }
    
    function drawAgent() {
        ctx.save();
        ctx.translate(agent.x, agent.y);
        
        const breathe = Math.sin(agent.breathePhase) * 2;
        const size = agent.size + breathe;
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath();
        ctx.ellipse(0, size * 0.7, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Glow
        const glows = {
            idle: 'rgba(100,100,100,0.3)',
            exploring: 'rgba(255,152,0,0.4)',
            examining: 'rgba(255,152,0,0.4)',
            surprised: 'rgba(198,40,40,0.5)',
            learning: 'rgba(35,78,112,0.5)',
            rupture: 'rgba(211,47,47,0.6)',
            regenerating: 'rgba(106,27,154,0.5)'
        };
        ctx.fillStyle = glows[agent.state] || glows.idle;
        ctx.beginPath();
        ctx.arc(0, 0, size + 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        const grad = ctx.createRadialGradient(-size * 0.3, -size * 0.3, 0, 0, 0, size);
        grad.addColorStop(0, '#fafafa');
        grad.addColorStop(0.5, '#e0e0e0');
        grad.addColorStop(1, '#bdbdbd');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Eyes
        const eyeOff = size * 0.35;
        const eyeSize = size * 0.25;
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(-eyeOff, -size * 0.1, eyeSize, eyeSize * 1.2, 0, 0, Math.PI * 2);
        ctx.ellipse(eyeOff, -size * 0.1, eyeSize, eyeSize * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Pupils
        let lookX = 0, lookY = 0;
        if (agent.currentTarget) {
            const dx = agent.currentTarget.x - agent.x;
            const dy = agent.currentTarget.y - agent.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            lookX = (dx / dist) * eyeSize * 0.4;
            lookY = (dy / dist) * eyeSize * 0.4;
        }
        
        let pupilSize = eyeSize * 0.5;
        if (agent.state === 'surprised') pupilSize = eyeSize * 0.7;
        
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(-eyeOff + lookX, -size * 0.1 + lookY, pupilSize, 0, Math.PI * 2);
        ctx.arc(eyeOff + lookX, -size * 0.1 + lookY, pupilSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye shine
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(-eyeOff + lookX - 2, -size * 0.1 + lookY - 2, 2, 0, Math.PI * 2);
        ctx.arc(eyeOff + lookX - 2, -size * 0.1 + lookY - 2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Mouth
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        if (agent.state === 'surprised') {
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.ellipse(0, size * 0.35, size * 0.18, size * 0.22, 0, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(0, size * 0.25, size * 0.18, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }
        
        // State symbol
        const symbols = { surprised: '!', examining: '?', learning: '✓', rupture: 'δ', regenerating: 'R' };
        if (symbols[agent.state]) {
            ctx.fillStyle = agent.state === 'rupture' ? '#d32f2f' : 
                           agent.state === 'regenerating' ? '#6a1b9a' : '#234e70';
            ctx.font = `bold ${size * 0.7}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(symbols[agent.state], 0, -size * 1.2);
        }
        
        ctx.restore();
    }
    
    function drawExplorationLine() {
        if (agent.currentTarget && agent.state !== 'idle') {
            ctx.save();
            ctx.strokeStyle = 'rgba(35,78,112,0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(agent.x, agent.y);
            ctx.lineTo(agent.currentTarget.x, agent.currentTarget.y);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    // ============================================================================
    // LEARNING SYSTEM
    // ============================================================================
    
    function getPrediction(shape) {
        const preds = [];
        let conf = 0;
        
        if (generativeModel.shapes[shape.type]) {
            preds.push(`Shape: ${SHAPE_TYPES[shape.type].name}`);
            conf += 0.3 * generativeModel.shapes[shape.type].confidence;
        }
        if (generativeModel.colors[shape.color]) {
            preds.push(`Color: ${COLORS[shape.color].name}`);
            conf += 0.3 * generativeModel.colors[shape.color].confidence;
        }
        
        return { predictions: preds, confidence: Math.min(conf, 0.9), hasKnowledge: preds.length > 0 };
    }
    
    function calculatePredictionError(shape, prediction) {
        if (!prediction.hasKnowledge) return { error: 1.0, message: "Complete novelty!" };
        
        let errors = [], errorSum = 0;
        
        if (!generativeModel.shapes[shape.type]) {
            errors.push(`Unknown: ${SHAPE_TYPES[shape.type].name}`);
            errorSum += 0.5;
        } else if (generativeModel.shapes[shape.type].disrupted) {
            errors.push(`Uncertain: ${SHAPE_TYPES[shape.type].name}`);
            errorSum += 0.25;
        }
        
        if (!generativeModel.colors[shape.color]) {
            errors.push(`Unknown: ${COLORS[shape.color].name}`);
            errorSum += 0.3;
        }
        
        if (errors.length === 0) return { error: 0.1, message: "Matches existing schemas." };
        return { error: errorSum, message: errors.join('; ') };
    }
    
    function updateGenerativeModel(shape) {
        const updates = [];
        
        if (!generativeModel.shapes[shape.type]) {
            generativeModel.shapes[shape.type] = {
                name: SHAPE_TYPES[shape.type].name,
                stage: SHAPE_TYPES[shape.type].stage,
                encounters: 1,
                confidence: 0.6
            };
            updates.push(`New: ${SHAPE_TYPES[shape.type].name}`);
        } else {
            generativeModel.shapes[shape.type].encounters++;
            generativeModel.shapes[shape.type].confidence = Math.min(0.95, 
                generativeModel.shapes[shape.type].confidence + 0.1);
            generativeModel.shapes[shape.type].disrupted = false;
        }
        
        if (!generativeModel.colors[shape.color]) {
            generativeModel.colors[shape.color] = {
                name: COLORS[shape.color].name,
                encounters: 1,
                confidence: 0.6
            };
            updates.push(`New: ${COLORS[shape.color].name}`);
        } else {
            generativeModel.colors[shape.color].encounters++;
            generativeModel.colors[shape.color].confidence = Math.min(0.95,
                generativeModel.colors[shape.color].confidence + 0.1);
        }
        
        return updates;
    }
    
    // ============================================================================
    // UI FUNCTIONS
    // ============================================================================
    
    function updateStatus(state, text) {
        document.getElementById('statusDot').className = 'status-dot ' + state;
        document.getElementById('statusText').textContent = text;
    }
    
    function updateCommentary(text, piaget, fep, crr, math) {
        document.getElementById('commentaryText').textContent = text;
        
        const comp = document.getElementById('frameworkComparison');
        if (piaget && fep) {
            comp.style.display = 'grid';
            document.getElementById('piagetTerm').textContent = piaget.term;
            document.getElementById('piagetDesc').textContent = piaget.desc;
            document.getElementById('fepTerm').textContent = fep.term;
            document.getElementById('fepDesc').textContent = fep.desc;
            if (crr) {
                comp.classList.add('triple');
                document.getElementById('crrTerm').textContent = crr.term;
                document.getElementById('crrDesc').textContent = crr.desc;
            } else {
                comp.classList.remove('triple');
            }
        } else {
            comp.style.display = 'none';
        }
        
        const mathEl = document.getElementById('mathNote');
        if (math) {
            mathEl.style.display = 'block';
            document.getElementById('mathContent').textContent = math;
        } else {
            mathEl.style.display = 'none';
        }
    }
    
    function showPrediction(pred) {
        const d = document.getElementById('predictionDisplay');
        d.style.display = 'block';
        document.getElementById('predictionContent').innerHTML = pred.hasKnowledge ?
            `<strong>Expected:</strong> ${pred.predictions.join(', ')}<br><span style="font-size:0.7rem;color:#666">Confidence: ${Math.round(pred.confidence*100)}%</span>` :
            `<em>No prediction—entirely novel</em>`;
    }
    
    function showError(err) {
        const d = document.getElementById('errorDisplay');
        d.style.display = 'block';
        d.className = err.error < 0.2 ? 'error-display low-error' : 'error-display';
        document.getElementById('errorContent').innerHTML = 
            `${err.message}<br><span style="font-size:0.7rem;color:${err.error<0.2?'#2e7d32':'#c62828'}">ε ≈ ${err.error.toFixed(2)}</span>`;
    }
    
    function hidePredictionAndError() {
        document.getElementById('predictionDisplay').style.display = 'none';
        document.getElementById('errorDisplay').style.display = 'none';
    }
    
    function updateBeliefDisplay(highlight = null) {
        const c = document.getElementById('beliefsList');
        c.innerHTML = '';
        
        if (Object.keys(generativeModel.shapes).length === 0) {
            c.innerHTML = `<div class="belief-item" style="opacity:0.5"><div class="belief-icon">?</div><div class="belief-text"><div class="belief-name">No schemas</div><div class="belief-details">Click to begin...</div></div></div>`;
            return;
        }
        
        const icons = {
            circle: '○', triangle: '△', square: '□', pentagon: '⬠', hexagon: '⬡', star: '☆',
            ring: '◎', nestedSquares: '⊞', diamond: '◇', crescentMoon: '☽', hexStar: '✡', triangleInCircle: '⊿',
            spiral: '🌀', mandala: '✿', pulsingStar: '✦', fractalTriangle: '△', flowField: '≋', interference: '◉',
            flock: '🐦', phaseTransition: '⇌', coupledOscillators: '∿', reactionDiffusion: '⊛', cellularAutomata: '⊞', bifurcation: '⑂',
            crrOscillator: 'Ω', coherenceWave: '∿', ruptureBloom: '❀', regenerativeSpiral: '🌀', nestedCRR: '⊚', autopoieticRing: '◎'
        };
        
        const stageLabels = ['', 'Simple', 'Compound', 'Dynamic', 'Emergent', 'Meta-CRR'];
        
        Object.entries(generativeModel.shapes).forEach(([key, schema]) => {
            const isNew = highlight && highlight.some(h => h.includes(schema.name));
            const item = document.createElement('div');
            item.className = 'belief-item' + (isNew ? ' new' : '') + (schema.disrupted ? ' disrupted' : '');
            item.innerHTML = `
                <div class="belief-icon">${icons[key] || '●'}</div>
                <div class="belief-text">
                    <div class="belief-name">${schema.name}</div>
                    <div class="belief-details">${stageLabels[schema.stage]} · ×${schema.encounters}</div>
                </div>
                <div class="confidence-bar"><div class="confidence-fill" style="width:${schema.confidence*100}%"></div></div>`;
            c.appendChild(item);
        });
        
        // Colors summary
        const colors = Object.values(generativeModel.colors);
        if (colors.length > 0) {
            const item = document.createElement('div');
            item.className = 'belief-item';
            item.innerHTML = `<div class="belief-icon" style="font-size:0.6rem">${colors.map(c => `<span style="color:${COLORS[Object.keys(generativeModel.colors).find(k => generativeModel.colors[k] === c)]?.hex || '#666'}">●</span>`).join('')}</div><div class="belief-text"><div class="belief-name">Colors (${colors.length})</div></div>`;
            c.appendChild(item);
        }
    }
    
    // ============================================================================
    // EXPLORATION
    // ============================================================================
    
    async function exploreShape(shape) {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        
        agent.currentTarget = shape;
        agent.state = 'exploring';
        agent.targetX = shape.x - shape.radius - 40;
        agent.targetY = shape.y;
        
        const info = SHAPE_TYPES[shape.type];
        let stageNote = '';
        if (info.emergent) stageNote = ' This emergent form exhibits collective dynamics—prediction requires understanding process, not just form.';
        if (info.metaCRR) stageNote = ' This meta-pattern embodies CRR itself—it accumulates coherence, ruptures, and regenerates. Self-similarity across scales.';
        
        updateStatus('exploring', `Approaching ${info.name}...`);
        updateCommentary(`The agent moves toward a ${info.name}.${stageNote}`, null, null, null, null);
        hidePredictionAndError();
        
        await waitForArrival();
        
        agent.state = 'examining';
        const pred = getPrediction(shape);
        showPrediction(pred);
        updateStatus('exploring', 'Generating predictions...');
        
        updateCommentary(
            pred.hasKnowledge ? 
                `Generative model produces predictions based on learned schemas.${info.metaCRR ? ' But can static schemas predict dynamic CRR processes?' : ''}` :
                `No applicable schemas—this ${info.stage >= 4 ? 'complex pattern' : 'form'} is entirely novel.`,
            { term: pred.hasKnowledge ? 'Assimilation Attempt' : 'No Schema', desc: pred.hasKnowledge ? 'Testing existing structures' : 'Cannot assimilate' },
            { term: pred.hasKnowledge ? 'Prior Prediction' : 'High Entropy', desc: pred.hasKnowledge ? 'g(μ) generates expectations' : 'Maximal uncertainty' },
            info.metaCRR ? { term: 'Recursive Recognition', desc: 'Pattern recognizes pattern' } : null,
            pred.hasKnowledge ? 'g(μ) = predicted sensation' : 'H[P(s)] = maximum'
        );
        
        await delay(1600);
        
        const err = calculatePredictionError(shape, pred);
        if (err.error > 0.3) agent.state = 'surprised';
        showError(err);
        
        updateCommentary(
            err.error > 0.3 ?
                `Surprise! ${info.metaCRR ? 'The shape\'s internal CRR dynamics confound static prediction. To model this, the agent must develop schemas for process itself.' : 'Prediction diverges from reality.'}` :
                `Prediction matches—existing schemas accommodate this experience.`,
            { term: err.error > 0.3 ? 'Disequilibrium' : 'Assimilation', desc: err.error > 0.3 ? 'Schema-experience gap' : 'Experience fits schemas' },
            { term: err.error > 0.3 ? 'Prediction Error' : 'Low Free Energy', desc: err.error > 0.3 ? 'ε = s − g(μ) high' : 'Model confirmed' },
            { term: err.error > 0.3 ? 'Coherence Pause' : 'C(t) +', desc: err.error > 0.3 ? 'Error before accumulation' : 'Success adds coherence' },
            err.error > 0.3 ? 'ε = s − g(μ) >> 0' : 'F(μ) ≈ minimum'
        );
        
        if (err.error <= 0.3) CRR.addCoherence(CRR.gains.successfulPrediction);
        
        await delay(1800);
        
        agent.state = 'learning';
        updateStatus('learning', 'Updating model...');
        
        const updates = updateGenerativeModel(shape);
        shape.explored = true;
        
        updateCommentary(
            updates.length > 0 ?
                `Accommodation: new schemas emerge—${updates.join(', ')}. ${info.metaCRR ? 'The agent now has schemas for CRR-embodying patterns—meta-learning.' : ''}` :
                `Schemas strengthened through confirmation.`,
            { term: updates.length > 0 ? 'Accommodation' : 'Strengthening', desc: updates.length > 0 ? 'New schemas created' : 'Existing schemas reinforced' },
            { term: updates.length > 0 ? 'Model Update' : 'Precision ↑', desc: updates.length > 0 ? 'μ* minimises F' : 'Confidence grows' },
            { term: 'C(t) Grows', desc: 'Learning adds coherence' },
            updates.length > 0 ? 'μ* = argmin F(μ)' : 'π(μ) increases'
        );
        
        CRR.addCoherence(updates.length > 0 ? CRR.gains.newSchema * updates.length : CRR.gains.successfulPrediction);
        updateBeliefDisplay(updates);
        
        await delay(1400);
        
        // Check full exploration
        if (shapes.every(s => s.explored) && CRR.phase === 'coherence') {
            CRR.addCoherence(CRR.gains.fullExploration);
            updateCommentary(
                `All forms explored. Coherence approaches Ω. ${CRR.stage < 5 ? 'When threshold is reached, rupture will transform the world into higher complexity.' : 'At the highest stage, the agent has learned to recognise CRR itself—the pattern that generates all patterns.'}`,
                { term: 'Mastery', desc: 'All schemas acquired' },
                { term: 'Model Complete', desc: 'Environment fully predicted' },
                { term: 'C(t) → Ω', desc: 'Approaching rupture' },
                'C(t) ≈ Ω'
            );
        }
        
        agent.state = 'idle';
        agent.currentTarget = null;
        updateStatus('idle', 'Ready...');
        hidePredictionAndError();
    }
    
    function waitForArrival() {
        return new Promise(resolve => {
            (function check() {
                if (Math.abs(agent.targetX - agent.x) < 5 && Math.abs(agent.targetY - agent.y) < 5) resolve();
                else requestAnimationFrame(check);
            })();
        });
    }
    
    function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    // ============================================================================
    // MAIN LOOP
    // ============================================================================
    
    function update(dt) {
        time += dt;
        worldPhase += dt * 0.5;
        
        agent.x += (agent.targetX - agent.x) * 0.05;
        agent.y += (agent.targetY - agent.y) * 0.05;
        agent.breathePhase += dt * 2;
        
        shapes.forEach(s => {
            if (s.hovered) s.pulsePhase += dt * 5;
            s.phase += dt * 0.8;
        });
    }
    
    function render() {
        drawBackground();
        drawExplorationLine();
        shapes.forEach(drawShape);
        drawAgent();
    }
    
    let lastTime = 0;
    function animate(ts) {
        const dt = Math.min((ts - lastTime) / 1000, 0.1);
        lastTime = ts;
        update(dt);
        render();
        requestAnimationFrame(animate);
    }
    
    // ============================================================================
    // EVENTS
    // ============================================================================
    
    function getMousePos(e) {
        const r = canvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
    }
    
    function getShapeAt(pos) {
        for (let i = shapes.length - 1; i >= 0; i--) {
            const s = shapes[i];
            if ((pos.x - s.x) ** 2 + (pos.y - s.y) ** 2 < s.radius ** 2) return s;
        }
        return null;
    }
    
    canvas.addEventListener('mousemove', e => {
        const pos = getMousePos(e);
        shapes.forEach(s => s.hovered = false);
        const s = getShapeAt(pos);
        if (s) { s.hovered = true; canvas.style.cursor = 'pointer'; }
        else canvas.style.cursor = 'default';
    });
    
    canvas.addEventListener('click', e => {
        const s = getShapeAt(getMousePos(e));
        if (s && agent.state === 'idle' && CRR.phase === 'coherence') exploreShape(s);
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
        generativeModel = { shapes: {}, colors: {}, sizes: {}, abstractions: [] };
        CRR.reset();
        initializeShapes();
        agent.state = 'idle';
        agent.x = agent.targetX = 80;
        agent.y = agent.targetY = H / 2;
        agent.currentTarget = null;
        updateBeliefDisplay();
        hidePredictionAndError();
        updateStatus('idle', 'Agent awaiting instruction...');
        updateCommentary('This agent learns through Active Inference and CRR. At higher stages, shapes themselves embody C→δ→R—self-similarity across scales.', null, null, null, null);
    });
    
    document.getElementById('randomBtn').addEventListener('click', () => {
        if (agent.state !== 'idle' || CRR.phase !== 'coherence') return;
        const unexplored = shapes.filter(s => !s.explored);
        const target = unexplored.length > 0 ? unexplored[Math.floor(Math.random() * unexplored.length)] : shapes[Math.floor(Math.random() * shapes.length)];
        exploreShape(target);
    });
    
    // ============================================================================
    // INIT
    // ============================================================================
    
    initializeShapes();
    CRR.updateDisplay();
    updateBeliefDisplay();
    requestAnimationFrame(animate);
    
    </script>
</body>
</html>
