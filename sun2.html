<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Solar Physics - Photorealistic</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #ffffff;
            color: #1a1a1a;
            font-family: Georgia, 'Times New Roman', serif;
            min-height: 100vh;
            padding: 40px 20px;
        }

        .main-container {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            border-radius: 0;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.06);
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
        }

        .header .subtitle {
            color: #666666;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .explainer-section {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0284c7;
            border-radius: 0;
            padding: 20px;
            margin-bottom: 20px;
        }

        .explainer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .explainer-header h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: #0c4a6e;
        }

        .explainer-toggle {
            font-size: 1.5rem;
            color: #0284c7;
            transition: transform 0.3s;
        }

        .explainer-toggle.open {
            transform: rotate(180deg);
        }

        .explainer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .explainer-content.open {
            max-height: 2000px;
            margin-top: 20px;
        }

        .explainer-box {
            background: white;
            border: 1px solid #bae6fd;
            border-radius: 0;
            padding: 20px;
            margin-bottom: 15px;
        }

        .explainer-box h4 {
            color: #0c4a6e;
            font-size: 1rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .explainer-box p {
            color: #334155;
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .explainer-box ul {
            color: #334155;
            font-size: 0.85rem;
            margin-left: 20px;
            line-height: 1.6;
        }

        .equation {
            background: #f1f5f9;
            padding: 12px;
            border-radius: 0;
            font-family: 'Courier New', monospace;
            color: #0f172a;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        .hash-box {
            background: #1e293b;
            color: #10b981;
            padding: 15px;
            border-radius: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            margin: 10px 0;
            overflow-x: auto;
        }

        .simulation-area {
            position: relative;
            width: 100%;
            height: 750px;
            background: linear-gradient(135deg, #000 0%, #001122 100%);
            border: 1px solid #e0e0e0;
            border-radius: 0;
            overflow: hidden;
            margin-bottom: 30px;
        }

        #solarCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .solar-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,15,30,0.95);
            color: rgba(200,220,255,0.95);
            padding: 20px;
            border-radius: 0;
            border: 2px solid rgba(100,150,255,0.3);
            font-size: 12px;
            min-width: 320px;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            font-family: 'Courier New', monospace;
        }

        .solar-controls .title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #88ddff;
            font-size: 14px;
            text-align: center;
        }

        .crr-status {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 0;
            padding: 12px;
            margin-bottom: 15px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 11px;
        }

        .status-label {
            color: #aaccff;
        }

        .status-value {
            color: #10b981;
            font-weight: bold;
        }

        .control-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
        }

        .control-group label {
            min-width: 120px;
            color: #aaccff;
            font-size: 11px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            background: rgba(100,150,255,0.2);
            border-radius: 0;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #88ddff;
            border-radius: 0;
            cursor: pointer;
        }

        .value {
            min-width: 60px;
            text-align: right;
            color: #ffdd88;
            font-family: monospace;
            font-size: 11px;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            background: rgba(100,150,255,0.2);
            border: 1px solid rgba(100,150,255,0.4);
            color: #88ddff;
            padding: 8px 12px;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(100,150,255,0.3);
            border-color: rgba(100,150,255,0.6);
        }

        button:active {
            transform: scale(0.98);
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 0;
            padding: 20px;
        }

        .metric-card h3 {
            color: #1a1a1a;
            font-size: 0.9rem;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.85rem;
        }

        .metric-label {
            color: #666666;
        }

        .metric-value {
            color: #1a1a1a;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>CRR Solar Physics Engine</h1>
            <div class="subtitle">Coherence-Rupture-Regeneration Framework Applied to Solar Dynamics</div>
        </div>

        <div class="explainer-section">
            <div class="explainer-header" onclick="toggleExplainer()">
                <h3>Understanding the CRR Framework in Solar Physics</h3>
                <span class="explainer-toggle" id="explainerToggle">▼</span>
            </div>
            <div class="explainer-content" id="explainerContent">
                <div class="explainer-box">
                    <h4>Nuclear Coherence (C_nuclear)</h4>
                    <p>Represents the Sun's evolutionary position in its main sequence lifetime (~10 billion years). This coherence accumulates monotonically as hydrogen fuses into helium.</p>
                    <div class="equation">C_nuclear(t) = ∫₀ᵗ L_fusion(τ) dτ ≈ 0.50 (halfway through life)</div>
                    <p>This is a <strong>resilient signature</strong> - steady buildup with rare catastrophic rupture at the end.</p>
                </div>

                <div class="explainer-box">
                    <h4>Magnetic Coherence (C_magnetic)</h4>
                    <p>Represents position within the ~11-year solar magnetic cycle. Builds up coherence, then undergoes rupture (pole reversal).</p>
                    <div class="equation">C_magnetic(t) = cyclical oscillation with period ≈ 11 years</div>
                    <p>This is an <strong>oscillatory signature</strong> - rhythmic renewal through periodic rupture.</p>
                </div>

                <div class="explainer-box">
                    <h4>Rupture Events (δ-functions)</h4>
                    <p>Discrete, impulsive events that punctuate the smooth evolution:</p>
                    <div class="equation">∑ᵢ ρᵢ(x)·δ(t-tᵢ)</div>
                    <ul>
                        <li><strong>Solar Flares:</strong> Electromagnetic ruptures (X-class = extreme)</li>
                        <li><strong>CMEs:</strong> Mass ejection ruptures (plasma expulsion)</li>
                        <li><strong>Magnetic Reversals:</strong> Complete field coherence reset</li>
                    </ul>
                </div>

                <div class="explainer-box">
                    <h4>Regeneration Operator (R)</h4>
                    <p>After rupture, the system regenerates through causally-constrained memory integration:</p>
                    <div class="equation">R[χ](x,t) = ∫ φ(x,τ)·e^(C(x)/Ω)·Θ(t-τ) dτ</div>
                    <p>The corona reforms, magnetic field rebuilds, but with memory of past states. This is not instantaneous reset but exponentially-weighted temporal recovery.</p>
                </div>

                <div class="explainer-box">
                    <h4>Multi-Scale Temporal Unity</h4>
                    <p>The profound achievement: CRR unifies vastly different timescales under one variational principle:</p>
                    <ul>
                        <li>Billion-year nuclear evolution</li>
                        <li>Decade-scale magnetic cycles</li>
                        <li>Hour-scale flare dynamics</li>
                    </ul>
                    <p>The sun can be thought of as a <strong>history-bearing system</strong> that actively constructs its own temporality.</p>
                </div>

                <div class="hash-box">
                    CRR_SOLAR_SIGNATURE = {
                      nuclear: "resilient",
                      magnetic: "oscillatory", 
                      flares: "metabolized_rupture",
                      identity: "maintained_through_change"
                    }
                </div>
            </div>
        </div>

        <div class="simulation-area">
            <canvas id="solarCanvas"></canvas>
            <div class="solar-controls">
                <div class="title">CRR DYNAMICS CONTROL</div>
                
                <div class="crr-status">
                    <div class="status-row">
                        <span class="status-label">Nuclear Coherence:</span>
                        <span class="status-value" id="nuclearC">0.500</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Magnetic Coherence:</span>
                        <span class="status-value" id="magneticC">0.460</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Total Ruptures:</span>
                        <span class="status-value" id="totalRuptures">0</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Time Speed:</label>
                    <input type="range" id="timespeed" min="1" max="50" value="10" step="1">
                    <span class="value" id="timespeed-display">10x</span>
                </div>

                <div class="control-group">
                    <label>Flare Intensity:</label>
                    <input type="range" id="flareintensity" min="0.5" max="5" value="2.2" step="0.1">
                    <span class="value" id="flareintensity-display">C6.6</span>
                </div>

                <div class="control-group">
                    <label>Magnetic Activity:</label>
                    <input type="range" id="magnetic" min="0.1" max="2.0" value="1.0" step="0.1">
                    <span class="value" id="magnetic-display">1.0</span>
                </div>

                <div class="button-group">
                    <button onclick="resetSystem()" style="grid-column: 1 / -1;">Reset System</button>
                </div>
            </div>
        </div>

        <div class="metrics-panel">
            <div class="metric-card">
                <h3>Coherence Metrics</h3>
                <div class="metric-row">
                    <span class="metric-label">Current Coherence:</span>
                    <span class="metric-value" id="coherenceValue">0.500</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Main Sequence Progress:</span>
                    <span class="metric-value" id="progressValue">50.0%</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Years Remaining:</span>
                    <span class="metric-value" id="yearsValue">5.0 Gyr</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Rupture Status</h3>
                <div class="metric-row">
                    <span class="metric-label">System State:</span>
                    <span class="metric-value" id="ruptureState">Stable</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Memory Signature:</span>
                    <span class="metric-value">Resilient/Oscillatory</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Temporal Mode:</span>
                    <span class="metric-value">Non-Markovian</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SOLAR_PHYSICS = {
            total_lifetime: 10e9,
            current_age: 4.6e9,
            years_remaining: 5.4e9,
            magnetic_cycle: 11,
            radius_km: 696000
        };

        class CRRSolarEngine {
            constructor() {
                this.canvas = document.getElementById('solarCanvas');
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas, 
                    antialias: true,
                    alpha: true 
                });
                this.renderer.setSize(this.canvas.offsetWidth, this.canvas.offsetHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    45, 
                    this.canvas.offsetWidth / this.canvas.offsetHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.z = 8;
                
                this.crr = {
                    nuclear_C: 0.50,
                    magnetic_C: 0.46,
                    flare_intensity: 2.2,
                    magnetic_activity: 1.0,
                    rupture_count: 0,
                    time_speed: 10
                };
                
                this.time = 0;
                this.rotation = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.autoRotate = false;
                
                this.init();
            }
            
            init() {
                this.createSolarLayers();
                this.setupLighting();
                this.bindControls();
                this.setupInteraction();
                this.animate();
                
                window.addEventListener('resize', () => this.handleResize());
            }
            
            handleResize() {
                const width = this.canvas.offsetWidth;
                const height = this.canvas.offsetHeight;
                this.renderer.setSize(width, height);
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
            }
            
            createSolarLayers() {
                // Enhanced photorealistic shaders
                const photosphereGeometry = new THREE.SphereGeometry(2.0, 128, 128);
                const chromosphereGeometry = new THREE.SphereGeometry(2.08, 128, 128);
                const coronaGeometry = new THREE.SphereGeometry(2.25, 128, 128);
                const extendedCoronaGeometry = new THREE.SphereGeometry(3.0, 64, 64);
                
                // PHOTOREALISTIC PHOTOSPHERE SHADER
                const photosphereShader = `
                    uniform float u_time;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // Enhanced 3D noise function
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        
                        vec3 i  = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        
                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }
                    
                    float fbm(vec3 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        
                        for(int i = 0; i < 6; i++) {
                            value += amplitude * snoise(p * frequency);
                            frequency *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }
                    
                    void main() {
                        vec3 pos = vPosition;
                        
                        // Multi-scale granulation
                        float granulation = fbm(pos * 4.0 + u_time * 0.05);
                        float supergranulation = fbm(pos * 1.5 + u_time * 0.02) * 0.4;
                        float sunspots = smoothstep(0.6, 0.65, fbm(pos * 2.5 + u_time * 0.01));
                        
                        // Limb darkening (realistic center-to-edge brightness)
                        float limb = dot(normalize(vNormal), vec3(0.0, 0.0, 1.0));
                        float limbDarkening = pow(limb, 0.6);
                        
                        // Base photosphere colors (realistic spectrum)
                        vec3 coreColor = vec3(1.0, 0.95, 0.85);       // Center: yellowish white
                        vec3 edgeColor = vec3(1.0, 0.75, 0.45);       // Edge: orange
                        vec3 spotColor = vec3(0.15, 0.08, 0.02);      // Sunspots: dark
                        
                        // Mix colors with granulation
                        vec3 surfaceColor = mix(edgeColor, coreColor, limbDarkening);
                        surfaceColor += granulation * 0.15;
                        surfaceColor += supergranulation * 0.1;
                        surfaceColor = mix(surfaceColor, spotColor, sunspots * 0.7);
                        
                        // Brightness modulation
                        float brightness = 1.2 + granulation * 0.2 + supergranulation * 0.1;
                        brightness *= (0.4 + limbDarkening * 0.6);
                        
                        gl_FragColor = vec4(surfaceColor * brightness, 1.0);
                    }
                `;
                
                this.photosphereMaterial = new THREE.ShaderMaterial({
                    vertexShader: this.getVertexShader(),
                    fragmentShader: photosphereShader,
                    uniforms: {
                        u_time: { value: 0 }
                    }
                });
                
                // PHOTOREALISTIC CHROMOSPHERE SHADER
                const chromosphereShader = `
                    uniform float u_time;
                    uniform float u_magnetic;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float snoise(vec3 v);
                    float fbm(vec3 p);
                    
                    void main() {
                        vec3 pos = vPosition;
                        
                        // Spicules and prominences
                        float spicules = fbm(pos * 8.0 + u_time * 0.1) * 0.5;
                        float prominences = smoothstep(0.3, 0.7, fbm(pos * 3.0 + u_time * 0.05)) * u_magnetic;
                        
                        // Edge detection for limb
                        float edge = 1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0)));
                        edge = pow(edge, 2.0);
                        
                        // Hydrogen-alpha red glow
                        vec3 chromoColor = vec3(1.0, 0.2, 0.15);
                        float intensity = (spicules * 0.3 + prominences * 0.6) * edge * 0.8;
                        
                        float alpha = intensity * 0.6;
                        gl_FragColor = vec4(chromoColor, alpha);
                    }
                `;
                
                // Include noise functions
                const chromosphereShaderFull = chromosphereShader.replace(
                    'float snoise(vec3 v);',
                    photosphereShader.substring(
                        photosphereShader.indexOf('vec3 mod289'),
                        photosphereShader.indexOf('float fbm')
                    )
                ).replace('float fbm(vec3 p);', 
                    photosphereShader.substring(
                        photosphereShader.indexOf('float fbm'),
                        photosphereShader.indexOf('void main()')
                    )
                );
                
                this.chromosphereMaterial = new THREE.ShaderMaterial({
                    vertexShader: this.getVertexShader(),
                    fragmentShader: chromosphereShaderFull,
                    uniforms: {
                        u_time: { value: 0 },
                        u_magnetic: { value: this.crr.magnetic_activity }
                    },
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                // PHOTOREALISTIC CORONA SHADER WITH FLARES
                const coronaShader = `
                    uniform float u_time;
                    uniform float u_flares;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float snoise(vec3 v);
                    float fbm(vec3 p);
                    
                    void main() {
                        vec3 pos = vPosition;
                        
                        // Coronal loops and magnetic field lines
                        float loops = fbm(pos * 5.0 + u_time * 0.08) * 0.6;
                        float streamers = fbm(pos * 2.5 + u_time * 0.04) * 0.4;
                        
                        // Solar flares - bright, intense bursts
                        float flarePattern = fbm(pos * 6.0 + u_time * 0.15);
                        float flareIntensity = smoothstep(0.4, 0.8, flarePattern) * u_flares;
                        
                        // Edge glow
                        float edge = 1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0)));
                        edge = pow(edge, 1.5);
                        
                        // Corona colors: white-blue with flare yellows
                        vec3 coronaBase = vec3(0.8, 0.9, 1.0);
                        vec3 flareColor = vec3(1.0, 0.9, 0.7);
                        vec3 color = mix(coronaBase, flareColor, flareIntensity);
                        
                        float intensity = (loops + streamers) * edge * 0.4;
                        intensity += flareIntensity * 0.8;
                        
                        float alpha = intensity * 0.5;
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
                
                const coronaShaderFull = coronaShader.replace(
                    'float snoise(vec3 v);',
                    photosphereShader.substring(
                        photosphereShader.indexOf('vec3 mod289'),
                        photosphereShader.indexOf('float fbm')
                    )
                ).replace('float fbm(vec3 p);', 
                    photosphereShader.substring(
                        photosphereShader.indexOf('float fbm'),
                        photosphereShader.indexOf('void main()')
                    )
                );
                
                this.coronaMaterial = new THREE.ShaderMaterial({
                    vertexShader: this.getVertexShader(),
                    fragmentShader: coronaShaderFull,
                    uniforms: {
                        u_time: { value: 0 },
                        u_flares: { value: this.crr.flare_intensity / 5.0 }
                    },
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                // EXTENDED CORONA (CMEs)
                const extendedCoronaShader = `
                    uniform float u_time;
                    uniform float u_flares;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float snoise(vec3 v);
                    float fbm(vec3 p);
                    
                    void main() {
                        vec3 pos = vPosition;
                        
                        // Faint extended corona
                        float corona = fbm(pos * 1.5 + u_time * 0.03) * 0.3;
                        
                        // CME ejections
                        float cme = fbm(pos * 3.0 + u_time * 0.2) * u_flares;
                        
                        float edge = 1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0)));
                        edge = pow(edge, 3.0);
                        
                        vec3 color = vec3(0.6, 0.7, 1.0);
                        float intensity = (corona + cme * 2.0) * edge * 0.3;
                        
                        float alpha = intensity * 0.3;
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
                
                const extendedCoronaShaderFull = extendedCoronaShader.replace(
                    'float snoise(vec3 v);',
                    photosphereShader.substring(
                        photosphereShader.indexOf('vec3 mod289'),
                        photosphereShader.indexOf('float fbm')
                    )
                ).replace('float fbm(vec3 p);', 
                    photosphereShader.substring(
                        photosphereShader.indexOf('float fbm'),
                        photosphereShader.indexOf('void main()')
                    )
                );
                
                this.extendedCoronaMaterial = new THREE.ShaderMaterial({
                    vertexShader: this.getVertexShader(),
                    fragmentShader: extendedCoronaShaderFull,
                    uniforms: {
                        u_time: { value: 0 },
                        u_flares: { value: 0.0 }
                    },
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                // Create meshes
                this.photosphereMesh = new THREE.Mesh(photosphereGeometry, this.photosphereMaterial);
                this.chromosphereMesh = new THREE.Mesh(chromosphereGeometry, this.chromosphereMaterial);
                this.coronaMesh = new THREE.Mesh(coronaGeometry, this.coronaMaterial);
                this.extendedCoronaMesh = new THREE.Mesh(extendedCoronaGeometry, this.extendedCoronaMaterial);
                
                this.scene.add(this.photosphereMesh);
                this.scene.add(this.chromosphereMesh);
                this.scene.add(this.coronaMesh);
                this.scene.add(this.extendedCoronaMesh);
            }
            
            getVertexShader() {
                return `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
            }
            
            setupLighting() {
                // High ambient light to ensure the sun is evenly lit from all directions
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
                this.scene.add(ambientLight);
                
                // Add multiple directional lights to eliminate any shadows
                const light1 = new THREE.DirectionalLight(0xffffff, 0.5);
                light1.position.set(1, 1, 1);
                this.scene.add(light1);
                
                const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
                light2.position.set(-1, -1, -1);
                this.scene.add(light2);
                
                const light3 = new THREE.DirectionalLight(0xffffff, 0.3);
                light3.position.set(1, -1, 0);
                this.scene.add(light3);
                
                const light4 = new THREE.DirectionalLight(0xffffff, 0.3);
                light4.position.set(-1, 1, 0);
                this.scene.add(light4);
            }
            
            bindControls() {
                const timeEl = document.getElementById('timespeed');
                const timeDisp = document.getElementById('timespeed-display');
                timeEl.addEventListener('input', (e) => {
                    this.crr.time_speed = parseFloat(e.target.value);
                    timeDisp.textContent = Math.round(this.crr.time_speed) + 'x';
                });
                
                const flareEl = document.getElementById('flareintensity');
                const flareDisp = document.getElementById('flareintensity-display');
                flareEl.addEventListener('input', (e) => {
                    this.crr.flare_intensity = parseFloat(e.target.value);
                    const classValue = this.crr.flare_intensity * 3;
                    flareDisp.textContent = 'C' + classValue.toFixed(1);
                    this.updateUniforms();
                });
                
                const magEl = document.getElementById('magnetic');
                const magDisp = document.getElementById('magnetic-display');
                magEl.addEventListener('input', (e) => {
                    this.crr.magnetic_activity = parseFloat(e.target.value);
                    magDisp.textContent = this.crr.magnetic_activity.toFixed(1);
                    this.updateUniforms();
                });
            }
            
            setupInteraction() {
                let isDragging = false;
                let previousMouse = { x: 0, y: 0 };
                
                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMouse = { x: e.clientX, y: e.clientY };
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - previousMouse.x;
                        const deltaY = e.clientY - previousMouse.y;
                        this.targetRotation.y += deltaX * 0.01;
                        this.targetRotation.x += deltaY * 0.01;
                        previousMouse = { x: e.clientX, y: e.clientY };
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => isDragging = false);
                this.canvas.addEventListener('mouseleave', () => isDragging = false);
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 1.1 : 0.9;
                    this.camera.position.z *= delta;
                    this.camera.position.z = Math.max(3, Math.min(25, this.camera.position.z));
                });
            }
            
            updateUniforms() {
                if (this.chromosphereMaterial?.uniforms) {
                    this.chromosphereMaterial.uniforms.u_magnetic.value = this.crr.magnetic_activity;
                }
                if (this.coronaMaterial?.uniforms) {
                    this.coronaMaterial.uniforms.u_flares.value = this.crr.flare_intensity / 5.0;
                }
            }
            
            updateDisplays() {
                document.getElementById('coherenceValue').textContent = this.crr.nuclear_C.toFixed(3);
                document.getElementById('progressValue').textContent = (this.crr.nuclear_C * 100).toFixed(1) + '%';
                document.getElementById('yearsValue').textContent = (SOLAR_PHYSICS.years_remaining / 1e9).toFixed(1) + ' Gyr';
                document.getElementById('ruptureState').textContent = 
                    this.crr.rupture_count > 0 ? 'Active' : 'Stable';
                
                document.getElementById('nuclearC').textContent = this.crr.nuclear_C.toFixed(3);
                document.getElementById('magneticC').textContent = this.crr.magnetic_C.toFixed(3);
                document.getElementById('totalRuptures').textContent = this.crr.rupture_count;
                
                // Update magnetic cycle position
                const cycleProgress = (this.time * this.crr.time_speed / 100) % 1;
                this.crr.magnetic_C = cycleProgress;
            }
            
            animate() {
                this.time += 0.016;
                
                if (this.autoRotate) {
                    this.rotation.y += 0.003;
                } else {
                    this.rotation.x += (this.targetRotation.x - this.rotation.x) * 0.1;
                    this.rotation.y += (this.targetRotation.y - this.rotation.y) * 0.1;
                }
                
                [this.photosphereMesh, this.chromosphereMesh, this.coronaMesh, this.extendedCoronaMesh]
                    .forEach(mesh => {
                        if (mesh) {
                            mesh.rotation.x = this.rotation.x;
                            mesh.rotation.y = this.rotation.y;
                        }
                    });
                
                const acceleratedTime = this.time * this.crr.time_speed;
                [this.photosphereMaterial, this.chromosphereMaterial, this.coronaMaterial, this.extendedCoronaMaterial]
                    .forEach(mat => {
                        if (mat?.uniforms?.u_time) {
                            mat.uniforms.u_time.value = acceleratedTime;
                        }
                    });
                
                this.updateDisplays();
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.animate());
            }
        }
        
        let engine;
        
        function toggleExplainer() {
            const content = document.getElementById('explainerContent');
            const toggle = document.getElementById('explainerToggle');
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        function toggleRotation() {
            if (engine) engine.autoRotate = !engine.autoRotate;
        }
        
        function resetSystem() {
            if (engine) {
                engine.crr = {
                    nuclear_C: 0.50,
                    magnetic_C: 0.46,
                    flare_intensity: 2.2,
                    magnetic_activity: 1.0,
                    rupture_count: 0,
                    time_speed: 10
                };
                engine.updateUniforms();
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            engine = new CRRSolarEngine();
            console.log('CRR Solar Engine initialized - Photorealistic rendering');
        });
    </script>
</body>
</html>