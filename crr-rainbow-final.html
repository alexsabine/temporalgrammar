<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Rainbow — Coherence · Rupture · Regeneration</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      min-height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Georgia, 'Times New Roman', serif;
      overflow: hidden;
      cursor: none;
    }
    
    body.show-cursor { cursor: crosshair; }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #sky { z-index: 1; }
    #droplets { z-index: 2; }
    #rain { z-index: 3; }
    #rainbow { z-index: 4; }
    #veil { z-index: 5; }
    
    .fixation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .fixation.visible { opacity: 1; }
    
    .cross {
      position: relative;
      width: 50px;
      height: 50px;
    }
    
    .cross::before,
    .cross::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.22);
    }
    
    .cross::before {
      width: 1px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .cross::after {
      width: 100%;
      height: 1px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .cross-dot {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 5px;
      height: 5px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
    }
    
    .controls {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 0.5rem;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    body.show-cursor .controls { opacity: 1; }
    
    button {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 0.5rem 1rem;
      font: inherit;
      font-size: 0.55rem;
      letter-spacing: 0.12em;
      color: rgba(255, 255, 255, 0.35);
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }
    
    button:hover {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.6);
    }
    
    button.active {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.75);
    }
    
    .info {
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
      color: rgba(220, 230, 240, 0.6);
    }
    
    body.show-cursor .info { opacity: 1; }
    
    .title {
      font-size: 0.75rem;
      letter-spacing: 0.5em;
      opacity: 0.4;
      margin-bottom: 0.25rem;
    }
    
    .hint {
      font-size: 0.5rem;
      font-style: italic;
      opacity: 0.3;
      max-width: 520px;
      line-height: 1.6;
    }
    
    .wavelength-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, 60px);
      font-family: 'Courier New', monospace;
      font-size: 0.5rem;
      color: rgba(255, 255, 255, 0.35);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      text-align: center;
      line-height: 1.5;
    }
    
    .wavelength-display.visible { opacity: 1; }
    
    .zoom-display {
      position: fixed;
      top: 1rem;
      right: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.55rem;
      color: rgba(180, 200, 220, 0.4);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
      text-align: right;
      line-height: 1.6;
    }
    
    body.show-cursor .zoom-display { opacity: 1; }
    
    .equation {
      position: fixed;
      bottom: 3.5rem;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 0.45rem;
      color: rgba(180, 200, 220, 0.3);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    body.show-cursor .equation { opacity: 1; }
  </style>
</head>
<body class="show-cursor">
  <div id="container">
    <canvas id="sky"></canvas>
    <canvas id="droplets"></canvas>
    <canvas id="rain"></canvas>
    <canvas id="rainbow"></canvas>
    <canvas id="veil"></canvas>
  </div>
  
  <div class="info">
    <div class="title">CRR RAINBOW</div>
    <div class="hint">
      scroll to zoom into the rainbow's micro-structure · fixate on the cross to fade ·
      trace through the spectrum to hear coherence singing
    </div>
  </div>
  
  <div class="fixation" id="fixation">
    <div class="cross">
      <div class="cross-dot"></div>
    </div>
  </div>
  
  <div class="wavelength-display" id="wavelengthDisplay">
    <div id="lambdaValue">λ = --- nm</div>
    <div id="freqValue">f = --- Hz</div>
    <div id="noteValue">---</div>
  </div>
  
  <div class="zoom-display" id="zoomDisplay">
    <div id="zoomLevel">1.0×</div>
    <div id="scaleInfo">macro view</div>
  </div>
  
  <div class="equation" id="equation">
    C(λ,t) = ∫L(λ,τ)dτ → δ(adaptation) → R(blank field)
  </div>
  
  <div class="controls">
    <button id="btnRain">RAIN</button>
    <button id="btnFixation">FIXATION</button>
    <button id="btnSing">SING</button>
    <button id="btnZoomReset">RESET ZOOM</button>
    <button id="btnImmerse">IMMERSE</button>
  </div>

<script>
/**
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║                                                                           ║
 * ║   CRR RAINBOW — With Zoom into Micro-Scale CRR Dynamics                   ║
 * ║                                                                           ║
 * ║   This version adds the ability to zoom into the rainbow to observe       ║
 * ║   CRR operating at progressively smaller scales:                          ║
 * ║                                                                           ║
 * ║   1× - 3×:   Macro view (full rainbow, atmospheric effects)               ║
 * ║   3× - 10×:  Meso view (individual rain streaks, color bands)             ║
 * ║   10× - 30×: Micro view (water droplets visible, refraction patterns)     ║
 * ║   30× - 100×: Nano view (interference fringes, wave coherence)            ║
 * ║                                                                           ║
 * ║   CRR operates at ALL scales - zoom reveals this universality.            ║
 * ║                                                                           ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 * 
 * ============================================================================
 * CRR (COHERENCE-RUPTURE-REGENERATION) FRAMEWORK
 * ============================================================================
 * 
 * Core equations:
 *   C(x,t) = ∫L(x,τ)dτ           — Coherence accumulates over time
 *   δ(now)                       — Rupture at scale-invariant transition moments
 *   R = ∫φ(x,τ)exp(C/Ω)Θ(...)dτ  — Regeneration with memory weighting
 * 
 * Key parameters:
 *   Ω = 1/π  for Z₂ (binary/half-cycle) systems
 *   Ω = 1/2π for SO(2) (continuous/full-cycle) systems
 *   CV = Ω/2 (coefficient of variation)
 * 
 * This simulation demonstrates CRR at multiple scales:
 * - Optical coherence (light through droplets)
 * - Perceptual coherence (Troxler fading)
 * - Behavioral coherence (mouse movement → audio)
 * - Particle coherence (individual droplets)
 * 
 * ============================================================================
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  
  /**
   * ZOOM CONFIGURATION
   * 
   * CRR is scale-invariant - the same dynamics operate at all scales.
   * Zooming reveals progressively finer structure:
   * 
   * - Macro: Full rainbow, atmospheric integration
   * - Meso: Color band structure, rain streaks
   * - Micro: Individual droplets, refraction geometry
   * - Nano: Interference fringes, wave coherence patterns
   */
  zoom: {
    min: 1,
    max: 100,
    current: 1,
    target: 1,
    speed: 0.08,          // Zoom animation smoothness
    centerX: 0.5,         // Zoom center (fraction of screen)
    centerY: 0.5,
    
    // Scale thresholds for different detail levels
    thresholds: {
      meso: 3,            // Show enhanced color bands
      micro: 10,          // Show individual droplets
      nano: 30,           // Show interference patterns
    }
  },
  
  /**
   * RAINBOW CONFIGURATION
   * 
   * CRR Mapping:
   * - Wavelength-dependent α compensates for cone adaptation rates
   * - Blur removes edges that resist adaptation
   * - Full circle places rainbow in peripheral vision for Troxler
   */
  rainbow: {
    alphaBase: 0.052,
    saturationBoost: 1.25,
    blur: 5,
    innerRadius: 0.28,
    outerRadius: 0.40,
    
    // CRR-compensated alpha for uniform adaptation across wavelengths
    alphaByWavelength: λ => {
      if (λ >= 640) return 0.58;   // Red - slow L-cones
      if (λ >= 600) return 0.65;
      if (λ >= 570) return 0.75;
      if (λ >= 540) return 0.85;
      if (λ >= 500) return 0.92;
      if (λ >= 460) return 0.98;
      if (λ >= 420) return 1.0;    // Blue - fast S-cones
      return 0.88;
    }
  },
  
  /**
   * DROPLET CONFIGURATION
   * 
   * CRR at the particle level:
   * - Each droplet is a tiny CRR system
   * - Light enters (coherence begins)
   * - Internal reflection (phase accumulation)  
   * - Exit at rainbow angle (coherence maximum → visible)
   * 
   * At high zoom, individual droplets become visible,
   * each one a complete CRR refraction cycle.
   */
  droplets: {
    count: 2000,              // Total droplet population
    minSize: 0.3,             // mm (typical rain: 0.5-5mm)
    maxSize: 2.5,
    baseAlpha: 0.6,
    
    // Droplet physics
    terminalVelocity: 9,      // m/s (size-dependent in reality)
    turbulence: 0.3,          // Random motion amplitude
    
    // Visual properties at different zoom levels
    glowAtZoom: 10,           // Zoom level where internal glow appears
    refractionAtZoom: 20,     // Zoom level where refraction bands appear
    interferenceAtZoom: 40,   // Zoom level where interference visible
  },
  
  /**
   * SUN CONFIGURATION
   * 
   * Positioned behind viewer (below screen) for correct rainbow geometry.
   * Rainbow appears at 42° from anti-solar point (screen center).
   */
  sun: {
    x: 0.5,
    y: 1.35,
    radius: 50,
    coronaSize: 300,
    color: { r: 255, g: 220, b: 180 },
    glowIntensity: 0.35,
  },
  
  /**
   * SKY - Rayleigh scattering gradient
   */
  sky: {
    zenith: '#0a1628',
    horizon: '#5a85a8',
    warmTint: 0.15,
  },
  
  /**
   * RAIN STREAKS (macro-scale)
   */
  rain: {
    enabled: false,
    count: 500,
    speed: { min: 12, max: 22 },
    length: { min: 25, max: 50 },
    wind: 0.08,
    alpha: 0.12,
    mieScatter: 0.025,
  },
  
  /**
   * ATMOSPHERIC EFFECTS
   */
  atmosphere: {
    veilingLuminance: 0.012,
    pathRadiance: 0.02,
    hazeAlpha: 0.05,
    scintillation: { amplitude: 0.004, frequency: 0.025 },
  },
  
  /**
   * AUDIO - CRR made audible
   */
  audio: {
    enabled: false,
    baseFreq: 196,
    octaves: 2.8,
    attackTime: 0.012,
    releaseTime: 0.5,
    maxGain: 0.1,
    coherenceDecay: 0.94,
    coherenceGain: 0.12,
  }
};

// ============================================================================
// PHYSICS ENGINE
// ============================================================================

const refractiveIndex = λ => 1.3247 + 3300 / (λ * λ);

const rainbowAngle = λ => {
  const n = refractiveIndex(λ);
  const cos2c = (n * n - 1) / 3;
  if (cos2c < 0 || cos2c > 1) return 42;
  const i = Math.acos(Math.sqrt(cos2c));
  const r = Math.asin(Math.sin(i) / n);
  return (Math.PI - (Math.PI + 2*i - 4*r)) * 180 / Math.PI;
};

const wavelengthToRGB = λ => {
  let r, g, b;
  
  if (λ < 440) { r = -(λ - 440) / 60; g = 0; b = 1; }
  else if (λ < 490) { r = 0; g = (λ - 440) / 50; b = 1; }
  else if (λ < 510) { r = 0; g = 1; b = -(λ - 510) / 20; }
  else if (λ < 580) { r = (λ - 510) / 70; g = 1; b = 0; }
  else if (λ < 645) { r = 1; g = -(λ - 645) / 65; b = 0; }
  else { r = 1; g = 0; b = 0; }
  
  let efficiency = 1;
  if (λ < 420) efficiency = 0.3 + 0.7 * (λ - 380) / 40;
  else if (λ > 680) efficiency = 0.3 + 0.7 * (700 - λ) / 20;
  
  const sat = CONFIG.rainbow.saturationBoost;
  const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  r = lum + (r - lum) * sat;
  g = lum + (g - lum) * sat;
  b = lum + (b - lum) * sat;
  
  const γ = 2.2;
  return [
    Math.pow(Math.max(0, Math.min(1, r)) * efficiency, 1/γ),
    Math.pow(Math.max(0, Math.min(1, g)) * efficiency, 1/γ),
    Math.pow(Math.max(0, Math.min(1, b)) * efficiency, 1/γ)
  ];
};

const buildSpectrum = () => {
  const spectrum = [];
  for (let λ = 700; λ >= 380; λ -= 0.5) {
    spectrum.push({
      wavelength: λ,
      angle: rainbowAngle(λ),
      rgb: wavelengthToRGB(λ),
      alpha: CONFIG.rainbow.alphaBase * CONFIG.rainbow.alphaByWavelength(λ)
    });
  }
  
  const angles = spectrum.map(s => s.angle);
  const minA = Math.min(...angles);
  const maxA = Math.max(...angles);
  spectrum.forEach(s => {
    s.normalizedRadius = (s.angle - minA) / (maxA - minA);
  });
  
  return spectrum;
};

const SPECTRUM = buildSpectrum();

// ============================================================================
// DROPLET SYSTEM - CRR at the particle level
// ============================================================================

/**
 * WATER DROPLET CLASS
 * 
 * Each droplet is a complete CRR micro-system:
 * 
 * COHERENCE PHASE:
 *   - Light enters droplet
 *   - Refracts at entry surface (phase shift)
 *   - Travels through water (phase accumulation)
 *   - Reflects off back surface (more phase)
 *   - Refracts at exit (final phase adjustment)
 *   
 * RUPTURE MOMENT:
 *   - At specific angle (42° for primary), phases align
 *   - Constructive interference = caustic = rainbow
 *   - This IS the rupture: sudden coherence → visibility
 *   
 * REGENERATION:
 *   - Light continues, droplet falls, new light enters
 *   - Continuous cycle of CRR at microscopic scale
 * 
 * At high zoom, we visualize:
 *   - Droplet sphere with internal refraction
 *   - Color bands from wavelength-dependent angles
 *   - Interference fringes at highest zoom
 */
class Droplet {
  constructor() {
    this.reset(true);
  }
  
  reset(initial = false) {
    // Position in normalized coordinates (0-1)
    // Concentrated in rainbow band region
    const angle = Math.random() * Math.PI * 2;
    const radiusNorm = CONFIG.rainbow.innerRadius + 
                       Math.random() * (CONFIG.rainbow.outerRadius - CONFIG.rainbow.innerRadius) * 1.5;
    
    this.x = 0.5 + Math.cos(angle) * radiusNorm * (0.8 + Math.random() * 0.4);
    this.y = 0.5 + Math.sin(angle) * radiusNorm * (0.8 + Math.random() * 0.4);
    
    // Also scatter some throughout the scene
    if (Math.random() < 0.3) {
      this.x = Math.random();
      this.y = Math.random();
    }
    
    // Physical properties
    this.size = CONFIG.droplets.minSize + 
                Math.random() * (CONFIG.droplets.maxSize - CONFIG.droplets.minSize);
    this.velocity = {
      x: (Math.random() - 0.5) * CONFIG.droplets.turbulence,
      y: CONFIG.droplets.terminalVelocity * (0.5 + this.size / CONFIG.droplets.maxSize)
    };
    
    // CRR phase - where in its coherence cycle is this droplet?
    this.phase = Math.random() * Math.PI * 2;
    this.phaseSpeed = 0.5 + Math.random() * 2;
    
    // Which wavelength this droplet is currently "resonating" with
    // (for visualization of the refraction)
    this.resonantWavelength = 380 + Math.random() * 320;
    
    // Unique identifier for consistent randomness
    this.seed = Math.random() * 1000;
  }
  
  /**
   * Update droplet physics
   * 
   * CRR: Phase accumulates (coherence), droplet falls (trajectory coherence),
   * exits screen (rupture), regenerates at new position.
   */
  update(dt) {
    // Fall with slight turbulence
    this.y += this.velocity.y * dt * 0.001;
    this.x += this.velocity.x * dt * 0.01;
    this.x += Math.sin(this.phase * 3 + this.seed) * CONFIG.droplets.turbulence * dt * 0.01;
    
    // CRR phase evolution
    this.phase += this.phaseSpeed * dt;
    
    // Slowly shift resonant wavelength (simulates changing sun angle)
    this.resonantWavelength += Math.sin(this.phase * 0.1) * dt * 5;
    this.resonantWavelength = Math.max(380, Math.min(700, this.resonantWavelength));
    
    // Rupture: exit screen → regenerate
    if (this.y > 1.2 || this.y < -0.2 || this.x > 1.2 || this.x < -0.2) {
      this.reset();
    }
  }
  
  /**
   * Render droplet at current zoom level
   * 
   * Different detail levels:
   * - Low zoom: Simple bright point
   * - Medium zoom: Glowing sphere
   * - High zoom: Internal refraction visible
   * - Very high zoom: Interference patterns
   */
  draw(ctx, zoom, viewX, viewY, viewW, viewH) {
    // Transform to screen coordinates
    const screenX = (this.x - viewX) / viewW * ctx.canvas.width;
    const screenY = (this.y - viewY) / viewH * ctx.canvas.height;
    
    // Skip if off screen
    if (screenX < -50 || screenX > ctx.canvas.width + 50 ||
        screenY < -50 || screenY > ctx.canvas.height + 50) {
      return;
    }
    
    // Size scales with zoom
    const baseSize = this.size * zoom * 2;
    const size = Math.max(1, baseSize);
    
    // Get color from resonant wavelength
    const rgb = wavelengthToRGB(this.resonantWavelength);
    const r = Math.round(rgb[0] * 255);
    const g = Math.round(rgb[1] * 255);
    const b = Math.round(rgb[2] * 255);
    
    // Alpha based on zoom and size
    const alpha = Math.min(1, CONFIG.droplets.baseAlpha * (0.3 + size / 20));
    
    if (zoom < CONFIG.droplets.glowAtZoom) {
      // LOW ZOOM: Simple glowing point
      // CRR: Just see the integrated effect, not the mechanism
      
      ctx.beginPath();
      ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`;
      ctx.fill();
      
      // Bright core
      if (size > 2) {
        ctx.beginPath();
        ctx.arc(screenX, screenY, size * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
        ctx.fill();
      }
      
    } else if (zoom < CONFIG.droplets.refractionAtZoom) {
      // MEDIUM ZOOM: Glowing sphere with highlight
      // CRR: Beginning to see the droplet structure
      
      const gradient = ctx.createRadialGradient(
        screenX - size * 0.3, screenY - size * 0.3, 0,
        screenX, screenY, size
      );
      gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.6})`);
      gradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${alpha * 0.8})`);
      gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${alpha * 0.4})`);
      gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      
      ctx.beginPath();
      ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Outline
      ctx.beginPath();
      ctx.arc(screenX, screenY, size * 0.9, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.2})`;
      ctx.lineWidth = 1;
      ctx.stroke();
      
    } else if (zoom < CONFIG.droplets.interferenceAtZoom) {
      // HIGH ZOOM: Internal refraction visible
      // CRR: See the phase accumulation path through the droplet
      
      // Droplet body
      const gradient = ctx.createRadialGradient(
        screenX - size * 0.25, screenY - size * 0.25, 0,
        screenX, screenY, size
      );
      gradient.addColorStop(0, `rgba(220, 230, 240, ${alpha * 0.3})`);
      gradient.addColorStop(0.5, `rgba(180, 200, 220, ${alpha * 0.15})`);
      gradient.addColorStop(1, `rgba(150, 170, 190, 0)`);
      
      ctx.beginPath();
      ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Internal refraction arc - this is where CRR coherence happens!
      // Light path through droplet showing where rainbow light exits
      const arcAngle = (this.resonantWavelength - 380) / 320 * 0.3 + 0.5;
      
      ctx.beginPath();
      ctx.arc(screenX, screenY, size * 0.85, 
              Math.PI * arcAngle, Math.PI * (arcAngle + 0.8));
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      ctx.lineWidth = size * 0.15;
      ctx.lineCap = 'round';
      ctx.stroke();
      
      // Secondary internal reflection
      ctx.beginPath();
      ctx.arc(screenX, screenY, size * 0.6,
              Math.PI * (arcAngle + 1), Math.PI * (arcAngle + 1.5));
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`;
      ctx.lineWidth = size * 0.08;
      ctx.stroke();
      
      // Bright exit point - the rupture where coherent light emerges
      const exitAngle = Math.PI * (arcAngle + 0.4);
      const exitX = screenX + Math.cos(exitAngle) * size * 0.85;
      const exitY = screenY + Math.sin(exitAngle) * size * 0.85;
      
      ctx.beginPath();
      ctx.arc(exitX, exitY, size * 0.12, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
      ctx.fill();
      
      // Outline
      ctx.beginPath();
      ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(200, 220, 240, ${alpha * 0.3})`;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
    } else {
      // VERY HIGH ZOOM: Interference fringes visible
      // CRR: Wave coherence patterns from path length differences
      
      // Droplet body with interference rings
      ctx.beginPath();
      ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200, 215, 230, ${alpha * 0.1})`;
      ctx.fill();
      
      // Interference fringes - concentric rings from wave coherence
      const fringeCount = Math.floor(size / 8);
      for (let i = 0; i < fringeCount; i++) {
        const fringeR = size * (0.3 + i * 0.15);
        const fringePhase = (this.phase + i * 0.5) % (Math.PI * 2);
        const fringeIntensity = (Math.sin(fringePhase) + 1) * 0.5;
        
        ctx.beginPath();
        ctx.arc(screenX, screenY, fringeR, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * fringeIntensity * 0.6})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Central caustic - the coherence maximum
      const causticSize = size * 0.2 * (1 + Math.sin(this.phase * 2) * 0.3);
      const causticGrad = ctx.createRadialGradient(
        screenX, screenY, 0,
        screenX, screenY, causticSize
      );
      causticGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
      causticGrad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.7})`);
      causticGrad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      
      ctx.beginPath();
      ctx.arc(screenX, screenY, causticSize, 0, Math.PI * 2);
      ctx.fillStyle = causticGrad;
      ctx.fill();
      
      // Rainbow ray exit
      const rayAngle = Math.PI * 0.7;
      const rayLength = size * 1.5;
      
      const rayGrad = ctx.createLinearGradient(
        screenX, screenY,
        screenX + Math.cos(rayAngle) * rayLength,
        screenY + Math.sin(rayAngle) * rayLength
      );
      rayGrad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.8})`);
      rayGrad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      
      ctx.beginPath();
      ctx.moveTo(screenX, screenY);
      ctx.lineTo(
        screenX + Math.cos(rayAngle) * rayLength,
        screenY + Math.sin(rayAngle) * rayLength
      );
      ctx.strokeStyle = rayGrad;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.stroke();
      
      // Outline
      ctx.beginPath();
      ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(180, 200, 220, ${alpha * 0.25})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

// Create droplet population
let droplets = [];

const initDroplets = () => {
  droplets = [];
  for (let i = 0; i < CONFIG.droplets.count; i++) {
    droplets.push(new Droplet());
  }
};

// ============================================================================
// AUDIO SYSTEM (unchanged - CRR made audible)
// ============================================================================

let audioCtx = null;
let oscillator = null;
let gainNode = null;
let filterNode = null;

let mouseCoherence = 0;
let lastMousePos = { x: 0, y: 0 };
let lastMouseTime = 0;
let currentWavelength = null;
let isInRainbow = false;

const initAudio = () => {
  if (audioCtx) return;
  
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  
  oscillator = audioCtx.createOscillator();
  oscillator.type = 'sine';
  oscillator.frequency.value = 440;
  
  const osc2 = audioCtx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.value = 440;
  osc2.detune.value = 4;
  
  const osc3 = audioCtx.createOscillator();
  osc3.type = 'triangle';
  osc3.frequency.value = 880;
  
  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0;
  
  const gain2 = audioCtx.createGain();
  gain2.gain.value = 0;
  
  const gain3 = audioCtx.createGain();
  gain3.gain.value = 0;
  
  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'lowpass';
  filterNode.frequency.value = 1500;
  filterNode.Q.value = 0.8;
  
  const reverb = audioCtx.createConvolver();
  const reverbLength = audioCtx.sampleRate * 1.5;
  const reverbBuffer = audioCtx.createBuffer(2, reverbLength, audioCtx.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const data = reverbBuffer.getChannelData(ch);
    for (let i = 0; i < reverbLength; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (reverbLength * 0.2));
    }
  }
  reverb.buffer = reverbBuffer;
  
  const reverbGain = audioCtx.createGain();
  reverbGain.gain.value = 0.15;
  
  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.7;
  
  oscillator.connect(gainNode);
  osc2.connect(gain2);
  osc3.connect(gain3);
  
  gainNode.connect(filterNode);
  gain2.connect(filterNode);
  gain3.connect(filterNode);
  
  filterNode.connect(masterGain);
  filterNode.connect(reverb);
  reverb.connect(reverbGain);
  reverbGain.connect(masterGain);
  
  masterGain.connect(audioCtx.destination);
  
  oscillator.start();
  osc2.start();
  osc3.start();
  
  oscillator._osc2 = osc2;
  oscillator._osc3 = osc3;
  oscillator._gain2 = gain2;
  oscillator._gain3 = gain3;
};

const wavelengthToFrequency = λ => {
  const normalized = (λ - 380) / (700 - 380);
  const inverted = 1 - normalized;
  return CONFIG.audio.baseFreq * Math.pow(2, inverted * CONFIG.audio.octaves);
};

const frequencyToNote = f => {
  const noteNames = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
  const semitones = 12 * Math.log2(f / 440) + 9;
  const noteIndex = Math.round(semitones) % 12;
  const octave = Math.floor((semitones + 3) / 12) + 4;
  return noteNames[(noteIndex + 12) % 12] + octave;
};

const updateAudio = (λ, coherence) => {
  if (!audioCtx || !CONFIG.audio.enabled) return;
  
  const now = audioCtx.currentTime;
  const freq = wavelengthToFrequency(λ);
  
  const glideTime = 0.03 + (1 - coherence) * 0.12;
  oscillator.frequency.linearRampToValueAtTime(freq, now + glideTime);
  oscillator._osc2.frequency.linearRampToValueAtTime(freq, now + glideTime);
  oscillator._osc3.frequency.linearRampToValueAtTime(freq * 2, now + glideTime);
  
  const targetGain = CONFIG.audio.maxGain * (0.25 + coherence * 0.75);
  gainNode.gain.linearRampToValueAtTime(targetGain, now + CONFIG.audio.attackTime);
  oscillator._gain2.gain.linearRampToValueAtTime(targetGain * 0.35, now + CONFIG.audio.attackTime);
  oscillator._gain3.gain.linearRampToValueAtTime(targetGain * 0.12 * coherence, now + CONFIG.audio.attackTime);
  
  filterNode.frequency.linearRampToValueAtTime(600 + coherence * 3500, now + 0.05);
};

const fadeOutAudio = () => {
  if (!audioCtx || !gainNode) return;
  const now = audioCtx.currentTime;
  gainNode.gain.linearRampToValueAtTime(0, now + CONFIG.audio.releaseTime);
  oscillator._gain2.gain.linearRampToValueAtTime(0, now + CONFIG.audio.releaseTime);
  oscillator._gain3.gain.linearRampToValueAtTime(0, now + CONFIG.audio.releaseTime);
};

// Rain audio
let rainGain = null;

const initRainAudio = () => {
  if (!audioCtx) initAudio();
  if (rainGain) return;
  
  const bufferSize = audioCtx.sampleRate * 3;
  const buffer = audioCtx.createBuffer(2, bufferSize, audioCtx.sampleRate);
  
  for (let ch = 0; ch < 2; ch++) {
    const data = buffer.getChannelData(ch);
    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
    for (let i = 0; i < bufferSize; i++) {
      const white = Math.random() * 2 - 1;
      b0 = 0.99886 * b0 + white * 0.0555179;
      b1 = 0.99332 * b1 + white * 0.0750759;
      b2 = 0.96900 * b2 + white * 0.1538520;
      b3 = 0.86650 * b3 + white * 0.3104856;
      b4 = 0.55000 * b4 + white * 0.5329522;
      b5 = -0.7616 * b5 - white * 0.0168980;
      data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.06;
      b6 = white * 0.115926;
    }
  }
  
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 2200;
  filter.Q.value = 0.5;
  
  rainGain = audioCtx.createGain();
  rainGain.gain.value = 0;
  
  source.connect(filter);
  filter.connect(rainGain);
  rainGain.connect(audioCtx.destination);
  
  source.start();
};

const setRainAudio = enabled => {
  if (!rainGain) return;
  const target = enabled ? 0.08 : 0;
  rainGain.gain.linearRampToValueAtTime(target, audioCtx.currentTime + 0.8);
};

// ============================================================================
// CANVAS SETUP
// ============================================================================

const skyCanvas = document.getElementById('sky');
const dropletsCanvas = document.getElementById('droplets');
const rainCanvas = document.getElementById('rain');
const rainbowCanvas = document.getElementById('rainbow');
const veilCanvas = document.getElementById('veil');

const skyCtx = skyCanvas.getContext('2d');
const dropletsCtx = dropletsCanvas.getContext('2d');
const rainCtx = rainCanvas.getContext('2d');
const rainbowCtx = rainbowCanvas.getContext('2d');
const veilCtx = veilCanvas.getContext('2d');

let W, H, CX, CY, SIZE;

// View window for zoom (in normalized 0-1 coordinates)
let viewX = 0, viewY = 0, viewW = 1, viewH = 1;

const resize = () => {
  W = window.innerWidth;
  H = window.innerHeight;
  CX = W / 2;
  CY = H / 2;
  SIZE = Math.min(W, H);
  
  [skyCanvas, dropletsCanvas, rainCanvas, rainbowCanvas, veilCanvas].forEach(c => {
    c.width = W;
    c.height = H;
  });
  
  renderSky();
  renderRainbow();
  renderVeil();
};

window.addEventListener('resize', resize);

// ============================================================================
// ZOOM SYSTEM
// ============================================================================

/**
 * Update view window based on zoom level
 * 
 * CRR at different scales:
 * - Zooming in reveals finer structure
 * - The same CRR dynamics operate at every scale
 * - This is the scale-invariance property of CRR
 */
const updateZoom = () => {
  // Smooth zoom animation
  CONFIG.zoom.current += (CONFIG.zoom.target - CONFIG.zoom.current) * CONFIG.zoom.speed;
  
  const zoom = CONFIG.zoom.current;
  
  // Calculate view window size
  viewW = 1 / zoom;
  viewH = 1 / zoom;
  
  // Center view on zoom center
  viewX = CONFIG.zoom.centerX - viewW / 2;
  viewY = CONFIG.zoom.centerY - viewH / 2;
  
  // Clamp to valid range
  viewX = Math.max(0, Math.min(1 - viewW, viewX));
  viewY = Math.max(0, Math.min(1 - viewH, viewY));
  
  // Update display
  const zoomLevel = document.getElementById('zoomLevel');
  const scaleInfo = document.getElementById('scaleInfo');
  
  zoomLevel.textContent = `${zoom.toFixed(1)}×`;
  
  if (zoom < CONFIG.zoom.thresholds.meso) {
    scaleInfo.textContent = 'macro view — full rainbow';
  } else if (zoom < CONFIG.zoom.thresholds.micro) {
    scaleInfo.textContent = 'meso view — color bands';
  } else if (zoom < CONFIG.zoom.thresholds.nano) {
    scaleInfo.textContent = 'micro view — droplets visible';
  } else {
    scaleInfo.textContent = 'nano view — interference patterns';
  }
};

// Mouse wheel zoom
document.addEventListener('wheel', e => {
  e.preventDefault();
  
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  CONFIG.zoom.target = Math.max(
    CONFIG.zoom.min,
    Math.min(CONFIG.zoom.max, CONFIG.zoom.target * zoomFactor)
  );
  
  // Update zoom center to mouse position
  CONFIG.zoom.centerX = e.clientX / W;
  CONFIG.zoom.centerY = e.clientY / H;
  
}, { passive: false });

// ============================================================================
// SKY RENDERING
// ============================================================================

const renderSky = () => {
  const ctx = skyCtx;
  
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0.0, '#0a1628');
  gradient.addColorStop(0.2, '#122540');
  gradient.addColorStop(0.4, '#1a3858');
  gradient.addColorStop(0.6, '#2a5068');
  gradient.addColorStop(0.8, '#3d6580');
  gradient.addColorStop(1.0, '#5a85a8');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
  
  const warmGrad = ctx.createLinearGradient(0, H * 0.5, 0, H);
  warmGrad.addColorStop(0, 'rgba(255, 200, 150, 0)');
  warmGrad.addColorStop(0.5, `rgba(255, 210, 170, ${CONFIG.sky.warmTint * 0.5})`);
  warmGrad.addColorStop(1, `rgba(255, 220, 180, ${CONFIG.sky.warmTint})`);
  ctx.fillStyle = warmGrad;
  ctx.fillRect(0, 0, W, H);
  
  // Sun glow from below
  const sunX = W * CONFIG.sun.x;
  const sunY = H * CONFIG.sun.y;
  
  const glow3 = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, H * 0.9);
  glow3.addColorStop(0, `rgba(255, 230, 190, ${CONFIG.sun.glowIntensity * 0.3})`);
  glow3.addColorStop(0.3, `rgba(255, 220, 180, ${CONFIG.sun.glowIntensity * 0.15})`);
  glow3.addColorStop(0.6, `rgba(255, 210, 170, ${CONFIG.sun.glowIntensity * 0.05})`);
  glow3.addColorStop(1, 'rgba(255, 200, 160, 0)');
  ctx.fillStyle = glow3;
  ctx.fillRect(0, 0, W, H);
  
  const glow2 = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, H * 0.5);
  glow2.addColorStop(0, `rgba(255, 245, 220, ${CONFIG.sun.glowIntensity * 0.5})`);
  glow2.addColorStop(0.2, `rgba(255, 235, 200, ${CONFIG.sun.glowIntensity * 0.25})`);
  glow2.addColorStop(0.5, `rgba(255, 225, 190, ${CONFIG.sun.glowIntensity * 0.1})`);
  glow2.addColorStop(1, 'rgba(255, 215, 180, 0)');
  ctx.fillStyle = glow2;
  ctx.fillRect(0, 0, W, H);
  
  const glow1 = ctx.createRadialGradient(sunX, H, 0, sunX, H, H * 0.25);
  glow1.addColorStop(0, `rgba(255, 255, 240, ${CONFIG.sun.glowIntensity * 0.6})`);
  glow1.addColorStop(0.3, `rgba(255, 250, 230, ${CONFIG.sun.glowIntensity * 0.3})`);
  glow1.addColorStop(0.6, `rgba(255, 245, 220, ${CONFIG.sun.glowIntensity * 0.1})`);
  glow1.addColorStop(1, 'rgba(255, 240, 210, 0)');
  ctx.fillStyle = glow1;
  ctx.fillRect(0, 0, W, H);
  
  // God rays
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  const rayCount = 16;
  for (let i = 0; i < rayCount; i++) {
    const baseAngle = -Math.PI / 2;
    const spread = Math.PI * 0.6;
    const angle = baseAngle + (i / rayCount - 0.5) * spread;
    const length = H * 0.7 + Math.sin(i * 2.7) * H * 0.15;
    const raySpread = 0.03 + Math.sin(i * 1.9) * 0.015;
    
    const rayGrad = ctx.createLinearGradient(
      sunX, H,
      sunX + Math.cos(angle) * length,
      H + Math.sin(angle) * length
    );
    rayGrad.addColorStop(0, `rgba(255, 245, 220, ${CONFIG.sun.glowIntensity * 0.08})`);
    rayGrad.addColorStop(0.4, `rgba(255, 240, 210, ${CONFIG.sun.glowIntensity * 0.03})`);
    rayGrad.addColorStop(1, 'rgba(255, 235, 200, 0)');
    
    ctx.beginPath();
    ctx.moveTo(sunX, H + 50);
    ctx.lineTo(
      sunX + Math.cos(angle - raySpread) * length,
      H + Math.sin(angle - raySpread) * length
    );
    ctx.lineTo(
      sunX + Math.cos(angle + raySpread) * length,
      H + Math.sin(angle + raySpread) * length
    );
    ctx.closePath();
    ctx.fillStyle = rayGrad;
    ctx.fill();
  }
  ctx.restore();
  
  // Horizon glow
  const horizonGlow = ctx.createLinearGradient(0, H * 0.75, 0, H);
  horizonGlow.addColorStop(0, 'rgba(200, 220, 240, 0)');
  horizonGlow.addColorStop(0.5, `rgba(220, 200, 180, ${CONFIG.sun.glowIntensity * 0.15})`);
  horizonGlow.addColorStop(1, `rgba(255, 230, 200, ${CONFIG.sun.glowIntensity * 0.25})`);
  ctx.fillStyle = horizonGlow;
  ctx.fillRect(0, H * 0.75, W, H * 0.25);
};

// ============================================================================
// RAINBOW RENDERING (with zoom support)
// ============================================================================

const renderRainbow = () => {
  const ctx = rainbowCtx;
  ctx.clearRect(0, 0, W, H);
  
  const zoom = CONFIG.zoom.current;
  
  // Rainbow center in screen coordinates (accounting for zoom)
  const rainbowCenterX = (0.5 - viewX) / viewW * W;
  const rainbowCenterY = (0.5 - viewY) / viewH * H;
  
  // Rainbow radii scaled by zoom
  const innerR = SIZE * CONFIG.rainbow.innerRadius * zoom;
  const outerR = SIZE * CONFIG.rainbow.outerRadius * zoom;
  const bandWidth = outerR - innerR;
  
  const offscreen = document.createElement('canvas');
  offscreen.width = W;
  offscreen.height = H;
  const offCtx = offscreen.getContext('2d');
  
  // Adjust alpha based on zoom (more visible when zoomed in)
  const zoomAlphaBoost = 1 + Math.log10(Math.max(1, zoom)) * 0.3;
  
  SPECTRUM.forEach(band => {
    const radius = innerR + band.normalizedRadius * bandWidth;
    const [r, g, b] = band.rgb;
    const adjustedAlpha = Math.min(0.9, band.alpha * zoomAlphaBoost);
    
    offCtx.beginPath();
    offCtx.arc(rainbowCenterX, rainbowCenterY, radius, 0, Math.PI * 2);
    offCtx.strokeStyle = `rgba(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)}, ${adjustedAlpha})`;
    offCtx.lineWidth = Math.max(1, bandWidth / SPECTRUM.length * 3.2);
    offCtx.stroke();
  });
  
  // Adjust blur based on zoom
  const adjustedBlur = CONFIG.rainbow.blur / Math.sqrt(zoom);
  ctx.filter = `blur(${Math.max(1, adjustedBlur)}px)`;
  ctx.drawImage(offscreen, 0, 0);
  ctx.filter = 'none';
};

// ============================================================================
// VEIL RENDERING
// ============================================================================

const renderVeil = () => {
  const ctx = veilCtx;
  ctx.clearRect(0, 0, W, H);
  
  // Reduce veil at high zoom (you're "inside" the atmosphere)
  const veilReduction = Math.max(0.2, 1 / Math.sqrt(CONFIG.zoom.current));
  
  ctx.fillStyle = `rgba(140, 165, 190, ${CONFIG.atmosphere.veilingLuminance * veilReduction})`;
  ctx.fillRect(0, 0, W, H);
  
  const sunX = W * CONFIG.sun.x;
  const sunY = H * CONFIG.sun.y;
  
  const sunVeil = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, H * 1.2);
  sunVeil.addColorStop(0, `rgba(255, 245, 230, ${CONFIG.atmosphere.pathRadiance * veilReduction})`);
  sunVeil.addColorStop(0.3, `rgba(230, 235, 240, ${CONFIG.atmosphere.pathRadiance * 0.4 * veilReduction})`);
  sunVeil.addColorStop(1, 'rgba(200, 215, 230, 0)');
  
  ctx.fillStyle = sunVeil;
  ctx.fillRect(0, 0, W, H);
};

// ============================================================================
// RAIN SYSTEM
// ============================================================================

class RainDrop {
  constructor() {
    this.reset(true);
  }
  
  reset(initial = false) {
    this.x = Math.random() * W * 1.3 - W * 0.15;
    this.y = initial ? Math.random() * H : -Math.random() * H * 0.3 - 30;
    this.speed = CONFIG.rain.speed.min + Math.random() * (CONFIG.rain.speed.max - CONFIG.rain.speed.min);
    this.length = CONFIG.rain.length.min + Math.random() * (CONFIG.rain.length.max - CONFIG.rain.length.min);
    this.alpha = CONFIG.rain.alpha * (0.4 + Math.random() * 0.6);
    this.thickness = 0.5 + Math.random() * 1;
  }
  
  update(dt) {
    this.y += this.speed * dt * 60;
    this.x += CONFIG.rain.wind * this.speed * dt * 60;
    if (this.y > H + this.length) this.reset();
  }
  
  draw(ctx) {
    const windAngle = Math.atan2(CONFIG.rain.wind, 1);
    const endX = this.x + Math.sin(windAngle) * this.length;
    const endY = this.y + Math.cos(windAngle) * this.length;
    
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = `rgba(210, 225, 245, ${this.alpha})`;
    ctx.lineWidth = this.thickness;
    ctx.stroke();
  }
}

let raindrops = [];

const initRain = () => {
  raindrops = [];
  for (let i = 0; i < CONFIG.rain.count; i++) {
    raindrops.push(new RainDrop());
  }
};

const renderRainLayer = () => {
  rainCtx.clearRect(0, 0, W, H);
  if (!CONFIG.rain.enabled) return;
  
  raindrops.forEach(drop => drop.draw(rainCtx));
  
  const sunX = W * CONFIG.sun.x;
  const mieGlow = rainCtx.createRadialGradient(sunX, H, 0, sunX, H, H * 0.4);
  mieGlow.addColorStop(0, `rgba(255, 250, 240, ${CONFIG.rain.mieScatter})`);
  mieGlow.addColorStop(0.4, `rgba(255, 248, 235, ${CONFIG.rain.mieScatter * 0.4})`);
  mieGlow.addColorStop(1, 'rgba(255, 245, 230, 0)');
  
  rainCtx.fillStyle = mieGlow;
  rainCtx.fillRect(0, 0, W, H);
};

// ============================================================================
// DROPLET RENDERING
// ============================================================================

const renderDroplets = () => {
  dropletsCtx.clearRect(0, 0, W, H);
  
  const zoom = CONFIG.zoom.current;
  
  // Only show droplets at sufficient zoom
  if (zoom < CONFIG.zoom.thresholds.meso) return;
  
  // Fade in droplets as zoom increases
  const dropletAlpha = Math.min(1, (zoom - CONFIG.zoom.thresholds.meso) / 5);
  dropletsCtx.globalAlpha = dropletAlpha;
  
  droplets.forEach(d => d.draw(dropletsCtx, zoom, viewX, viewY, viewW, viewH));
  
  dropletsCtx.globalAlpha = 1;
};

// ============================================================================
// SCINTILLATION
// ============================================================================

let scintTime = 0;

const updateScintillation = dt => {
  scintTime += dt;
  
  const amp = CONFIG.atmosphere.scintillation.amplitude;
  const freq = CONFIG.atmosphere.scintillation.frequency;
  
  const mod = 1 + 
    Math.sin(scintTime * freq * Math.PI * 2) * amp +
    Math.sin(scintTime * freq * 0.6 * Math.PI * 2) * amp * 0.6;
  
  rainbowCanvas.style.opacity = mod;
};

// ============================================================================
// MOUSE INTERACTION
// ============================================================================

const getWavelengthAtPosition = (x, y) => {
  // Convert screen position to normalized coordinates
  const normX = viewX + (x / W) * viewW;
  const normY = viewY + (y / H) * viewH;
  
  // Distance from center (0.5, 0.5)
  const dx = normX - 0.5;
  const dy = normY - 0.5;
  const dist = Math.sqrt(dx * dx + dy * dy);
  
  const innerR = CONFIG.rainbow.innerRadius;
  const outerR = CONFIG.rainbow.outerRadius;
  
  if (dist < innerR - 0.03 || dist > outerR + 0.03) return null;
  
  const normalized = (dist - innerR) / (outerR - innerR);
  const clamped = Math.max(0, Math.min(1, normalized));
  
  return 380 + clamped * (700 - 380);
};

const updateMouseCoherence = (x, y, time) => {
  if (lastMouseTime === 0) {
    lastMousePos = { x, y };
    lastMouseTime = time;
    return 0.5;
  }
  
  const dt = (time - lastMouseTime) / 1000;
  const dx = x - lastMousePos.x;
  const dy = y - lastMousePos.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const velocity = dist / Math.max(dt, 0.001);
  
  const smoothness = 1 / (1 + velocity / 400);
  
  mouseCoherence = mouseCoherence * CONFIG.audio.coherenceDecay + 
                   smoothness * CONFIG.audio.coherenceGain;
  mouseCoherence = Math.max(0, Math.min(1, mouseCoherence));
  
  lastMousePos = { x, y };
  lastMouseTime = time;
  
  return mouseCoherence;
};

const wavelengthDisplay = document.getElementById('wavelengthDisplay');
const lambdaValue = document.getElementById('lambdaValue');
const freqValue = document.getElementById('freqValue');
const noteValue = document.getElementById('noteValue');

const handleMouseMove = e => {
  const λ = getWavelengthAtPosition(e.clientX, e.clientY);
  
  if (λ !== null && CONFIG.audio.enabled) {
    isInRainbow = true;
    currentWavelength = λ;
    
    const coherence = updateMouseCoherence(e.clientX, e.clientY, performance.now());
    const freq = wavelengthToFrequency(λ);
    const note = frequencyToNote(freq);
    
    wavelengthDisplay.classList.add('visible');
    lambdaValue.textContent = `λ = ${Math.round(λ)} nm`;
    freqValue.textContent = `f = ${Math.round(freq)} Hz`;
    noteValue.textContent = note;
    
    updateAudio(λ, coherence);
  } else {
    if (isInRainbow) {
      fadeOutAudio();
      wavelengthDisplay.classList.remove('visible');
    }
    isInRainbow = false;
    currentWavelength = null;
  }
};

const handleMouseLeave = () => {
  fadeOutAudio();
  wavelengthDisplay.classList.remove('visible');
  isInRainbow = false;
  mouseCoherence = 0;
  lastMouseTime = 0;
};

document.addEventListener('mousemove', handleMouseMove);
document.addEventListener('mouseleave', handleMouseLeave);

// ============================================================================
// UI CONTROLS
// ============================================================================

const btnRain = document.getElementById('btnRain');
const btnFixation = document.getElementById('btnFixation');
const btnSing = document.getElementById('btnSing');
const btnZoomReset = document.getElementById('btnZoomReset');
const btnImmerse = document.getElementById('btnImmerse');
const fixation = document.getElementById('fixation');

let immersed = false;
let cursorTimeout;

const showUI = () => {
  document.body.classList.add('show-cursor');
  clearTimeout(cursorTimeout);
  if (immersed) {
    cursorTimeout = setTimeout(() => {
      document.body.classList.remove('show-cursor');
    }, 2500);
  }
};

document.addEventListener('mousemove', showUI);

btnRain.addEventListener('click', () => {
  CONFIG.rain.enabled = !CONFIG.rain.enabled;
  btnRain.classList.toggle('active', CONFIG.rain.enabled);
  
  if (CONFIG.rain.enabled) {
    if (raindrops.length === 0) initRain();
    initRainAudio();
    setRainAudio(true);
  } else {
    setRainAudio(false);
  }
});

btnFixation.addEventListener('click', () => {
  fixation.classList.toggle('visible');
  btnFixation.classList.toggle('active', fixation.classList.contains('visible'));
});

btnSing.addEventListener('click', () => {
  CONFIG.audio.enabled = !CONFIG.audio.enabled;
  btnSing.classList.toggle('active', CONFIG.audio.enabled);
  
  if (CONFIG.audio.enabled) {
    initAudio();
  } else {
    fadeOutAudio();
    wavelengthDisplay.classList.remove('visible');
  }
});

btnZoomReset.addEventListener('click', () => {
  CONFIG.zoom.target = 1;
  CONFIG.zoom.centerX = 0.5;
  CONFIG.zoom.centerY = 0.5;
});

btnImmerse.addEventListener('click', () => {
  immersed = !immersed;
  btnImmerse.classList.toggle('active', immersed);
  
  if (immersed) {
    document.documentElement.requestFullscreen?.();
    fixation.classList.add('visible');
    btnFixation.classList.add('active');
    document.body.classList.remove('show-cursor');
  } else {
    document.exitFullscreen?.();
  }
});

document.addEventListener('keydown', e => {
  if (e.key === 'r') btnRain.click();
  if (e.key === 'f') btnFixation.click();
  if (e.key === 's') btnSing.click();
  if (e.key === 'z' || e.key === '0') btnZoomReset.click();
  if (e.key === 'i' || e.key === 'Enter') btnImmerse.click();
  if (e.key === 'Escape') {
    immersed = false;
    btnImmerse.classList.remove('active');
    document.body.classList.add('show-cursor');
  }
  // Keyboard zoom
  if (e.key === '=' || e.key === '+') {
    CONFIG.zoom.target = Math.min(CONFIG.zoom.max, CONFIG.zoom.target * 1.3);
  }
  if (e.key === '-' || e.key === '_') {
    CONFIG.zoom.target = Math.max(CONFIG.zoom.min, CONFIG.zoom.target / 1.3);
  }
});

// ============================================================================
// ANIMATION LOOP
// ============================================================================

let lastTime = 0;

const animate = time => {
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  
  // Update zoom
  updateZoom();
  
  // Update droplets
  droplets.forEach(d => d.update(dt));
  
  // Update rain
  if (CONFIG.rain.enabled) {
    raindrops.forEach(drop => drop.update(dt));
  }
  
  // Render layers
  renderRainbow();
  renderDroplets();
  renderRainLayer();
  renderVeil();
  updateScintillation(dt);
  
  // Decay audio coherence
  if (performance.now() - lastMouseTime > 100) {
    mouseCoherence *= 0.96;
  }
  
  requestAnimationFrame(animate);
};

// ============================================================================
// INITIALIZATION
// ============================================================================

resize();
initRain();
initDroplets();
requestAnimationFrame(animate);

const equationEl = document.getElementById('equation');
setInterval(() => {
  if (isInRainbow && currentWavelength) {
    const c = mouseCoherence.toFixed(2);
    equationEl.textContent = `C(${Math.round(currentWavelength)}nm) = ${c} · δ(touch) · R(tone)`;
  } else {
    const zoom = CONFIG.zoom.current;
    if (zoom > CONFIG.zoom.thresholds.nano) {
      equationEl.textContent = `NANO: interference fringes from wave coherence`;
    } else if (zoom > CONFIG.zoom.thresholds.micro) {
      equationEl.textContent = `MICRO: droplet refraction — light path through CRR`;
    } else if (zoom > CONFIG.zoom.thresholds.meso) {
      equationEl.textContent = `MESO: individual droplets — each a CRR system`;
    } else {
      equationEl.textContent = `MACRO: C(λ,t) = ∫L(λ,τ)dτ → δ(adaptation) → R(blank)`;
    }
  }
}, 100);

/**
 * ============================================================================
 * ZOOM LEVELS AND CRR SCALE INVARIANCE
 * ============================================================================
 * 
 * 1× - 3×  MACRO
 *   - See full rainbow arc
 *   - Atmospheric integration visible
 *   - CRR: Perceptual coherence (Troxler fading)
 *   
 * 3× - 10×  MESO  
 *   - Color bands become distinct
 *   - Individual rain streaks visible
 *   - CRR: Wavelength separation from dispersion
 *   
 * 10× - 30×  MICRO
 *   - Individual water droplets visible
 *   - Internal refraction geometry shown
 *   - CRR: Light path through droplet = coherence accumulation
 *   - Exit point = rupture where rainbow light emerges
 *   
 * 30× - 100×  NANO
 *   - Interference fringes visible
 *   - Wave coherence patterns
 *   - CRR: Phase relationships between paths
 *   - Constructive interference = coherence maximum
 * 
 * The same CRR dynamics operate at EVERY scale.
 * Zoom reveals this universality.
 * 
 * — Alexander Sabine, 2025
 * ============================================================================
 */

</script>
</body>
</html>
