<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRR Living Forest | Mathematical CRR Implementation</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a1a;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'EB Garamond', Georgia, serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(to bottom, #1a1d24 0%, #252830 50%, #2a2d35 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.8s ease-out;
    }
    .loading-screen.fade-out { opacity: 0; pointer-events: none; }
    .loading-screen.hidden { display: none; }
    
    .loading-content { text-align: center; color: rgba(255, 255, 255, 0.85); }
    .loading-title { font-size: 2.5rem; font-weight: 400; letter-spacing: 0.15em; margin-bottom: 0.5rem; color: rgba(255, 255, 255, 0.9); }
    .loading-subtitle { font-size: 1.1rem; font-style: italic; opacity: 0.6; margin-bottom: 3rem; }
    
    .loading-indicator { display: flex; gap: 8px; justify-content: center; margin-bottom: 2rem; }
    .snow-dot {
      width: 6px; height: 6px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      animation: snowfall 1.5s ease-in-out infinite;
    }
    .snow-dot:nth-child(2) { animation-delay: 0.2s; }
    .snow-dot:nth-child(3) { animation-delay: 0.4s; }
    .snow-dot:nth-child(4) { animation-delay: 0.6s; }
    .snow-dot:nth-child(5) { animation-delay: 0.8s; }
    
    @keyframes snowfall {
      0%, 100% { transform: translateY(-10px); opacity: 0.3; }
      50% { transform: translateY(10px); opacity: 1; }
    }
    
    .loading-quote { font-size: 1rem; font-style: italic; opacity: 0.5; max-width: 400px; line-height: 1.6; }
    
    /* Calendar Overlay */
    .calendar-overlay {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 20px 30px;
      background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.2) 60%, transparent 100%);
      color: rgba(255, 255, 255, 0.85);
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in;
    }
    .calendar-overlay.visible { opacity: 1; }
    
    .datetime { text-align: left; }
    .datetime .time { font-size: 2.8rem; font-weight: 400; letter-spacing: 0.02em; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .datetime .date { font-size: 1.1rem; opacity: 0.8; margin-top: 2px; font-style: italic; }
    
    .events { text-align: right; display: flex; gap: 35px; }
    .event { text-align: center; }
    .event .countdown { font-size: 1.6rem; font-weight: 500; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .event .label { font-size: 0.85rem; opacity: 0.75; margin-top: 2px; font-style: italic; }
    .event.imminent .countdown { color: #ffd700; }
    .event.past .countdown { color: rgba(255,255,255,0.5); }
    .event .culture { font-size: 0.7rem; opacity: 0.5; margin-top: 1px; }
    
    .celebration-message {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      text-align: center; color: #ffd700;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
      opacity: 0; transition: opacity 2s ease-in-out;
      pointer-events: none; z-index: 100;
    }
    .celebration-message.visible { opacity: 1; }
    .celebration-message h1 { font-size: 4rem; font-weight: 400; letter-spacing: 0.1em; margin-bottom: 0.5rem; }
    .celebration-message p { font-size: 1.5rem; font-style: italic; opacity: 0.9; }
    
    /* Weather Indicator */
    .weather-indicator {
      position: fixed;
      top: 20px; right: 20px;
      padding: 10px 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.85rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in;
      text-align: right;
      backdrop-filter: blur(5px);
    }
    .weather-indicator.visible { opacity: 1; }
    .weather-indicator .location { font-weight: 500; color: rgba(255, 255, 255, 0.9); }
    .weather-indicator .conditions { font-style: italic; opacity: 0.8; margin-top: 3px; }
    .weather-indicator .temp { font-size: 1.1rem; margin-top: 2px; }
    
    /* Demo Control Panel */
    .demo-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
      z-index: 500;
      min-width: 280px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
    }
    .demo-panel.collapsed {
      min-width: 0;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.5);
    }
    .demo-panel.collapsed .panel-content {
      display: none;
    }
    .demo-panel.collapsed h3 {
      margin: 0;
      font-size: 0.9rem;
    }
    .demo-panel.collapsed h3 span:first-child {
      display: none;
    }
    .demo-panel h3 {
      margin: 0 0 15px 0;
      font-weight: 500;
      font-size: 1.1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .demo-panel .toggle-btn {
      background: rgba(255,255,255,0.15);
      border: none;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8rem;
      white-space: nowrap;
    }
    .demo-panel .toggle-btn:hover {
      background: rgba(255,255,255,0.25);
    }
    .demo-panel .section {
      margin-bottom: 18px;
    }
    .demo-panel .section-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.6;
      margin-bottom: 8px;
    }
    .demo-panel .season-btns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .demo-panel .season-btn {
      background: rgba(255,255,255,0.1);
      border: 2px solid transparent;
      color: white;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      transition: all 0.2s;
      text-align: left;
    }
    .demo-panel .season-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    .demo-panel .season-btn.active {
      border-color: rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.2);
    }
    .demo-panel .season-btn .icon {
      font-size: 1.2rem;
      margin-right: 6px;
    }
    .demo-panel .slider-group {
      margin-bottom: 12px;
    }
    .demo-panel .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 0.8rem;
    }
    .demo-panel input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.2);
      appearance: none;
      outline: none;
    }
    .demo-panel input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .demo-panel .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }
    .demo-panel input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    .demo-panel .info-text {
      font-size: 0.75rem;
      opacity: 0.5;
      font-style: italic;
      margin-top: 10px;
      line-height: 1.4;
    }
  
    /* CRR Debug Panel */
    .crr-debug {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(10px);
      border-radius: 8px;
      padding: 12px 16px;
      color: rgba(255, 255, 255, 0.8);
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      line-height: 1.5;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    .crr-debug.visible { opacity: 1; }
    .crr-debug .title { 
      font-weight: 600; 
      color: #7dd3fc;
      margin-bottom: 6px;
      font-size: 12px;
    }
    .crr-debug .row { display: flex; justify-content: space-between; gap: 20px; }
    .crr-debug .label { color: rgba(255,255,255,0.5); }
    .crr-debug .value { color: #fcd34d; font-weight: 500; }
    .crr-debug .omega { color: #a78bfa; }
    .crr-debug .phase { color: #34d399; }

  </style>
</head>
<body>

<div class="loading-screen" id="loadingScreen">
  <div class="loading-content">
    <h1 class="loading-title" id="loadingTitle">Season Preview</h1>
    <p class="loading-subtitle" id="loadingSubtitle">Interactive Demo</p>
    <div class="loading-indicator">
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
      <div class="snow-dot"></div>
    </div>
    <p class="loading-quote" id="loadingQuote">"In every walk with nature, one receives far more than one seeks."</p>
  </div>
</div>


<div class="crr-debug" id="crrDebug">
  <div class="title">CRR State (press 'c' to toggle)</div>
  <div class="row"><span class="label">Œ© (SO‚ÇÇ):</span><span class="value omega" id="crrOmega">0.159</span></div>
  <div class="row"><span class="label">Phase:</span><span class="value phase" id="crrPhase">coherence</span></div>
  <div class="row"><span class="label">Day/Night C:</span><span class="value" id="crrDayC">0.00</span></div>
  <div class="row"><span class="label">Amplitude:</span><span class="value" id="crrAmplitude">0.00</span></div>
  <div class="row"><span class="label">exp(C/Œ©):</span><span class="value" id="crrMemory">1.00</span></div>
  <div class="row"><span class="label">CV:</span><span class="value" id="crrCV">0.08</span></div>
</div>

<canvas id="canvas"></canvas>

<!-- Demo Control Panel -->
<div class="demo-panel collapsed" id="demoPanel">
  <h3>
    <span>üé® Season Preview</span>
    <button class="toggle-btn" id="togglePanel">üé® Show Controls</button>
  </h3>
  <div class="panel-content">
    <div class="section">
      <div class="section-title">Season</div>
      <div class="season-btns">
        <button class="season-btn" data-season="spring">
          <span class="icon">üå∏</span>Spring
        </button>
        <button class="season-btn" data-season="summer">
          <span class="icon">‚òÄÔ∏è</span>Summer
        </button>
        <button class="season-btn" data-season="autumn">
          <span class="icon">üçÇ</span>Autumn
        </button>
        <button class="season-btn active" data-season="winter">
          <span class="icon">‚ùÑÔ∏è</span>Winter
        </button>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Time of Day</div>
      <div class="slider-group">
        <div class="slider-label">
          <span>Hour</span>
          <span id="timeDisplay">12:00</span>
        </div>
        <input type="range" id="timeSlider" min="0" max="24" step="0.25" value="12">
      </div>
      <div class="slider-group">
        <div class="slider-label">
          <span>Moon Phase</span>
          <span id="moonDisplay">Full</span>
        </div>
        <input type="range" id="moonSlider" min="0" max="100" step="1" value="50">
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Weather Effects</div>
      <div class="slider-group">
        <div class="slider-label">
          <span>Precipitation</span>
          <span id="precipDisplay">70%</span>
        </div>
        <input type="range" id="precipSlider" min="0" max="150" value="70">
      </div>
      <div class="slider-group">
        <div class="slider-label">
          <span>Wind</span>
          <span id="windDisplay">50%</span>
        </div>
        <input type="range" id="windSlider" min="10" max="150" value="50">
      </div>
      <div class="slider-group">
        <div class="slider-label">
          <span>Mist</span>
          <span id="mistDisplay">60%</span>
        </div>
        <input type="range" id="mistSlider" min="0" max="140" value="60">
      </div>
      <div class="slider-group">
        <div class="slider-label">
          <span>Cloud Cover</span>
          <span id="cloudDisplay">30%</span>
        </div>
        <input type="range" id="cloudSlider" min="0" max="100" value="30">
      </div>
    </div>
    
    <div class="section">
      <div class="section-title">Options</div>
      <label class="checkbox-group">
        <input type="checkbox" id="autoTimeCheck" checked>
        <span>Real-time clock</span>
      </label>
      <label class="checkbox-group">
        <input type="checkbox" id="autoSeasonCheck">
        <span>Auto-detect season</span>
      </label>
      <label class="checkbox-group">
        <input type="checkbox" id="rainbowCheck">
        <span id="rainbowLabel">CRR Rainbow</span>
      </label>
    </div>
    
    <div class="info-text">
      Keys: 1-4 seasons, d/n/s/m times, h hide, r rainbow.<br>
      Set time to night to see moon phases clearly.
    </div>
  </div>
</div>

<div class="calendar-overlay" id="calendarOverlay">
  <div class="datetime">
    <div class="time" id="currentTime">00:00</div>
    <div class="date" id="currentDate">Loading...</div>
    <div class="season-info" id="seasonInfo" style="font-size: 0.9rem; opacity: 0.6; margin-top: 4px;"></div>
  </div>
  <div class="events" id="events"></div>
</div>

<div class="celebration-message" id="celebrationMessage">
  <h1 id="celebrationTitle">Celebration</h1>
  <p id="celebrationSubtitle">Joy to All</p>
</div>

<div class="weather-indicator" id="weatherIndicator">
  <div class="location" id="weatherLocation">Detecting location...</div>
  <div class="conditions" id="weatherConditions"></div>
  <div class="temp" id="weatherTemp"></div>
  <div class="season-badge" id="seasonBadge" style="display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; margin-top: 4px; background: rgba(255,255,255,0.15);"></div>
  <div class="moon-info" id="moonInfo" style="font-size: 10px; margin-top: 4px; opacity: 0.8;"></div>
</div>

<script>
// ============================================================================
// CRR LIVING FOREST - Year-Round Seasonal Version
// With Multicultural Calendar, Seasonal Weather & Real-Time Data
// ============================================================================

const CONFIG = {
  networkDepth: 6,
  branchCount: [2, 4],
  starlingCount: 350,
  spatialCellSize: 60
};

// ============================================================================
// CRR RAINBOW SYSTEM - Using actual wavelength physics with CRR mathematics
// ============================================================================

// Rainbow state
let rainbowEnabled = false;
let rainbowIntensity = 0;
let rainbowTargetIntensity = 0;
let naturalRainbowActive = false;

// CRR Rainbow Calculator
// Uses C(Œª) = ‚à´L(Œª,œÑ)dœÑ where Œª is wavelength
// Œ©_rainbow = 1/(2œÄ) for the SO(2) symmetry of the circular arc
// R(Œª) = œÜ(Œª) * exp(C(Œª)/Œ©) gives intensity weighting
class CRRRainbow {
  constructor() {
    this.omega = 1 / (2 * Math.PI); // SO(2) symmetry for circular phenomena
    this.coherence = 0;
    this.phase = 0;
  }
  
  // Calculate coherence for a given wavelength position (0-1 normalized)
  // C(Œª) represents accumulated "light coherence" at that wavelength
  getCoherence(normalizedWavelength) {
    // Coherence accumulates as we move through the spectrum
    // Peak coherence at center (green-yellow), tapering at edges
    const center = 0.5;
    const spread = 0.4;
    const gaussian = Math.exp(-Math.pow(normalizedWavelength - center, 2) / (2 * spread * spread));
    return gaussian * 0.8 + 0.2; // Base coherence + gaussian peak
  }
  
  // CRR memory weighting: exp(C/Œ©)
  // This creates the characteristic intensity distribution
  getMemoryWeight(normalizedWavelength) {
    const C = this.getCoherence(normalizedWavelength);
    // Clamp to prevent overflow
    return Math.exp(Math.min(C / this.omega, 5));
  }
  
  // Convert wavelength (nm) to RGB using CRR-weighted intensity
  wavelengthToRGB(wavelength, baseIntensity = 1.0) {
    // Normalize wavelength to 0-1 range (380nm to 700nm)
    const normalized = (wavelength - 380) / (700 - 380);
    
    // Get CRR memory weight for this wavelength
    const memoryWeight = this.getMemoryWeight(normalized);
    
    // Base color calculation using spectral physics
    let r, g, b;
    
    if (wavelength >= 380 && wavelength < 440) {
      r = -(wavelength - 440) / (440 - 380);
      g = 0;
      b = 1;
    } else if (wavelength >= 440 && wavelength < 490) {
      r = 0;
      g = (wavelength - 440) / (490 - 440);
      b = 1;
    } else if (wavelength >= 490 && wavelength < 510) {
      r = 0;
      g = 1;
      b = -(wavelength - 510) / (510 - 490);
    } else if (wavelength >= 510 && wavelength < 580) {
      r = (wavelength - 510) / (580 - 510);
      g = 1;
      b = 0;
    } else if (wavelength >= 580 && wavelength < 645) {
      r = 1;
      g = -(wavelength - 645) / (645 - 580);
      b = 0;
    } else if (wavelength >= 645 && wavelength <= 700) {
      r = 1;
      g = 0;
      b = 0;
    } else {
      r = 0; g = 0; b = 0;
    }
    
    // Apply intensity falloff at spectrum edges (atmospheric absorption)
    let factor;
    if (wavelength >= 380 && wavelength < 420) {
      factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
    } else if (wavelength >= 420 && wavelength < 645) {
      factor = 1.0;
    } else if (wavelength >= 645 && wavelength <= 700) {
      factor = 0.3 + 0.7 * (700 - wavelength) / (700 - 645);
    } else {
      factor = 0;
    }
    
    // Apply CRR memory weighting (normalized to reasonable range)
    const crrFactor = (memoryWeight - 1) / (Math.exp(5) - 1); // Normalize to 0-1
    const combinedFactor = factor * (0.7 + 0.3 * crrFactor);
    
    // Final intensity with base intensity
    const intensity = baseIntensity * combinedFactor;
    
    return {
      r: Math.round(r * 255 * intensity),
      g: Math.round(g * 255 * intensity),
      b: Math.round(b * 255 * intensity),
      a: intensity * 0.6 // Subtle alpha for the ethereal look
    };
  }
}

const crrRainbow = new CRRRainbow();

// Draw CRR Rainbow arc
function drawCRRRainbow(colors, sun) {
  // Check for natural rainbow conditions: sun visible AND rain/precipitation
  const sunVisible = sun.intensity > 0.3;
  const isRaining = weatherState.isRaining || weatherState.precipitationIntensity > 0.5;
  const naturalRainbow = sunVisible && isRaining && weatherState.realWeatherEnabled;
  
  // Track natural rainbow state for UI
  if (naturalRainbow !== naturalRainbowActive) {
    naturalRainbowActive = naturalRainbow;
    const label = document.getElementById('rainbowLabel');
    if (label) {
      label.textContent = naturalRainbow ? 'CRR Rainbow ‚ú®' : 'CRR Rainbow';
      label.style.color = naturalRainbow ? '#ffd700' : '';
    }
  }
  
  // Rainbow can appear from manual toggle OR natural weather conditions
  const shouldShow = rainbowEnabled || naturalRainbow;
  
  if (!shouldShow && rainbowIntensity < 0.01) return;
  
  // Smooth intensity transition
  rainbowTargetIntensity = shouldShow ? 1 : 0;
  rainbowIntensity += (rainbowTargetIntensity - rainbowIntensity) * 0.02;
  
  if (rainbowIntensity < 0.01) return;
  
  const ambient = colors.ambient;
  
  // Intensity modifier based on conditions
  const intensityMod = naturalRainbow ? (sun.intensity * 0.8) : (rainbowEnabled ? 1.0 : 0);
  
  if (intensityMod < 0.01) return;
  
  // Rainbow geometry - raised high in sky, well above the trees
  const centerX = W * 0.5;
  const centerY = H * 0.65; // Raised higher (was 0.85)
  
  // Primary rainbow radius - larger to create higher arc
  const primaryRadius = H * 0.55;
  const bandWidth = H * 0.06; // Width of the rainbow band
  
  // Number of color bands for smooth gradient
  const numBands = 64;
  
  ctx.save();
  
  // Arc angles adjusted for higher position
  const startAngle = Math.PI * 1.05;
  const endAngle = Math.PI * 1.95;
  
  // Draw rainbow bands from outer (red) to inner (violet)
  for (let i = 0; i < numBands; i++) {
    const t = i / (numBands - 1);
    
    // Wavelength from red (700nm) to violet (380nm)
    const wavelength = 700 - t * (700 - 380);
    
    // Get CRR-calculated color - increased visibility
    const color = crrRainbow.wavelengthToRGB(wavelength, rainbowIntensity * intensityMod * 0.55);
    
    // Band radius (outer to inner)
    const radius = primaryRadius - t * bandWidth;
    const nextRadius = primaryRadius - (t + 1/numBands) * bandWidth;
    
    // Create arc for this band
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.arc(centerX, centerY, nextRadius, endAngle, startAngle, true);
    ctx.closePath();
    
    // Apply subtle glow effect - increased alpha
    const alpha = color.a * ambient * 0.85;
    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
    ctx.fill();
  }
  
  // Secondary rainbow (fainter, reversed colors, at ~51¬∞)
  if (rainbowIntensity > 0.5) {
    const secondaryRadius = primaryRadius * 1.15;
    const secondaryBandWidth = bandWidth * 0.6;
    
    for (let i = 0; i < numBands; i++) {
      const t = i / (numBands - 1);
      
      // Reversed: violet (380nm) to red (700nm) for secondary
      const wavelength = 380 + t * (700 - 380);
      
      const color = crrRainbow.wavelengthToRGB(wavelength, rainbowIntensity * intensityMod * 0.15);
      
      const radius = secondaryRadius - t * secondaryBandWidth;
      const nextRadius = secondaryRadius - (t + 1/numBands) * secondaryBandWidth;
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.arc(centerX, centerY, nextRadius, endAngle, startAngle, true);
      ctx.closePath();
      
      const alpha = color.a * ambient * 0.3;
      ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
      ctx.fill();
    }
  }
  
  // Alexander's dark band (very subtle darker sky between primary and secondary)
  if (rainbowIntensity > 0.5) {
    const darkBandInner = primaryRadius + bandWidth * 0.1;
    const darkBandOuter = primaryRadius * 1.12;
    
    ctx.beginPath();
    ctx.arc(centerX, centerY, darkBandOuter, startAngle, endAngle);
    ctx.arc(centerX, centerY, darkBandInner, endAngle, startAngle, true);
    ctx.closePath();
    
    ctx.fillStyle = `rgba(0, 0, 20, ${rainbowIntensity * 0.02 * ambient})`;
    ctx.fill();
  }
  
  ctx.restore();
}

// ============================================================================
// SEASONAL SYSTEM & MULTICULTURAL CALENDAR
// ============================================================================
const SEASONS = {
  spring: { name: 'Spring', icon: 'üå∏', quotes: [
    '"To see a World in a Grain of Sand, And a Heaven in a Wild Flower" ‚Äî Blake',
    '"The busy bee has no time for sorrow" ‚Äî Blake',
    '"No bird soars too high if he soars with his own wings" ‚Äî Blake'
  ]},
  summer: { name: 'Summer', icon: '‚òÄÔ∏è', quotes: [
    '"The Sun does not rise and set for any man" ‚Äî Blake',
    '"Energy is Eternal Delight" ‚Äî Blake',
    '"Exuberance is Beauty" ‚Äî Blake'
  ]},
  autumn: { name: 'Autumn', icon: 'üçÇ', quotes: [
    '"The tree which moves some to tears of joy is in the eyes of others only a green thing" ‚Äî Blake',
    '"Without contraries is no progression" ‚Äî Blake',
    '"What is now proved was once only imagined" ‚Äî Blake'
  ]},
  winter: { name: 'Winter', icon: '‚ùÑÔ∏è', quotes: [
    '"In the depth of winter, I found there was within me an invincible summer" ‚Äî Camus',
    '"The cut worm forgives the plough" ‚Äî Blake',
    '"If the doors of perception were cleansed, every thing would appear as it is, Infinite" ‚Äî Blake'
  ]}
};

const SEASONAL_PALETTES = {
  spring: {
    ground: { day: {r:130,g:155,b:100}, night: {r:65,g:80,b:55} },
    sunArcHeight: 0.40,
    precipitation: 'blossoms'
  },
  summer: {
    ground: { day: {r:110,g:145,b:85}, night: {r:55,g:75,b:45} },
    sunArcHeight: 0.50,
    precipitation: 'none'
  },
  autumn: {
    ground: { day: {r:145,g:125,b:85}, night: {r:75,g:65,b:50} },
    sunArcHeight: 0.35,
    precipitation: 'leaves'
  },
  winter: {
    ground: { day: {r:225,g:222,b:218}, night: {r:180,g:178,b:175} },
    sunArcHeight: 0.28,
    precipitation: 'snow'
  }
};


function getSeasonallyBlendedPalette() {
  const now = new Date();
  const seasonState = seasonalCRR.getSeasonalBlend(now, SEASONAL_PALETTES);
  
  if (!seasonState.inTransition) {
    return SEASONAL_PALETTES[seasonState.season];
  }
  
  // CRR-modulated seasonal transition
  const from = SEASONAL_PALETTES[seasonState.fromSeason];
  const to = SEASONAL_PALETTES[seasonState.toSeason];
  const blend = seasonState.crrBlend; // CRR-modulated blend factor
  
  return {
    ground: {
      day: lerpColor(from.ground.day, to.ground.day, blend),
      night: lerpColor(from.ground.night, to.ground.night, blend)
    },
    sunArcHeight: lerp(from.sunArcHeight, to.sunArcHeight, blend),
    precipitation: blend > 0.5 ? to.precipitation : from.precipitation
  };
}


let currentSeason = 'winter';
let currentHemisphere = 'northern';
let seasonalPalette = SEASONAL_PALETTES.winter;
let yearEvents = [];

function detectSeason(date = new Date(), latitude = null) {
  const month = date.getMonth();
  let hemisphere = latitude !== null && latitude < 0 ? 'southern' : 'northern';
  currentHemisphere = hemisphere;
  let adjustedMonth = hemisphere === 'southern' ? (month + 6) % 12 : month;
  if (adjustedMonth >= 2 && adjustedMonth <= 4) return 'spring';
  if (adjustedMonth >= 5 && adjustedMonth <= 7) return 'summer';
  if (adjustedMonth >= 8 && adjustedMonth <= 10) return 'autumn';
  return 'winter';
}

function generateYearEvents(year) {
  const events = [];
  const add = (name, date, culture, icon = '‚ú®') => events.push({ name, date: new Date(date), culture, icon });
  
  // Global & Western
  add("New Year's Day", `${year}-01-01`, 'Global', 'üéâ');
  add("Epiphany", `${year}-01-06`, 'Christian', '‚≠ê');
  add("Chinese New Year", `${year}-01-29`, 'Chinese', 'üßß');
  add("Valentine's Day", `${year}-02-14`, 'Global', '‚ù§Ô∏è');
  add("Holi", `${year}-03-14`, 'Hindu', 'üé®');
  add("St. Patrick's Day", `${year}-03-17`, 'Irish', '‚òòÔ∏è');
  add("Nowruz", `${year}-03-20`, 'Persian', 'üå∑');
  add("Spring Equinox", `${year}-03-20`, 'Global', 'üå∏');
  add("Easter Sunday", `${year}-04-20`, 'Christian', 'üê£');
  add("Earth Day", `${year}-04-22`, 'Global', 'üåç');
  add("Beltane", `${year}-05-01`, 'Celtic', 'üî•');
  add("Vesak", `${year}-05-12`, 'Buddhist', 'ü™∑');
  add("Summer Solstice", `${year}-06-21`, 'Global', '‚òÄÔ∏è');
  add("Midsummer", `${year}-06-24`, 'Nordic', 'üåû');
  add("Independence Day", `${year}-07-04`, 'American', 'üá∫üá∏');
  add("Tanabata", `${year}-07-07`, 'Japanese', 'üéã');
  add("Obon", `${year}-08-15`, 'Japanese', 'üèÆ');
  add("Mid-Autumn Festival", `${year}-09-17`, 'Chinese', 'ü•Æ');
  add("Autumn Equinox", `${year}-09-22`, 'Global', 'üçÇ');
  add("Rosh Hashanah", `${year}-09-25`, 'Jewish', 'üçØ');
  add("Dussehra", `${year}-10-12`, 'Hindu', 'üèπ');
  add("Halloween", `${year}-10-31`, 'Western', 'üéÉ');
  add("D√≠a de los Muertos", `${year}-11-01`, 'Mexican', 'üíÄ');
  add("Diwali", `${year}-11-01`, 'Hindu', 'ü™î');
  add("Remembrance Day", `${year}-11-11`, 'Commonwealth', 'üå∫');
  add("Thanksgiving", `${year}-11-28`, 'American', 'ü¶É');
  add("Hanukkah", `${year}-12-25`, 'Jewish', 'üïé');
  add("Winter Solstice", `${year}-12-21`, 'Global', '‚ùÑÔ∏è');
  add("Christmas Eve", `${year}-12-24`, 'Christian', 'üåü');
  add("Christmas Day", `${year}-12-25`, 'Christian', 'üéÑ');
  add("Boxing Day", `${year}-12-26`, 'Commonwealth', 'üéÅ');
  add("Kwanzaa Begins", `${year}-12-26`, 'African American', 'üïØÔ∏è');
  add("New Year's Eve", `${year}-12-31T23:59:59`, 'Global', 'üéä');
  add("Eid al-Fitr", `${year}-03-30`, 'Islamic', 'üåô');
  add("Eid al-Adha", `${year}-06-06`, 'Islamic', 'üêë');
  
  events.sort((a, b) => a.date - b.date);
  return events;
}

function updateSeasonalState() {
  const now = new Date();
  currentSeason = detectSeason(now, weatherState.latitude);
  seasonalPalette = SEASONAL_PALETTES[currentSeason];
  yearEvents = [...generateYearEvents(now.getFullYear()), ...generateYearEvents(now.getFullYear() + 1)];
  
  const seasonData = SEASONS[currentSeason];
  document.getElementById('loadingTitle').textContent = `${seasonData.name} Forest`;
  document.getElementById('loadingSubtitle').textContent = 'A Living Landscape';
  document.getElementById('loadingQuote').innerHTML = seasonData.quotes[Math.floor(Math.random() * seasonData.quotes.length)];
  
  const bgColors = {
    spring: 'linear-gradient(to bottom, #2d3a2e 0%, #3d4a3e 50%, #4a5a4a 100%)',
    summer: 'linear-gradient(to bottom, #2a3545 0%, #3a4555 50%, #4a5565 100%)',
    autumn: 'linear-gradient(to bottom, #3a2a1a 0%, #4a3a2a 50%, #5a4a3a 100%)',
    winter: 'linear-gradient(to bottom, #1a1d24 0%, #252830 50%, #2a2d35 100%)'
  };
  document.getElementById('loadingScreen').style.background = bgColors[currentSeason];
}


// ============================================================================
// CRR MATHEMATICAL FRAMEWORK
// Coherence-Rupture-Regeneration as developed by Alexander Sabine
// 
// Core equations:
//   C(x,t) = ‚à´L(x,œÑ)dœÑ           - Coherence accumulation  
//   Œ¥(now)                        - Rupture as scale-invariant moment
//   R = ‚à´œÜ(x,œÑ)exp(C/Œ©)Œò(...)dœÑ  - Regeneration with memory weighting
//
// For SO(2) systems (full rotation): Œ© = 1/(2œÄ)
// For Z‚ÇÇ systems (half rotation):    Œ© = 1/œÄ
// ============================================================================

const CRR_CONSTANTS = {
  // SO(2) symmetry (full cycle) - used for day/night and seasonal cycles
  OMEGA_SO2: 1 / (2 * Math.PI),  // ‚âà 0.159
  
  // Z‚ÇÇ symmetry (half cycle) - used for systems with binary state changes
  OMEGA_Z2: 1 / Math.PI,         // ‚âà 0.318
  
  // Coefficient of variation CV = Œ©/2
  CV_SO2: 1 / (4 * Math.PI),     // ‚âà 0.08
  CV_Z2: 1 / (2 * Math.PI),      // ‚âà 0.16
};

class CRRSystem {
  /**
   * Mathematical CRR system implementing the coherence-rupture-regeneration cycle
   * @param {number} omega - The Œ© parameter (1/2œÄ for SO(2), 1/œÄ for Z‚ÇÇ)
   * @param {number} learningRate - Rate of coherence accumulation L(x,œÑ)
   * @param {string} symmetry - 'SO2' for full rotation, 'Z2' for half rotation
   */
  constructor(omega = CRR_CONSTANTS.OMEGA_SO2, learningRate = 0.1, symmetry = 'SO2') {
    this.omega = omega;
    this.learningRate = learningRate;
    this.symmetry = symmetry;
    
    // State tracking
    this.coherence = 0;           // C(x,t) - accumulated coherence
    this.state = 'coherence';     // Current phase: coherence, rupture, regeneration
    this.amplitude = 0;           // Output amplitude
    
    // Memory buffer for exp(C/Œ©) weighted integration
    this.coherenceHistory = [];   // Tracks C(x,œÑ) over time for memory weighting
    this.maxHistoryLength = 100;  // Discretized history buffer
    
    // Rupture tracking
    this.lastRuptureTime = 0;
    this.timeSinceRupture = 0;
    
    // Regeneration resources œÜ(x,œÑ)
    this.phi = 1.0;               // Reconstruction resource availability
  }
  
  /**
   * The core CRR update implementing the three phases
   * @param {number} dt - Time delta
   * @param {number} attention - L(x,œÑ) input signal (attention/learning)
   * @param {number} globalTime - Global simulation time
   * @returns {number} Current amplitude
   */
  update(dt, attention = 1, globalTime = 0) {
    this.timeSinceRupture += dt;
    
    if (this.state === 'coherence') {
      // COHERENCE PHASE: C(x,t) = ‚à´L(x,œÑ)dœÑ
      // Accumulate coherence based on attention/learning signal
      const dC = this.learningRate * attention * dt;
      this.coherence += dC;
      
      // Store coherence history for memory-weighted regeneration
      this.coherenceHistory.push({ t: globalTime, C: this.coherence });
      if (this.coherenceHistory.length > this.maxHistoryLength) {
        this.coherenceHistory.shift();
      }
      
      // Amplitude builds toward threshold
      this.amplitude = Math.min(1, this.coherence / this.omega);
      
      // Check for rupture threshold: when C ‚â• Œ©
      if (this.coherence >= this.omega) {
        this.state = 'rupture';
        this.lastRuptureTime = globalTime;
      }
      
    } else if (this.state === 'rupture') {
      // RUPTURE PHASE: Œ¥(now) - the scale-invariant choice moment
      // This is instantaneous - a punctuation in continuous flow
      this.amplitude = 1.0;
      this.state = 'regeneration';
      
    } else {
      // REGENERATION PHASE: R = ‚à´œÜ(x,œÑ)exp(C/Œ©)Œò(...)dœÑ
      // The exp(C/Œ©) term creates differential memory weighting
      
      // Calculate memory-weighted regeneration
      const memoryWeight = this.calculateMemoryWeight();
      
      // œÜ(x,œÑ) - reconstruction resources (recover over time)
      this.phi = Math.min(1, this.phi + dt * 0.5);
      
      // Regeneration with exponential memory decay modulated by exp(C/Œ©)
      // Large Œ© ‚Üí exp(C/Œ©) ‚âà 1 ‚Üí all history weighted equally
      // Small Œ© ‚Üí exp(C/Œ©) peaked ‚Üí only high coherence moments accessible
      const decayRate = 2 * Math.exp(-memoryWeight);
      this.coherence *= Math.exp(-decayRate * dt);
      this.amplitude = this.coherence / this.omega;
      
      // Return to coherence phase when sufficiently decayed
      if (this.coherence < 0.01 * this.omega) {
        this.coherence = 0;
        this.state = 'coherence';
        this.coherenceHistory = [];
      }
    }
    
    return this.amplitude;
  }
  
  /**
   * Calculate exp(C/Œ©) memory weighting
   * This is the key CRR insight: memory access is weighted by coherence
   */
  calculateMemoryWeight() {
    if (this.coherenceHistory.length === 0) return 1;
    
    // Compute exp(C/Œ©) for current coherence
    // Capped to prevent numerical overflow
    const exponent = Math.min(this.coherence / this.omega, 5);
    return Math.exp(exponent);
  }
  
  /**
   * Get the coefficient of variation for this system
   */
  getCV() {
    return this.omega / 2;
  }
  
  /**
   * Get precision (inverse variance) - connects to FEP
   */
  getPrecision() {
    // For CRR-FEP unification: precision = 1/œÉ¬≤ = 1/Œ©
    return 1 / this.omega;
  }
}

// ============================================================================
// CRR-DRIVEN DAY/NIGHT CYCLE
// The diurnal cycle is an SO(2) system (full rotation)
// ============================================================================

class CRRDayNightCycle {
  constructor() {
    // Day/night is SO(2) symmetric (full 24-hour rotation)
    this.omega = CRR_CONSTANTS.OMEGA_SO2;
    
    // Separate CRR systems for dawn and dusk transitions
    this.dawnCRR = new CRRSystem(this.omega, 0.08, 'SO2');
    this.duskCRR = new CRRSystem(this.omega, 0.08, 'SO2');
    
    // State tracking
    this.lastPhase = 'night';  // night, dawn, day, dusk
    this.transitionProgress = 0;
    this.coherenceField = 0;   // Accumulated "dayness" or "nightness"
  }
  
  /**
   * Update the day/night cycle with CRR dynamics
   * @param {number} dayTime - Hour of day (0-24)
   * @param {number} dt - Time delta
   * @returns {object} CRR-modulated transition parameters
   */
  update(dayTime, dt, sunTimes) {
    const { rise, set } = sunTimes;
    
    // Determine current phase and distance to transitions
    let phase, transitionType = null, transitionProgress = 0;
    
    if (dayTime < rise - 1) {
      phase = 'night';
    } else if (dayTime < rise + 1.5) {
      phase = 'dawn';
      transitionType = 'dawn';
      transitionProgress = (dayTime - (rise - 1)) / 2.5;
    } else if (dayTime < set - 1) {
      phase = 'day';
    } else if (dayTime < set + 1.5) {
      phase = 'dusk';
      transitionType = 'dusk';
      transitionProgress = (dayTime - (set - 1)) / 2.5;
    } else {
      phase = 'night';
    }
    
    // Update CRR systems based on phase
    let crrModulation = 1.0;
    
    if (transitionType === 'dawn') {
      // During dawn, coherence builds in night‚Üíday transition
      const attention = 1 + Math.sin(transitionProgress * Math.PI);
      this.dawnCRR.update(dt, attention, dayTime);
      
      // exp(C/Œ©) modulates the transition sharpness
      const memoryWeight = this.dawnCRR.calculateMemoryWeight();
      crrModulation = Math.tanh(memoryWeight * transitionProgress);
      
      // Rupture creates the "moment" of dawn
      if (this.dawnCRR.state === 'rupture') {
        crrModulation = 1.0; // Full transition at rupture
      }
    } else if (transitionType === 'dusk') {
      const attention = 1 + Math.sin(transitionProgress * Math.PI);
      this.duskCRR.update(dt, attention, dayTime);
      
      const memoryWeight = this.duskCRR.calculateMemoryWeight();
      crrModulation = Math.tanh(memoryWeight * transitionProgress);
      
      if (this.duskCRR.state === 'rupture') {
        crrModulation = 1.0;
      }
    } else {
      // Reset CRR systems during stable phases
      if (phase === 'day' && this.lastPhase !== 'day') {
        this.dawnCRR = new CRRSystem(this.omega, 0.08, 'SO2');
      }
      if (phase === 'night' && this.lastPhase !== 'night') {
        this.duskCRR = new CRRSystem(this.omega, 0.08, 'SO2');
      }
    }
    
    this.lastPhase = phase;
    this.transitionProgress = transitionProgress;
    
    return {
      phase,
      transitionType,
      transitionProgress,
      crrModulation,
      dawnAmplitude: this.dawnCRR.amplitude,
      duskAmplitude: this.duskCRR.amplitude,
      omega: this.omega,
      cv: this.omega / 2
    };
  }
}

// ============================================================================
// CRR-DRIVEN SEASONAL CYCLE  
// Annual cycle is also SO(2) symmetric
// ============================================================================

class CRRSeasonalCycle {
  constructor() {
    this.omega = CRR_CONSTANTS.OMEGA_SO2;
    
    // CRR systems for each seasonal transition
    this.transitions = {
      winterToSpring: new CRRSystem(this.omega, 0.02, 'SO2'),
      springToSummer: new CRRSystem(this.omega, 0.02, 'SO2'),
      summerToAutumn: new CRRSystem(this.omega, 0.02, 'SO2'),
      autumnToWinter: new CRRSystem(this.omega, 0.02, 'SO2')
    };
    
    this.currentSeason = 'winter';
    this.seasonCoherence = 0;
  }
  
  /**
   * Get seasonal palette with CRR-modulated transitions
   */
  getSeasonalBlend(date, basePalettes) {
    const month = date.getMonth();
    const day = date.getDate();
    const yearProgress = (month * 30 + day) / 365;
    
    // Determine which transition we're in (if any)
    let fromSeason, toSeason, transitionKey, transitionProgress;
    
    // Transition windows around equinoxes/solstices
    if (month === 2 && day >= 10 || month === 3 && day <= 10) {
      // Around March equinox
      fromSeason = 'winter'; toSeason = 'spring';
      transitionKey = 'winterToSpring';
      transitionProgress = (month === 2) ? (day - 10) / 30 : (20 + day) / 30;
    } else if (month === 5 && day >= 11 || month === 6 && day <= 10) {
      // Around June solstice  
      fromSeason = 'spring'; toSeason = 'summer';
      transitionKey = 'springToSummer';
      transitionProgress = (month === 5) ? (day - 11) / 30 : (20 + day) / 30;
    } else if (month === 8 && day >= 12 || month === 9 && day <= 12) {
      // Around September equinox
      fromSeason = 'summer'; toSeason = 'autumn';
      transitionKey = 'summerToAutumn';
      transitionProgress = (month === 8) ? (day - 12) / 30 : (19 + day) / 30;
    } else if (month === 11 && day >= 11 || month === 0 && day <= 10) {
      // Around December solstice
      fromSeason = 'autumn'; toSeason = 'winter';
      transitionKey = 'autumnToWinter';
      transitionProgress = (month === 11) ? (day - 11) / 30 : (20 + day) / 30;
    } else {
      // Not in transition - return current season
      return { 
        inTransition: false,
        season: this.getCurrentSeason(month),
        blendFactor: 0
      };
    }
    
    // Update CRR for this transition
    const crr = this.transitions[transitionKey];
    const attention = 1 + 0.5 * Math.sin(transitionProgress * Math.PI);
    crr.update(0.001, attention, yearProgress);
    
    // CRR modulates the blend curve
    const memoryWeight = crr.calculateMemoryWeight();
    const crrBlend = Math.tanh(memoryWeight * transitionProgress);
    
    return {
      inTransition: true,
      fromSeason,
      toSeason,
      transitionProgress,
      crrBlend,
      crrAmplitude: crr.amplitude,
      omega: this.omega
    };
  }
  
  getCurrentSeason(month) {
    if (month >= 2 && month <= 4) return 'spring';
    if (month >= 5 && month <= 7) return 'summer';
    if (month >= 8 && month <= 10) return 'autumn';
    return 'winter';
  }
}

// Global CRR cycle controllers
const dayNightCRR = new CRRDayNightCycle();
const seasonalCRR = new CRRSeasonalCycle();


class AudioSystem {
  constructor() { this.ctx = null; this.isInit = false; }
  
  init() {
    if (this.isInit) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.isInit = true;
  }
  
  playBell(time, pitch, vol) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.frequency.value = pitch; osc.type = 'sine';
    osc.connect(gain); gain.connect(this.ctx.destination);
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.08 * vol, time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
    osc.start(time); osc.stop(time + 0.4);
  }
  
  playJingle() {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();
    const now = this.ctx.currentTime;
    const pitches = [2400, 2600, 2800, 3000];
    for (let r = 0; r < 20; r++) {
      [0, 0.15, 0.3, 0.45, 0.6, 0.75].forEach((t, i) => {
        this.playBell(now + r * 1 + t, pitches[i % 4] * (0.98 + Math.random() * 0.04), 0.5);
      });
    }
  }
}

// ============================================================================
// GLOBALS
// ============================================================================
const { sin, cos, sqrt, abs, floor, max, min, random, PI, atan2 } = Math;
const PI2 = PI * 2;
const lerp = (a, b, t) => a + (b - a) * t;
const lerpColor = (c1, c2, t) => ({ r: lerp(c1.r, c2.r, t), g: lerp(c1.g, c2.g, t), b: lerp(c1.b, c2.b, t) });
const rgba = (c, a) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W, H, horizonY, forestY, time = 0, dayTime = 12, isLoaded = false;

const audio = new AudioSystem();
const flockCRR = new CRRSystem(8, 0.15);
const mistCRR = new CRRSystem(15, 0.05);
const weatherCRR = new CRRSystem(20, 0.03);

let starlings = [], mistPatches = [], precipitationParticles = [], stars = [];
let perchSpots = [], predator = null, predatorCooldown = 15;
let sleigh = null, sleighActive = false, sleighTriggered = false;
let forestLamps = [], pathPoints = [], lowryFigures = [];

// Ambient weather particles
let breezeParticles = [], atmosphericMotes = [], lightShafts = [];

// Cloud system
let cloudLayers = [];

// Spatial hashing
let spatialHash = {};

// Tree layers and texture
const treeLayers = {};
let textureLayer;

let moonPhase = 0;

let currentColors = null;
let lastColorUpdate = 0;

// Weather state
const weatherState = {
  precipitationIntensity: 0.7,
  mistIntensity: 0.6,
  windStrength: 0.5,
  cloudCover: 0.3,
  targetPrecipitation: 0.7,
  targetMist: 0.6,
  targetWind: 0.5,
  targetCloudCover: 0.3,
  realWeatherEnabled: false,
  realWeatherData: null,
  locationName: '',
  latitude: null,
  longitude: null,
  isRaining: false
};

// ============================================================================
// TREE CONFIG
// ============================================================================
const TREE_CONFIG = {
  frost: { num: 7, height: 0.32, xOff: 0, yOff: 0, depth: 2, perch: false },
  gold: { num: 5, height: 0.38, xOff: 0.05, yOff: 0.008, depth: 1, perch: false },
  blue: { num: 5, height: 0.36, xOff: -0.04, yOff: 0.005, depth: 1, perch: false },
  silver: { num: 6, height: 0.42, xOff: 0.01, yOff: 0.012, depth: 0, perch: true }
};

const TREE_COLORS = {
  frost: { base: { r: 180, g: 175, b: 165 }, bright: { r: 220, g: 215, b: 205 } },
  gold: { base: { r: 95, g: 80, b: 65 }, bright: { r: 155, g: 130, b: 100 } },
  blue: { base: { r: 70, g: 80, b: 95 }, bright: { r: 130, g: 145, b: 165 } },
  silver: { base: { r: 55, g: 50, b: 45 }, bright: { r: 110, g: 100, b: 90 } }
};

// ============================================================================
// CANVAS SETUP
// ============================================================================
function initCanvas() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);
  horizonY = H * 0.52;
  forestY = H * 0.62;
}

// ============================================================================
// SPATIAL HASHING
// ============================================================================
function getSpatialKey(x, y) {
  return `${floor(x / CONFIG.spatialCellSize)},${floor(y / CONFIG.spatialCellSize)}`;
}

function updateSpatialHash() {
  spatialHash = {};
  for (let i = 0; i < starlings.length; i++) {
    const b = starlings[i];
    if (b.state !== 'flying') continue;
    const key = getSpatialKey(b.x, b.y);
    if (!spatialHash[key]) spatialHash[key] = [];
    spatialHash[key].push(i);
  }
}

function getNearbyBirds(x, y) {
  const result = [];
  const cx = floor(x / CONFIG.spatialCellSize), cy = floor(y / CONFIG.spatialCellSize);
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      const key = `${cx + dx},${cy + dy}`;
      if (spatialHash[key]) result.push(...spatialHash[key]);
    }
  }
  return result;
}

// ============================================================================
// MOON PHASE CALCULATIONS
// ============================================================================
function calculateMoonPhase(date = new Date()) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  let Y = year, M = month;
  if (M < 3) { Y--; M += 12; }
  const A = floor(Y / 100);
  const B = 2 - A + floor(A / 4);
  const JD = floor(365.25 * (Y + 4716)) + floor(30.6001 * (M + 1)) + day + B - 1524.5;
  const phase = ((JD - 2451550.1) / 29.530588853) % 1;
  return phase < 0 ? phase + 1 : phase;
}

function getMoonIllumination(phase) {
  return 0.5 * (1 - cos(phase * PI2));
}

// ============================================================================
// STARS
// ============================================================================
function initStars() {
  stars = [];
  const count = floor((W * horizonY) / 4000);
  for (let i = 0; i < count; i++) {
    stars.push({
      x: random() * W,
      y: random() * horizonY * 0.9,
      size: 0.5 + random() * 1.2,
      brightness: 0.3 + random() * 0.7,
      twinkleSpeed: 1 + random() * 2,
      twinklePhase: random() * PI2
    });
  }
}

function drawStars(ambient) {
  if (ambient > 0.5) return;
  const visibility = 1 - ambient * 2;
  // Reduce star visibility based on cloud cover
  const cloudDim = 1 - weatherState.cloudCover * 0.8;
  
  ctx.fillStyle = '#fff';
  for (let i = 0, len = stars.length; i < len; i++) {
    const s = stars[i];
    const twinkle = 0.7 + sin(time * s.twinkleSpeed + s.twinklePhase) * 0.3;
    const alpha = s.brightness * visibility * twinkle * cloudDim;
    if (alpha < 0.05) continue;
    
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, PI2);
    ctx.fill();
    
    // Add subtle glow to brighter stars
    if (s.brightness > 0.6) {
      ctx.globalAlpha = alpha * 0.3;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size * 2.5, 0, PI2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

// ============================================================================
// EFFICIENT CLOUD SYSTEM - Procedural with cached rendering
// ============================================================================

function initClouds() {
  cloudLayers = [];
  
  // Generate cloud formations for each layer
  const layerConfigs = [
    { count: 4, yRange: [0.08, 0.2], sizeRange: [0.15, 0.25], speed: 8, opacity: 0.25 },  // High wisps
    { count: 5, yRange: [0.2, 0.4], sizeRange: [0.12, 0.22], speed: 12, opacity: 0.4 },   // Mid clouds
    { count: 6, yRange: [0.35, 0.55], sizeRange: [0.18, 0.35], speed: 18, opacity: 0.6 }  // Low cumulus
  ];
  
  layerConfigs.forEach((config, layerIdx) => {
    for (let i = 0; i < config.count; i++) {
      const cloud = {
        x: random() * W * 1.5 - W * 0.25,
        y: horizonY * (config.yRange[0] + random() * (config.yRange[1] - config.yRange[0])),
        width: W * (config.sizeRange[0] + random() * (config.sizeRange[1] - config.sizeRange[0])),
        height: H * (0.03 + random() * 0.04),
        speed: config.speed * (0.7 + random() * 0.6),
        baseOpacity: config.opacity * (0.7 + random() * 0.3),
        layer: layerIdx,
        // Pre-generate puff positions for this cloud
        puffs: []
      };
      
      // Generate organic puff arrangement
      const puffCount = 5 + floor(random() * 4);
      for (let p = 0; p < puffCount; p++) {
        cloud.puffs.push({
          xOff: (p / puffCount) * 0.8 + (random() - 0.5) * 0.15,
          yOff: (random() - 0.5) * 0.4,
          size: 0.5 + random() * 0.5,
          bright: random() > 0.5 // Top-lit vs shadow
        });
      }
      
      cloudLayers.push(cloud);
    }
  });
  
  // Sort by y position for proper layering
  cloudLayers.sort((a, b) => a.y - b.y);
}

function updateClouds(dt) {
  const windFactor = 0.3 + weatherState.windStrength * 0.7;
  
  for (let i = 0; i < cloudLayers.length; i++) {
    const cloud = cloudLayers[i];
    cloud.x += cloud.speed * windFactor * dt;
    
    // Wrap around
    if (cloud.x > W + cloud.width * 0.5) {
      cloud.x = -cloud.width;
    }
  }
}

function drawClouds(ambient) {
  const coverage = weatherState.cloudCover;
  if (coverage < 0.05) return;
  
  const isDay = ambient > 0.4;
  const isGoldenHour = ambient > 0.3 && ambient < 0.6;
  
  ctx.save();
  
  for (let i = 0; i < cloudLayers.length; i++) {
    const cloud = cloudLayers[i];
    const opacity = cloud.baseOpacity * coverage;
    if (opacity < 0.03) continue;
    
    // Base colors based on time of day
    let baseR, baseG, baseB;
    let shadowR, shadowG, shadowB;
    
    if (isDay) {
      if (isGoldenHour) {
        // Warm sunset/sunrise tones
        const warmth = 1 - Math.abs(ambient - 0.45) / 0.15;
        baseR = 255; baseG = 250 - warmth * 20; baseB = 245 - warmth * 50;
        shadowR = 200 + warmth * 30; shadowG = 180; shadowB = 170 - warmth * 30;
      } else {
        // Normal daylight - white to light gray
        baseR = 255; baseG = 255; baseB = 255;
        shadowR = 190; shadowG = 195; shadowB = 205;
      }
    } else {
      // Night - dark blue-gray
      baseR = 70; baseG = 75; baseB = 90;
      shadowR = 40; shadowG = 45; shadowB = 55;
    }
    
    // Draw cloud puffs
    for (let p = 0; p < cloud.puffs.length; p++) {
      const puff = cloud.puffs[p];
      const px = cloud.x + cloud.width * puff.xOff;
      const py = cloud.y + cloud.height * puff.yOff * 5;
      const ps = cloud.height * puff.size * 2.5;
      
      // Skip if off screen
      if (px + ps < 0 || px - ps > W) continue;
      
      // Shadow/underside
      ctx.fillStyle = `rgba(${shadowR}, ${shadowG}, ${shadowB}, ${opacity * 0.5})`;
      ctx.beginPath();
      ctx.ellipse(px + 2, py + ps * 0.2, ps * 1.1, ps * 0.6, 0, 0, PI2);
      ctx.fill();
      
      // Main puff with gradient
      const grad = ctx.createRadialGradient(px - ps * 0.2, py - ps * 0.2, 0, px, py, ps);
      grad.addColorStop(0, `rgba(${baseR}, ${baseG}, ${baseB}, ${opacity})`);
      grad.addColorStop(0.6, `rgba(${(baseR + shadowR) / 2 | 0}, ${(baseG + shadowG) / 2 | 0}, ${(baseB + shadowB) / 2 | 0}, ${opacity * 0.8})`);
      grad.addColorStop(1, `rgba(${shadowR}, ${shadowG}, ${shadowB}, ${opacity * 0.3})`);
      
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(px, py, ps, ps * 0.6, 0, 0, PI2);
      ctx.fill();
    }
  }
  
  // Overcast haze at high coverage
  if (coverage > 0.6) {
    const hazeOpacity = (coverage - 0.6) * 0.25;
    ctx.fillStyle = isDay 
      ? `rgba(210, 215, 225, ${hazeOpacity})`
      : `rgba(50, 55, 65, ${hazeOpacity * 0.6})`;
    ctx.fillRect(0, 0, W, horizonY);
  }
  
  ctx.restore();
}

// ============================================================================
// FOREST LAMPS - Ornate Victorian Street Lamps (Visible Day & Night)
// ============================================================================
function initForestLamps() {
  forestLamps = [];
  
  // Place ornate Victorian lamps along the path
  const lampConfigs = [
    { xRatio: 0.18, scale: 0.42, brightness: 0.85 },
    { xRatio: 0.45, scale: 0.45, brightness: 0.9 },
    { xRatio: 0.72, scale: 0.43, brightness: 0.82 },
  ];
  
  const pathY = H * 0.79;
  
  lampConfigs.forEach((cfg, idx) => {
    const waveY = sin(cfg.xRatio * W * 0.008) * 3 + sin(cfg.xRatio * W * 0.02 + 1) * 2;
    const x = W * cfg.xRatio;
    const y = pathY - 2 + waveY;
    const s = cfg.scale;
    const postHeight = 90 * s;
    const topY = y - postHeight;
    const lanternY = topY + 4 * s;
    const lanternH = 14 * s;
    const bracketY = topY + 18 * s;
    
    forestLamps.push({
      x: x,
      y: y,
      scale: s,
      brightness: cfg.brightness,
      phase: random() * PI2,
      crr: new CRRSystem(0.3 + random() * 0.2, 0.12 + random() * 0.08)
    });
    
    // Add lamp perch spots for birds
    // Top of lantern finial - prime perching spot
    perchSpots.push({ 
      x: x, 
      y: lanternY - lanternH * 0.7 - 6 * s - 2, 
      occupied: false,
      lampPerch: true,
      lampIdx: idx
    });
    
    // Left and right bracket arms - additional perch spots
    perchSpots.push({ 
      x: x - 5 * s, 
      y: bracketY - 4 * s, 
      occupied: false,
      lampPerch: true,
      lampIdx: idx
    });
    perchSpots.push({ 
      x: x + 5 * s, 
      y: bracketY - 4 * s, 
      occupied: false,
      lampPerch: true,
      lampIdx: idx
    });
  });
}

function drawForestLamps(ambient) {
  if (!forestLamps || forestLamps.length === 0) return;
  
  // Calculate lamp light intensity (only lit at night)
  const isNight = ambient < 0.5;
  const lampIntensity = isNight ? 1 - (ambient / 0.5) : 0;
  
  forestLamps.forEach((lamp, idx) => {
    lamp.crr.update(0.016, 0.8 + sin(time * 0.5 + idx) * 0.2);
    
    // Enhanced flicker - more variation (only affects light, not structure)
    const baseFlicker = 0.82 + lamp.crr.amplitude * 0.18;
    const microFlicker = 1 + sin(time * 15 + idx * 7) * 0.03 + sin(time * 23 + idx * 13) * 0.02;
    const flicker = baseFlicker * microFlicker;
    const intensity = lamp.brightness * flicker * lampIntensity;
    
    const x = lamp.x;
    const baseY = lamp.y;
    const s = lamp.scale;
    const postHeight = 90 * s;
    const topY = baseY - postHeight;
    
    // Iron colors adapt to ambient light
    const ironBase = isNight ? 25 : 45;
    const ironBrightness = isNight ? 0.85 : 0.7;
    const ironColor = `rgba(${ironBase}, ${ironBase - 3}, ${ironBase - 7}, ${ironBrightness + ambient * 0.1})`;
    const ironLight = `rgba(${ironBase + 20}, ${ironBase + 15}, ${ironBase + 10}, ${0.5 + ambient * 0.3})`;
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // === SCENE ILLUMINATION (only at night) ===
    if (intensity > 0.1) {
      const lanternY = topY + 4 * s;
      
      // Large scene illumination - affects ground and nearby area
      const sceneGlow = ctx.createRadialGradient(x, lanternY, 0, x, lanternY, 120 * s);
      sceneGlow.addColorStop(0, `rgba(255, 220, 160, ${intensity * 0.08})`);
      sceneGlow.addColorStop(0.3, `rgba(255, 200, 130, ${intensity * 0.05})`);
      sceneGlow.addColorStop(0.6, `rgba(255, 180, 100, ${intensity * 0.025})`);
      sceneGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = sceneGlow;
      ctx.beginPath();
      ctx.arc(x, lanternY, 120 * s, 0, PI2);
      ctx.fill();
      
      // Ground illumination pool - wider and softer
      const groundGlow = ctx.createRadialGradient(x, baseY, 0, x, baseY, 60 * s);
      groundGlow.addColorStop(0, `rgba(255, 215, 150, ${intensity * 0.2})`);
      groundGlow.addColorStop(0.4, `rgba(255, 200, 130, ${intensity * 0.1})`);
      groundGlow.addColorStop(0.7, `rgba(255, 180, 100, ${intensity * 0.04})`);
      groundGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = groundGlow;
      ctx.beginPath();
      ctx.ellipse(x, baseY + 3, 60 * s, 20 * s, 0, 0, PI2);
      ctx.fill();
    }
    
    // === ORNATE BASE (always visible) ===
    ctx.fillStyle = ironColor;
    // Base plinth
    ctx.beginPath();
    ctx.moveTo(x - 8 * s, baseY);
    ctx.lineTo(x - 6 * s, baseY - 4 * s);
    ctx.lineTo(x + 6 * s, baseY - 4 * s);
    ctx.lineTo(x + 8 * s, baseY);
    ctx.closePath();
    ctx.fill();
    
    // Decorative base collar
    ctx.beginPath();
    ctx.ellipse(x, baseY - 4 * s, 5 * s, 2 * s, 0, 0, PI2);
    ctx.fill();
    
    // === MAIN POST with decorative elements (always visible) ===
    ctx.strokeStyle = ironColor;
    ctx.lineWidth = 3 * s;
    ctx.beginPath();
    ctx.moveTo(x, baseY - 4 * s);
    ctx.lineTo(x, topY + 20 * s);
    ctx.stroke();
    
    // Post highlight
    ctx.strokeStyle = ironLight;
    ctx.lineWidth = 1 * s;
    ctx.beginPath();
    ctx.moveTo(x + 1 * s, baseY - 4 * s);
    ctx.lineTo(x + 1 * s, topY + 20 * s);
    ctx.stroke();
    
    // Decorative rings on post
    ctx.fillStyle = ironColor;
    [0.25, 0.5, 0.75].forEach(t => {
      const ringY = baseY - 4 * s - (postHeight - 24 * s) * t;
      ctx.beginPath();
      ctx.ellipse(x, ringY, 3.5 * s, 1.2 * s, 0, 0, PI2);
      ctx.fill();
    });
    
    // === ORNATE BRACKET (always visible) ===
    const bracketY = topY + 18 * s;
    ctx.strokeStyle = ironColor;
    ctx.lineWidth = 2 * s;
    
    // Main bracket curve
    ctx.beginPath();
    ctx.moveTo(x, bracketY);
    ctx.quadraticCurveTo(x + 4 * s, bracketY - 8 * s, x, bracketY - 12 * s);
    ctx.stroke();
    
    // Decorative scrollwork
    ctx.lineWidth = 1.5 * s;
    ctx.beginPath();
    ctx.moveTo(x - 2 * s, bracketY - 2 * s);
    ctx.quadraticCurveTo(x - 6 * s, bracketY - 6 * s, x - 3 * s, bracketY - 10 * s);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 2 * s, bracketY - 2 * s);
    ctx.quadraticCurveTo(x + 6 * s, bracketY - 6 * s, x + 3 * s, bracketY - 10 * s);
    ctx.stroke();
    
    // Small decorative curls
    ctx.lineWidth = 1 * s;
    ctx.beginPath();
    ctx.arc(x - 5 * s, bracketY - 5 * s, 2 * s, 0, PI, false);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x + 5 * s, bracketY - 5 * s, 2 * s, 0, PI, false);
    ctx.stroke();
    
    // === LANTERN HOUSING (always visible) ===
    const lanternY = topY + 4 * s;
    const lanternW = 8 * s;
    const lanternH = 14 * s;
    
    // Lantern top (crown)
    ctx.fillStyle = ironColor;
    ctx.beginPath();
    ctx.moveTo(x - lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.lineTo(x - lanternW * 0.2, lanternY - lanternH * 0.6);
    ctx.lineTo(x, lanternY - lanternH * 0.7);
    ctx.lineTo(x + lanternW * 0.2, lanternY - lanternH * 0.6);
    ctx.lineTo(x + lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.closePath();
    ctx.fill();
    
    // Finial spike
    ctx.beginPath();
    ctx.moveTo(x - 1.5 * s, lanternY - lanternH * 0.7);
    ctx.lineTo(x, lanternY - lanternH * 0.7 - 6 * s);
    ctx.lineTo(x + 1.5 * s, lanternY - lanternH * 0.7);
    ctx.closePath();
    ctx.fill();
    
    // Lantern body frame
    ctx.strokeStyle = ironColor;
    ctx.lineWidth = 1.5 * s;
    ctx.beginPath();
    ctx.moveTo(x - lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.lineTo(x - lanternW * 0.4, lanternY + lanternH * 0.3);
    ctx.lineTo(x - lanternW * 0.2, lanternY + lanternH * 0.45);
    ctx.lineTo(x + lanternW * 0.2, lanternY + lanternH * 0.45);
    ctx.lineTo(x + lanternW * 0.4, lanternY + lanternH * 0.3);
    ctx.lineTo(x + lanternW * 0.4, lanternY - lanternH * 0.3);
    ctx.stroke();
    
    // Vertical bars
    ctx.lineWidth = 1 * s;
    [-0.2, 0, 0.2].forEach(off => {
      ctx.beginPath();
      ctx.moveTo(x + lanternW * off, lanternY - lanternH * 0.5);
      ctx.lineTo(x + lanternW * off * 0.6, lanternY + lanternH * 0.45);
      ctx.stroke();
    });
    
    // === GLASS PANELS (show ambient light during day, glow at night) ===
    if (isNight) {
      // Night: glass panels lit
      if (intensity > 0.05) {
        // Glass panel glow - brighter
        ctx.fillStyle = `rgba(255, 245, 210, ${intensity * 0.65})`;
        ctx.beginPath();
        ctx.moveTo(x - lanternW * 0.35, lanternY - lanternH * 0.25);
        ctx.lineTo(x - lanternW * 0.35, lanternY + lanternH * 0.25);
        ctx.lineTo(x + lanternW * 0.35, lanternY + lanternH * 0.25);
        ctx.lineTo(x + lanternW * 0.35, lanternY - lanternH * 0.25);
        ctx.closePath();
        ctx.fill();
        
        // Inner flame core - bright flickering center
        const flameGrad = ctx.createRadialGradient(x, lanternY, 0, x, lanternY, lanternW * 0.6);
        flameGrad.addColorStop(0, `rgba(255, 255, 240, ${intensity * 0.95})`);
        flameGrad.addColorStop(0.3, `rgba(255, 240, 200, ${intensity * 0.8})`);
        flameGrad.addColorStop(0.6, `rgba(255, 210, 150, ${intensity * 0.5})`);
        flameGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.arc(x, lanternY, lanternW * 0.6, 0, PI2);
        ctx.fill();
        
        // Inner warm glow - enhanced
        const innerGlow = ctx.createRadialGradient(x, lanternY, 0, x, lanternY, 30 * s);
        innerGlow.addColorStop(0, `rgba(255, 240, 200, ${intensity * 0.55})`);
        innerGlow.addColorStop(0.4, `rgba(255, 220, 160, ${intensity * 0.3})`);
        innerGlow.addColorStop(0.7, `rgba(255, 200, 130, ${intensity * 0.15})`);
        innerGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = innerGlow;
        ctx.beginPath();
        ctx.arc(x, lanternY, 30 * s, 0, PI2);
        ctx.fill();
        
        // Mid-range glow
        const midGlow = ctx.createRadialGradient(x, lanternY, 15 * s, x, lanternY, 55 * s);
        midGlow.addColorStop(0, `rgba(255, 215, 150, ${intensity * 0.2})`);
        midGlow.addColorStop(0.5, `rgba(255, 200, 120, ${intensity * 0.1})`);
        midGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = midGlow;
        ctx.beginPath();
        ctx.arc(x, lanternY, 55 * s, 0, PI2);
        ctx.fill();
        
        // Outer atmospheric glow - larger
        const outerGlow = ctx.createRadialGradient(x, lanternY, 30 * s, x, lanternY, 85 * s);
        outerGlow.addColorStop(0, `rgba(255, 200, 130, ${intensity * 0.12})`);
        outerGlow.addColorStop(0.6, `rgba(255, 180, 100, ${intensity * 0.05})`);
        outerGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = outerGlow;
        ctx.beginPath();
        ctx.arc(x, lanternY, 85 * s, 0, PI2);
        ctx.fill();
      }
    } else {
      // Day: glass panels reflect sky (subtle)
      const dayGlassAlpha = 0.15 + ambient * 0.1;
      ctx.fillStyle = `rgba(200, 210, 220, ${dayGlassAlpha})`;
      ctx.beginPath();
      ctx.moveTo(x - lanternW * 0.35, lanternY - lanternH * 0.25);
      ctx.lineTo(x - lanternW * 0.35, lanternY + lanternH * 0.25);
      ctx.lineTo(x + lanternW * 0.35, lanternY + lanternH * 0.25);
      ctx.lineTo(x + lanternW * 0.35, lanternY - lanternH * 0.25);
      ctx.closePath();
      ctx.fill();
    }
  });
}

// ============================================================================
// PATH & LOWRY FIGURES
// ============================================================================

function initPath() {
  // Create a winding path through the forest
  pathPoints = [];
  const pathY = H * 0.79; // Base Y for path
  
  // Generate path control points
  for (let i = 0; i <= 10; i++) {
    pathPoints.push({
      x: (i / 10) * W,
      y: pathY + sin(i * 0.8) * H * 0.015 + sin(i * 1.7) * H * 0.008
    });
  }
}

function initLowryFigures() {
  lowryFigures = [];
  const numFigures = 12 + floor(random() * 6);
  
  for (let i = 0; i < numFigures; i++) {
    const t = random(); // Position along path (0-1)
    lowryFigures.push({
      t: t,
      speed: (0.003 + random() * 0.006) * (random() > 0.5 ? 1 : -1), // Direction
      height: 12 + random() * 8, // Varying heights
      phase: random() * PI2,
      type: floor(random() * 6), // Different figure types
      color: random() > 0.7 ? 'dark' : (random() > 0.5 ? 'grey' : 'muted'),
      hasHat: random() > 0.6,
      ownsUmbrella: random() > 0.5, // Whether they own an umbrella
      umbrellaOpen: false, // Whether umbrella is currently open
      isChild: random() > 0.88,
      lean: (random() - 0.5) * 0.15, // Slight lean
      armSwing: random() * 0.5 + 0.3,
      // Seasonal attire properties
      hasScarf: random() > 0.5,
      hasCoat: true, // Default, modified by season
      coatColor: ['#2a2a35', '#3a3530', '#352a2a', '#2a3530'][floor(random() * 4)],
      scarfColor: ['#8b3a3a', '#3a5a8b', '#5a8b3a', '#8b6a3a'][floor(random() * 4)]
    });
  }
  
  // Sort by position for proper depth
  lowryFigures.sort((a, b) => getPathY(a.t) - getPathY(b.t));
}

function getPathY(t) {
  // Interpolate Y position along path
  if (!pathPoints || pathPoints.length === 0) return H * 0.79;
  if (pathPoints.length === 1) return pathPoints[0].y;
  const idx = t * (pathPoints.length - 1);
  const i = max(0, min(floor(idx), pathPoints.length - 2));
  const frac = idx - floor(idx);
  return lerp(pathPoints[i].y, pathPoints[i + 1].y, frac);
}

function getPathX(t) {
  return t * W;
}

function updateLowryFigures(dt) {
  if (!lowryFigures || lowryFigures.length === 0) return;
  
  // Determine if it's raining based on precipitation and season
  const isRaining = weatherState.isRaining || 
    (weatherState.precipitationIntensity > 0.5 && 
     (currentSeason === 'spring' || currentSeason === 'autumn' || currentSeason === 'winter'));
  
  lowryFigures.forEach(fig => {
    fig.t += fig.speed * dt;
    fig.phase += dt * 4;
    
    // Wrap around
    if (fig.t > 1.1) fig.t = -0.1;
    if (fig.t < -0.1) fig.t = 1.1;
    
    // Update umbrella state based on rain
    if (fig.ownsUmbrella) {
      if (isRaining && !fig.umbrellaOpen) {
        // Open umbrella when rain starts
        fig.umbrellaOpen = true;
      } else if (!isRaining && fig.umbrellaOpen && random() < 0.01) {
        // Gradually close umbrellas after rain stops
        fig.umbrellaOpen = false;
      }
    }
  });
  
  // Re-sort occasionally for depth
  if (random() < 0.01) {
    lowryFigures.sort((a, b) => getPathY(a.t) - getPathY(b.t));
  }
}

function drawPath(colors) {
  if (!colors || !colors.ground) return;
  
  const pathY = H * 0.79;
  
  // Path surface (subtle, worn)
  ctx.fillStyle = `rgba(${colors.ground.r - 15 | 0}, ${colors.ground.g - 12 | 0}, ${colors.ground.b - 10 | 0}, 0.35)`;
  ctx.beginPath();
  ctx.moveTo(-10, pathY + H * 0.025);
  
  // Top edge of path
  for (let i = 0; i <= W; i += 20) {
    const wave = sin(i * 0.008) * 3 + sin(i * 0.02 + 1) * 2;
    ctx.lineTo(i, pathY - H * 0.008 + wave);
  }
  
  // Bottom edge
  for (let i = W; i >= 0; i -= 20) {
    const wave = sin(i * 0.008 + 2) * 3 + sin(i * 0.02) * 2;
    ctx.lineTo(i, pathY + H * 0.025 + wave);
  }
  ctx.closePath();
  ctx.fill();
  
  // Path edges (subtle darker lines)
  ctx.strokeStyle = `rgba(${colors.ground.r - 30 | 0}, ${colors.ground.g - 25 | 0}, ${colors.ground.b - 20 | 0}, 0.2)`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, pathY - H * 0.006);
  for (let i = 0; i <= W; i += 30) {
    ctx.lineTo(i, pathY - H * 0.006 + sin(i * 0.01) * 2);
  }
  ctx.stroke();
}

function drawLowryFigures(ambient) {
  if (!lowryFigures || lowryFigures.length === 0) return;
  
  const visibility = min(1, max(0.3, ambient + 0.2));
  const isWinter = currentSeason === 'winter';
  const isSummer = currentSeason === 'summer';
  const isSpring = currentSeason === 'spring';
  
  lowryFigures.forEach(fig => {
    if (fig.t < -0.05 || fig.t > 1.05) return;
    
    const x = getPathX(fig.t);
    const baseY = getPathY(fig.t);
    const h = fig.isChild ? fig.height * 0.6 : fig.height;
    const walkCycle = sin(fig.phase) * fig.armSwing;
    const direction = fig.speed > 0 ? 1 : -1;
    
    // Figure colors (muted, Lowry-esque)
    let bodyColor, legColor;
    if (fig.color === 'dark') {
      bodyColor = `rgba(25, 25, 30, ${visibility * 0.85})`;
      legColor = `rgba(20, 20, 25, ${visibility * 0.85})`;
    } else if (fig.color === 'grey') {
      bodyColor = `rgba(60, 58, 55, ${visibility * 0.8})`;
      legColor = `rgba(40, 38, 35, ${visibility * 0.8})`;
    } else {
      bodyColor = `rgba(75, 65, 60, ${visibility * 0.75})`;
      legColor = `rgba(50, 45, 42, ${visibility * 0.75})`;
    }
    
    ctx.save();
    ctx.translate(x, baseY);
    ctx.scale(direction, 1);
    ctx.rotate(fig.lean);
    
    // === LOWRY MATCHSTICK FIGURE WITH SEASONAL ATTIRE ===
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Legs (thin, walking motion)
    ctx.strokeStyle = legColor;
    ctx.lineWidth = h * 0.08;
    
    // Back leg
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.4);
    ctx.lineTo(-h * 0.08 - walkCycle * h * 0.12, 0);
    ctx.stroke();
    
    // Front leg
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.4);
    ctx.lineTo(h * 0.08 + walkCycle * h * 0.12, 0);
    ctx.stroke();
    
    // Body (slightly hunched, Lowry style)
    // Winter: thicker coat
    const bodyWidth = isWinter ? h * 0.16 : (isSummer ? h * 0.1 : h * 0.12);
    ctx.strokeStyle = isWinter ? fig.coatColor : bodyColor;
    ctx.globalAlpha = visibility * (isWinter ? 0.9 : 0.85);
    ctx.lineWidth = bodyWidth;
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.4);
    ctx.quadraticCurveTo(h * 0.03, -h * 0.6, h * 0.02, -h * 0.8);
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Winter scarf
    if (isWinter && fig.hasScarf && !fig.isChild) {
      ctx.strokeStyle = fig.scarfColor;
      ctx.lineWidth = h * 0.06;
      ctx.beginPath();
      ctx.moveTo(-h * 0.06, -h * 0.78);
      ctx.quadraticCurveTo(-h * 0.08, -h * 0.72, -h * 0.12, -h * 0.65);
      ctx.lineTo(-h * 0.1, -h * 0.55);
      ctx.stroke();
      // Scarf around neck
      ctx.lineWidth = h * 0.05;
      ctx.beginPath();
      ctx.arc(h * 0.02, -h * 0.77, h * 0.07, PI * 0.3, PI * 1.2);
      ctx.stroke();
    }
    
    // Arms (swinging) - modified for umbrella
    ctx.strokeStyle = isWinter ? fig.coatColor : bodyColor;
    ctx.globalAlpha = visibility * (isWinter ? 0.9 : 0.85);
    ctx.lineWidth = h * 0.06;
    
    if (fig.umbrellaOpen) {
      // Arm holding umbrella up
      ctx.beginPath();
      ctx.moveTo(h * 0.02, -h * 0.7);
      ctx.lineTo(h * 0.15, -h * 0.85);
      ctx.stroke();
      
      // Other arm slightly forward
      ctx.beginPath();
      ctx.moveTo(h * 0.02, -h * 0.7);
      ctx.lineTo(-h * 0.08 - walkCycle * h * 0.1, -h * 0.5);
      ctx.stroke();
    } else {
      // Normal arm swing
      // Back arm
      ctx.beginPath();
      ctx.moveTo(h * 0.02, -h * 0.7);
      ctx.lineTo(-h * 0.1 - walkCycle * h * 0.15, -h * 0.45);
      ctx.stroke();
      
      // Front arm
      ctx.beginPath();
      ctx.moveTo(h * 0.02, -h * 0.7);
      ctx.lineTo(h * 0.12 + walkCycle * h * 0.15, -h * 0.5);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    
    // Head (small, round)
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(h * 0.02, -h * 0.88, h * 0.1, 0, PI2);
    ctx.fill();
    
    // Hat (if applicable) - more prominent in winter
    if (fig.hasHat && !fig.isChild) {
      ctx.fillStyle = legColor;
      if (isWinter) {
        // Winter cap with ear flaps suggestion
        ctx.beginPath();
        ctx.ellipse(h * 0.02, -h * 0.96, h * 0.13, h * 0.05, 0, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(h * 0.02, -h * 1.0, h * 0.1, 0, PI2);
        ctx.fill();
        // Pompom
        ctx.fillStyle = fig.scarfColor || '#555';
        ctx.beginPath();
        ctx.arc(h * 0.02, -h * 1.08, h * 0.03, 0, PI2);
        ctx.fill();
      } else if (fig.type % 2 === 0) {
        // Flat cap
        ctx.beginPath();
        ctx.ellipse(h * 0.02, -h * 0.95, h * 0.12, h * 0.04, 0.1, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-h * 0.08, -h * 0.95);
        ctx.quadraticCurveTo(h * 0.02, -h * 1.02, h * 0.12, -h * 0.95);
        ctx.fill();
      } else {
        // Bowler
        ctx.beginPath();
        ctx.ellipse(h * 0.02, -h * 0.96, h * 0.13, h * 0.03, 0, 0, PI2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(h * 0.02, -h * 1.02, h * 0.08, 0, PI2);
        ctx.fill();
      }
    }
    
    // Open umbrella when raining
    if (fig.umbrellaOpen) {
      // Umbrella handle
      ctx.strokeStyle = legColor;
      ctx.lineWidth = h * 0.03;
      ctx.beginPath();
      ctx.moveTo(h * 0.15, -h * 0.85);
      ctx.lineTo(h * 0.18, -h * 1.35);
      ctx.stroke();
      
      // Umbrella canopy
      ctx.fillStyle = `rgba(30, 30, 35, ${visibility * 0.8})`;
      ctx.beginPath();
      ctx.moveTo(h * 0.18, -h * 1.35);
      ctx.quadraticCurveTo(h * 0.45, -h * 1.25, h * 0.5, -h * 1.1);
      ctx.quadraticCurveTo(h * 0.35, -h * 1.15, h * 0.18, -h * 1.1);
      ctx.quadraticCurveTo(0, -h * 1.15, -h * 0.15, -h * 1.1);
      ctx.quadraticCurveTo(-h * 0.1, -h * 1.25, h * 0.18, -h * 1.35);
      ctx.fill();
      
      // Umbrella ribs
      ctx.strokeStyle = `rgba(50, 50, 55, ${visibility * 0.5})`;
      ctx.lineWidth = h * 0.015;
      for (let r = -2; r <= 2; r++) {
        ctx.beginPath();
        ctx.moveTo(h * 0.18, -h * 1.35);
        ctx.quadraticCurveTo(h * (0.18 + r * 0.12), -h * 1.22, h * (0.18 + r * 0.16), -h * 1.1);
        ctx.stroke();
      }
    } else if (fig.ownsUmbrella && !fig.umbrellaOpen) {
      // Closed umbrella carried
      ctx.strokeStyle = legColor;
      ctx.lineWidth = h * 0.04;
      ctx.beginPath();
      ctx.moveTo(h * 0.15, -h * 0.55);
      ctx.lineTo(h * 0.25, -h * 0.9);
      ctx.stroke();
      // Umbrella handle
      ctx.beginPath();
      ctx.arc(h * 0.15, -h * 0.52, h * 0.03, 0, PI);
      ctx.stroke();
    }
    
    ctx.restore();
  });
}

function drawLowryFiguresShadows(ambient) {
  if (ambient > 0.7) return;
  if (!lowryFigures || lowryFigures.length === 0) return;
  
  const shadowAlpha = (1 - ambient) * 0.15;
  
  lowryFigures.forEach(fig => {
    if (fig.t < -0.05 || fig.t > 1.05) return;
    
    const x = getPathX(fig.t);
    const baseY = getPathY(fig.t);
    const h = fig.isChild ? fig.height * 0.6 : fig.height;
    
    // Simple shadow blob - larger if umbrella open
    const shadowWidth = fig.umbrellaOpen ? h * 0.7 : h * 0.4;
    ctx.fillStyle = `rgba(20, 18, 15, ${shadowAlpha})`;
    ctx.beginPath();
    ctx.ellipse(x + h * 0.3, baseY + 2, shadowWidth, h * 0.1, 0.2, 0, PI2);
    ctx.fill();
  });
}

// ============================================================================
// LOADING SYSTEM
// ============================================================================
async function loadAllAssets() {
  // Split initialization into chunks to allow UI updates
  await new Promise(r => setTimeout(r, 10));
  
  // Generate trees in parallel-ish manner
  generateAllTrees();
  await new Promise(r => setTimeout(r, 5));
  
  // Lighter-weight texture
  createTexture();
  
  // Initialize other systems
  initStarlings();
  initMist();
  initPrecipitation();
  initStars();
  initClouds();
  initPath();
  initForestLamps();
  initLowryFigures();
  initAmbientWeather();
  moonPhase = calculateMoonPhase();
}

function hideLoadingScreen() {
  const loadingScreen = document.getElementById('loadingScreen');
  const calendarOverlay = document.getElementById('calendarOverlay');
  
  loadingScreen.classList.add('fade-out');
  
  setTimeout(() => {
    loadingScreen.classList.add('hidden');
    calendarOverlay.classList.add('visible');
    isLoaded = true;
  }, 800);
}

// ============================================================================
// TREE GENERATION
// ============================================================================
function generateBranchesForLayer(layerName) {
  const cfg = TREE_CONFIG[layerName];
  const branches = [];
  
  function addBranch(x1, y1, x2, y2, depth, maxDepth) {
    if (depth > maxDepth) return;
    const midX = (x1 + x2) / 2 + (random() - 0.5) * H * 0.015;
    const midY = (y1 + y2) / 2 + (random() - 0.5) * H * 0.015;
    branches.push({ x1, y1, cx: midX, cy: midY, x2, y2, depth });
    
    if (cfg.perch && depth >= 2 && depth <= 5 && abs(Math.atan2(y2 - y1, x2 - x1) + PI/2) > 0.3) {
      for (let t = 0.3; t <= 0.7; t += 0.2) {
        const mt = 1 - t;
        perchSpots.push({ x: mt*mt*x1 + 2*mt*t*midX + t*t*x2, y: mt*mt*y1 + 2*mt*t*midY + t*t*y2, occupied: false });
      }
    }
    
    if (depth < maxDepth) {
      const num = CONFIG.branchCount[0] + floor(random() * (CONFIG.branchCount[1] - CONFIG.branchCount[0] + 1));
      const len = sqrt((x2-x1)**2 + (y2-y1)**2) * (0.5 + random() * 0.3);
      const base = Math.atan2(y2 - y1, x2 - x1);
      for (let i = 0; i < num; i++) {
        const a = base + (random() - 0.5) * 1.2;
        addBranch(x2, y2, x2 + cos(a) * len, y2 + sin(a) * len, depth + 1, maxDepth);
      }
    }
  }
  
  for (let t = 0; t < cfg.num; t++) {
    const baseX = (W / (cfg.num + 1)) * (t + 1) + (random() - 0.5) * W * 0.05 + cfg.xOff * W;
    const baseY = forestY + cfg.yOff * H + random() * H * 0.015;
    const height = H * cfg.height * (0.7 + random() * 0.35);
    const lean = (random() - 0.5) * height * 0.1;
    
    [[-0.1, 0.35], [0, 0.4], [0.1, 0.35]].forEach(([a, l]) => {
      addBranch(baseX, baseY, baseX + lean + cos(-PI/2 + a) * height * l, baseY + sin(-PI/2 + a) * height * l, 0, CONFIG.networkDepth + cfg.depth);
    });
    
    for (let i = 0; i < 4; i++) {
      const by = baseY - height * (0.15 + i * 0.18);
      const bx = baseX + lean * (i * 0.25);
      const side = (i % 2 === 0) ? -1 : 1;
      const bl = height * (0.1 + random() * 0.08);
      const ang = -PI/2 + side * (0.4 + random() * 0.5);
      addBranch(bx, by, bx + cos(ang) * bl, by + sin(ang) * bl, 1, CONFIG.networkDepth + cfg.depth - 1);
    }
  }
  return branches;
}

function renderBranchesToCanvas(branches, colors) {
  const layer = document.createElement('canvas');
  layer.width = W; layer.height = H;
  const lctx = layer.getContext('2d');
  lctx.lineCap = 'round';
  
  // Group branches by depth for batching
  const byDepth = {};
  const tipBranches = []; // Collect branch tips for foliage
  
  branches.forEach(b => {
    if (!byDepth[b.depth]) byDepth[b.depth] = [];
    byDepth[b.depth].push(b);
    // Collect outer branches for foliage placement
    if (b.depth >= CONFIG.networkDepth - 1) {
      tipBranches.push(b);
    }
  });
  
  // Render each depth level with batched paths
  Object.keys(byDepth).forEach(depth => {
    const depthBranches = byDepth[depth];
    const fade = Math.pow(0.75, depth);
    const width = max(0.5, 2.2 * fade);
    
    // Shadow pass
    lctx.strokeStyle = rgba(colors.base, 0.12 * fade);
    lctx.lineWidth = width * 4;
    lctx.beginPath();
    depthBranches.forEach(b => {
      lctx.moveTo(b.x1, b.y1);
      lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    });
    lctx.stroke();
    
    // Main pass
    lctx.strokeStyle = rgba(colors.base, 0.5 * fade);
    lctx.lineWidth = width;
    lctx.beginPath();
    depthBranches.forEach(b => {
      lctx.moveTo(b.x1, b.y1);
      lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    });
    lctx.stroke();
    
    // Highlight pass
    lctx.strokeStyle = rgba(colors.bright, 0.3 * fade);
    lctx.lineWidth = width * 0.4;
    lctx.beginPath();
    depthBranches.forEach(b => {
      lctx.moveTo(b.x1, b.y1);
      lctx.quadraticCurveTo(b.cx, b.cy, b.x2, b.y2);
    });
    lctx.stroke();
  });
  
  // Add seasonal foliage at branch tips
  renderSeasonalFoliage(lctx, tipBranches, colors);
  
  return layer;
}

function renderSeasonalFoliage(lctx, tipBranches, treeColors) {
  const season = currentSeason;
  
  // Skip foliage for winter (bare branches)
  if (season === 'winter') {
    // Just add frost highlights on tips
    tipBranches.forEach(b => {
      if (random() > 0.7) {
        const size = 1 + random() * 2;
        lctx.fillStyle = `rgba(220, 230, 245, ${0.3 + random() * 0.3})`;
        lctx.beginPath();
        lctx.arc(b.x2, b.y2, size, 0, PI2);
        lctx.fill();
      }
    });
    return;
  }
  
  // Foliage colors and styles per season
  const foliageStyles = {
    spring: {
      leafColors: [
        { r: 120, g: 180, b: 100 }, // Fresh green
        { r: 140, g: 195, b: 110 }, // Light green
        { r: 100, g: 165, b: 90 },  // Medium green
      ],
      blossomColors: [
        { r: 255, g: 200, b: 210 }, // Pink
        { r: 255, g: 220, b: 225 }, // Light pink
        { r: 255, g: 255, b: 245 }, // White
      ],
      blossomChance: 0.35,
      leafSize: [3, 8],
      density: 0.6
    },
    summer: {
      leafColors: [
        { r: 80, g: 140, b: 70 },   // Deep green
        { r: 95, g: 155, b: 80 },   // Forest green
        { r: 70, g: 130, b: 65 },   // Dark green
        { r: 110, g: 165, b: 90 },  // Lighter green
      ],
      blossomColors: [],
      blossomChance: 0,
      leafSize: [5, 12],
      density: 0.85
    },
    autumn: {
      leafColors: [
        { r: 220, g: 140, b: 50 },  // Orange
        { r: 200, g: 90, b: 40 },   // Rust
        { r: 180, g: 60, b: 30 },   // Deep red
        { r: 240, g: 180, b: 60 },  // Gold
        { r: 160, g: 120, b: 70 },  // Brown
        { r: 230, g: 100, b: 50 },  // Bright orange
      ],
      blossomColors: [],
      blossomChance: 0,
      leafSize: [4, 10],
      density: 0.55 // Some leaves have fallen
    }
  };
  
  const style = foliageStyles[season];
  if (!style) return;
  
  // Draw leaf clusters at branch tips
  tipBranches.forEach(b => {
    if (random() > style.density) return; // Skip some branches
    
    const clusterSize = 3 + floor(random() * 5);
    const baseX = b.x2;
    const baseY = b.y2;
    
    for (let i = 0; i < clusterSize; i++) {
      const angle = random() * PI2;
      const dist = random() * 8;
      const x = baseX + cos(angle) * dist;
      const y = baseY + sin(angle) * dist - random() * 4;
      
      // Check if this should be a blossom (spring only)
      const isBlossom = random() < style.blossomChance && style.blossomColors.length > 0;
      
      if (isBlossom) {
        // Draw cherry blossom / flower
        const blossomColor = style.blossomColors[floor(random() * style.blossomColors.length)];
        const size = 2 + random() * 3;
        
        lctx.fillStyle = `rgba(${blossomColor.r}, ${blossomColor.g}, ${blossomColor.b}, ${0.6 + random() * 0.3})`;
        
        // 5-petal flower
        for (let p = 0; p < 5; p++) {
          const petalAngle = (p / 5) * PI2 + random() * 0.2;
          const px = x + cos(petalAngle) * size * 0.8;
          const py = y + sin(petalAngle) * size * 0.8;
          lctx.beginPath();
          lctx.ellipse(px, py, size * 0.5, size * 0.3, petalAngle, 0, PI2);
          lctx.fill();
        }
        
        // Yellow center
        lctx.fillStyle = `rgba(255, 220, 100, 0.8)`;
        lctx.beginPath();
        lctx.arc(x, y, size * 0.25, 0, PI2);
        lctx.fill();
      } else {
        // Draw leaf
        const leafColor = style.leafColors[floor(random() * style.leafColors.length)];
        const size = style.leafSize[0] + random() * (style.leafSize[1] - style.leafSize[0]);
        const leafAngle = random() * PI;
        
        // Vary opacity for depth
        const alpha = 0.5 + random() * 0.4;
        
        // Leaf shape - ellipse with slight variation
        lctx.save();
        lctx.translate(x, y);
        lctx.rotate(leafAngle);
        
        // Main leaf
        lctx.fillStyle = `rgba(${leafColor.r}, ${leafColor.g}, ${leafColor.b}, ${alpha})`;
        lctx.beginPath();
        lctx.ellipse(0, 0, size * 0.6, size * 0.35, 0, 0, PI2);
        lctx.fill();
        
        // Leaf highlight
        lctx.fillStyle = `rgba(${min(255, leafColor.r + 40)}, ${min(255, leafColor.g + 40)}, ${min(255, leafColor.b + 30)}, ${alpha * 0.5})`;
        lctx.beginPath();
        lctx.ellipse(-size * 0.15, -size * 0.08, size * 0.3, size * 0.15, 0, 0, PI2);
        lctx.fill();
        
        lctx.restore();
      }
    }
  });
  
  // Add some scattered leaves in the canopy area for fuller look
  if (season !== 'winter') {
    const extraLeaves = floor(tipBranches.length * style.density * 0.5);
    for (let i = 0; i < extraLeaves; i++) {
      const baseBranch = tipBranches[floor(random() * tipBranches.length)];
      const x = baseBranch.x2 + (random() - 0.5) * 25;
      const y = baseBranch.y2 + (random() - 0.5) * 20 - random() * 10;
      
      const leafColor = style.leafColors[floor(random() * style.leafColors.length)];
      const size = style.leafSize[0] + random() * (style.leafSize[1] - style.leafSize[0]) * 0.8;
      const alpha = 0.3 + random() * 0.3;
      
      lctx.fillStyle = `rgba(${leafColor.r}, ${leafColor.g}, ${leafColor.b}, ${alpha})`;
      lctx.beginPath();
      lctx.ellipse(x, y, size * 0.5, size * 0.3, random() * PI, 0, PI2);
      lctx.fill();
    }
  }
}

function generateAllTrees() {
  perchSpots = [];
  ['frost', 'gold', 'blue', 'silver'].forEach(name => {
    const branches = generateBranchesForLayer(name);
    treeLayers[name] = renderBranchesToCanvas(branches, TREE_COLORS[name]);
  });
}

function createTexture() {
  textureLayer = document.createElement('canvas');
  textureLayer.width = W; textureLayer.height = H;
  const lctx = textureLayer.getContext('2d');
  lctx.globalAlpha = 0.035;
  // Reduced from 5000 to 2000, slightly larger particles
  for (let i = 0; i < 2000; i++) {
    const gray = 100 + random() * 80;
    lctx.fillStyle = `rgb(${gray|0},${gray * 0.96|0},${gray * 0.92|0})`;
    lctx.fillRect(random() * W, random() * H, 3 + random() * 5, 3 + random() * 5);
  }
}

// ============================================================================
// TIME & COLORS
// ============================================================================
function updateDayTime() {
  const now = new Date();
  dayTime = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
  // Update moon phase once per day cycle
  moonPhase = calculateMoonPhase(now);
}

function getTimeColors() {
  if (time - lastColorUpdate < 0.1 && currentColors) return currentColors;
  lastColorUpdate = time;
  
  const t = dayTime;
  
  // Get seasonal sunrise/sunset times
  const sunTimes = {
    spring: { rise: 6.5, set: 19.5 },
    summer: { rise: 5.5, set: 21.0 },
    autumn: { rise: 7.0, set: 18.0 },
    winter: { rise: 7.5, set: 16.5 }
  };
  const st = sunTimes[currentSeason];
  
  // Update CRR day/night cycle
  const crrState = dayNightCRR.update(t, 0.016, st);
  
  // Enhanced color palette with smoother transitions
  const times = [0, 5, 6.5, 8, 12, 16, 18, 19.5, 21, 24];
  const palettes = [
    // Midnight (0)
    { skyTop: {r:12,g:15,b:25}, skyMid: {r:20,g:25,b:40}, skyHorizon: {r:35,g:40,b:55}, ground: {r:180,g:178,b:175}, ambient: 0.08 },
    // Pre-dawn (5)
    { skyTop: {r:15,g:20,b:35}, skyMid: {r:30,g:35,b:55}, skyHorizon: {r:55,g:50,b:65}, ground: {r:185,g:182,b:178}, ambient: 0.12 },
    // Dawn (6.5)
    { skyTop: {r:45,g:55,b:85}, skyMid: {r:120,g:100,b:110}, skyHorizon: {r:200,g:150,b:130}, ground: {r:195,g:190,b:185}, ambient: 0.35 },
    // Morning (8)
    { skyTop: {r:140,g:170,b:210}, skyMid: {r:180,g:195,b:215}, skyHorizon: {r:220,g:215,b:210}, ground: {r:215,g:212,b:208}, ambient: 0.75 },
    // Noon (12)
    { skyTop: {r:160,g:185,b:220}, skyMid: {r:195,g:210,b:228}, skyHorizon: {r:225,g:225,b:222}, ground: {r:225,g:222,b:218}, ambient: 1.0 },
    // Afternoon (16)
    { skyTop: {r:150,g:175,b:210}, skyMid: {r:190,g:200,b:215}, skyHorizon: {r:218,g:212,b:205}, ground: {r:218,g:215,b:210}, ambient: 0.85 },
    // Golden hour (18)
    { skyTop: {r:100,g:130,b:175}, skyMid: {r:175,g:160,b:155}, skyHorizon: {r:235,g:180,b:140}, ground: {r:210,g:205,b:195}, ambient: 0.55 },
    // Dusk (19.5)
    { skyTop: {r:50,g:60,b:95}, skyMid: {r:100,g:85,b:100}, skyHorizon: {r:170,g:120,b:110}, ground: {r:195,g:190,b:185}, ambient: 0.3 },
    // Evening (21)
    { skyTop: {r:18,g:22,b:38}, skyMid: {r:30,g:35,b:55}, skyHorizon: {r:55,g:50,b:60}, ground: {r:185,g:182,b:178}, ambient: 0.12 },
    // Midnight (24)
    { skyTop: {r:12,g:15,b:25}, skyMid: {r:20,g:25,b:40}, skyHorizon: {r:35,g:40,b:55}, ground: {r:180,g:178,b:175}, ambient: 0.08 }
  ];
  
  let i = 0;
  while (i < times.length - 1 && t >= times[i + 1]) i++;
  const divisor = times[i + 1] - times[i];
  const blend = divisor > 0 ? Math.max(0, Math.min(1, (t - times[i]) / divisor)) : 0;
  
  // CRR-MODULATED SMOOTHSTEP
  // Instead of simple smoothstep, use CRR memory weighting
  // During transitions (dawn/dusk), the crrModulation shapes the curve
  let smoothBlend;
  if (crrState && crrState.transitionType && !isNaN(crrState.crrModulation) && !isNaN(crrState.transitionProgress)) {
    // During dawn/dusk transitions, CRR modulates the blend
    // exp(C/Œ©) creates the characteristic CRR transition shape
    const baseSmooth = blend * blend * (3 - 2 * blend);
    smoothBlend = lerp(baseSmooth, crrState.crrModulation, crrState.transitionProgress);
  } else {
    // Outside transitions, use standard smoothstep
    smoothBlend = blend * blend * (3 - 2 * blend);
  }
  
  // Ensure smoothBlend is valid
  if (isNaN(smoothBlend)) smoothBlend = blend * blend * (3 - 2 * blend);
  
  const p1 = palettes[i], p2 = palettes[min(i + 1, palettes.length - 1)];
  
  // Ensure smoothBlend is clamped to valid range
  smoothBlend = Math.max(0, Math.min(1, smoothBlend));
  
  const ambientValue = lerp(p1.ambient, p2.ambient, smoothBlend);
  
  currentColors = {
    skyTop: lerpColor(p1.skyTop, p2.skyTop, smoothBlend),
    skyMid: lerpColor(p1.skyMid, p2.skyMid, smoothBlend),
    skyHorizon: lerpColor(p1.skyHorizon, p2.skyHorizon, smoothBlend),
    ground: lerpColor(p1.ground, p2.ground, smoothBlend),
    ambient: isNaN(ambientValue) ? 0.5 : ambientValue,
    // Expose CRR state for debugging/visualization
    crrState: crrState || {}
  };
  
  return currentColors;
}

function getSunPosition() {
  // Sun arc calculation with seasonal adjustments
  const t = dayTime;
  
  // Seasonal sunrise/sunset times
  const sunTimes = {
    spring: { rise: 6.5, set: 19.5 },
    summer: { rise: 5.5, set: 21.0 },
    autumn: { rise: 7.0, set: 18.0 },
    winter: { rise: 7.5, set: 16.5 }
  };
  const st = sunTimes[currentSeason];
  const sunArcHeight = seasonalPalette.sunArcHeight;
  
  if (t < st.rise || t > st.set) {
    return { x: W * 0.5, y: H, intensity: 0 };
  }
  
  const dayProgress = (t - st.rise) / (st.set - st.rise);
  const sunAngle = dayProgress * PI;
  
  return {
    x: W * (0.1 + 0.8 * dayProgress),
    y: horizonY - sin(sunAngle) * H * sunArcHeight,
    intensity: sin(sunAngle)
  };
}

// ============================================================================
// WEATHER SYSTEM
// ============================================================================
function updateWeatherIndicator(w) {
  const indicator = document.getElementById('weatherIndicator');
  const locationEl = document.getElementById('weatherLocation');
  const conditionsEl = document.getElementById('weatherConditions');
  const tempEl = document.getElementById('weatherTemp');
  const moonEl = document.getElementById('moonInfo');
  const seasonBadge = document.getElementById('seasonBadge');
  
  locationEl.textContent = weatherState.locationName || 'Your Location';
  
  // Weather code to description
  const codes = {
    0: 'Clear', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',
    45: 'Foggy', 48: 'Freezing fog', 51: 'Light drizzle', 53: 'Drizzle',
    55: 'Dense drizzle', 56: 'Freezing drizzle', 61: 'Slight rain', 63: 'Rain',
    65: 'Heavy rain', 66: 'Freezing rain', 71: 'Light snow', 73: 'Snow',
    75: 'Heavy snow', 77: 'Snow grains', 80: 'Rain showers', 81: 'Heavy showers',
    85: 'Snow showers', 86: 'Heavy snow showers', 95: 'Thunderstorm'
  };
  conditionsEl.textContent = codes[w.weatherCode] || 'Unknown';
  tempEl.textContent = `${w.temperature.toFixed(1)}¬∞C`;
  
  const seasonData = SEASONS[currentSeason];
  seasonBadge.textContent = `${seasonData.icon} ${seasonData.name}`;
  
  const illumination = getMoonIllumination(moonPhase);
  const phaseName = moonPhase < 0.03 ? 'New Moon' :
                    moonPhase < 0.22 ? 'Waxing Crescent' :
                    moonPhase < 0.28 ? 'First Quarter' :
                    moonPhase < 0.47 ? 'Waxing Gibbous' :
                    moonPhase < 0.53 ? 'Full Moon' :
                    moonPhase < 0.72 ? 'Waning Gibbous' :
                    moonPhase < 0.78 ? 'Last Quarter' :
                    moonPhase < 0.97 ? 'Waning Crescent' : 'New Moon';
  moonEl.textContent = `üåô ${phaseName} (${(illumination * 100).toFixed(0)}% illuminated)`;
  
  indicator.classList.add('visible');
}

async function fetchRealWeather() {
  try {
    const position = await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        timeout: 10000,
        maximumAge: 300000
      });
    });
    
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    weatherState.latitude = lat;
    weatherState.longitude = lon;
    
    // Update season based on actual location (hemisphere detection)
    currentSeason = detectSeason(new Date(), lat);
    seasonalPalette = SEASONAL_PALETTES[currentSeason];
    
    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,precipitation,rain,snowfall,cloud_cover,wind_speed_10m,visibility,weather_code&timezone=auto`;
    
    const response = await fetch(weatherUrl);
    if (!response.ok) throw new Error('Weather fetch failed');
    
    const data = await response.json();
    const current = data.current;
    
    let locationName = '';
    try {
      const geoUrl = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`;
      const geoResponse = await fetch(geoUrl, {
        headers: { 'User-Agent': 'CRR-Living-Forest/1.0' }
      });
      if (geoResponse.ok) {
        const geoData = await geoResponse.json();
        locationName = geoData.address?.city || geoData.address?.town || geoData.address?.village || geoData.address?.county || '';
      }
    } catch (e) { /* ignore */ }
    
    weatherState.realWeatherData = {
      temperature: current.temperature_2m,
      humidity: current.relative_humidity_2m,
      precipitation: current.precipitation,
      rain: current.rain,
      snowfall: current.snowfall,
      cloudCover: current.cloud_cover,
      windSpeed: current.wind_speed_10m,
      visibility: current.visibility,
      weatherCode: current.weather_code
    };
    weatherState.locationName = locationName;
    weatherState.realWeatherEnabled = true;
    
    applyRealWeather();
    
    console.log('Real weather loaded:', weatherState.realWeatherData, 'Location:', locationName, 'Season:', currentSeason);
    
  } catch (error) {
    console.log('Could not fetch real weather, using simulated:', error.message);
    weatherState.realWeatherEnabled = false;
    
    // Still show moon phase and season info even without weather
    const indicator = document.getElementById('weatherIndicator');
    const locationEl = document.getElementById('weatherLocation');
    const moonEl = document.getElementById('moonInfo');
    const seasonBadge = document.getElementById('seasonBadge');
    
    locationEl.textContent = 'Weather unavailable';
    
    const seasonData = SEASONS[currentSeason];
    seasonBadge.textContent = `${seasonData.icon} ${seasonData.name}`;
    
    const illumination = getMoonIllumination(moonPhase);
    const phaseName = moonPhase < 0.03 ? 'New Moon' :
                      moonPhase < 0.22 ? 'Waxing Crescent' :
                      moonPhase < 0.28 ? 'First Quarter' :
                      moonPhase < 0.47 ? 'Waxing Gibbous' :
                      moonPhase < 0.53 ? 'Full Moon' :
                      moonPhase < 0.72 ? 'Waning Gibbous' :
                      moonPhase < 0.78 ? 'Last Quarter' :
                      moonPhase < 0.97 ? 'Waning Crescent' : 'New Moon';
    moonEl.textContent = `üåô ${phaseName} (${(illumination * 100).toFixed(0)}% illuminated)`;
    
    indicator.classList.add('visible');
  }
}

function applyRealWeather() {
  if (!weatherState.realWeatherData) return;
  
  const w = weatherState.realWeatherData;
  updateWeatherIndicator(w);
  
  // Determine if it's actually raining
  weatherState.isRaining = w.rain > 0 || w.precipitation > 0 || 
    (w.weatherCode >= 51 && w.weatherCode <= 67) || 
    (w.weatherCode >= 80 && w.weatherCode <= 82);
  
  // Seasonal weather interpretation
  let precipFactor = 0.3;
  
  if (currentSeason === 'winter') {
    if (w.snowfall > 0) {
      precipFactor = 0.8 + min(w.snowfall / 5, 0.8);
    } else if (w.precipitation > 0 && w.temperature < 2) {
      precipFactor = 0.7 + min(w.precipitation / 10, 0.5);
    } else if (w.temperature < 0) {
      precipFactor = 0.9;
    }
  } else if (currentSeason === 'spring' || currentSeason === 'autumn') {
    if (w.precipitation > 0) {
      precipFactor = 0.4 + min(w.precipitation / 10, 0.6);
    } else {
      precipFactor = 0.5; // Gentle background precipitation (petals/leaves)
    }
  } else { // summer
    precipFactor = 0.2;
  }
  
  weatherState.targetPrecipitation = precipFactor;
  weatherState.targetWind = 0.3 + min(w.windSpeed / 30, 1.2);
  
  // Cloud cover from real data
  weatherState.targetCloudCover = w.cloudCover / 100;
  
  let mistFactor = 0.3;
  if (w.visibility < 10000) {
    mistFactor = 0.4 + (1 - w.visibility / 10000) * 0.6;
  }
  if (w.humidity > 80) {
    mistFactor += (w.humidity - 80) / 100;
  }
  weatherState.targetMist = min(mistFactor, 1.2);
}

function updateWeather(dt) {
  weatherCRR.update(dt, 0.5 + sin(time * 0.03) * 0.3);
  
  if (weatherState.realWeatherEnabled && floor(time / 600) !== floor((time - dt) / 600)) {
    fetchRealWeather();
  }
  
  const variationRate = weatherState.realWeatherEnabled ? 0.0002 : 0.001;
  if (random() < variationRate) {
    weatherState.targetPrecipitation = max(0.2, weatherState.targetPrecipitation + (random() - 0.5) * 0.3);
  }
  if (random() < variationRate * 0.8) {
    weatherState.targetMist = max(0.2, weatherState.targetMist + (random() - 0.5) * 0.3);
  }
  if (random() < variationRate * 1.2) {
    weatherState.targetWind = max(0.2, weatherState.targetWind + (random() - 0.5) * 0.3);
  }
  if (random() < variationRate * 0.5) {
    weatherState.targetCloudCover = max(0, min(1, weatherState.targetCloudCover + (random() - 0.5) * 0.2));
  }
  
  weatherState.precipitationIntensity = lerp(weatherState.precipitationIntensity, weatherState.targetPrecipitation, 0.002);
  weatherState.mistIntensity = lerp(weatherState.mistIntensity, weatherState.targetMist, 0.001);
  weatherState.windStrength = lerp(weatherState.windStrength, weatherState.targetWind, 0.003);
  weatherState.cloudCover = lerp(weatherState.cloudCover, weatherState.targetCloudCover, 0.002);
  
  const weatherPulse = weatherCRR.amplitude;
  weatherState.precipitationIntensity += (weatherPulse - 0.5) * 0.02;
  weatherState.precipitationIntensity = max(0.2, min(1.5, weatherState.precipitationIntensity));
  
  // Update isRaining based on current precipitation intensity
  if (!weatherState.realWeatherEnabled) {
    weatherState.isRaining = weatherState.precipitationIntensity > 0.6 && 
      (currentSeason !== 'summer');
  }
}

// ============================================================================
// PREDATOR
// ============================================================================
function spawnPredator() {
  const side = random() > 0.5;
  predator = { x: side ? -50 : W + 50, y: horizonY - H * 0.1 + random() * H * 0.15,
    vx: side ? 180 + random() * 60 : -180 - random() * 60, vy: (random() - 0.5) * 40,
    wingPhase: 0, size: 3 + random() * 1.5 };
}

function updatePredator(dt) {
  predatorCooldown -= dt;
  if (!predator && predatorCooldown <= 0 && random() < 0.002) {
    spawnPredator();
    predatorCooldown = 30 + random() * 60;
  }
  if (!predator) return;
  
  predator.wingPhase += dt * 8;
  let targetX = predator.x + predator.vx, targetY = predator.y, closestDist = Infinity;
  for (let i = 0; i < starlings.length; i += 10) {
    const b = starlings[i];
    if (b.state !== 'flying') continue;
    const d = sqrt((b.x - predator.x) ** 2 + (b.y - predator.y) ** 2);
    if (d < closestDist && d > 50) { closestDist = d; targetX = b.x; targetY = b.y; }
  }
  
  const dx = targetX - predator.x, dy = targetY - predator.y, dist = sqrt(dx * dx + dy * dy);
  if (dist > 0) { predator.vx += (dx / dist) * 50 * dt; predator.vy += (dy / dist) * 30 * dt; }
  
  const speed = sqrt(predator.vx ** 2 + predator.vy ** 2);
  if (speed > 250) { predator.vx = (predator.vx / speed) * 250; predator.vy = (predator.vy / speed) * 250; }
  
  predator.x += predator.vx * dt; predator.y += predator.vy * dt;
  if (predator.y < H * 0.05) predator.vy += 100 * dt;
  if (predator.y > horizonY) predator.vy -= 100 * dt;
  if (predator.x < -100 || predator.x > W + 100) predator = null;
}

function drawPredator(ambient) {
  if (!predator) return;
  const p = predator, angle = Math.atan2(p.vy, p.vx), wf = sin(p.wingPhase) * 0.6;
  
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(angle);
  ctx.fillStyle = `rgba(25, 20, 15, ${0.7 + ambient * 0.2})`;
  
  ctx.beginPath(); ctx.ellipse(0, 0, p.size * 2.5, p.size * 0.8, 0, 0, PI2); ctx.fill();
  
  const ws = p.size * 6;
  ctx.beginPath();
  ctx.moveTo(-p.size, 0);
  ctx.quadraticCurveTo(-p.size * 0.5, -ws * 0.4 * (1 + wf), p.size * 0.5, -ws * (0.7 + wf * 0.2));
  ctx.lineTo(p.size, -ws * 0.3 * (1 + wf));
  ctx.quadraticCurveTo(p.size * 0.3, -ws * 0.1, 0, 0);
  ctx.moveTo(-p.size, 0);
  ctx.quadraticCurveTo(-p.size * 0.5, ws * 0.4 * (1 + wf), p.size * 0.5, ws * (0.7 + wf * 0.2));
  ctx.lineTo(p.size, ws * 0.3 * (1 + wf));
  ctx.quadraticCurveTo(p.size * 0.3, ws * 0.1, 0, 0);
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(-p.size * 2.5, 0);
  ctx.lineTo(-p.size * 4, -p.size * 0.6);
  ctx.lineTo(-p.size * 4, p.size * 0.6);
  ctx.closePath(); ctx.fill();
  
  ctx.beginPath(); ctx.arc(p.size * 2, 0, p.size * 0.7, 0, PI2); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(p.size * 2.6, -p.size * 0.2);
  ctx.lineTo(p.size * 3.5, 0);
  ctx.lineTo(p.size * 3.2, p.size * 0.3);
  ctx.lineTo(p.size * 2.6, p.size * 0.2);
  ctx.fill();
  
  ctx.restore();
}

function getPredatorInfluence(bx, by) {
  if (!predator) return null;
  const dx = bx - predator.x, dy = by - predator.y, dist = sqrt(dx * dx + dy * dy);
  if (dist < 200) { const s = (200 - dist) / 200; return { dx: dx / dist * s * 80, dy: dy / dist * s * 80 }; }
  return null;
}

// ============================================================================
// STARLINGS
// ============================================================================
function initStarlings() {
  starlings = [];
  const cx = W * 0.5, cy = horizonY - H * 0.18;
  for (let i = 0; i < CONFIG.starlingCount; i++) {
    const a = random() * PI2, d = random() * W * 0.1;
    starlings.push({ x: cx + cos(a) * d, y: cy + sin(a) * d * 0.4, vx: (random() - 0.5) * 50, vy: (random() - 0.5) * 30,
      size: 1.2 + random() * 0.8, state: 'flying', perchSpot: null, perchTime: 0, stateTimer: 0,
      wingPhase: random() * PI2, wingSpeed: 15 + random() * 5 });
  }
}

function updateStarlings(dt) {
  flockCRR.update(dt, 1 + sin(time * 0.1) * 0.3);
  const fc = flockCRR.amplitude, isRup = flockCRR.state === 'rupture';
  
  const bf = 0.12 + fc * 0.08;
  const ax = W * 0.5 + sin(time * bf) * W * 0.22 + sin(time * bf * 1.6 + 1) * W * 0.1;
  const ay = horizonY - H * 0.16 + sin(time * bf * 0.7) * H * 0.07;
  const ss = isRup ? 1.5 : 0.8;
  const a2x = ax + sin(time * 0.35) * W * 0.12 * ss, a2y = ay + cos(time * 0.28) * H * 0.06 * ss;
  
  const scare = random() < (isRup ? 0.01 : 0.0003);
  const sx = scare ? random() * W : 0, sy = scare ? random() * horizonY * 0.5 : 0;
  const perched = starlings.filter(b => b.state === 'perched').length;
  const launch = (perched > CONFIG.starlingCount * 0.35 && random() < 0.003) || isRup;
  
  updateSpatialHash();
  
  for (let i = 0; i < starlings.length; i++) {
    const b = starlings[i];
    b.stateTimer += dt; b.wingPhase += b.wingSpeed * dt;
    
    if (b.state === 'perched') {
      b.perchTime += dt;
      // Birds on lamp posts stay longer and are less easily startled
      const isLampPerch = b.perchSpot && b.perchSpot.lampPerch;
      const restTime = isLampPerch ? 8 : 4; // Lamp birds rest longer
      const leaveChance = isLampPerch ? 0.003 : 0.008; // Lamp birds leave less often
      const startleResist = isLampPerch && !predator; // Lamp birds resist casual scares
      
      if (random() < (b.perchTime > restTime ? leaveChance : 0.001) || launch || (scare && !startleResist) || predator) {
        b.state = 'takeoff'; b.stateTimer = 0; b.vy = -40 - random() * 25; b.vx = (random() - 0.5) * 50;
        if (b.perchSpot) b.perchSpot.occupied = false; b.perchSpot = null;
      }
      continue;
    }
    
    if (b.state === 'takeoff') {
      b.vy -= 60 * dt; b.x += b.vx * dt; b.y += b.vy * dt;
      if (b.stateTimer > 0.4) b.state = 'flying';
      continue;
    }
    
    if (b.state === 'landing') {
      const spot = b.perchSpot, dx = spot.x - b.x, dy = spot.y - b.y, dist = sqrt(dx * dx + dy * dy);
      if (dist < 2) { b.state = 'perched'; b.x = spot.x; b.y = spot.y; b.perchTime = 0; b.vx = 0; b.vy = 0; }
      else { b.vx = dx * 4; b.vy = dy * 4; b.x += b.vx * dt; b.y += b.vy * dt; }
      continue;
    }
    
    let sepX = 0, sepY = 0, alignX = 0, alignY = 0, cohX = 0, cohY = 0, nc = 0;
    const nearby = getNearbyBirds(b.x, b.y);
    
    for (let j = 0; j < nearby.length; j++) {
      const idx = nearby[j]; if (idx === i) continue;
      const o = starlings[idx]; if (o.state !== 'flying') continue;
      const dx = o.x - b.x, dy = o.y - b.y, distSq = dx * dx + dy * dy;
      if (distSq > 3600) continue;
      const dist = sqrt(distSq);
      if (dist < 20 && dist > 0) { const f = (20 - dist) / 20; sepX -= (dx / dist) * f; sepY -= (dy / dist) * f; }
      if (dist < 60) { alignX += o.vx; alignY += o.vy; cohX += o.x; cohY += o.y; nc++; }
    }
    
    if (nc > 0) {
      b.vx += sepX * 2.5; b.vy += sepY * 2.5;
      b.vx += (alignX / nc - b.vx) * (0.06 + fc * 0.04); b.vy += (alignY / nc - b.vy) * (0.06 + fc * 0.04);
      b.vx += (cohX / nc - b.x) * (0.008 + fc * 0.012); b.vy += (cohY / nc - b.y) * (0.008 + fc * 0.012);
    }
    
    const t1x = ax - b.x, t1y = ay - b.y, d1 = sqrt(t1x*t1x + t1y*t1y);
    const t2x = a2x - b.x, t2y = a2y - b.y, d2 = sqrt(t2x*t2x + t2y*t2y);
    if (d1 < d2 || random() > 0.3) { b.vx += (t1x / max(d1, 1)) * 0.5; b.vy += (t1y / max(d1, 1)) * 0.5; }
    else { b.vx += (t2x / max(d2, 1)) * 0.4; b.vy += (t2y / max(d2, 1)) * 0.4; }
    
    const pred = getPredatorInfluence(b.x, b.y);
    if (pred) { b.vx += pred.dx; b.vy += pred.dy; }
    
    if (scare) { const sdx = b.x - sx, sdy = b.y - sy, sd = sqrt(sdx*sdx + sdy*sdy);
      if (sd < W * 0.35 && sd > 0) { b.vx += (sdx / sd) * 40; b.vy += (sdy / sd) * 40; } }
    
    if (b.x < W * 0.03) b.vx += 4; if (b.x > W * 0.97) b.vx -= 4;
    if (b.y < H * 0.06) b.vy += 3; if (b.y > forestY - H * 0.03) b.vy -= 3;
    
    const spd = sqrt(b.vx * b.vx + b.vy * b.vy);
    if (spd > 100) { b.vx = (b.vx / spd) * 100; b.vy = (b.vy / spd) * 100; }
    else if (spd < 25 && spd > 0) { b.vx = (b.vx / spd) * 25; b.vy = (b.vy / spd) * 25; }
    
    b.x += b.vx * dt; b.y += b.vy * dt;
    
    // Tree perch landing (lower in scene)
    if (!predator && b.y > forestY - H * 0.12 && spd < 55 && random() < 0.004 && perchSpots.length > 0) {
      let best = null, bestD = Infinity;
      for (let p = 0; p < perchSpots.length; p++) {
        const spot = perchSpots[p]; if (spot.occupied || spot.lampPerch) continue;
        const d = sqrt((b.x - spot.x)**2 + (b.y - spot.y)**2);
        if (d < H * 0.12 && d < bestD) { bestD = d; best = spot; }
      }
      if (best) { b.state = 'landing'; b.perchSpot = best; best.occupied = true; b.stateTimer = 0; }
    }
    
    // Lamp perch landing (higher up, rarer, occurs when bird passes near a lamp)
    if (!predator && b.y > H * 0.25 && b.y < H * 0.55 && spd < 60 && random() < 0.0008 && perchSpots.length > 0) {
      let best = null, bestD = Infinity;
      for (let p = 0; p < perchSpots.length; p++) {
        const spot = perchSpots[p]; if (spot.occupied || !spot.lampPerch) continue;
        const d = sqrt((b.x - spot.x)**2 + (b.y - spot.y)**2);
        if (d < H * 0.18 && d < bestD) { bestD = d; best = spot; }
      }
      if (best) { b.state = 'landing'; b.perchSpot = best; best.occupied = true; b.stateTimer = 0; }
    }
  }
}

function drawStarling(b, ambient) {
  const flying = b.state === 'flying' || b.state === 'takeoff' || b.state === 'landing';
  let mist = 1;
  if (b.y > forestY - H * 0.08) mist = max(0.3, 1 - (b.y - (forestY - H * 0.08)) / (H * 0.1));
  
  ctx.fillStyle = `rgba(35, 40, 50, ${(0.6 + ambient * 0.25) * mist})`;
  ctx.save(); ctx.translate(b.x, b.y);
  
  if (flying) {
    ctx.rotate(Math.atan2(b.vy, b.vx));
    const spd = sqrt(b.vx * b.vx + b.vy * b.vy), stretch = min(spd / 50, 1.8);
    const flap = sin(b.wingPhase) * (0.4 + spd / 200), ws = b.size * 3;
    
    ctx.beginPath(); ctx.ellipse(0, 0, b.size * stretch, b.size * 0.45, 0, 0, PI2); ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(-b.size * 0.3, 0);
    ctx.quadraticCurveTo(-b.size * 0.5, -ws * 0.5 * (1 + flap), -b.size * 0.2, -ws * (0.8 + flap * 0.3));
    ctx.quadraticCurveTo(b.size * 0.2, -ws * 0.3 * (1 + flap), b.size * 0.3, 0);
    ctx.moveTo(-b.size * 0.3, 0);
    ctx.quadraticCurveTo(-b.size * 0.5, ws * 0.5 * (1 + flap), -b.size * 0.2, ws * (0.8 + flap * 0.3));
    ctx.quadraticCurveTo(b.size * 0.2, ws * 0.3 * (1 + flap), b.size * 0.3, 0);
    ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(-b.size * stretch, 0);
    ctx.lineTo(-b.size * stretch - b.size * 0.8, -b.size * 0.3);
    ctx.lineTo(-b.size * stretch - b.size * 0.8, b.size * 0.3);
    ctx.closePath(); ctx.fill();
  } else {
    ctx.beginPath(); ctx.ellipse(0, 0, b.size * 0.9, b.size * 1.1, 0, 0, PI2); ctx.fill();
    ctx.beginPath(); ctx.arc(0, -b.size * 0.9, b.size * 0.5, 0, PI2); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(b.size * 0.4, -b.size * 0.9);
    ctx.lineTo(b.size * 0.9, -b.size * 0.85);
    ctx.lineTo(b.size * 0.4, -b.size * 0.75);
    ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

// ============================================================================
// AMBIENT WEATHER - Subtle Beautiful Effects
// ============================================================================
function initAmbientWeather() {
  // Gentle breeze particles (almost invisible drifting motes)
  breezeParticles = [];
  for (let i = 0; i < 40; i++) {
    breezeParticles.push({
      x: random() * W,
      y: random() * H,
      size: 0.3 + random() * 0.8,
      opacity: 0.03 + random() * 0.06,
      speedX: 3 + random() * 8,
      speedY: (random() - 0.5) * 2,
      wobblePhase: random() * PI2,
      wobbleSpeed: 0.5 + random() * 1.5
    });
  }
  
  // Atmospheric motes (dust/moisture catching light)
  atmosphericMotes = [];
  for (let i = 0; i < 25; i++) {
    atmosphericMotes.push({
      x: random() * W,
      y: random() * horizonY * 0.8,
      size: 1 + random() * 2,
      baseOpacity: 0.02 + random() * 0.04,
      driftSpeed: 0.5 + random() * 1.5,
      pulsePhase: random() * PI2,
      pulseSpeed: 0.3 + random() * 0.7
    });
  }
  
  // Subtle light shafts (only visible in certain conditions)
  lightShafts = [];
  for (let i = 0; i < 5; i++) {
    lightShafts.push({
      x: W * 0.2 + random() * W * 0.6,
      width: W * 0.03 + random() * W * 0.04,
      opacity: 0,
      targetOpacity: 0,
      angle: -0.05 + random() * 0.1
    });
  }
}

function updateAmbientWeather(dt, ambient) {
  const windStr = weatherState.windStrength;
  
  // Update breeze particles
  for (let i = 0; i < breezeParticles.length; i++) {
    const p = breezeParticles[i];
    p.wobblePhase += p.wobbleSpeed * dt;
    p.x += p.speedX * windStr * dt;
    p.y += p.speedY * dt + sin(p.wobblePhase) * 0.5 * dt;
    
    if (p.x > W + 10) {
      p.x = -10;
      p.y = random() * H;
    }
    if (p.y < 0) p.y = H;
    if (p.y > H) p.y = 0;
  }
  
  // Update atmospheric motes
  for (let i = 0; i < atmosphericMotes.length; i++) {
    const m = atmosphericMotes[i];
    m.pulsePhase += m.pulseSpeed * dt;
    m.x += m.driftSpeed * windStr * 0.3 * dt;
    m.y += sin(time * 0.5 + i) * 0.2 * dt;
    
    if (m.x > W + 20) {
      m.x = -20;
      m.y = random() * horizonY * 0.8;
    }
  }
  
  // Update light shafts (only active during certain light conditions and reduced by clouds)
  const cloudDim = 1 - weatherState.cloudCover * 0.8;
  const lightShaftCondition = ambient > 0.4 && ambient < 0.85 && cloudDim > 0.4;
  for (let i = 0; i < lightShafts.length; i++) {
    const shaft = lightShafts[i];
    shaft.targetOpacity = lightShaftCondition ? (0.015 + sin(time * 0.1 + i * 2) * 0.01) * cloudDim : 0;
    shaft.opacity = lerp(shaft.opacity, shaft.targetOpacity, 0.01);
  }
  
  // Update clouds
  updateClouds(dt);
}

function drawAmbientWeather(ambient, colors) {
  // Draw breeze particles (very subtle, ghostly movement)
  ctx.fillStyle = '#fff';
  for (let i = 0; i < breezeParticles.length; i++) {
    const p = breezeParticles[i];
    const alphaModifier = 0.5 + ambient * 0.5;
    ctx.globalAlpha = p.opacity * alphaModifier;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, PI2);
    ctx.fill();
  }
  
  // Draw atmospheric motes (catching light)
  const moteColor = ambient > 0.5 ? 
    `rgba(255, 252, 248, ` : 
    `rgba(200, 210, 230, `;
  
  for (let i = 0; i < atmosphericMotes.length; i++) {
    const m = atmosphericMotes[i];
    const pulse = 0.5 + sin(m.pulsePhase) * 0.5;
    const finalOpacity = m.baseOpacity * pulse * (0.3 + ambient * 0.7);
    
    if (finalOpacity > 0.005) {
      ctx.globalAlpha = finalOpacity;
      
      // Soft glow around mote
      const grad = ctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, m.size * 3);
      grad.addColorStop(0, moteColor + '1)');
      grad.addColorStop(0.5, moteColor + '0.3)');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(m.x, m.y, m.size * 3, 0, PI2);
      ctx.fill();
    }
  }
  
  // Draw light shafts (subtle god rays)
  for (let i = 0; i < lightShafts.length; i++) {
    const shaft = lightShafts[i];
    if (shaft.opacity < 0.002) continue;
    
    ctx.save();
    ctx.translate(shaft.x, 0);
    ctx.rotate(shaft.angle);
    
    const shaftGrad = ctx.createLinearGradient(-shaft.width / 2, 0, shaft.width / 2, 0);
    shaftGrad.addColorStop(0, 'transparent');
    shaftGrad.addColorStop(0.3, `rgba(255, 250, 240, ${shaft.opacity})`);
    shaftGrad.addColorStop(0.5, `rgba(255, 250, 240, ${shaft.opacity * 1.5})`);
    shaftGrad.addColorStop(0.7, `rgba(255, 250, 240, ${shaft.opacity})`);
    shaftGrad.addColorStop(1, 'transparent');
    
    ctx.fillStyle = shaftGrad;
    ctx.fillRect(-shaft.width / 2, 0, shaft.width, horizonY);
    
    ctx.restore();
  }
  
  ctx.globalAlpha = 1;
}

// Draw subtle atmospheric haze that shifts with time
function drawAtmosphericHaze(ambient, colors) {
  // Very subtle color wash that creates depth
  const hazeIntensity = 0.02 + weatherState.mistIntensity * 0.03;
  
  // Upper atmosphere subtle blue
  const upperHaze = ctx.createLinearGradient(0, 0, 0, horizonY * 0.6);
  upperHaze.addColorStop(0, `rgba(180, 195, 220, ${hazeIntensity * 0.5})`);
  upperHaze.addColorStop(1, 'transparent');
  ctx.fillStyle = upperHaze;
  ctx.fillRect(0, 0, W, horizonY * 0.6);
  
  // Horizon warmth (subtle)
  if (ambient > 0.3) {
    const horizonWarmth = ctx.createLinearGradient(0, horizonY * 0.7, 0, horizonY);
    horizonWarmth.addColorStop(0, 'transparent');
    horizonWarmth.addColorStop(1, `rgba(255, 245, 235, ${hazeIntensity * ambient * 0.3})`);
    ctx.fillStyle = horizonWarmth;
    ctx.fillRect(0, horizonY * 0.7, W, horizonY * 0.3);
  }
}

// ============================================================================
// MIST & SNOW
// ============================================================================
function initMist() {
  mistPatches = [];
  for (let i = 0; i < 18; i++) {
    mistPatches.push({ x: random() * W * 1.4 - W * 0.2, y: forestY + random() * H * 0.1 - H * 0.03,
      width: W * (0.2 + random() * 0.3), height: H * (0.05 + random() * 0.06),
      speed: 2 + random() * 5, baseOpacity: 0.08 + random() * 0.1,
      phase: random() * PI2, vDrift: 0.3 + random() * 0.5 });
  }
}

function drawMist(dt, colors) {
  mistCRR.update(dt);
  const intensity = (0.7 + mistCRR.amplitude * 0.5) * weatherState.mistIntensity;
  if (intensity < 0.01) return; // Skip if invisible
  
  const mc = lerpColor({ r: 230, g: 228, b: 225 }, colors.ground, 0.25);
  const mcStr = `${mc.r|0},${mc.g|0},${mc.b|0}`;
  const windStr = weatherState.windStrength;
  const t = time * 0.2;
  
  for (let i = 0, len = mistPatches.length; i < len; i++) {
    const m = mistPatches[i];
    m.x += m.speed * dt * windStr;
    if (m.x > W + m.width * 0.5) m.x = -m.width;
    
    const cy = m.y + sin(t + m.phase) * H * 0.01 * m.vDrift;
    const op = m.baseOpacity * intensity;
    if (op < 0.01) continue; // Skip nearly invisible patches
    
    const cx = m.x + m.width * 0.5;
    const rad = m.width * 0.5;
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, rad);
    grad.addColorStop(0, `rgba(${mcStr},${op})`);
    grad.addColorStop(0.5, `rgba(${mcStr},${op * 0.5})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.ellipse(m.x + m.width * 0.5, cy, m.width * 0.5, m.height * 0.5, 0, 0, PI2); ctx.fill();
  }
}

function initPrecipitation() {
  precipitationParticles = [];
  // Increased particle count for more pronounced precipitation
  const count = floor((W * H) / 4500);
  for (let i = 0; i < count; i++) {
    precipitationParticles.push({ x: random() * W, y: random() * H, size: 0.5 + random() * 2.5,
      speed: 12 + random() * 25, drift: (random() - 0.5) * 0.5,
      opacity: 0.25 + random() * 0.5, phase: random() * PI2,
      rotation: random() * PI2,
      rotationSpeed: (random() - 0.5) * 2.5
    });
  }
}

function drawPrecipitation(dt, ambient) {
  const precipType = seasonalPalette.precipitation;
  if (precipType === 'none' && weatherState.precipitationIntensity < 0.4) return;
  
  // Enhanced base alpha for more visible precipitation
  const baseAlpha = (0.4 + ambient * 0.5) * weatherState.precipitationIntensity;
  const windDrift = weatherState.windStrength * 0.7;
  const intensity = weatherState.precipitationIntensity;
  const t = time * 0.15;
  
  for (let i = 0, len = precipitationParticles.length; i < len; i++) {
    const f = precipitationParticles[i];
    
    // Different physics for different precipitation types
    if (precipType === 'snow') {
      const wobble = sin(t + f.phase) * f.drift + sin(t * 1.7 + f.phase * 0.7) * f.drift * 0.3;
      f.y += f.speed * dt * intensity * (0.8 + sin(t * 0.5 + i) * 0.2);
      f.x += (wobble + windDrift * 0.5) * dt * 40;
      f.rotation += f.rotationSpeed * dt;
    } else if (precipType === 'leaves') {
      // Slow, gentle tumbling fall for autumn leaves
      const wobble = sin(t * 0.4 + f.phase) * 1.2 + cos(t * 0.6 + f.phase * 1.3) * 0.8;
      const flutter = sin(t * 2 + f.phase * 2) * 0.3; // Quick flutter
      f.y += f.speed * dt * intensity * 0.28; // Slightly faster fall
      f.x += (wobble + windDrift * 0.9 + flutter) * dt * 28;
      f.rotation += f.rotationSpeed * dt * 0.8 + flutter * 0.5;
    } else if (precipType === 'blossoms') {
      const wobble = sin(t * 0.6 + f.phase) * 1.2 + cos(t * 0.9 + f.phase * 0.8) * 0.6;
      f.y += f.speed * dt * intensity * 0.45;
      f.x += (wobble + windDrift * 0.8) * dt * 50;
      f.rotation += f.rotationSpeed * dt * 0.3;
    } else {
      // Rain or default - more pronounced
      f.y += f.speed * dt * intensity * 3.0;
      f.x += windDrift * dt * 50;
    }
    
    if (f.y > H + 5) { f.y = -5; f.x = random() * W; }
    if (f.x < -5) f.x = W + 5;
    else if (f.x > W + 5) f.x = -5;
    
    const df = f.y < horizonY ? 0.4 : 1;
    const finalAlpha = f.opacity * df * baseAlpha;
    
    if (finalAlpha > 0.02) {
      ctx.globalAlpha = finalAlpha;
      const size = f.size * df;
      
      if (precipType === 'snow') {
        ctx.fillStyle = '#fff';
        if (size > 1.5 && ambient > 0.5) {
          ctx.globalAlpha = finalAlpha * 0.35;
          ctx.beginPath(); ctx.arc(f.x, f.y, size * 2.2, 0, PI2); ctx.fill();
          ctx.globalAlpha = finalAlpha;
        }
        if (size < 1.2) {
          ctx.fillRect(f.x - size * 0.5, f.y - size * 0.5, size, size);
        } else {
          ctx.beginPath(); ctx.arc(f.x, f.y, size, 0, PI2); ctx.fill();
        }
      } else if (precipType === 'leaves') {
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate(f.rotation);
        // Richer autumn leaf colors
        const leafColors = [
          {r:210,g:120,b:40}, {r:190,g:80,b:35}, {r:165,g:50,b:25},
          {r:230,g:165,b:50}, {r:145,g:100,b:55}, {r:220,g:90,b:40},
          {r:180,g:140,b:60}, {r:200,g:60,b:30}
        ];
        const col = leafColors[i % leafColors.length];
        const leafSize = size * 2.0 + 2.5;
        
        // Leaf shape with stem
        ctx.fillStyle = `rgba(${col.r}, ${col.g}, ${col.b}, ${finalAlpha})`;
        ctx.beginPath();
        // Main leaf body - more leaf-like shape
        ctx.moveTo(0, -leafSize * 0.6);
        ctx.bezierCurveTo(leafSize * 0.5, -leafSize * 0.4, leafSize * 0.5, leafSize * 0.2, 0, leafSize * 0.5);
        ctx.bezierCurveTo(-leafSize * 0.5, leafSize * 0.2, -leafSize * 0.5, -leafSize * 0.4, 0, -leafSize * 0.6);
        ctx.fill();
        
        // Leaf vein
        ctx.strokeStyle = `rgba(${col.r - 30}, ${col.g - 30}, ${col.b - 20}, ${finalAlpha * 0.5})`;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(0, -leafSize * 0.5);
        ctx.lineTo(0, leafSize * 0.4);
        ctx.stroke();
        
        ctx.restore();
      } else if (precipType === 'blossoms') {
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate(f.rotation);
        const pinkShade = 200 + (i % 3) * 20;
        ctx.fillStyle = `rgba(255, ${pinkShade}, ${pinkShade + 20}, ${finalAlpha})`;
        for (let p = 0; p < 5; p++) {
          ctx.beginPath();
          ctx.ellipse(0, -size, size * 0.6, size * 0.4, (p * PI2 / 5), 0, PI2);
          ctx.fill();
        }
        ctx.restore();
      }
    }
  }
  ctx.globalAlpha = 1;
}

// ============================================================================
// SLEIGH
// ============================================================================
function initSleigh() {
  sleigh = { x: -W * 0.2, y: H * 0.15, speed: W * 0.06, bobPhase: 0, scale: H * 0.001, trail: [] };
  sleighActive = true; audio.init(); audio.playJingle();
  document.getElementById('celebrationTitle').textContent = 'Merry Christmas';
  document.getElementById('celebrationSubtitle').textContent = 'Peace on Earth, Goodwill to All';
  document.getElementById('celebrationMessage').classList.add('visible');
  setTimeout(() => document.getElementById('celebrationMessage').classList.remove('visible'), 8000);
}

function updateSleigh(dt) {
  if (!sleighActive || !sleigh) return;
  sleigh.x += sleigh.speed * dt; sleigh.bobPhase += dt * 2;
  sleigh.y = H * 0.15 + sin(sleigh.bobPhase) * H * 0.02 + sin(sleigh.bobPhase * 0.7) * H * 0.01;
  if (random() < 0.4) sleigh.trail.push({ x: sleigh.x - 20 + random() * 40, y: sleigh.y + random() * 20, life: 1, size: 1 + random() * 2, vx: -20 - random() * 30, vy: (random() - 0.5) * 20 });
  for (let i = sleigh.trail.length - 1; i >= 0; i--) { const p = sleigh.trail[i]; p.life -= dt * 0.8; p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 15 * dt; if (p.life <= 0) sleigh.trail.splice(i, 1); }
  if (sleigh.x > W * 1.3) { sleighActive = false; sleigh = null; }
}

function drawSleigh() {
  if (!sleighActive || !sleigh) return;
  const s = sleigh.scale, x = sleigh.x, y = sleigh.y;
  ctx.save();
  sleigh.trail.forEach(p => { const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
    grad.addColorStop(0, `rgba(255, 223, 100, ${p.life * 0.8})`); grad.addColorStop(0.5, `rgba(255, 200, 50, ${p.life * 0.4})`); grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 3, 0, PI2); ctx.fill(); });
  
  ctx.fillStyle = 'rgba(20, 25, 35, 0.9)'; ctx.strokeStyle = 'rgba(20, 25, 35, 0.9)';
  const rs = s * 35;
  for (let i = 0; i < 8; i++) { const row = floor(i / 2), col = i % 2;
    const rx = x - 80 - row * rs, ry = y + (col === 0 ? -12 : 12) * s + sin(sleigh.bobPhase * 3 + i) * 3;
    ctx.save(); ctx.translate(rx, ry); const leg = sin((sleigh.bobPhase + i * 0.3) * 4);
    ctx.beginPath(); ctx.ellipse(0, 0, 18 * s, 10 * s, 0, 0, PI2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(15 * s, -5 * s); ctx.quadraticCurveTo(22 * s, -12 * s, 28 * s, -10 * s); ctx.quadraticCurveTo(35 * s, -8 * s, 32 * s, -5 * s); ctx.quadraticCurveTo(28 * s, -2 * s, 20 * s, 0); ctx.fill();
    ctx.lineWidth = 2 * s; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(26 * s, -12 * s); ctx.lineTo(22 * s, -22 * s); ctx.moveTo(24 * s, -17 * s); ctx.lineTo(20 * s, -20 * s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(30 * s, -12 * s); ctx.lineTo(34 * s, -22 * s); ctx.moveTo(32 * s, -17 * s); ctx.lineTo(36 * s, -20 * s); ctx.stroke();
    ctx.lineWidth = 3 * s;
    ctx.beginPath(); ctx.moveTo(10 * s, 8 * s); ctx.lineTo(12 * s + leg * 4 * s, 22 * s); ctx.moveTo(6 * s, 8 * s); ctx.lineTo(4 * s - leg * 4 * s, 22 * s); ctx.moveTo(-10 * s, 8 * s); ctx.lineTo(-8 * s - leg * 4 * s, 22 * s); ctx.moveTo(-14 * s, 8 * s); ctx.lineTo(-16 * s + leg * 4 * s, 22 * s); ctx.stroke();
    if (i === 0) { ctx.fillStyle = 'rgba(200, 50, 50, 0.9)'; ctx.beginPath(); ctx.arc(34 * s, -6 * s, 3 * s, 0, PI2); ctx.fill();
      const ng = ctx.createRadialGradient(34 * s, -6 * s, 0, 34 * s, -6 * s, 15 * s); ng.addColorStop(0, 'rgba(255, 100, 100, 0.4)'); ng.addColorStop(1, 'transparent'); ctx.fillStyle = ng; ctx.beginPath(); ctx.arc(34 * s, -6 * s, 15 * s, 0, PI2); ctx.fill(); ctx.fillStyle = 'rgba(20, 25, 35, 0.9)'; }
    ctx.restore(); }
  
  ctx.strokeStyle = 'rgba(40, 35, 30, 0.7)'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(x - 30, y);
  for (let i = 0; i < 8; i++) { const row = floor(i / 2), col = i % 2; ctx.lineTo(x - 80 - row * rs + 15 * s, y + (col === 0 ? -12 : 12) * s + sin(sleigh.bobPhase * 3 + i) * 3); } ctx.stroke();
  
  ctx.fillStyle = 'rgba(25, 20, 30, 0.95)';
  ctx.beginPath(); ctx.moveTo(x - 25, y + 15); ctx.quadraticCurveTo(x - 35, y + 25, x - 20, y + 30); ctx.lineTo(x + 50, y + 30); ctx.quadraticCurveTo(x + 65, y + 25, x + 60, y + 10); ctx.quadraticCurveTo(x + 55, y - 5, x + 40, y - 10); ctx.lineTo(x - 15, y - 10); ctx.quadraticCurveTo(x - 30, y - 5, x - 25, y + 15); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x - 30, y + 32); ctx.quadraticCurveTo(x - 40, y + 38, x - 35, y + 40); ctx.lineTo(x + 55, y + 40); ctx.quadraticCurveTo(x + 70, y + 38, x + 65, y + 32); ctx.lineWidth = 3; ctx.stroke();
  
  ctx.fillStyle = 'rgba(20, 15, 25, 0.95)';
  ctx.beginPath(); ctx.ellipse(x + 15, y + 5, 18, 15, 0, 0, PI2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + 15, y - 18, 12, 0, PI2); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x + 3, y - 22); ctx.lineTo(x + 10, y - 45); ctx.quadraticCurveTo(x + 25, y - 42, x + 28, y - 25); ctx.lineTo(x + 27, y - 22); ctx.fill();
  ctx.beginPath(); ctx.arc(x + 12, y - 46, 4, 0, PI2); ctx.fill();
  ctx.save(); ctx.translate(x + 25, y - 5); ctx.rotate(-0.5 + sin(sleigh.bobPhase * 2) * 0.3); ctx.fillRect(0, -3, 20, 6); ctx.beginPath(); ctx.arc(20, 0, 5, 0, PI2); ctx.fill(); ctx.restore();
  ctx.fillStyle = 'rgba(30, 20, 25, 0.9)'; ctx.beginPath(); ctx.ellipse(x + 42, y + 5, 12, 18, 0.2, 0, PI2); ctx.fill();
  const gi = 0.3 + sin(sleigh.bobPhase * 4) * 0.1; const glow = ctx.createRadialGradient(x + 15, y, 0, x + 15, y, 100);
  glow.addColorStop(0, `rgba(255, 230, 150, ${gi * 0.3})`); glow.addColorStop(0.5, `rgba(255, 210, 100, ${gi * 0.1})`); glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow; ctx.fillRect(x - 100, y - 80, 230, 160);
  ctx.restore();
}

function checkMidnight() {
  const now = new Date();
  const isMidnight = now.getMonth() === 11 && now.getDate() === 25 && now.getHours() === 0 && now.getMinutes() < 5;
  const test = new URLSearchParams(window.location.search).get('test') === 'sleigh';
  if ((isMidnight || test) && !sleighTriggered) { sleighTriggered = true; initSleigh(); }
}

// ============================================================================
// CALENDAR - Multicultural Events
// ============================================================================
function updateCalendar() {
  const now = new Date(), h = now.getHours(), m = now.getMinutes();
  document.getElementById('currentTime').textContent = `${h % 12 || 12}:${m.toString().padStart(2, '0')} ${h >= 12 ? 'pm' : 'am'}`;
  document.getElementById('currentDate').textContent = now.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
  
  const seasonData = SEASONS[currentSeason];
  document.getElementById('seasonInfo').textContent = `${seasonData.icon} ${seasonData.name}${currentHemisphere === 'southern' ? ' (Southern Hemisphere)' : ''}`;
  
  const cont = document.getElementById('events'); cont.innerHTML = '';
  let shown = 0;
  
  for (const e of yearEvents) { 
    if (shown >= 3) break;
    const diff = e.date - now;
    const past = diff < 0;
    if (past && abs(diff) > 86400000) continue;
    if (diff > 60 * 86400000) continue; // Skip events more than 60 days away
    
    const div = document.createElement('div');
    div.className = 'event' + (diff >= 0 && diff < 86400000 ? ' imminent' : '') + (past ? ' past' : '');
    let txt; if (past) txt = 'Now!';
    else if (diff < 86400000) txt = `${floor(diff / 3600000)}h ${floor((diff % 3600000) / 60000)}m`;
    else { const d = floor(diff / 86400000); txt = `${d}d ${floor((diff % 86400000) / 3600000)}h`; }
    div.innerHTML = `<div class="countdown">${e.icon || '‚ú®'} ${txt}</div><div class="label">${e.name}</div><div class="culture">${e.culture}</div>`;
    cont.appendChild(div); shown++;
  }
}

// ============================================================================
// LANDSCAPE
// ============================================================================
function drawSky(colors, sun) {
  const grad = ctx.createLinearGradient(0, 0, 0, horizonY);
  grad.addColorStop(0, rgba(colors.skyTop, 1)); grad.addColorStop(0.5, rgba(colors.skyMid, 1)); grad.addColorStop(1, rgba(colors.skyHorizon, 1));
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, horizonY + 20);
  
  // Draw atmospheric haze (subtle)
  drawAtmosphericHaze(colors.ambient, colors);
  
  // Draw clouds before sun/moon
  drawClouds(colors.ambient);
  
  if (sun.intensity > 0.1) {
    // Daytime sun
    const g1 = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, H * 0.45);
    g1.addColorStop(0, `rgba(255, 248, 230, ${0.35 * sun.intensity})`); g1.addColorStop(0.3, `rgba(255, 240, 210, ${0.15 * sun.intensity})`); g1.addColorStop(1, 'transparent');
    ctx.fillStyle = g1; ctx.fillRect(0, 0, W, H);
    const g2 = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, H * 0.12);
    g2.addColorStop(0, `rgba(255, 255, 248, ${0.85 * sun.intensity})`); g2.addColorStop(0.5, `rgba(255, 250, 235, ${0.4 * sun.intensity})`); g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2; ctx.fillRect(0, 0, W, H);
  } else {
    // Nighttime - draw stars and moon
    drawStars(colors.ambient);
    
    // === REALISTIC MOON (correct phase rendering) ===
    const mx = W * 0.75, my = H * 0.14;
    const moonRadius = H * 0.032;
    const illumination = getMoonIllumination(moonPhase);
    const isWaxing = moonPhase < 0.5;
    
    // Calculate terminator position (0 = new moon edge, 1 = full moon)
    // For waxing: goes 0 -> 1 as moonPhase goes 0 -> 0.5
    // For waning: goes 1 -> 0 as moonPhase goes 0.5 -> 1
    const terminatorPos = isWaxing ? moonPhase * 2 : (1 - moonPhase) * 2;
    
    // Outer atmospheric glow (scales with illumination)
    const outerGlowSize = moonRadius * (3 + illumination * 3);
    const outerGlow = ctx.createRadialGradient(mx, my, moonRadius * 0.5, mx, my, outerGlowSize);
    outerGlow.addColorStop(0, `rgba(210, 215, 235, ${0.06 + illumination * 0.14})`);
    outerGlow.addColorStop(0.4, `rgba(190, 200, 225, ${0.03 + illumination * 0.07})`);
    outerGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(mx, my, outerGlowSize, 0, PI2);
    ctx.fill();
    
    // Create clipping path for the illuminated portion only
    ctx.save();
    ctx.beginPath();
    
    if (illumination > 0.99) {
      // Full moon - show entire disc
      ctx.arc(mx, my, moonRadius, 0, PI2);
    } else if (illumination < 0.01) {
      // New moon - show nothing (or very faint earthshine)
      ctx.arc(mx, my, moonRadius * 0.1, 0, PI2);
    } else {
      // The terminator is an ellipse whose width depends on phase
      // At first/last quarter (terminatorPos = 0.5), width = 0 (straight line)
      // At new/full moon (terminatorPos = 0 or 1), width = moonRadius
      
      const isGibbous = terminatorPos > 0.5;
      // Ellipse width: 0 at quarter, moonRadius at new/full
      const ellipseWidth = isGibbous 
        ? moonRadius * (terminatorPos - 0.5) * 2  // 0 at quarter, moonRadius at full
        : moonRadius * (0.5 - terminatorPos) * 2; // moonRadius at new, 0 at quarter
      
      if (isWaxing) {
        // Waxing: illuminated on RIGHT side
        // Draw right semicircle (from top, clockwise to bottom)
        ctx.arc(mx, my, moonRadius, -PI/2, PI/2, false);
        
        if (isGibbous) {
          // Waxing gibbous: terminator bulges LEFT (outward from center)
          // Draw ellipse counterclockwise on left side (bulges left)
          ctx.ellipse(mx, my, ellipseWidth, moonRadius, 0, PI/2, -PI/2, true);
        } else {
          // Waxing crescent: terminator bulges RIGHT (inward toward lit area)
          // Draw ellipse clockwise on left side (bulges right) 
          ctx.ellipse(mx, my, ellipseWidth, moonRadius, 0, PI/2, -PI/2, false);
        }
      } else {
        // Waning: illuminated on LEFT side
        // Draw left semicircle (from top, counterclockwise to bottom)
        ctx.arc(mx, my, moonRadius, -PI/2, PI/2, true);
        
        if (isGibbous) {
          // Waning gibbous: terminator bulges RIGHT (outward from center)
          // Draw ellipse clockwise on right side (bulges right)
          ctx.ellipse(mx, my, ellipseWidth, moonRadius, 0, PI/2, -PI/2, false);
        } else {
          // Waning crescent: terminator bulges LEFT (inward toward lit area)
          // Draw ellipse counterclockwise on right side (bulges left)
          ctx.ellipse(mx, my, ellipseWidth, moonRadius, 0, PI/2, -PI/2, true);
        }
      }
    }
    ctx.clip();
    
    // Moon surface gradient (only in illuminated area)
    const moonGrad = ctx.createRadialGradient(
      mx + (isWaxing ? -moonRadius * 0.2 : moonRadius * 0.2), my - moonRadius * 0.2, 0,
      mx, my, moonRadius * 1.1
    );
    moonGrad.addColorStop(0, 'rgba(252, 250, 248, 1)');
    moonGrad.addColorStop(0.4, 'rgba(242, 240, 235, 1)');
    moonGrad.addColorStop(0.7, 'rgba(228, 225, 220, 1)');
    moonGrad.addColorStop(1, 'rgba(210, 208, 205, 1)');
    ctx.fillStyle = moonGrad;
    ctx.beginPath();
    ctx.arc(mx, my, moonRadius, 0, PI2);
    ctx.fill();
    
    // Maria (dark patches)
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = 'rgba(130, 125, 120, 1)';
    
    // Mare Imbrium
    ctx.beginPath();
    ctx.ellipse(mx - moonRadius * 0.25, my - moonRadius * 0.2, moonRadius * 0.3, moonRadius * 0.25, -0.3, 0, PI2);
    ctx.fill();
    
    // Mare Serenitatis
    ctx.beginPath();
    ctx.ellipse(mx + moonRadius * 0.15, my - moonRadius * 0.25, moonRadius * 0.18, moonRadius * 0.15, 0.2, 0, PI2);
    ctx.fill();
    
    // Mare Tranquillitatis
    ctx.beginPath();
    ctx.ellipse(mx + moonRadius * 0.28, my + moonRadius * 0.05, moonRadius * 0.2, moonRadius * 0.22, 0.4, 0, PI2);
    ctx.fill();
    
    // Oceanus Procellarum
    ctx.beginPath();
    ctx.ellipse(mx - moonRadius * 0.38, my + moonRadius * 0.08, moonRadius * 0.22, moonRadius * 0.35, -0.2, 0, PI2);
    ctx.fill();
    
    // Mare Nubium
    ctx.beginPath();
    ctx.ellipse(mx - moonRadius * 0.12, my + moonRadius * 0.38, moonRadius * 0.18, moonRadius * 0.1, 0.1, 0, PI2);
    ctx.fill();
    
    ctx.globalAlpha = 1;
    
    // Subtle crater details
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = 'rgba(170, 165, 160, 1)';
    [[0.35, -0.35, 0.05], [-0.2, 0.45, 0.04], [0.45, 0.25, 0.035], [-0.5, -0.2, 0.04]].forEach(([ox, oy, r]) => {
      ctx.beginPath();
      ctx.arc(mx + ox * moonRadius, my + oy * moonRadius, r * moonRadius, 0, PI2);
      ctx.fill();
    });
    
    // Bright crater (Aristarchus)
    ctx.fillStyle = 'rgba(255, 253, 250, 1)';
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.arc(mx - moonRadius * 0.52, my - moonRadius * 0.12, moonRadius * 0.03, 0, PI2);
    ctx.fill();
    
    ctx.globalAlpha = 1;
    
    // Limb darkening
    const limbGrad = ctx.createRadialGradient(mx, my, moonRadius * 0.5, mx, my, moonRadius);
    limbGrad.addColorStop(0, 'transparent');
    limbGrad.addColorStop(0.75, 'transparent');
    limbGrad.addColorStop(1, 'rgba(100, 95, 90, 0.25)');
    ctx.fillStyle = limbGrad;
    ctx.beginPath();
    ctx.arc(mx, my, moonRadius, 0, PI2);
    ctx.fill();
    
    // Soft terminator edge (gradient at the shadow boundary)
    if (illumination > 0.02 && illumination < 0.98) {
      const termGrad = ctx.createLinearGradient(
        isWaxing ? mx - moonRadius * 0.3 : mx + moonRadius * 0.3, my,
        isWaxing ? mx + moonRadius * 0.1 : mx - moonRadius * 0.1, my
      );
      termGrad.addColorStop(0, 'rgba(180, 175, 170, 0.2)');
      termGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = termGrad;
      ctx.beginPath();
      ctx.arc(mx, my, moonRadius, 0, PI2);
      ctx.fill();
    }
    
    ctx.restore();
    
    // Faint earthshine on unilluminated portion (only visible during crescent phases)
    if (illumination > 0.05 && illumination < 0.4) {
      ctx.save();
      ctx.globalAlpha = (0.4 - illumination) * 0.12;
      
      // Clip to the dark side (opposite of lit side)
      ctx.beginPath();
      if (isWaxing) {
        // Waxing: dark side is on LEFT
        ctx.arc(mx, my, moonRadius * 0.98, PI/2, -PI/2, false);
        if (terminatorPos < 0.5) {
          // Close via RIGHT side of ellipse (clockwise)
          ctx.ellipse(mx, my, moonRadius * (1 - terminatorPos * 2) * 0.98, moonRadius * 0.98, 0, -PI/2, PI/2, false);
        }
      } else {
        // Waning: dark side is on RIGHT
        ctx.arc(mx, my, moonRadius * 0.98, -PI/2, PI/2, false);
        if (terminatorPos < 0.5) {
          // Close via LEFT side of ellipse (counterclockwise)
          ctx.ellipse(mx, my, moonRadius * (1 - terminatorPos * 2) * 0.98, moonRadius * 0.98, 0, PI/2, -PI/2, true);
        }
      }
      ctx.clip();
      
      // Very faint blue-grey earthshine
      ctx.fillStyle = 'rgba(140, 150, 170, 1)';
      ctx.beginPath();
      ctx.arc(mx, my, moonRadius, 0, PI2);
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  // Draw CRR Rainbow (after sun/moon, before landscape)
  drawCRRRainbow(colors, sun);
}

function drawLandscape(colors) {
  ctx.fillStyle = `rgba(${colors.ground.r * 0.65 | 0}, ${colors.ground.g * 0.65 | 0}, ${colors.ground.b * 0.7 | 0}, 0.4)`;
  ctx.beginPath(); ctx.moveTo(0, horizonY);
  for (let x = 0; x <= W; x += 25) ctx.lineTo(x, horizonY - H * 0.04 + sin(x * 0.0025) * H * 0.035 + sin(x * 0.006 + 2) * H * 0.02);
  ctx.lineTo(W, horizonY + 15); ctx.lineTo(0, horizonY + 15); ctx.fill();
  
  const sg = ctx.createLinearGradient(0, horizonY, 0, H);
  sg.addColorStop(0, rgba(colors.ground, 1)); sg.addColorStop(0.4, rgba(lerpColor(colors.ground, { r: 255, g: 255, b: 255 }, 0.08), 1));
  sg.addColorStop(1, rgba(lerpColor(colors.ground, { r: 170, g: 165, b: 160 }, 0.15), 1));
  ctx.fillStyle = sg; ctx.fillRect(0, horizonY - 5, W, H - horizonY + 5);
  
  ctx.beginPath(); ctx.moveTo(0, forestY + H * 0.07);
  for (let x = 0; x <= W; x += 35) ctx.lineTo(x, forestY + H * 0.07 + sin(x * 0.004) * 7 + sin(x * 0.01 + 1) * 4);
  ctx.lineTo(W, H); ctx.lineTo(0, H);
  ctx.fillStyle = `rgba(${colors.ground.r + 15 | 0}, ${colors.ground.g + 12 | 0}, ${colors.ground.b + 10 | 0}, 0.35)`; ctx.fill();
}

// Cache for vignette
let vignetteCache = null;
let vignetteCacheAmbient = -1;

function drawVignette(ambient) {
  // Ensure ambient is a valid number
  if (typeof ambient !== 'number' || isNaN(ambient)) {
    ambient = 0.5; // Default to mid-day lighting
  }
  ambient = Math.max(0, Math.min(1, ambient)); // Clamp to 0-1
  
  // Round ambient to avoid recreating gradient too often
  const roundedAmbient = Math.round(ambient * 20) / 20;
  
  if (!vignetteCache || roundedAmbient !== vignetteCacheAmbient) {
    const str = 0.12 + (1 - roundedAmbient) * 0.18;
    vignetteCache = ctx.createRadialGradient(W * 0.5, H * 0.4, H * 0.35, W * 0.5, H * 0.5, H * 0.95);
    vignetteCache.addColorStop(0, 'transparent');
    vignetteCache.addColorStop(0.65, `rgba(25, 22, 18, ${str * 0.4})`);
    vignetteCache.addColorStop(1, `rgba(8, 6, 4, ${str})`);
    vignetteCacheAmbient = roundedAmbient;
  }
  
  ctx.fillStyle = vignetteCache;
  ctx.fillRect(0, 0, W, H);
}

// ============================================================================
// MAIN LOOP
// ============================================================================
let lastTime = performance.now(), calendarTime = 0;

function animate(now) {
  requestAnimationFrame(animate);
  
  if (!isLoaded) return;
  
  const dt = min((now - lastTime) / 1000, 0.05);
  lastTime = now; time += dt;
  
  if (floor(time) !== floor(time - dt)) updateDayTime();
  if (time - calendarTime > 1) { updateCalendar(); checkMidnight(); calendarTime = time; }
  
  updateWeather(dt);
  
  const colors = getTimeColors();
  const sun = getSunPosition();
  
  updateStarlings(dt);
  updatePredator(dt);
  updateSleigh(dt);
  updateLowryFigures(dt);
  updateAmbientWeather(dt, colors.ambient);
  
  // RENDER
  drawSky(colors, sun);
  if (sleighActive) drawSleigh();
  
  // Draw ambient weather effects (light shafts, atmospheric motes) - before landscape
  drawAmbientWeather(colors.ambient, colors);
  
  drawLandscape(colors);
  
  // Draw path through the forest
  drawPath(colors);
  
  for (let i = 0; i < starlings.length; i++) { const b = starlings[i]; if (b.state === 'flying' && b.y < forestY - H * 0.05) drawStarling(b, colors.ambient); }
  
  drawPredator(colors.ambient);
  
  const baseAlpha = 0.45 + colors.ambient * 0.35;
  ctx.globalAlpha = baseAlpha * 0.5; ctx.drawImage(treeLayers.frost, 0, 0);
  ctx.globalAlpha = baseAlpha * 0.6; ctx.drawImage(treeLayers.gold, 0, 0);
  ctx.globalAlpha = baseAlpha * 0.65; ctx.drawImage(treeLayers.blue, 0, 0);
  ctx.globalAlpha = baseAlpha * 0.85; ctx.drawImage(treeLayers.silver, 0, 0);
  ctx.globalAlpha = 1;
  
  // Draw Lowry figure shadows first
  drawLowryFiguresShadows(colors.ambient);
  
  // Draw forest lamps (after trees, before foreground birds) - now visible day and night
  drawForestLamps(colors.ambient);
  
  // Draw Lowry figures on the path
  drawLowryFigures(colors.ambient);
  
  for (let i = 0; i < starlings.length; i++) { const b = starlings[i]; if (b.state !== 'flying' || b.y >= forestY - H * 0.05) drawStarling(b, colors.ambient); }
  
  drawMist(dt, colors);
  drawPrecipitation(dt, colors.ambient);
  
  ctx.globalCompositeOperation = 'overlay';
  ctx.globalAlpha = 0.28;
  ctx.drawImage(textureLayer, 0, 0);
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
  
  drawVignette(colors.ambient);
  updateCRRDebug(colors.crrState);
}

// ============================================================================
// INIT
// ============================================================================
async function init() {
  initCanvas();
  updateSeasonalState();
  updateDayTime();
  updateCalendar();
  
  requestAnimationFrame(animate);
  
  await loadAllAssets();
  
  fetchRealWeather();
  
  hideLoadingScreen();
  initDemoPanel();
}

// ============================================================================
// DEMO CONTROL PANEL
// ============================================================================
let demoMode = {
  manualTime: false,
  manualSeason: true,
  targetTime: 12
};

function initDemoPanel() {
  const panel = document.getElementById('demoPanel');
  const toggleBtn = document.getElementById('togglePanel');
  const timeSlider = document.getElementById('timeSlider');
  const timeDisplay = document.getElementById('timeDisplay');
  const precipSlider = document.getElementById('precipSlider');
  const precipDisplay = document.getElementById('precipDisplay');
  const windSlider = document.getElementById('windSlider');
  const windDisplay = document.getElementById('windDisplay');
  const mistSlider = document.getElementById('mistSlider');
  const mistDisplay = document.getElementById('mistDisplay');
  const cloudSlider = document.getElementById('cloudSlider');
  const cloudDisplay = document.getElementById('cloudDisplay');
  const autoTimeCheck = document.getElementById('autoTimeCheck');
  const autoSeasonCheck = document.getElementById('autoSeasonCheck');
  const seasonBtns = document.querySelectorAll('.season-btn');
  
  // Toggle panel visibility
  toggleBtn.addEventListener('click', () => {
    panel.classList.toggle('collapsed');
    toggleBtn.textContent = panel.classList.contains('collapsed') ? 'üé® Show Controls' : 'Hide';
  });
  
  // Season buttons
  seasonBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const season = btn.dataset.season;
      seasonBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      switchSeason(season);
      demoMode.manualSeason = true;
      autoSeasonCheck.checked = false;
    });
  });
  
  // Keyboard shortcuts for seasons
  document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT') return; // Don't trigger when typing in inputs
    
    const seasonKeys = {
      '1': 'spring',
      '2': 'summer', 
      '3': 'autumn',
      '4': 'winter'
    };
    
    if (seasonKeys[e.key]) {
      const season = seasonKeys[e.key];
      seasonBtns.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.season === season);
      });
      switchSeason(season);
      demoMode.manualSeason = true;
      autoSeasonCheck.checked = false;
    }
    
    // Time shortcuts
    if (e.key === 'd') { // Dawn
      dayTime = 6.5;
      timeSlider.value = 6.5;
      timeDisplay.textContent = '06:30';
      currentColors = null;
      demoMode.manualTime = true;
      autoTimeCheck.checked = false;
    }
    if (e.key === 'n') { // Noon
      dayTime = 12;
      timeSlider.value = 12;
      timeDisplay.textContent = '12:00';
      currentColors = null;
      demoMode.manualTime = true;
      autoTimeCheck.checked = false;
    }
    if (e.key === 's') { // Sunset
      dayTime = 18;
      timeSlider.value = 18;
      timeDisplay.textContent = '18:00';
      currentColors = null;
      demoMode.manualTime = true;
      autoTimeCheck.checked = false;
    }
    if (e.key === 'm') { // Midnight
      dayTime = 0;
      timeSlider.value = 0;
      timeDisplay.textContent = '00:00';
      currentColors = null;
      demoMode.manualTime = true;
      autoTimeCheck.checked = false;
    }
    
    // Toggle panel with 'h' key
    if (e.key === 'h') {
      panel.classList.toggle('collapsed');
      toggleBtn.textContent = panel.classList.contains('collapsed') ? 'üé® Show Controls' : 'Hide';
    }
    
    // Toggle rainbow with 'r' key
    if (e.key === 'r') {
      rainbowEnabled = !rainbowEnabled;
      const rainbowCheck = document.getElementById('rainbowCheck');
      if (rainbowCheck) rainbowCheck.checked = rainbowEnabled;
    }
  });
  
  // Time slider
  timeSlider.addEventListener('input', (e) => {
    const t = parseFloat(e.target.value);
    demoMode.targetTime = t;
    const hours = Math.floor(t);
    const mins = Math.floor((t % 1) * 60);
    timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    
    if (!autoTimeCheck.checked) {
      dayTime = t;
      currentColors = null; // Force color recalculation
    }
  });
  
  // Moon phase slider
  const moonSlider = document.getElementById('moonSlider');
  const moonDisplay = document.getElementById('moonDisplay');
  
  function getMoonPhaseName(phase) {
    if (phase < 0.03) return 'New Moon üåë';
    if (phase < 0.22) return 'Waxing Crescent üåí';
    if (phase < 0.28) return 'First Quarter üåì';
    if (phase < 0.47) return 'Waxing Gibbous üåî';
    if (phase < 0.53) return 'Full Moon üåï';
    if (phase < 0.72) return 'Waning Gibbous üåñ';
    if (phase < 0.78) return 'Last Quarter üåó';
    if (phase < 0.97) return 'Waning Crescent üåò';
    return 'New Moon üåë';
  }
  
  moonSlider.addEventListener('input', (e) => {
    const v = parseInt(e.target.value);
    moonPhase = v / 100;
    moonDisplay.textContent = getMoonPhaseName(moonPhase);
  });
  
  // Set initial moon display
  moonSlider.value = moonPhase * 100;
  moonDisplay.textContent = getMoonPhaseName(moonPhase);
  
  // Weather sliders
  precipSlider.addEventListener('input', (e) => {
    const v = parseInt(e.target.value);
    precipDisplay.textContent = `${v}%`;
    weatherState.targetPrecipitation = v / 100;
    weatherState.precipitationIntensity = v / 100;
    // Update isRaining state
    weatherState.isRaining = v > 60 && currentSeason !== 'summer';
  });
  
  windSlider.addEventListener('input', (e) => {
    const v = parseInt(e.target.value);
    windDisplay.textContent = `${v}%`;
    weatherState.targetWind = v / 100;
    weatherState.windStrength = v / 100;
  });
  
  mistSlider.addEventListener('input', (e) => {
    const v = parseInt(e.target.value);
    mistDisplay.textContent = `${v}%`;
    weatherState.targetMist = v / 100;
    weatherState.mistIntensity = v / 100;
  });
  
  cloudSlider.addEventListener('input', (e) => {
    const v = parseInt(e.target.value);
    cloudDisplay.textContent = `${v}%`;
    weatherState.targetCloudCover = v / 100;
    weatherState.cloudCover = v / 100;
  });
  
  // Auto-time checkbox
  autoTimeCheck.addEventListener('change', (e) => {
    demoMode.manualTime = !e.target.checked;
    if (e.target.checked) {
      updateDayTime();
      timeSlider.value = dayTime;
      const hours = Math.floor(dayTime);
      const mins = Math.floor((dayTime % 1) * 60);
      timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    }
  });
  
  // Auto-season checkbox
  autoSeasonCheck.addEventListener('change', (e) => {
    demoMode.manualSeason = !e.target.checked;
    if (e.target.checked) {
      const detectedSeason = detectSeason(new Date(), weatherState.latitude);
      switchSeason(detectedSeason);
      seasonBtns.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.season === detectedSeason);
      });
    }
  });
  
  // Rainbow checkbox
  const rainbowCheck = document.getElementById('rainbowCheck');
  rainbowCheck.addEventListener('change', (e) => {
    rainbowEnabled = e.target.checked;
  });
  
  // Set initial season button state
  seasonBtns.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.season === currentSeason);
  });
  
  // Initial time display
  const hours = Math.floor(dayTime);
  const mins = Math.floor((dayTime % 1) * 60);
  timeSlider.value = dayTime;
  timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
}

function switchSeason(newSeason) {
  if (currentSeason === newSeason) return;
  
  currentSeason = newSeason;
  seasonalPalette = SEASONAL_PALETTES[newSeason];
  
  // Regenerate trees with new seasonal colors
  generateAllTrees();
  
  // Reset precipitation particles for new type
  initPrecipitation();
  
  // Force color recalculation
  currentColors = null;
  
  // Update UI elements
  const seasonData = SEASONS[currentSeason];
  document.getElementById('seasonInfo').textContent = `${seasonData.icon} ${seasonData.name}${currentHemisphere === 'southern' ? ' (Southern Hemisphere)' : ''}`;
  
  const seasonBadge = document.getElementById('seasonBadge');
  if (seasonBadge) {
    seasonBadge.textContent = `${seasonData.icon} ${seasonData.name}`;
  }
  
  console.log('Switched to season:', newSeason);
}

// Override updateDayTime to respect demo mode
const originalUpdateDayTime = updateDayTime;
updateDayTime = function() {
  if (demoMode.manualTime) {
    // Don't update from real time, use slider value
    return;
  }
  originalUpdateDayTime();
  
  // Update slider to match if auto-time is enabled
  const timeSlider = document.getElementById('timeSlider');
  const timeDisplay = document.getElementById('timeDisplay');
  if (timeSlider && document.getElementById('autoTimeCheck')?.checked) {
    timeSlider.value = dayTime;
    const hours = Math.floor(dayTime);
    const mins = Math.floor((dayTime % 1) * 60);
    timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
  }
};


// CRR Debug panel toggle
let crrDebugVisible = false;
document.addEventListener('keydown', (e) => {
  if (e.key === 'c' && !e.ctrlKey && !e.metaKey && e.target.tagName !== 'INPUT') {
    crrDebugVisible = !crrDebugVisible;
    document.getElementById('crrDebug').classList.toggle('visible', crrDebugVisible);
  }
});

function updateCRRDebug(crrState) {
  if (!crrDebugVisible || !crrState) return;
  
  document.getElementById('crrOmega').textContent = crrState.omega?.toFixed(4) || '0.159';
  document.getElementById('crrPhase').textContent = crrState.phase || 'stable';
  document.getElementById('crrDayC').textContent = crrState.dawnAmplitude?.toFixed(3) || '0.00';
  document.getElementById('crrAmplitude').textContent = 
    ((crrState.dawnAmplitude || 0) + (crrState.duskAmplitude || 0)).toFixed(3);
  document.getElementById('crrMemory').textContent = 
    Math.exp(Math.min((crrState.dawnAmplitude || 0) / (crrState.omega || 0.159), 5)).toFixed(2);
  document.getElementById('crrCV').textContent = crrState.cv?.toFixed(4) || '0.08';
}


document.addEventListener('click', () => audio.init(), { once: true });
document.addEventListener('keydown', () => audio.init(), { once: true });

window.addEventListener('resize', () => {
  initCanvas();
  vignetteCache = null; // Reset vignette cache
  vignetteCacheAmbient = -1;
  generateAllTrees();
  createTexture();
  initPrecipitation();
  initStars();
  initClouds();
  initPath();
  initForestLamps();
  initLowryFigures();
  initAmbientWeather();
});

init();

</script>
</body>
</html>
