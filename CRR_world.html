<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Living Sunrise - Enhanced Murmuration</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        .fps { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #4ade80; font: 12px monospace; padding: 5px 10px; border-radius: 4px; z-index: 100; }
        .fps.warn { color: #fbbf24; }
        .fps.bad { color: #f87171; }
        .debug { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.85); color: #fff; font: 10px monospace; padding: 8px 12px; border-radius: 4px; opacity: 0; transition: opacity 0.3s; line-height: 1.6; }
        .debug.show { opacity: 1; }
        .debug .t { color: #fcd34d; }
        .debug .v { color: #a78bfa; }
        .debug .section { border-top: 1px solid rgba(255,255,255,0.2); margin-top: 6px; padding-top: 6px; }
        .hint { position: fixed; bottom: 10px; right: 10px; color: rgba(255,255,255,0.25); font: 9px sans-serif; }
        .math-panel { position: fixed; top: 50px; left: 10px; background: rgba(0,0,0,0.92); color: #e0e0e0; font: 11px 'Courier New', monospace; padding: 12px 16px; border-radius: 6px; max-width: 420px; max-height: calc(100vh - 100px); overflow-y: auto; opacity: 0; transition: opacity 0.3s; border: 1px solid rgba(255,200,100,0.3); line-height: 1.5; }
        .math-panel.show { opacity: 1; }
        .math-panel h2 { color: #fcd34d; font-size: 13px; margin-bottom: 8px; border-bottom: 1px solid rgba(255,200,100,0.3); padding-bottom: 6px; }
        .math-panel h3 { color: #a78bfa; font-size: 11px; margin: 10px 0 4px 0; }
        .math-panel .eq { background: rgba(255,255,255,0.08); padding: 6px 10px; margin: 4px 0; border-radius: 4px; font-size: 12px; color: #fff; border-left: 2px solid #fcd34d; }
        .math-panel .note { color: #888; font-size: 9px; margin-top: 2px; }
    </style>
</head>
<body>
<div class="fps" id="fps">60 FPS</div>
<div class="math-panel" id="mathPanel">
    <h2>⟨ CRR FRAMEWORK ⟩</h2>
    <p style="color:#888;font-size:9px;margin-bottom:8px;">Coherence-Rupture-Regeneration by Alexander Sabine</p>
    <h3>▸ CORE EQUATIONS</h3>
    <div class="eq">C(x,t) = ∫L(x,τ)dτ <span class="note">— Coherence accumulation</span></div>
    <div class="eq">δ(now) → Rupture at C ≥ Ω <span class="note">— Scale-invariant transition</span></div>
    <div class="eq">R = ∫φ·exp(C/Ω)·Θ(...)dτ <span class="note">— Memory-weighted regeneration</span></div>
    <div class="eq">Ω = 1/π (Z₂) | 1/2π (SO(2)) <span class="note">— Symmetry determines Ω</span></div>
    <h3>▸ ENHANCED MURMURATION</h3>
    <div class="eq">k = 7 topological neighbors <span class="note">— Scale-invariant interaction</span></div>
    <div class="eq">CRR rupture → new move <span class="note">— Choreographed pattern changes</span></div>
    <div class="eq">Moves: vortex, wave, split, breathe, ribbon, column, sweep, tornado</div>
    <div class="eq">cohesionMult ∈ [0.7, 1.8] <span class="note">— Pattern-specific tightness</span></div>
    <div class="eq">angularMom drives swirl <span class="note">— Per-move rotation</span></div>
    <h3>▸ SUNRISE HEAT HAZE (Z₂)</h3>
    <div class="eq">Ω = 1/π ≈ 0.318 <span class="note">— Shimmer intensity pulsing</span></div>
    <div class="eq">Intensity ∝ exp(C/Ω) <span class="note">— Memory-weighted glow</span></div>
    <h3>▸ RAINBOW OPTICS</h3>
    <div class="eq">C(s) = ∫ L·n(λ)·ds <span class="note">— Phase accumulation in droplet</span></div>
    <div class="eq">Ω(λ) = π·n(λ) <span class="note">— Z₂ symmetry at boundaries</span></div>
    <div class="eq">θ_primary ≈ 42° | θ_secondary ≈ 51° <span class="note">— Emergent caustic angles</span></div>
    <h3>▸ PREDATOR DYNAMICS</h3>
    <div class="eq">Ω_pred = 0.4 <span class="note">— Longer coherence cycles</span></div>
    <div class="eq">v_dive = 180·smoothAmp <span class="note">— Peak at rupture</span></div>
    <p style="color:#555;font-size:8px;margin-top:10px;border-top:1px solid rgba(255,255,255,0.1);padding-top:6px;">cohere.org.uk | Z₂→Ω=1/π, SO(2)→Ω=1/2π</p>
</div>
<div class="debug" id="debug">
    <div><span class="t">Sun Phase:</span> <span class="v" id="sunPhase">0.00</span></div>
    <div><span class="t">Weather:</span> <span class="v" id="weatherState">clear</span></div>
    <div><span class="t">Rain Intensity:</span> <span class="v" id="rainInt">0%</span></div>
    <div><span class="t">Rainbow:</span> <span class="v" id="rainbowVis">0%</span></div>
    <div><span class="t">Sound:</span> <span class="v" id="soundState">OFF (press s)</span></div>
    <div class="section"></div>
    <div><span class="t">Flock C/Ω:</span> <span class="v" id="flockCoh">0.00</span></div>
    <div><span class="t">Flock State:</span> <span class="v" id="flockState">coh</span></div>
    <div><span class="t">Move:</span> <span class="v" id="currentMove">-</span></div>
    <div><span class="t">Flock Density:</span> <span class="v" id="flockDensity">0</span></div>
    <div><span class="t">Birds (fly/perch):</span> <span id="birds">0/0</span></div>
    <div class="section"></div>
    <div><span class="t">Predator:</span> <span class="v" id="predState">soar</span></div>
    <div><span class="t">Hunt C/Ω:</span> <span class="v" id="predCoh">0.00</span></div>
    <div class="section"></div>
    <div><span class="t">Update:</span> <span id="upd">0</span>ms</div>
</div>
<div class="hint">m = math | c = debug | click = startle | r = rain | s = sound</div>
<canvas id="c"></canvas>
<script>
/*
╔═══════════════════════════════════════════════════════════════════════════════╗
║  CRR MATHEMATICAL FRAMEWORK DEMONSTRATION                                      ║
║  Coherence-Rupture-Regeneration by Alexander Sabine                           ║
║                                                                                ║
║  ENHANCED MURMURATION:                                                         ║
║  - Topological neighbors (k=7) instead of metric distance                     ║
║  - Turning wave propagation through delayed velocity response                  ║
║  - Dynamic orbiting attractors for shape-shifting                             ║
║  - Collective turn direction on CRR flock rupture                             ║
║  - Density-responsive expansion/contraction                                    ║
║                                                                                ║
║  CORE EQUATIONS:                                                               ║
║  C(x,t) = ∫L(x,τ)dτ           — Coherence: accumulated attention/energy       ║
║  δ(now) when C ≥ Ω            — Rupture: scale-invariant choice-moment        ║
║  R = ∫φ(x,τ)·exp(C/Ω)·Θ(...)dτ — Regeneration: memory-weighted reconstruction ║
║                                                                                ║
║  Ω-SYMMETRY HYPOTHESIS:                                                        ║
║  Z₂ (binary):     Ω = 1/π  ≈ 0.318                                            ║
║  SO(2) (circular): Ω = 1/2π ≈ 0.159                                           ║
╚═══════════════════════════════════════════════════════════════════════════════╝
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const { sin, cos, sqrt, abs, floor, max, min, random, PI, atan2, exp, pow } = Math;
const PI2 = PI * 2;
let W, H, time = 0;

// CRR Constants from Ω-symmetry hypothesis
const OMEGA_Z2 = 1 / PI;        // ≈ 0.318 for binary transitions
const OMEGA_SO2 = 1 / (2 * PI); // ≈ 0.159 for continuous rotations

// ═══════════════════════════════════════════════════════════════════════════════
// DIEGETIC SOUND SYSTEM - Sounds emerge from the scene
// ═══════════════════════════════════════════════════════════════════════════════
const soundSystem = {
    ctx: null,
    enabled: false,
    initialized: false,
    masterGain: null,
    
    rain: { noise: null, filter: null, gain: null },
    wind: { noise: null, filter: null, gain: null },
    birds: { lastChirp: 0, chirpInterval: 2 },
    falcon: { lastCry: 0 },
    
    init() {
        if (this.initialized) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.6;
            this.masterGain.connect(this.ctx.destination);
            
            this.rain.gain = this.ctx.createGain();
            this.rain.gain.gain.value = 0;
            this.rain.filter = this.ctx.createBiquadFilter();
            this.rain.filter.type = 'bandpass';
            this.rain.filter.frequency.value = 3000;
            this.rain.filter.Q.value = 0.5;
            this.rain.filter.connect(this.rain.gain);
            this.rain.gain.connect(this.masterGain);
            this.startNoise('rain');
            
            this.wind.gain = this.ctx.createGain();
            this.wind.gain.gain.value = 0;
            this.wind.filter = this.ctx.createBiquadFilter();
            this.wind.filter.type = 'lowpass';
            this.wind.filter.frequency.value = 400;
            this.wind.filter.Q.value = 1;
            this.wind.filter.connect(this.wind.gain);
            this.wind.gain.connect(this.masterGain);
            this.startNoise('wind');
            
            this.initialized = true;
        } catch (e) {
            console.log('Audio not available:', e);
        }
    },
    
    startNoise(type) {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        noise.loop = true;
        noise.connect(this[type].filter);
        noise.start();
        this[type].noise = noise;
    },
    
    chirp() {
        if (!this.ctx || !this.enabled) return;
        
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        const baseFreq = 2000 + Math.random() * 2000;
        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, now);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.3, now + 0.05);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, now + 0.15);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.08, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(now);
        osc.stop(now + 0.25);
    },
    
    flockStartle() {
        if (!this.ctx || !this.enabled) return;
        for (let i = 0; i < 8; i++) {
            setTimeout(() => this.chirp(), i * 30 + Math.random() * 50);
        }
    },
    
    falconCry() {
        if (!this.ctx || !this.enabled) return;
        if (this.ctx.currentTime - this.falcon.lastCry < 2) return;
        this.falcon.lastCry = this.ctx.currentTime;
        
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(1800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.6);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.12, now + 0.05);
        gain.gain.setValueAtTime(0.1, now + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(now);
        osc.stop(now + 0.8);
    },
    
    update(dt, rainIntensity, windIntensity, sunPhase, predatorState, flockRuptured) {
        if (!this.ctx || !this.enabled) return;
        
        const targetRain = rainIntensity * 0.5;
        this.rain.gain.gain.linearRampToValueAtTime(targetRain, this.ctx.currentTime + 0.1);
        this.rain.filter.frequency.value = 2000 + rainIntensity * 2000 + Math.sin(time * 0.5) * 500;
        
        const targetWind = (0.05 + sunPhase * 0.1 + rainIntensity * 0.15);
        this.wind.gain.gain.linearRampToValueAtTime(targetWind, this.ctx.currentTime + 0.1);
        this.wind.filter.frequency.value = 200 + rainIntensity * 300 + Math.sin(time * 0.3) * 100;
        
        const chirpChance = (1 - rainIntensity * 0.8) * (predatorState < 2 ? 1 : 0.2) * sunPhase;
        if (Math.random() < chirpChance * dt * 0.8) {
            this.chirp();
        }
    },
    
    toggle() {
        if (!this.initialized) {
            this.init();
        }
        this.enabled = !this.enabled;
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        return this.enabled;
    }
};

// Fast trig
const TN = 512;
const ST = new Float32Array(TN), CT = new Float32Array(TN);
for (let i = 0; i < TN; i++) { const a = i/TN*PI2; ST[i] = sin(a); CT[i] = cos(a); }
const fsin = a => ST[((a%PI2+PI2)%PI2)/PI2*TN|0];
const fcos = a => CT[((a%PI2+PI2)%PI2)/PI2*TN|0];
const lerp = (a,b,t) => a+(b-a)*t;
const clamp = (v,a,b) => max(a,min(b,v));

// Spatial hash for broad-phase neighbor finding
const CELL = 45;
let hash = {};
let flyingIndices = []; // Cached list of flying bird indices
const hkey = (x,y) => ((x/CELL|0) * 10000 + (y/CELL|0));

function buildHash(birds) {
    hash = {};
    flyingIndices.length = 0;
    for (let i = 0; i < birds.length; i++) {
        const b = birds[i]; 
        if (b.st !== 0) continue;
        flyingIndices.push(i);
        const k = hkey(b.x, b.y);
        (hash[k] || (hash[k] = [])).push(i);
    }
}

// Get candidates from nearby cells (for topological selection)
function getCandidates(x, y) {
    const r = [], cx = x/CELL|0, cy = y/CELL|0;
    for (let dx = -2; dx <= 2; dx++) {
        for (let dy = -2; dy <= 2; dy++) {
            const k = (cx+dx) * 10000 + (cy+dy);
            if (hash[k]) r.push(...hash[k]);
        }
    }
    return r;
}

// Pre-allocated arrays for bird rendering (performance)
const MAX_BIRDS = 500;

// ═══════════════════════════════════════════════════════════════════════════════
// CRR CLASS - Core implementation of Coherence-Rupture-Regeneration
// ═══════════════════════════════════════════════════════════════════════════════
class CRR {
    constructor(omega, lr = 0.1) {
        this.omega = omega;
        this.lr = lr;
        this.C = 0;
        this.st = 0;
        this.amp = 0;
        this.smoothAmp = 0;
    }
    
    update(dt, attn = 1) {
        if (this.st === 0) {
            this.C += this.lr * attn * dt;
            this.amp = min(1, this.C / this.omega);
            if (this.C >= this.omega) this.st = 1;
        }
        else if (this.st === 1) {
            this.amp = 1;
            this.st = 2;
        }
        else {
            const decay = 1.5 * exp(-min(this.C/this.omega, 4) * 0.5);
            this.C *= exp(-decay * dt);
            this.amp = this.C / this.omega;
            if (this.C < 0.01 * this.omega) { this.C = 0; this.st = 0; }
        }
        this.smoothAmp = lerp(this.smoothAmp, this.amp, min(1, dt * 8));
        return this.smoothAmp;
    }
    
    mem() { return exp(min(this.C / this.omega, 4)); }
    rupture() { if (this.st === 0 && this.C > 0.05 * this.omega) this.st = 1; }
    stateName() { return ['coh', 'RUP', 'reg'][this.st]; }
}

// ═══════════════════════════════════════════════════════════════════════════════
// CRR RAINBOW PHYSICS
// ═══════════════════════════════════════════════════════════════════════════════
const RainbowCRR = {
    omega_base: PI,
    
    getN: function(wavelength_nm) {
        const λ = wavelength_nm / 1000;
        return 1.3199 + 0.00653 / (λ * λ);
    },
    
    getOmega: function(wavelength_nm) {
        return this.omega_base * this.getN(wavelength_nm);
    },
    
    getL: function(wavelength_nm) {
        return 2 * PI * this.getN(wavelength_nm) / (wavelength_nm / 500);
    },
    
    spectrum: []
};

for (let nm = 700; nm >= 380; nm -= 8) {
    let r, g, b;
    if (nm >= 620) {
        r = 255;
        g = Math.floor(140 * (1 - (nm - 620) / 80));
        b = 0;
    } else if (nm >= 580) {
        r = 255;
        g = Math.floor(140 + 90 * (1 - (nm - 580) / 40));
        b = 0;
    } else if (nm >= 530) {
        r = Math.floor(255 * (nm - 530) / 50);
        g = 255;
        b = 0;
    } else if (nm >= 490) {
        r = 0;
        g = 255;
        b = Math.floor(200 * (1 - (nm - 490) / 40));
    } else if (nm >= 450) {
        r = 0;
        g = Math.floor(255 * (nm - 450) / 40);
        b = 255;
    } else {
        r = Math.floor(180 * (1 - (nm - 380) / 70));
        g = 0;
        b = 255;
    }
    RainbowCRR.spectrum.push({ nm, r, g, b });
}

function traceRayCRR(wavelength_nm, impactParam, reflections = 1) {
    if (abs(impactParam) >= 0.99) return null;
    
    const n = RainbowCRR.getN(wavelength_nm);
    const Ω = RainbowCRR.getOmega(wavelength_nm);
    const L = RainbowCRR.getL(wavelength_nm);
    const n_air = 1.0003;
    
    let totalC = 0;
    
    const sinI = abs(impactParam);
    const sinR = (n_air / n) * sinI;
    if (sinR > 1) return null;
    
    totalC += L * 0.1;
    totalC += L * n * 2 * sqrt(1 - sinR * sinR);
    
    for (let r = 0; r < reflections; r++) {
        totalC += L * n * 2 * sqrt(1 - sinR * sinR);
    }
    
    const theta_i = Math.asin(sinI);
    const theta_r = Math.asin(sinR);
    
    let deviation;
    if (reflections === 1) {
        deviation = 2 * theta_i - 4 * theta_r + PI;
    } else {
        deviation = 2 * theta_i - 6 * theta_r + 2 * PI;
    }
    
    let viewAngle = abs(PI - deviation) * 180 / PI;
    if (reflections === 2) {
        viewAngle = abs(deviation - PI) * 180 / PI;
    }
    
    const expCO = exp(totalC / Ω);
    const intensity = min(1, expCO * 0.0005);
    
    return { angle: viewAngle, intensity: intensity, wavelength: wavelength_nm, C: totalC, Ω: Ω, expCO: expCO };
}

// ═══════════════════════════════════════════════════════════════════════════════
// WEATHER SYSTEM
// ═══════════════════════════════════════════════════════════════════════════════
const weather = {
    crr: new CRR(1.2, 0.025),
    state: 0,
    rainIntensity: 0,
    targetRainIntensity: 0,
    raindrops: [],
    rainbowVisible: 0,
    manualRain: false,
    
    init() {
        this.raindrops = [];
        this.state = 0;
        this.rainIntensity = 0;
    },
    
    update(dt, sunPhase) {
        this.crr.update(dt, 0.5);
        
        if (sunPhase > 0.5 || this.manualRain) {
            if (this.manualRain && this.state === 0) {
                this.state = 1;
            }
            
            if (this.state === 0) {
                if (this.crr.st === 1 && random() < 0.3) {
                    this.state = 1;
                }
            } else if (this.state === 1) {
                this.targetRainIntensity = min(1, this.targetRainIntensity + dt * 0.15);
                if (this.targetRainIntensity > 0.7) {
                    this.state = 2;
                }
            } else if (this.state === 2) {
                this.targetRainIntensity = 0.8 + fsin(time * 0.5) * 0.2;
                if (this.crr.st === 1 && !this.manualRain) {
                    this.state = 3;
                }
            } else if (this.state === 3) {
                this.targetRainIntensity = max(0, this.targetRainIntensity - dt * 0.1);
                if (this.targetRainIntensity < 0.05) {
                    this.state = 0;
                    this.targetRainIntensity = 0;
                    this.manualRain = false;
                }
            }
        }
        
        this.rainIntensity = lerp(this.rainIntensity, this.targetRainIntensity, dt * 2);
        
        const sunVisible = sunPhase > 0.2;
        const raining = this.rainIntensity > 0.1;
        const targetRainbow = (sunVisible && raining) ? min(1, this.rainIntensity * 1.5 + 0.3) : 0;
        this.rainbowVisible = lerp(this.rainbowVisible, targetRainbow, dt * 2);
        
        const spawnRate = this.rainIntensity * 25;
        for (let i = 0; i < spawnRate; i++) {
            if (random() < 0.7) {
                this.raindrops.push({
                    x: random() * W * 1.2 - W * 0.1,
                    y: -10 - random() * 50,
                    vx: -15 - random() * 10,
                    vy: 200 + random() * 150,
                    len: 8 + random() * 12,
                    alpha: 0.15 + random() * 0.2
                });
            }
        }
        
        const groundLevel = H * 0.88;
        for (let i = this.raindrops.length - 1; i >= 0; i--) {
            const drop = this.raindrops[i];
            drop.x += drop.vx * dt;
            drop.y += drop.vy * dt;
            if (drop.y > groundLevel + 10) {
                this.raindrops.splice(i, 1);
            }
        }
        
        if (this.raindrops.length > 1200) {
            this.raindrops.splice(0, this.raindrops.length - 1200);
        }
    },
    
    drawRain() {
        if (this.rainIntensity < 0.01) return;
        
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        
        for (const drop of this.raindrops) {
            const angle = atan2(drop.vy, drop.vx);
            const endX = drop.x + cos(angle) * drop.len;
            const endY = drop.y + sin(angle) * drop.len;
            
            const groundFade = drop.y > H * 0.7 ? 1 - (drop.y - H * 0.7) / (H * 0.18) : 1;
            const alpha = this.rainIntensity * 0.35 * drop.alpha * max(0.3, groundFade);
            
            ctx.strokeStyle = `rgba(180, 200, 220, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    },
    
    drawRainbow(sunX, sunY) {
        if (this.rainbowVisible < 0.01) return;
        
        const sunNormX = sunX / W;
        const antiSolarX = W * (1 - sunNormX);
        const sunHeight = (H * 0.88 - sunY) / H;
        const antiSolarY = H * 0.88 + sunHeight * H * 0.8;
        
        const baseSize = max(W, H);
        const primaryRadius = baseSize * 0.55;
        const secondaryRadius = baseSize * 0.72;
        const bandWidth = baseSize * 0.045;
        
        const arcStart = PI * 1.05;
        const arcEnd = PI * 1.95;
        
        for (let i = 0; i < RainbowCRR.spectrum.length; i++) {
            const color = RainbowCRR.spectrum[i];
            const t = i / RainbowCRR.spectrum.length;
            const r = primaryRadius - t * bandWidth;
            
            const trace = traceRayCRR(color.nm, 0.85, 1);
            const intensity = trace ? trace.intensity * 4 : 0.6;
            
            const warmBoost = color.nm > 550 ? 1 + (color.nm - 550) / 300 : 1;
            const coolFade = color.nm < 480 ? 0.6 + (color.nm - 380) / 250 : 1;
            
            ctx.beginPath();
            ctx.arc(antiSolarX, antiSolarY, r, arcStart, arcEnd);
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${this.rainbowVisible * intensity * 0.06 * warmBoost * coolFade})`;
            ctx.lineWidth = bandWidth / RainbowCRR.spectrum.length * 2;
            ctx.stroke();
        }
        
        for (let i = RainbowCRR.spectrum.length - 1; i >= 0; i--) {
            const color = RainbowCRR.spectrum[i];
            const t = (RainbowCRR.spectrum.length - 1 - i) / RainbowCRR.spectrum.length;
            const r = secondaryRadius - t * bandWidth * 0.7;
            
            const trace = traceRayCRR(color.nm, 0.95, 2);
            const intensity = trace ? trace.intensity * 2.5 : 0.35;
            
            const warmBoost = color.nm > 550 ? 1 + (color.nm - 550) / 300 : 1;
            const coolFade = color.nm < 480 ? 0.6 + (color.nm - 380) / 250 : 1;
            
            ctx.beginPath();
            ctx.arc(antiSolarX, antiSolarY, r, arcStart + 0.05, arcEnd - 0.05);
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${this.rainbowVisible * intensity * 0.03 * warmBoost * coolFade})`;
            ctx.lineWidth = bandWidth / RainbowCRR.spectrum.length * 1.5;
            ctx.stroke();
        }
        
        const darkBandInner = primaryRadius + bandWidth * 0.2;
        const darkBandOuter = secondaryRadius - bandWidth * 0.4;
        
        ctx.beginPath();
        ctx.arc(antiSolarX, antiSolarY, (darkBandInner + darkBandOuter) / 2, arcStart, arcEnd);
        ctx.lineWidth = (darkBandOuter - darkBandInner) * 0.8;
        ctx.strokeStyle = `rgba(0, 10, 30, ${this.rainbowVisible * 0.015})`;
        ctx.stroke();
    },
    
    stateName() {
        return ['clear', 'clouding', 'RAIN', 'clearing'][this.state];
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SAHARA HEAT HAZE
// ═══════════════════════════════════════════════════════════════════════════════
const desertHaze = {
    bands: [],
    initialized: false,
    
    init() {
        this.bands = [];
        
        const numBands = 8;
        for (let i = 0; i < numBands; i++) {
            const t = i / numBands;
            const heightBias = t * t * t;
            const baseY = H * (0.88 - heightBias * 0.25);
            
            this.bands.push({
                baseY: baseY,
                y: baseY,
                crr: new CRR(OMEGA_Z2, 0.2 + random() * 0.15),
                waveFreq: 0.002 + random() * 0.002,
                waveAmp: 1.5 + (1 - t) * 3,
                waveSpeed: 0.4 + random() * 0.3,
                phase: random() * PI2,
                thickness: 2 + (1 - t) * 4,
                baseAlpha: 0.008 + (1 - t) * 0.012,
                driftSpeed: 0.15 + random() * 0.2,
                driftAmp: 1 + random() * 2,
                driftPhase: random() * PI2,
                warmth: 0.3 + random() * 0.4,
                wave2Freq: 0.006 + random() * 0.004,
                wave2Amp: 0.8 + random() * 1.2,
                wave2Speed: 0.6 + random() * 0.4
            });
        }
        
        this.initialized = true;
    },
    
    update(dt, sunPhase) {
        if (!this.initialized) this.init();
        
        for (const band of this.bands) {
            band.crr.update(dt, 0.3 + sunPhase * 0.3);
            band.y = band.baseY + fsin(time * band.driftSpeed + band.driftPhase) * band.driftAmp;
        }
    },
    
    draw(sunPhase) {
        if (!this.initialized || sunPhase < 0.05) return;
        
        const rainFactor = 1 - weather.rainIntensity * 0.9;
        
        let sunriseIntensity;
        if (sunPhase < 0.1) {
            sunriseIntensity = sunPhase / 0.1;
        } else if (sunPhase < 0.4) {
            sunriseIntensity = 1.0;
        } else if (sunPhase < 0.65) {
            sunriseIntensity = 1.0 - (sunPhase - 0.4) / 0.25;
        } else {
            sunriseIntensity = 0;
        }
        
        if (sunriseIntensity < 0.01) return;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        for (const band of this.bands) {
            const shimmer = band.crr.smoothAmp;
            const alpha = band.baseAlpha * sunriseIntensity * (0.6 + shimmer * 0.4) * rainFactor;
            
            if (alpha < 0.002) continue;
            
            const horizonDist = (H * 0.88 - band.y) / (H * 0.3);
            const distanceFade = max(0, 1 - horizonDist);
            const finalAlpha = alpha * distanceFade;
            
            if (finalAlpha < 0.001) continue;
            
            ctx.beginPath();
            
            const segments = 80;
            const y = band.y;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const px = t * W;
                
                const wave1 = fsin(px * band.waveFreq + time * band.waveSpeed + band.phase) * band.waveAmp * shimmer;
                const wave2 = fsin(px * band.wave2Freq + time * band.wave2Speed + band.phase * 1.5) * band.wave2Amp * shimmer;
                const waveY = wave1 + wave2;
                
                const py = y + waveY - band.thickness * 0.5;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            
            for (let i = segments; i >= 0; i--) {
                const t = i / segments;
                const px = t * W;
                
                const wave1 = fsin(px * band.waveFreq + time * band.waveSpeed + band.phase + 0.2) * band.waveAmp * shimmer * 0.9;
                const wave2 = fsin(px * band.wave2Freq + time * band.wave2Speed + band.phase * 1.5 + 0.15) * band.wave2Amp * shimmer;
                const waveY = wave1 + wave2;
                
                const py = y + waveY + band.thickness * 0.5;
                ctx.lineTo(px, py);
            }
            
            ctx.closePath();
            
            const grad = ctx.createLinearGradient(0, y - band.thickness, 0, y + band.thickness);
            const r = 255;
            const g = 250 + band.warmth * 5 | 0;
            const b = 240 + band.warmth * 10 | 0;
            
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${finalAlpha * 0.5})`);
            grad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${finalAlpha})`);
            grad.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${finalAlpha * 0.5})`);
            grad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = grad;
            ctx.fill();
        }
        
        const groundAlpha = 0.015 * sunriseIntensity * rainFactor;
        if (groundAlpha > 0.003) {
            const groundY = H * 0.87;
            const groundGrad = ctx.createLinearGradient(0, groundY, 0, groundY - H * 0.06);
            
            const pulse = 0.8 + 0.2 * fsin(time * 0.8);
            
            groundGrad.addColorStop(0, `rgba(255, 252, 245, ${groundAlpha * pulse})`);
            groundGrad.addColorStop(0.5, `rgba(255, 250, 242, ${groundAlpha * 0.3 * pulse})`);
            groundGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, groundY - H * 0.06, W, H * 0.06);
        }
        
        ctx.restore();
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SUNRISE
// ═══════════════════════════════════════════════════════════════════════════════
const sunrise = {
    crr: new CRR(2.0, 0.015),
    phase: 0, targetPhase: 0, x: 0.5, y: 1.0, radius: 0.11,
    rays: [],
    rayLayers: [],
    
    init() { 
        this.phase = 0; 
        this.y = 0.85; 
        desertHaze.init();
        
        this.rays = [];
        this.rayLayers = [];
        
        for (let i = 0; i < 24; i++) {
            const baseAngle = (i / 24) * PI2;
            this.rays.push({
                angle: baseAngle + (random() - 0.5) * 0.15,
                length: 0.6 + random() * 0.8,
                width: 0.012 + random() * 0.018,
                speed: 0.02 + random() * 0.04,
                phase: random() * PI2,
                intensity: 0.3 + random() * 0.4,
                driftSpeed: 0.005 + random() * 0.01,
                driftAmp: 0.02 + random() * 0.03
            });
        }
        
        for (let i = 0; i < 8; i++) {
            this.rayLayers.push({
                angle: (i / 8) * PI2 + random() * 0.3,
                length: 1.2 + random() * 0.6,
                width: 0.04 + random() * 0.06,
                speed: 0.008 + random() * 0.012,
                phase: random() * PI2,
                intensity: 0.15 + random() * 0.15
            });
        }
    },
    
    update(dt) {
        this.crr.update(dt, 0.8);
        this.targetPhase = min(1, this.targetPhase + dt * 0.012);
        this.phase = lerp(this.phase, this.targetPhase, dt * 2);
        this.x = 0.48 + fsin(this.phase * 0.3) * 0.02;
        this.y = 0.85 - this.phase * 0.45;
        desertHaze.update(dt, this.phase);
    },
    
    draw() {
        const cx = W * this.x, cy = H * this.y, r = H * this.radius;
        const rainDim = 1 - weather.rainIntensity * 0.4;
        const int = (0.7 + this.phase * 0.3) * rainDim;
        
        desertHaze.draw(this.phase);
        
        // God rays
        if (this.phase > 0.05 && weather.rainIntensity < 0.8) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            const horizonFactor = max(0, 1 - (H * 0.88 - cy) / (H * 0.5));
            const atmosphericDensity = 0.3 + horizonFactor * 0.5;
            
            for (const ray of this.rayLayers) {
                const drift = fsin(time * ray.speed * 0.5 + ray.phase) * 0.02;
                const currentAngle = ray.angle + drift;
                const pulse = 0.7 + 0.3 * fsin(time * ray.speed * 0.3 + ray.phase);
                
                const rayDirY = sin(currentAngle);
                if (rayDirY > 0.3) continue;
                
                const rayAlpha = 0.008 * int * pulse * ray.intensity * atmosphericDensity * (1 - weather.rainIntensity * 0.7);
                
                if (rayAlpha > 0.001) {
                    const rayLen = r * (4 + ray.length * 6);
                    const rayWidth = r * ray.width * (1.5 + pulse * 0.2);
                    
                    const endX = cx + cos(currentAngle) * rayLen;
                    const endY = cy + sin(currentAngle) * rayLen;
                    
                    const grad = ctx.createLinearGradient(cx, cy, endX, endY);
                    
                    grad.addColorStop(0, `rgba(255, 230, 180, ${rayAlpha * 1.2})`);
                    grad.addColorStop(0.15, `rgba(255, 200, 140, ${rayAlpha})`);
                    grad.addColorStop(0.4, `rgba(255, 170, 100, ${rayAlpha * 0.5})`);
                    grad.addColorStop(0.7, `rgba(255, 140, 70, ${rayAlpha * 0.2})`);
                    grad.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    
                    const halfWidth = rayWidth * 0.5;
                    const ctrlDist = rayLen * 0.4;
                    
                    ctx.quadraticCurveTo(
                        cx + cos(currentAngle - halfWidth * 0.5) * ctrlDist,
                        cy + sin(currentAngle - halfWidth * 0.5) * ctrlDist,
                        endX + cos(currentAngle - PI/2) * rayWidth * rayLen * 0.02,
                        endY + sin(currentAngle - PI/2) * rayWidth * rayLen * 0.02
                    );
                    ctx.quadraticCurveTo(
                        cx + cos(currentAngle + halfWidth * 0.5) * ctrlDist,
                        cy + sin(currentAngle + halfWidth * 0.5) * ctrlDist,
                        cx, cy
                    );
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            for (const ray of this.rays) {
                const drift = fsin(time * ray.driftSpeed + ray.phase) * ray.driftAmp;
                const currentAngle = ray.angle + drift;
                
                const breathe = 0.85 + 0.15 * fsin(time * ray.speed + ray.phase);
                const shimmer = 0.95 + 0.05 * fsin(time * ray.speed * 3 + ray.phase * 2);
                
                const rayDirY = sin(currentAngle);
                if (rayDirY > 0.4) continue;
                
                const lowSunBoost = 1 + (1 - this.phase) * 0.5;
                
                const rayAlpha = 0.012 * int * breathe * shimmer * ray.intensity * lowSunBoost * (1 - weather.rainIntensity * 0.6);
                
                if (rayAlpha > 0.002) {
                    const rayLen = r * (2.5 + ray.length * 4);
                    const baseWidth = r * ray.width;
                    
                    const startWidth = baseWidth * 1.2;
                    const endWidth = baseWidth * 0.3;
                    
                    const endX = cx + cos(currentAngle) * rayLen;
                    const endY = cy + sin(currentAngle) * rayLen;
                    
                    const perpX = -sin(currentAngle);
                    const perpY = cos(currentAngle);
                    
                    const grad = ctx.createLinearGradient(cx, cy, endX, endY);
                    
                    const warmR = 255;
                    const warmG = 200 + this.phase * 40;
                    const warmB = 120 + this.phase * 80;
                    
                    grad.addColorStop(0, `rgba(${warmR}, ${warmG}, ${warmB}, ${rayAlpha * 0.8})`);
                    grad.addColorStop(0.1, `rgba(${warmR}, ${warmG - 20}, ${warmB - 30}, ${rayAlpha})`);
                    grad.addColorStop(0.3, `rgba(${warmR}, ${warmG - 40}, ${warmB - 50}, ${rayAlpha * 0.7})`);
                    grad.addColorStop(0.6, `rgba(${warmR}, ${warmG - 60}, ${warmB - 70}, ${rayAlpha * 0.3})`);
                    grad.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    
                    ctx.moveTo(cx + perpX * startWidth, cy + perpY * startWidth);
                    ctx.lineTo(endX + perpX * endWidth, endY + perpY * endWidth);
                    ctx.lineTo(endX - perpX * endWidth, endY - perpY * endWidth);
                    ctx.lineTo(cx - perpX * startWidth, cy - perpY * startWidth);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            const glowGrad = ctx.createRadialGradient(cx, cy, r * 0.9, cx, cy, r * 2);
            const glowAlpha = 0.015 * int * atmosphericDensity * (1 - weather.rainIntensity * 0.5);
            glowGrad.addColorStop(0, `rgba(255, 220, 160, ${glowAlpha})`);
            glowGrad.addColorStop(0.5, `rgba(255, 180, 100, ${glowAlpha * 0.4})`);
            glowGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 2, 0, PI2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Corona
        const hGlow = 1 + (1 - this.phase) * 0.8;
        
        for (let i = 5; i >= 0; i--) {
            const gr = r * (1.5 + i * 0.5) * hGlow;
            const a = (0.06 - i * 0.008) * int;
            
            const g = ctx.createRadialGradient(cx, cy, r * 0.8, cx, cy, gr);
            g.addColorStop(0, `rgba(255, ${200 + this.phase * 50 | 0}, ${120 + this.phase * 80 | 0}, ${a})`);
            g.addColorStop(0.4, `rgba(255, ${150 + this.phase * 50 | 0}, ${60 + this.phase * 50 | 0}, ${a * 0.5})`);
            g.addColorStop(0.7, `rgba(255, ${100 + this.phase * 40 | 0}, ${30 + this.phase * 30 | 0}, ${a * 0.2})`);
            g.addColorStop(1, 'transparent');
            
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(cx, cy, gr, 0, PI2);
            ctx.fill();
        }
        
        // Inner corona
        const innerCorona = ctx.createRadialGradient(cx, cy, r * 0.95, cx, cy, r * 1.4);
        innerCorona.addColorStop(0, `rgba(255, 255, 240, ${0.4 * int})`);
        innerCorona.addColorStop(0.3, `rgba(255, 250, 200, ${0.2 * int})`);
        innerCorona.addColorStop(1, 'transparent');
        ctx.fillStyle = innerCorona;
        ctx.beginPath();
        ctx.arc(cx, cy, r * 1.4, 0, PI2);
        ctx.fill();
        
        // Heat haze distortion
        let hazeDistortion = 0;
        if (this.phase < 0.1) {
            hazeDistortion = this.phase / 0.1;
        } else if (this.phase < 0.4) {
            hazeDistortion = 1.0;
        } else if (this.phase < 0.65) {
            hazeDistortion = 1.0 - (this.phase - 0.4) / 0.25;
        }
        hazeDistortion *= (1 - weather.rainIntensity);
        
        // Sun disc
        const disc = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        
        disc.addColorStop(0, `rgba(255, 255, ${250 + this.phase * 5 | 0}, ${int})`);
        disc.addColorStop(0.3, `rgba(255, 253, ${235 + this.phase * 15 | 0}, ${int})`);
        disc.addColorStop(0.6, `rgba(255, ${248 + this.phase * 7 | 0}, ${210 + this.phase * 25 | 0}, ${int})`);
        disc.addColorStop(0.8, `rgba(255, ${235 + this.phase * 15 | 0}, ${170 + this.phase * 40 | 0}, ${int * 0.95})`);
        disc.addColorStop(0.95, `rgba(255, ${200 + this.phase * 30 | 0}, ${100 + this.phase * 40 | 0}, ${int * 0.85})`);
        disc.addColorStop(1, `rgba(255, ${170 + this.phase * 30 | 0}, ${70 + this.phase * 30 | 0}, ${int * 0.7})`);
        
        ctx.fillStyle = disc;
        ctx.beginPath();
        
        if (hazeDistortion > 0.01) {
            const segments = 64;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * PI2;
                
                const wobble1 = fsin(angle * 3 + time * 2.4) * 0.0075 * hazeDistortion;
                const wobble2 = fsin(angle * 5 + time * 1.6 + 1) * 0.005 * hazeDistortion;
                const wobble3 = fsin(angle * 8 + time * 3.6 + 2) * 0.003 * hazeDistortion;
                const wobble4 = fsin(angle * 12 + time * 5.0 + 3) * 0.0015 * hazeDistortion;
                
                const verticalWobble = fsin(time * 1.0) * 0.006 * hazeDistortion;
                
                const totalWobble = 1 + wobble1 + wobble2 + wobble3 + wobble4;
                
                const px = cx + cos(angle) * r * totalWobble;
                const py = cy + sin(angle) * r * totalWobble * (1 + verticalWobble);
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        } else {
            ctx.arc(cx, cy, r, 0, PI2);
        }
        ctx.fill();
        
        if (weather.rainIntensity < 0.3) {
            ctx.strokeStyle = `rgba(255, 200, 150, ${0.3 * int * (1 - weather.rainIntensity)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 1.01, 0, PI2);
            ctx.stroke();
        }
        
        // Solar granulation
        ctx.save();
        ctx.globalCompositeOperation = 'overlay';
        ctx.globalAlpha = 0.08 * int;
        
        for (let i = 0; i < 8; i++) {
            const spotAngle = (i / 8) * PI2 + time * 0.01;
            const spotDist = r * (0.3 + (i % 3) * 0.2);
            const spotX = cx + cos(spotAngle) * spotDist;
            const spotY = cy + sin(spotAngle) * spotDist * 0.8;
            const spotR = r * (0.1 + (i % 2) * 0.05);
            
            const spotGrad = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, spotR);
            spotGrad.addColorStop(0, 'rgba(255, 250, 230, 0.3)');
            spotGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = spotGrad;
            ctx.beginPath();
            ctx.arc(spotX, spotY, spotR, 0, PI2);
            ctx.fill();
        }
        ctx.restore();
    },
    
    drawLensFlare() {
        const cx = W * this.x, cy = H * this.y, r = H * this.radius;
        
        let flareIntensity;
        if (this.phase < 0.1) {
            flareIntensity = this.phase / 0.1 * 0.5;
        } else if (this.phase < 0.35) {
            flareIntensity = 0.5 + (this.phase - 0.1) / 0.25 * 0.5;
        } else if (this.phase < 0.6) {
            flareIntensity = 1.0;
        } else if (this.phase < 0.85) {
            flareIntensity = 1.0 - (this.phase - 0.6) / 0.25;
        } else {
            flareIntensity = 0;
        }
        
        flareIntensity *= (1 - weather.rainIntensity * 0.8);
        
        if (flareIntensity < 0.02) return;
        
        const crrPulse = 0.85 + this.crr.smoothAmp * 0.15;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Anamorphic streak
        const streakLength = W * 1.2;
        const streakGrad = ctx.createLinearGradient(cx - streakLength/2, cy, cx + streakLength/2, cy);
        const streakAlpha = 0.025 * flareIntensity * crrPulse;
        
        streakGrad.addColorStop(0, 'transparent');
        streakGrad.addColorStop(0.15, `rgba(180, 220, 255, ${streakAlpha * 0.2})`);
        streakGrad.addColorStop(0.35, `rgba(200, 235, 255, ${streakAlpha * 0.6})`);
        streakGrad.addColorStop(0.5, `rgba(230, 245, 255, ${streakAlpha})`);
        streakGrad.addColorStop(0.65, `rgba(200, 235, 255, ${streakAlpha * 0.6})`);
        streakGrad.addColorStop(0.85, `rgba(180, 220, 255, ${streakAlpha * 0.2})`);
        streakGrad.addColorStop(1, 'transparent');
        
        ctx.strokeStyle = streakGrad;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - streakLength/2, cy);
        ctx.lineTo(cx + streakLength/2, cy);
        ctx.stroke();
        
        // Lens ghosts
        const centerX = W * 0.5, centerY = H * 0.5;
        const axisAngle = atan2(centerY - cy, centerX - cx);
        const axisDist = sqrt((centerX - cx) ** 2 + (centerY - cy) ** 2);
        
        const ghosts = [
            { pos: 0.25, size: 0.04, alpha: 0.06, color: [255, 200, 150], sides: 6 },
            { pos: 0.45, size: 0.025, alpha: 0.05, color: [200, 255, 200], sides: 6 },
            { pos: 0.7, size: 0.06, alpha: 0.04, color: [180, 220, 255], sides: 0 },
            { pos: 1.0, size: 0.035, alpha: 0.05, color: [255, 180, 220], sides: 6 },
            { pos: 1.3, size: 0.05, alpha: 0.04, color: [220, 200, 255], sides: 0 },
            { pos: 1.6, size: 0.02, alpha: 0.06, color: [255, 240, 200], sides: 6 },
            { pos: 1.9, size: 0.07, alpha: 0.03, color: [200, 230, 255], sides: 0 }
        ];
        
        for (const ghost of ghosts) {
            const gx = cx + cos(axisAngle) * axisDist * ghost.pos;
            const gy = cy + sin(axisAngle) * axisDist * ghost.pos;
            const gr = H * ghost.size * (0.8 + crrPulse * 0.2);
            const ga = ghost.alpha * flareIntensity * crrPulse;
            
            if (ga < 0.005) continue;
            
            const ghostGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gr);
            const [red, green, blue] = ghost.color;
            ghostGrad.addColorStop(0, `rgba(${red}, ${green}, ${blue}, ${ga})`);
            ghostGrad.addColorStop(0.5, `rgba(${red}, ${green}, ${blue}, ${ga * 0.5})`);
            ghostGrad.addColorStop(0.8, `rgba(${red}, ${green}, ${blue}, ${ga * 0.2})`);
            ghostGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = ghostGrad;
            ctx.beginPath();
            
            if (ghost.sides === 0) {
                ctx.arc(gx, gy, gr, 0, PI2);
            } else {
                for (let i = 0; i <= ghost.sides; i++) {
                    const angle = (i / ghost.sides) * PI2 - PI/2;
                    const px = gx + cos(angle) * gr;
                    const py = gy + sin(angle) * gr;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            }
            ctx.fill();
        }
        
        // Horizon glow
        const horizonY = H * 0.88;
        const glowHeight = H * 0.2;
        const horizonGlowAlpha = 0.06 * flareIntensity * crrPulse;
        
        const horizonGrad = ctx.createLinearGradient(0, horizonY, 0, horizonY - glowHeight);
        horizonGrad.addColorStop(0, `rgba(255, 180, 100, ${horizonGlowAlpha})`);
        horizonGrad.addColorStop(0.4, `rgba(255, 160, 80, ${horizonGlowAlpha * 0.4})`);
        horizonGrad.addColorStop(1, 'transparent');
        
        ctx.fillStyle = horizonGrad;
        ctx.fillRect(0, horizonY - glowHeight, W, glowHeight);
        
        ctx.restore();
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// ATMOSPHERE
// ═══════════════════════════════════════════════════════════════════════════════
const atmosphere = {
    crr: new CRR(OMEGA_SO2, 0.08),
    colors: {
        nightTop: {r:12,g:15,b:30}, nightMid: {r:20,g:25,b:45}, nightHor: {r:35,g:30,b:50},
        dawnTop: {r:55,g:45,b:75}, dawnMid: {r:180,g:100,b:70}, dawnHor: {r:255,g:150,b:60},
        dayTop: {r:85,g:130,b:190}, dayMid: {r:150,g:175,b:210}, dayHor: {r:220,g:200,b:180},
        rainTop: {r:60,g:70,b:85}, rainMid: {r:90,g:100,b:115}, rainHor: {r:130,g:135,b:145}
    },
    cur: { top: null, mid: null, hor: null },
    update(dt, sunPhase) {
        this.crr.update(dt, 0.3 + sunPhase * 0.4);
        const t = sunPhase;
        const lc = (a,b,t) => ({r:lerp(a.r,b.r,t),g:lerp(a.g,b.g,t),b:lerp(a.b,b.b,t)});
        
        let baseTop, baseMid, baseHor;
        if (t < 0.3) {
            const p = t/0.3, s = p*p*(3-2*p);
            baseTop = lc(this.colors.nightTop, this.colors.dawnTop, s);
            baseMid = lc(this.colors.nightMid, this.colors.dawnMid, s);
            baseHor = lc(this.colors.nightHor, this.colors.dawnHor, s);
        } else {
            const p = (t-0.3)/0.7, s = p*p*(3-2*p);
            baseTop = lc(this.colors.dawnTop, this.colors.dayTop, s);
            baseMid = lc(this.colors.dawnMid, this.colors.dayMid, s);
            baseHor = lc(this.colors.dawnHor, this.colors.dayHor, s);
        }
        
        const rain = weather.rainIntensity;
        this.cur.top = lc(baseTop, this.colors.rainTop, rain * 0.7);
        this.cur.mid = lc(baseMid, this.colors.rainMid, rain * 0.7);
        this.cur.hor = lc(baseHor, this.colors.rainHor, rain * 0.7);
    },
    draw() {
        const c = this.cur, g = ctx.createLinearGradient(0, 0, 0, H*0.88);
        g.addColorStop(0, `rgb(${c.top.r|0},${c.top.g|0},${c.top.b|0})`);
        g.addColorStop(0.35, `rgb(${c.mid.r|0},${c.mid.g|0},${c.mid.b|0})`);
        g.addColorStop(0.7, `rgb(${c.hor.r|0},${c.hor.g|0},${c.hor.b|0})`);
        g.addColorStop(1, `rgb(${c.hor.r*0.9|0},${c.hor.g*0.85|0},${c.hor.b*0.8|0})`);
        ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// CLOUDS
// ═══════════════════════════════════════════════════════════════════════════════
const clouds = [];

function initClouds() {
    clouds.length = 0;
    
    const cloudConfigs = [
        { x: 0.15, y: 0.10, scale: 0.12 },
        { x: 0.45, y: 0.06, scale: 0.09 },
        { x: 0.72, y: 0.12, scale: 0.14 },
        { x: 0.30, y: 0.17, scale: 0.07 },
        { x: 0.88, y: 0.14, scale: 0.08 }
    ];
    
    for (const cfg of cloudConfigs) {
        const pts = [];
        const numPts = 8;
        for (let i = 0; i < numPts; i++) {
            const a = (i / numPts) * PI2;
            const r = 0.4 + random() * 0.3;
            pts.push({ x: cos(a) * r, y: sin(a) * r * 0.4 });
        }
        
        clouds.push({
            x: cfg.x,
            y: cfg.y,
            scale: cfg.scale,
            pts: pts,
            speed: 0.00003 + random() * 0.00003,
            baseOpacity: 0.15 + random() * 0.1,
            curOpacity: 0
        });
    }
}

function updateClouds(dt) {
    for (const c of clouds) {
        c.x += c.speed * dt * 50;
        if (c.x > 1.25) c.x = -0.25;
        
        const rainFactor = 1 + weather.rainIntensity * 1.2;
        c.curOpacity = c.baseOpacity * (0.5 + sunrise.phase * 0.5) * rainFactor;
    }
}

function drawClouds() {
    for (const c of clouds) {
        if (c.curOpacity < 0.02) continue;
        
        ctx.save();
        ctx.translate(W * c.x, H * c.y);
        ctx.scale(W * c.scale, W * c.scale);
        
        ctx.beginPath();
        ctx.moveTo(c.pts[0].x, c.pts[0].y);
        for (let i = 1; i <= c.pts.length; i++) {
            const p = c.pts[i - 1];
            const q = c.pts[i % c.pts.length];
            ctx.quadraticCurveTo(p.x, p.y, (p.x + q.x) / 2, (p.y + q.y) / 2);
        }
        ctx.closePath();
        
        const rainGrey = weather.rainIntensity;
        const r = lerp(lerp(200, 255, sunrise.phase), 90, rainGrey);
        const g = lerp(lerp(180, 250, sunrise.phase), 95, rainGrey);
        const b = lerp(lerp(190, 255, sunrise.phase), 110, rainGrey);
        
        ctx.fillStyle = `rgba(${r|0}, ${g|0}, ${b|0}, ${c.curOpacity})`;
        ctx.fill();
        
        ctx.restore();
    }
}

// Tree
class Tree {
    constructor(bx,by,h) {
        this.bx=bx; this.by=by; this.h=h; this.crr=new CRR(1.5,0.03);
        this.branches=[]; this.perches=[]; this.sway=0;
        this.generate(); this.byDepth={};
        for (const b of this.branches) (this.byDepth[b.d]||(this.byDepth[b.d]=[])).push(b);
    }
    generate() {
        const add = (x1,y1,x2,y2,d,maxD) => {
            if (d > maxD) return;
            const mx=(x1+x2)/2+(random()-0.5)*this.h*0.016, my=(y1+y2)/2+(random()-0.5)*this.h*0.016;
            this.branches.push({x1,y1,cx:mx,cy:my,x2,y2,d,w:max(1.2,4.5*pow(0.68,d)),phase:random()*PI2,sw:0,tsw:0});
            
            if (d >= 1 && d <= 6 && abs(atan2(y2-y1,x2-x1)+PI/2) > 0.2) {
                for (let t = 0.2; t <= 0.85; t += 0.15) {
                    const mt = 1-t;
                    const px = mt*mt*x1 + 2*mt*t*mx + t*t*x2;
                    const py = mt*mt*y1 + 2*mt*t*my + t*t*y2;
                    this.perches.push({ x: px + (random()-0.5) * 3, y: py + (random()-0.5) * 2, occ: false });
                }
            }
            
            if (d < maxD) { 
                const n = 2 + floor(random()*2);
                const len = sqrt((x2-x1)**2+(y2-y1)**2) * (0.55+random()*0.18);
                const base = atan2(y2-y1, x2-x1);
                for (let i = 0; i < n; i++) { 
                    const a = base + (random()-0.5)*1.2; 
                    add(x2, y2, x2+cos(a)*len, y2+sin(a)*len, d+1, maxD); 
                }
            }
        };
        
        [[-0.16,0.46],[0,0.54],[0.16,0.46]].forEach(([ao,lm])=>{
            const a=-PI/2+ao;
            add(this.bx,this.by,this.bx+cos(a)*this.h*lm,this.by+sin(a)*this.h*lm,0,7);
        });
        
        for (let i=0;i<8;i++) { 
            const by=this.by-this.h*(0.08+i*0.11);
            const side=i%2===0?-1:1;
            const bl=this.h*(0.1+random()*0.12);
            const a=-PI/2+side*(0.3+random()*0.6); 
            add(this.bx,by,this.bx+cos(a)*bl,by+sin(a)*bl,1,6); 
        }
    }
    
    update(dt,wind) {
        const rainWind = 1 + weather.rainIntensity * 2.5;
        const ambientBreeze = fsin(time * 0.15) * 0.4 + 0.5;
        this.crr.update(dt, 0.08 + wind * 0.15 * rainWind);
        const gustStrength = this.crr.smoothAmp * 0.6;
        const totalWind = (ambientBreeze + gustStrength) * wind * rainWind;
        
        const slowSway = fsin(time * 0.2) * 0.003;
        const medSway = fsin(time * 0.45 + 1) * 0.002;
        const fastSway = fsin(time * 0.9 + 2) * 0.001;
        this.sway = lerp(this.sway, (slowSway + medSway + fastSway) * totalWind, min(1, dt * 2.5));
        
        for (const b of this.branches) {
            const depthFactor = (7 - b.d) / 7;
            const wave1 = fsin(time * 0.35 + b.phase) * 0.005;
            const wave2 = fsin(time * 0.7 + b.phase * 1.3 + b.d * 0.4) * 0.003;
            const wave3 = fsin(time * 1.2 + b.phase * 0.7) * 0.0015 * depthFactor;
            const gustEffect = gustStrength * depthFactor * 0.004;
            
            b.tsw = (wave1 + wave2 + wave3 + gustEffect) * depthFactor * totalWind;
            b.sw = lerp(b.sw, b.tsw, min(1, dt * (4 + b.d * 0.5)));
        }
    }
    
    draw() {
        ctx.lineCap='round';
        for (const d in this.byDepth) {
            const bs=this.byDepth[d],fade=pow(0.68,d),w=max(1.2,4.5*fade);
            ctx.strokeStyle=`rgba(12,10,8,${0.6*fade})`; ctx.lineWidth=w*3.5; ctx.beginPath();
            for (const b of bs) { const sw=b.sw+this.sway; ctx.moveTo(b.x1,b.y1); ctx.quadraticCurveTo(b.cx+sw*40,b.cy,b.x2+sw*80,b.y2); }
            ctx.stroke();
            ctx.strokeStyle=`rgba(18,15,12,${0.85*fade})`; ctx.lineWidth=w; ctx.beginPath();
            for (const b of bs) { const sw=b.sw+this.sway; ctx.moveTo(b.x1,b.y1); ctx.quadraticCurveTo(b.cx+sw*40,b.cy,b.x2+sw*80,b.y2); }
            ctx.stroke();
        }
        ctx.strokeStyle='rgba(10,8,6,0.95)'; ctx.lineWidth=18; ctx.beginPath();
        ctx.moveTo(this.bx,this.by+15); ctx.quadraticCurveTo(this.bx+this.sway*20,this.by-this.h*0.07,this.bx+this.sway*40,this.by-this.h*0.14); ctx.stroke();
    }
}

// Grass
class Grass {
    constructor(gy,W,H) { this.gy=gy; this.W=W; this.H=H; this.crr=new CRR(0.28,0.3); this.phase=0; this.stems=[]; this.generate(); }
    generate() {
        const treeX=this.W*0.82;
        for (let i=0;i<150;i++) {
            const x=(i/150)*this.W*1.1-this.W*0.05;
            if (abs(x-treeX)<this.W*0.08) continue;
            const h=this.H*(0.022+random()*0.048),lean=(random()-0.5)*0.35;
            this.stems.push({x:x+(random()-0.5)*6,h,lean,seed:random()>0.35,stype:floor(random()*3),phase:random()*PI2,omega:0.08+random()*0.12,sway:0,tsway:0});
            if (random()>0.45) this.stems.push({x:x+(random()-0.5)*10,h:h*(0.45+random()*0.4),lean:lean+(random()-0.5)*0.25,seed:random()>0.55,stype:floor(random()*3),phase:random()*PI2,omega:0.1+random()*0.1,sway:0,tsway:0});
        }
    }
    update(dt) {
        const rainWind = 1 + weather.rainIntensity * 1.5;
        this.crr.update(dt,0.4+fsin(time*0.12)*0.15);
        this.phase=this.crr.C*2.2;
        for (const s of this.stems) { 
            const wInf=fsin(s.x/this.W*9-this.phase)*0.5+0.5; 
            s.tsway=fsin(time*0.9+s.phase+this.phase*0.4)*0.01*wInf/(s.omega*5)*rainWind; 
            s.sway=lerp(s.sway,s.tsway,min(1,dt*5)); 
        }
    }
    draw() {
        ctx.fillStyle='#080808'; ctx.beginPath(); ctx.moveTo(0,this.gy);
        for (let x=0;x<=this.W;x+=15) ctx.lineTo(x,this.gy-fsin(x*0.01+this.phase*0.15)*2.5-1);
        ctx.lineTo(this.W,this.H); ctx.lineTo(0,this.H); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='#0a0a0a'; ctx.fillStyle='#0a0a0a'; ctx.lineCap='round';
        for (const s of this.stems) {
            const tipX=s.x+s.lean*s.h+s.sway*this.W,tipY=this.gy-s.h,ctrlX=s.x+s.lean*s.h*0.5+s.sway*this.W*0.6,ctrlY=(this.gy+tipY)/2;
            ctx.lineWidth=s.seed?1.1:0.7; ctx.beginPath(); ctx.moveTo(s.x,this.gy); ctx.quadraticCurveTo(ctrlX,ctrlY,tipX,tipY); ctx.stroke();
            if (s.seed) { ctx.save(); ctx.translate(tipX,tipY); ctx.rotate(atan2(tipY-ctrlY,tipX-ctrlX)+PI/2);
                if (s.stype===0) { ctx.beginPath(); ctx.ellipse(0,-3.5,1.8,5,0,0,PI2); ctx.fill(); }
                else if (s.stype===1) { ctx.beginPath(); ctx.ellipse(0,-7,2.2,8.5,0,0,PI2); ctx.fill(); }
                ctx.restore();
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PREDATOR - Peregrine Falcon
// ═══════════════════════════════════════════════════════════════════════════════
class Predator {
    constructor(x,y) {
        this.x=x; this.y=y; this.vx=15; this.vy=0;
        this.crr = new CRR(0.4, 0.12);
        this.huntCRR = new CRR(0.4, 0.08);
        this.feedCRR = new CRR(0.6, 0.05);
        this.target = null;
        this.huntPhase = 0;
        this.baseSize = 3.5;
        this.size = this.baseSize;
        this.wingSpan = 12;
        this.wingPhase = random()*PI2;
        this.patrolX = x; this.patrolY = y; this.patrolR = 200;
        this.bank = 0;
        this.groundY = 0;
        this.feedTimer = 0;
        this.peckPhase = 0;
        this.lastFlightY = y;
        this.flightTimer = 0;
    }
    
    update(dt, birds, flock, grassY, tree) {
        this.crr.update(dt, 0.5);
        this.wingPhase += 4 * dt * (0.5 + this.crr.smoothAmp * 0.3);
        
        const perspectiveScale = 1 + 0.4 * (this.y / H);
        this.size = this.baseSize * perspectiveScale;
        
        let nearD = Infinity, nearB = null;
        let flyingCount = 0;
        let perchedCount = 0;
        
        for (const b of birds) {
            if (b.st === 0) {
                flyingCount++;
                const d = sqrt((b.x-this.x)**2+(b.y-this.y)**2);
                if (d < nearD) { nearD = d; nearB = b; }
            } else if (b.st === 2) {
                perchedCount++;
            }
        }
        
        if (this.huntPhase < 4) {
            this.flightTimer += dt;
        }
        const tiredEnoughToFeed = this.flightTimer > 15;
        const heavyRain = weather.rainIntensity > 0.6;
        
        if (this.huntPhase === 0) {
            this.huntCRR.update(dt, 0.3);
            const pa = time * 0.3;
            const tx = this.patrolX + cos(pa) * this.patrolR;
            const ty = this.patrolY + sin(pa) * this.patrolR * 0.4;
            this.vx = lerp(this.vx, (tx-this.x)*0.5, dt*2);
            this.vy = lerp(this.vy, (ty-this.y)*0.5, dt*2);
            
            if (tiredEnoughToFeed || heavyRain) {
                this.huntPhase = 4;
                this.groundY = grassY - 8;
                this.lastFlightY = this.y;
            } else if (nearB && nearD < 400 && this.huntCRR.C > this.huntCRR.omega * 0.3) {
                this.huntPhase = 1; this.target = nearB;
            }
        } else if (this.huntPhase === 1) {
            if (tiredEnoughToFeed || heavyRain) {
                this.huntPhase = 4;
                this.groundY = grassY - 8;
                this.lastFlightY = this.y;
                this.target = null;
            } else {
                this.huntCRR.update(dt, 1.5);
                if (this.target && this.target.st === 0) {
                    const dx=this.target.x-this.x, dy=this.target.y-this.y, d=sqrt(dx*dx+dy*dy);
                    const circleOff = (1 - this.huntCRR.smoothAmp) * 0.8;
                    const angle = atan2(dy,dx) + sin(time*3) * circleOff;
                    const spd = 40 + this.huntCRR.smoothAmp * 30;
                    this.vx = lerp(this.vx, cos(angle)*spd, dt*3);
                    this.vy = lerp(this.vy, sin(angle)*spd, dt*3);
                    if (d < 150) flock.rupture();
                    if (this.huntCRR.st === 1) this.huntPhase = 2;
                    if (d > 500) { this.huntPhase = 0; this.target = null; }
                } else { this.huntPhase = 0; this.target = null; }
            }
        } else if (this.huntPhase === 2) {
            this.huntCRR.update(dt, 0.3);
            if (this.target) {
                const dx=this.target.x-this.x, dy=this.target.y-this.y, d=sqrt(dx*dx+dy*dy);
                const diveSpd = 120 + this.huntCRR.smoothAmp * 60;
                const angle = atan2(dy,dx);
                this.vx = cos(angle) * diveSpd;
                this.vy = sin(angle) * diveSpd;
                if (d < 25) {
                    this.target.crr.rupture();
                    this.target.vx += (random()-0.5)*100;
                    this.target.vy -= 50+random()*30;
                    this.huntPhase = 3;
                }
                if (this.huntCRR.st === 2 && this.huntCRR.smoothAmp < 0.5) this.huntPhase = 3;
            } else this.huntPhase = 3;
        } else if (this.huntPhase === 3) {
            this.huntCRR.update(dt, 0.3);
            this.vx *= 0.98;
            this.vy = lerp(this.vy, -5, dt);
            if (this.huntCRR.st === 0) {
                this.huntPhase = 0; this.target = null;
                this.patrolX = lerp(this.patrolX, this.x, 0.3);
                this.patrolY = lerp(this.patrolY, this.y, 0.3);
            }
        } else if (this.huntPhase === 4) {
            this.vx = lerp(this.vx, 15, dt * 2);
            this.vy = lerp(this.vy, 25, dt * 2);
            
            if (this.y >= this.groundY - 5) {
                this.y = this.groundY;
                this.vx = 0; this.vy = 0;
                this.huntPhase = 5;
                this.feedCRR.C = 0; this.feedCRR.st = 0;
                this.feedTimer = 0;
            }
        } else if (this.huntPhase === 5) {
            this.feedCRR.update(dt, 0.8);
            this.feedTimer += dt;
            this.peckPhase += dt * 4;
            
            this.vx = 0; this.vy = 0;
            this.y = this.groundY;
            this.x += sin(this.peckPhase * 0.5) * 0.3;
            
            if (nearD < 200) {
                this.huntPhase = 6;
                flock.rupture();
            }
            
            const feedDuration = heavyRain ? 8 : 3;
            if (this.feedCRR.st === 0 && this.feedTimer > feedDuration) {
                this.huntPhase = 6;
                flock.rupture();
            }
        } else if (this.huntPhase === 6) {
            this.vy = lerp(this.vy, -40, dt * 3);
            this.vx = lerp(this.vx, 20 + random() * 10, dt * 2);
            
            if (this.y < this.lastFlightY + 50) {
                this.flightTimer = 0;
                if (nearB && flyingCount > 0 && !heavyRain) {
                    this.huntPhase = 1;
                    this.target = nearB;
                    this.huntCRR.C = this.huntCRR.omega * 0.5;
                } else {
                    this.huntPhase = 0;
                }
                this.huntCRR.st = 0;
                this.patrolX = this.x;
                this.patrolY = this.y;
            }
        }
        
        if (this.huntPhase !== 5) {
            this.x += this.vx * dt; 
            this.y += this.vy * dt;
        }
        
        if (this.huntPhase < 4 || this.huntPhase === 6) {
            if (this.x < W*0.05) this.vx += 30*dt;
            if (this.x > W*0.95) this.vx -= 30*dt;
            if (this.y < H*0.08) this.vy += 20*dt;
            if (this.y > H*0.65) this.vy -= 20*dt;
        }
        
        this.bank = lerp(this.bank, clamp(this.vx*0.02,-0.6,0.6), dt*4);
        const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
        if (spd > 180) { this.vx=this.vx/spd*180; this.vy=this.vy/spd*180; }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.huntPhase === 5) {
            const feedSize = this.size * 1.1;
            const peck = sin(this.peckPhase * 3) * 0.15;
            const headDip = max(0, sin(this.peckPhase * 3)) * 4;
            
            ctx.fillStyle = 'rgba(12,10,15,0.94)';
            
            ctx.beginPath();
            ctx.ellipse(0, 0, feedSize * 1.8, feedSize * 0.7, peck * 0.2, 0, PI2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(-feedSize * 0.3, -feedSize * 0.2, feedSize * 1.2, feedSize * 0.5, 0.1, 0, PI2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-feedSize * 1.5, 0);
            ctx.lineTo(-feedSize * 2.5, -feedSize * 0.5);
            ctx.lineTo(-feedSize * 2.8, 0);
            ctx.lineTo(-feedSize * 2.5, feedSize * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(12,10,15,0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-feedSize * 0.3, feedSize * 0.5);
            ctx.lineTo(-feedSize * 0.4, feedSize * 1.2);
            ctx.moveTo(feedSize * 0.3, feedSize * 0.5);
            ctx.lineTo(feedSize * 0.2, feedSize * 1.2);
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(12,10,15,0.94)';
            ctx.beginPath();
            ctx.arc(feedSize * 1.2, headDip * 0.5, feedSize * 0.45, 0, PI2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(feedSize * 1.5, headDip * 0.5);
            ctx.lineTo(feedSize * 1.9, headDip + feedSize * 0.3);
            ctx.lineTo(feedSize * 1.5, headDip * 0.5 + feedSize * 0.15);
            ctx.closePath();
            ctx.fill();
            
        } else {
            ctx.rotate(atan2(this.vy, this.vx));
            ctx.scale(1, 1-abs(this.bank)*0.3);
            
            const spd = sqrt(this.vx*this.vx+this.vy*this.vy);
            const stretch = min(spd/60, 1.8);
            const flapInt = this.huntPhase === 2 ? 0.1 : (this.huntPhase === 6 ? 0.6 : 0.4);
            const flap = fsin(this.wingPhase) * flapInt * (1-this.huntCRR.smoothAmp*0.5);
            
            ctx.fillStyle = 'rgba(15,12,18,0.92)';
            
            ctx.beginPath(); 
            ctx.ellipse(0, 0, this.size*stretch*1.2, this.size*0.5, 0, 0, PI2); 
            ctx.fill();
            
            const ws = this.wingSpan * (this.size / this.baseSize);
            const sweep = 0.3 + this.huntCRR.smoothAmp*0.2;
            ctx.beginPath();
            ctx.moveTo(-this.size*0.3,0);
            ctx.quadraticCurveTo(-this.size*0.5,-ws*0.4*(1+flap),-this.size*sweep,-ws*(0.8+flap*0.15));
            ctx.quadraticCurveTo(this.size*0.3,-ws*0.3*(1+flap),this.size*0.4,0);
            ctx.quadraticCurveTo(this.size*0.3,ws*0.3*(1+flap),-this.size*sweep,ws*(0.8+flap*0.15));
            ctx.quadraticCurveTo(-this.size*0.5,ws*0.4*(1+flap),-this.size*0.3,0);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-this.size*stretch,0);
            ctx.lineTo(-this.size*stretch-this.size*1.2,-this.size*0.4);
            ctx.lineTo(-this.size*stretch-this.size*0.8,0);
            ctx.lineTo(-this.size*stretch-this.size*1.2,this.size*0.4);
            ctx.closePath(); 
            ctx.fill();
            
            ctx.beginPath(); 
            ctx.arc(this.size*stretch*0.8, 0, this.size*0.35, 0, PI2); 
            ctx.fill();
        }
        
        ctx.restore();
        
        if (this.huntPhase > 0 && this.huntPhase < 4) {
            ctx.strokeStyle = `rgba(255,100,50,${0.1+this.huntCRR.smoothAmp*0.2})`;
            ctx.lineWidth = 1; ctx.beginPath();
            ctx.arc(this.x,this.y,30+this.huntCRR.smoothAmp*20,0,PI2); ctx.stroke();
        }
    }
    
    stateName() { return ['soar','stalk','DIVE','recover','descend','FEED','takeoff'][this.huntPhase]; }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENHANCED STARLINGS - Topological neighbors + turning waves + TIGHT FLOCKING
// Optimized for 400+ birds at 60fps
// ═══════════════════════════════════════════════════════════════════════════════
class Bird {
    constructor(x, y, flock) {
        this.crr = new CRR(0.06 + random() * 0.05, 1.0);
        this.flock = flock;
        this.x = x; this.y = y;
        // Gentler initial velocity - let cohesion build first
        this.vx = (random() - 0.5) * 25; 
        this.vy = (random() - 0.5) * 15;
        // Target velocity for smooth turning waves
        this.tvx = this.vx;
        this.tvy = this.vy;
        this.size = 1.0 + random() * 0.3;
        this.wph = random() * PI2; 
        this.wsp = 12 + random() * 5;
        this.st = 0; // 0=flying, 1=landing, 2=perched, 3=takeoff
        this.perch = null; 
        this.perchT = 0; 
        this.timer = 0;
        this.react = 0.85 + random() * 0.3;
        // Local density tracking
        this.localDensity = 0;
        // Angular momentum for swirling
        this.angMom = 0;
    }
    
    update(dt, allBirds, attrs, scare, perches, pred, flockTurnDir, flockAngMom, flockCenterX, flockCenterY) {
        this.timer += dt;
        this.wph += this.wsp * dt;  // Always update wing phase
        
        // ═══════════════════════════════════════════════════════════════════
        // STATE: PERCHED
        // ═══════════════════════════════════════════════════════════════════
        if (this.st === 2) {
            this.perchT += dt;
            
            // Check every 0.4 seconds for takeoff conditions
            if (this.timer > 0.4) {
                this.timer = 0;
                
                const scared = scare && sqrt((this.x-scare.x)**2+(this.y-scare.y)**2) < scare.r * 1.3;
                const predFlying = pred && pred.huntPhase !== 5;
                const predNear = predFlying && sqrt((this.x-pred.x)**2+(this.y-pred.y)**2) < 180;
                const flockRupture = this.flock.st === 1;
                const rainStopped = weather.rainIntensity < 0.2 && this.perchT > 2;
                
                // Natural takeoff timing - some birds rest briefly, others longer
                const minRestTime = 3 + this.react * 4;  // 3-7 seconds minimum
                const restless = this.perchT > minRestTime && random() < 0.03;
                const veryRestless = this.perchT > 12 && random() < 0.06;
                
                // Rejoin flock periodically
                const shouldRejoin = this.perchT > 5 && random() < 0.012;
                
                if (scared || predNear || flockRupture || rainStopped || restless || veryRestless || shouldRejoin) {
                    this.st = 3;  // Takeoff
                    this.vy = -28 - random() * 18;
                    this.vx = (random() - 0.5) * 25 - 12;  // Bias toward flock center (left)
                    this.tvx = this.vx;
                    this.tvy = this.vy;
                    if (this.perch) {
                        this.perch.occ = false;
                        this.perch = null;
                    }
                }
            }
            return;
        }
        
        this.crr.update(dt, this.st === 0 ? 1 : 0.3);
        
        // ═══════════════════════════════════════════════════════════════════
        // STATE: TAKEOFF
        // ═══════════════════════════════════════════════════════════════════
        if (this.st === 3) {
            this.vy -= 40 * dt;  // Upward boost
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            if (this.timer > 0.35) {
                this.st = 0;
                this.tvx = this.vx;
                this.tvy = this.vy;
            }
            return;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // STATE: LANDING
        // ═══════════════════════════════════════════════════════════════════
        if (this.st === 1) {
            if (!this.perch) {
                this.st = 0;
                return;
            }
            const dx = this.perch.x - this.x;
            const dy = this.perch.y - this.y;
            const d = sqrt(dx*dx + dy*dy);
            
            if (d < 3) {
                this.st = 2;  // Landed
                this.x = this.perch.x;
                this.y = this.perch.y;
                this.vx = this.vy = 0;
                this.perchT = 0;
            } else {
                const landSpeed = min(d * 2.5, 60);
                this.vx = dx / d * landSpeed;
                this.vy = dy / d * landSpeed;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            return;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // TOPOLOGICAL NEIGHBOR SELECTION (k=7 nearest) - VERY TIGHT DISTANCES
        // ═══════════════════════════════════════════════════════════════════
        const candidates = getCandidates(this.x, this.y);
        const K_NEIGHBORS = 7;
        
        // Collect all flying birds with distances
        const neighbors = [];
        for (const i of candidates) {
            const o = allBirds[i];
            if (o === this || o.st !== 0) continue;
            const dx = o.x - this.x;
            const dy = o.y - this.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < 100*100) { // Slightly larger range for better connectivity
                neighbors.push({ bird: o, d2, dx, dy, d: sqrt(d2) });
            }
        }
        
        // Sort by distance, take k nearest
        neighbors.sort((a, b) => a.d2 - b.d2);
        const kNearest = neighbors.slice(0, K_NEIGHBORS);
        
        // Calculate local density
        this.localDensity = kNearest.length > 0 ? 
            K_NEIGHBORS / (kNearest[kNearest.length-1]?.d || 30) : 0;
        
        // ═══════════════════════════════════════════════════════════════════
        // FLOCKING FORCES - Tight cohesion with choreography multipliers
        // ═══════════════════════════════════════════════════════════════════
        const fm = min(this.flock.mem() / 4, 2.0);
        const choreo = this.flock.getChoreo();
        const cohesionMult = choreo ? choreo.cohesionMult : 1.0;
        const separationMult = choreo && choreo.separationMult ? choreo.separationMult : 1.0;
        
        let sx = 0, sy = 0;
        let ax = 0, ay = 0;
        let cx = 0, cy = 0;
        let angSum = 0;
        let nc = 0;
        
        for (const n of kNearest) {
            const { bird: o, d, dx, dy } = n;
            
            // SEPARATION - modulated by choreography
            if (d < 12 * separationMult && d > 0) {
                const f = (12 * separationMult - d) / (12 * separationMult) / (this.crr.omega * 5);
                sx -= dx/d * f;
                sy -= dy/d * f;
            }
            
            ax += o.vx;
            ay += o.vy;
            cx += o.x;
            cy += o.y;
            angSum += o.angMom;
            nc++;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // GLOBAL FLOCK COHESION - pulls isolated birds back to main flock
        // ═══════════════════════════════════════════════════════════════════
        if (nc < 4) {
            // Bird has few neighbors - strongly attract to global flock center
            const globalPull = (4 - nc) * 0.015;  // Stronger when more isolated
            this.tvx += (flockCenterX - this.x) * globalPull;
            this.tvy += (flockCenterY - this.y) * globalPull;
        }
        
        if (nc > 0) {
            // Separation
            this.tvx += sx * 1.6 * this.react;
            this.tvy += sy * 1.6 * this.react;
            
            // STRONG Alignment
            const af = (0.14 + fm * 0.12) * this.react;
            this.tvx += (ax/nc - this.vx) * af;
            this.tvy += (ay/nc - this.vy) * af;
            
            // VERY STRONG Cohesion - multiplied by choreography
            const cf = (0.035 + fm * 0.030) * this.react * cohesionMult;
            this.tvx += (cx/nc - this.x) * cf;
            this.tvy += (cy/nc - this.y) * cf;
            
            // Angular momentum from neighbors + choreography
            const choreoAng = choreo ? choreo.angularMom * 0.3 : 0;
            this.angMom = lerp(this.angMom, angSum / nc + choreoAng, 0.12);
        } else {
            // No neighbors at all - strong pull to flock center
            this.tvx += (flockCenterX - this.x) * 0.05;
            this.tvy += (flockCenterY - this.y) * 0.05;
        }
        
        // Apply angular momentum as perpendicular velocity
        if (abs(this.angMom) > 0.01) {
            const spd = sqrt(this.vx*this.vx + this.vy*this.vy);
            if (spd > 5) {
                const perpX = -this.vy / spd;
                const perpY = this.vx / spd;
                this.tvx += perpX * this.angMom * 0.8;
                this.tvy += perpY * this.angMom * 0.8;
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // COLLECTIVE TURN on flock rupture - with angular momentum
        // ═══════════════════════════════════════════════════════════════════
        if (flockTurnDir && this.flock.st === 1) {
            const turnStrength = 0.18 * this.react;
            this.tvx += flockTurnDir.x * turnStrength;
            this.tvy += flockTurnDir.y * turnStrength;
            // Add swirl
            this.angMom += flockAngMom * 0.3;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // DYNAMIC ATTRACTORS - reduced, choreography now drives movement
        // ═══════════════════════════════════════════════════════════════════
        for (const a of attrs) { 
            const dx = a.x - this.x;
            const dy = a.y - this.y;
            const d = sqrt(dx*dx + dy*dy); 
            if (d > 0 && d < 300) {
                const strength = (1 - d/300) * 0.4 * a.s;
                this.tvx += dx/d * strength;
                this.tvy += dy/d * strength;
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // CHOREOGRAPHY-DRIVEN GRAVITY - pull toward pattern target
        // ═══════════════════════════════════════════════════════════════════
        let targetX = W * 0.5;
        let targetY = H * 0.38;
        
        // Use choreography target if available
        if (choreo) {
            targetX = choreo.targetX;
            targetY = choreo.targetY;
            
            // Handle split mode - birds attracted to one of two points
            if (choreo.splitMode && choreo.splitDist > 20) {
                // Split based on bird position relative to center
                const side = this.x > W * 0.5 ? 1 : -1;
                targetX = W * 0.5 + side * choreo.splitDist;
            }
            
            // Vertical bias for column move
            if (choreo.verticalBias) {
                this.tvy += choreo.verticalBias * 1.5;
            }
        }
        
        // Rain shifts target toward tree
        if (weather.rainIntensity > 0.3) {
            const rainPull = weather.rainIntensity * 0.35;
            targetX = lerp(targetX, W * 0.75, rainPull);
            targetY = lerp(targetY, H * 0.45, rainPull);
        }
        
        const toCenterX = targetX - this.x;
        const toCenterY = targetY - this.y;
        const distFromCenter = sqrt(toCenterX*toCenterX + toCenterY*toCenterY);
        const gravityStrength = 0.08 + 0.28 * max(0, (distFromCenter - 60) / 200);
        this.tvx += toCenterX / max(distFromCenter, 1) * gravityStrength;
        this.tvy += toCenterY / max(distFromCenter, 1) * gravityStrength;
        
        // ═══════════════════════════════════════════════════════════════════
        // PREDATOR AVOIDANCE
        // ═══════════════════════════════════════════════════════════════════
        if (pred && pred.huntPhase !== 5) {
            const dx = this.x - pred.x;
            const dy = this.y - pred.y;
            const d = sqrt(dx*dx + dy*dy);
            if (d < 200 && d > 0) {
                const f = (200 - d) / 200 * 120;
                this.tvx += dx/d * f;
                this.tvy += dy/d * f;
                // Add swirl away from predator
                if (d < 100) {
                    this.angMom += (random() > 0.5 ? 1 : -1) * 2;
                }
                if (d < 80) this.crr.rupture();
            }
        }
        
        // STARTLE
        if (scare) { 
            const dx = this.x - scare.x;
            const dy = this.y - scare.y;
            const d = sqrt(dx*dx + dy*dy); 
            if (d < scare.r && d > 0) {
                this.tvx += dx/d * (scare.r-d)/scare.r * 70;
                this.tvy += dy/d * (scare.r-d)/scare.r * 70;
                this.angMom += (random() > 0.5 ? 1 : -1) * 3;
                this.crr.rupture();
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // TURNING WAVE - smooth velocity update
        // ═══════════════════════════════════════════════════════════════════
        const turnLerp = min(1, dt * (10 + this.localDensity * 3));
        this.vx = lerp(this.vx, this.tvx, turnLerp);
        this.vy = lerp(this.vy, this.tvy, turnLerp);
        
        // Decay angular momentum
        this.angMom *= 0.98;
        
        // Boundary forces - MUCH STRONGER to keep flock on screen
        const margin = 0.08;
        const boundaryForce = 8;
        if (this.x < W * margin) this.vx += boundaryForce * (1 - this.x / (W * margin));
        if (this.x > W * (1 - margin)) this.vx -= boundaryForce * (1 - (W - this.x) / (W * margin));
        if (this.y < H * margin) this.vy += boundaryForce * (1 - this.y / (H * margin));
        if (this.y > H * 0.75) this.vy -= boundaryForce * (1 - (H * 0.88 - this.y) / (H * 0.13));
        
        // Speed limits - moderate speed keeps flock cohesive
        const spd = sqrt(this.vx*this.vx + this.vy*this.vy);
        if (spd > 75) { 
            this.vx = this.vx/spd * 75; 
            this.vy = this.vy/spd * 75; 
        } else if (spd < 18 && spd > 0) { 
            this.vx = this.vx/spd * 18; 
            this.vy = this.vy/spd * 18; 
        }
        
        // Update position
        this.x += this.vx * dt; 
        this.y += this.vy * dt;
        
        // ═══════════════════════════════════════════════════════════════════
        // PERCHING LOGIC - natural tree landing behavior
        // ═══════════════════════════════════════════════════════════════════
        const predatorFeeding = pred && pred.huntPhase === 5;
        const raining = weather.rainIntensity > 0.4;
        const nearTree = this.x > W * 0.6;
        const veryNearTree = this.x > W * 0.72 && this.y > H * 0.45;
        const movingSlow = spd < 35;
        
        // Calculate perch chance based on conditions
        let perchChance = 0;
        
        if (veryNearTree) {
            // Very close to tree - higher chance to land
            if (raining) {
                perchChance = 0.004;  // Seek shelter
            } else if (predatorFeeding) {
                perchChance = 0.003;
            } else if (movingSlow) {
                perchChance = 0.002;  // Natural resting
            } else {
                perchChance = 0.0008;  // Occasional landing even when active
            }
        } else if (nearTree) {
            // Near tree area
            if (raining) {
                perchChance = 0.0015;
            } else if (predatorFeeding) {
                perchChance = 0.001;
            } else if (movingSlow && this.y > H * 0.5) {
                perchChance = 0.0005;
            }
        }
        
        // Slight randomness - some birds are more likely to perch
        if (this.react < 0.95) {
            perchChance *= 1.3;  // Less reactive birds perch more
        }
        
        if (random() < perchChance) {
            // Find nearest available perch
            let best = null;
            let bestD = veryNearTree ? 80 : 120;
            
            for (const p of perches) {
                if (p.occ) continue;
                const d = sqrt((this.x - p.x)**2 + (this.y - p.y)**2);
                if (d < bestD) {
                    bestD = d;
                    best = p;
                }
            }
            
            if (best) {
                this.st = 1;
                this.perch = best;
                best.occ = true;
                this.timer = 0;
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BIRD DRAWING - Beautiful flapping wings, ALL states visible
// ═══════════════════════════════════════════════════════════════════════════════
function drawBirds(birds) {
    ctx.fillStyle = 'rgba(18,18,24,0.9)';
    
    for (const b of birds) {
        // ═══════════════════════════════════════════════════════════════════
        // PERCHED - sitting still on branch
        // ═══════════════════════════════════════════════════════════════════
        if (b.st === 2) {
            ctx.save();
            ctx.translate(b.x, b.y);
            
            // Body - slightly puffed when perched
            ctx.beginPath();
            ctx.ellipse(0, 0, b.size * 1.1, b.size * 0.9, 0, 0, PI2);
            ctx.fill();
            
            // Folded wings - subtle tuck
            ctx.beginPath();
            ctx.ellipse(b.size * 0.2, 0, b.size * 0.8, b.size * 0.5, 0.2, 0, PI2);
            ctx.fill();
            
            ctx.restore();
            continue;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // FLYING / LANDING / TAKEOFF - with flapping wings
        // ═══════════════════════════════════════════════════════════════════
        const angle = atan2(b.vy, b.vx);
        const spd = sqrt(b.vx*b.vx + b.vy*b.vy);
        
        // Wing flap speed varies by state
        let flapMult = 1.0;
        if (b.st === 3) flapMult = 1.4;  // Faster flapping on takeoff
        if (b.st === 1) flapMult = 0.7;  // Slower on landing approach
        
        const flap = fsin(b.wph * flapMult) * 0.45;
        
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(angle);
        
        // Body - elongates with speed
        const stretch = 1 + min(spd / 120, 0.35);
        ctx.beginPath();
        ctx.ellipse(0, 0, b.size * 1.35 * stretch, b.size * 0.5, 0, 0, PI2);
        ctx.fill();
        
        // Wings with beautiful flapping motion
        const ws = b.size * 2.6;
        const wingLift = 0.42 + flap * 0.38;
        
        ctx.beginPath();
        // Right wing (top in flight direction)
        ctx.moveTo(-b.size * 0.25, 0);
        ctx.quadraticCurveTo(
            -b.size * 0.05, -ws * wingLift * 0.55,
            b.size * 0.35, -ws * wingLift
        );
        ctx.quadraticCurveTo(
            b.size * 0.18, -ws * wingLift * 0.25,
            b.size * 0.12, 0
        );
        // Left wing (bottom in flight direction)
        ctx.quadraticCurveTo(
            b.size * 0.18, ws * wingLift * 0.25,
            b.size * 0.35, ws * wingLift
        );
        ctx.quadraticCurveTo(
            -b.size * 0.05, ws * wingLift * 0.55,
            -b.size * 0.25, 0
        );
        ctx.fill();
        
        ctx.restore();
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENHANCED FLOCK - CRR collective coherence with choreographed moves
// ═══════════════════════════════════════════════════════════════════════════════
class Flock {
    constructor() {
        this.crr = new CRR(0.6, 0.22);  // Slightly faster cycles for more moves
        this.st = 0;
        this.turnDir = { x: 0, y: 0 };
        this.angularMomentum = 0;
        this.lastRuptureTime = 0;
        this.choreoMods = null;  // Current choreography modifiers
    }
    
    update(dt, birds) {
        const prevSt = this.crr.st;
        this.crr.update(dt, 0.5);
        this.st = this.crr.st;
        
        // Calculate flock center
        let cx = 0, cy = 0, count = 0;
        let avgVx = 0, avgVy = 0;
        for (const b of birds) {
            if (b.st === 0) {
                cx += b.x; cy += b.y;
                avgVx += b.vx; avgVy += b.vy;
                count++;
            }
        }
        if (count > 0) {
            cx /= count; cy /= count;
            avgVx /= count; avgVy /= count;
        }
        
        // On rupture, trigger new choreographed move
        if (this.crr.st === 1 && prevSt === 0) {
            Choreographer.onRupture();
            
            // Calculate turn direction based on new move
            const turnSign = random() > 0.5 ? 1 : -1;
            const turnAngle = turnSign * (PI/3 + random() * PI/4);
            const mag = sqrt(avgVx*avgVx + avgVy*avgVy);
            const baseAngle = atan2(avgVy, avgVx);
            const newAngle = baseAngle + turnAngle;
            
            this.turnDir.x = cos(newAngle) * mag * 0.5;
            this.turnDir.y = sin(newAngle) * mag * 0.5;
            this.angularMomentum = turnSign * (1.5 + random() * 2);
            this.lastRuptureTime = time;
        }
        
        // Update choreography
        this.choreoMods = Choreographer.update(dt, cx, cy);
        
        // Apply choreography angular momentum
        if (this.choreoMods) {
            this.angularMomentum = lerp(this.angularMomentum, this.choreoMods.angularMom, dt * 2);
        }
        
        // Fade turn direction
        const fadeTime = time - this.lastRuptureTime;
        if (fadeTime > 0.4) {
            this.turnDir.x *= 0.94;
            this.turnDir.y *= 0.94;
        }
    }
    
    mem() { return this.crr.mem(); }
    rupture() { this.crr.rupture(); }
    stateName() { return this.crr.stateName(); }
    getTurnDir() { 
        const mag = sqrt(this.turnDir.x**2 + this.turnDir.y**2);
        return mag > 0.1 ? this.turnDir : null; 
    }
    getAngularMomentum() {
        return this.angularMomentum;
    }
    getChoreo() {
        return this.choreoMods;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MURMURATION CHOREOGRAPHER - CRR-driven classic patterns
// Each flock rupture triggers a new move from the repertoire
// ═══════════════════════════════════════════════════════════════════════════════
const Choreographer = {
    // Move repertoire - each is a classic murmuration pattern
    moves: [
        'vortex',      // Swirling spiral
        'wave',        // Sinusoidal wave propagation
        'split',       // Divide and reunite
        'breathe',     // Expand and contract
        'ribbon',      // Figure-8 twist
        'column',      // Vertical rise
        'sweep',       // Horizontal sweep
        'tornado'      // Tight spinning column
    ],
    
    currentMove: 'vortex',
    moveIndex: 0,
    moveTime: 0,
    moveDuration: 0,
    
    // Move-specific state
    vortexSign: 1,
    splitPhase: 0,
    breathePhase: 0,
    ribbonPhase: 0,
    sweepDir: 1,
    
    // Initialize
    init() {
        this.moveIndex = floor(random() * this.moves.length);
        this.currentMove = this.moves[this.moveIndex];
        this.moveTime = 0;
        this.moveDuration = 4 + random() * 4;
        this.vortexSign = random() > 0.5 ? 1 : -1;
    },
    
    // Called on flock CRR rupture - select next move
    onRupture() {
        // Cycle through moves, occasionally random
        if (random() < 0.3) {
            this.moveIndex = floor(random() * this.moves.length);
        } else {
            this.moveIndex = (this.moveIndex + 1) % this.moves.length;
        }
        this.currentMove = this.moves[this.moveIndex];
        this.moveTime = 0;
        this.moveDuration = 4 + random() * 5;
        
        // Reset move-specific state
        this.vortexSign = random() > 0.5 ? 1 : -1;
        this.splitPhase = 0;
        this.breathePhase = 0;
        this.sweepDir = random() > 0.5 ? 1 : -1;
    },
    
    // Update and return forces to apply to birds
    update(dt, flockCenterX, flockCenterY) {
        this.moveTime += dt;
        
        // Return movement modifiers based on current pattern
        const t = this.moveTime;
        const phase = (t / this.moveDuration) * PI2;
        
        // Occasionally bias the flock toward tree area for natural perching
        const treeVisitBias = sin(t * 0.15) > 0.7 ? 0.15 : 0;  // ~30% of time drifts toward tree
        const baseX = W * (0.5 + treeVisitBias);
        
        switch (this.currentMove) {
            case 'vortex':
                // Swirling spiral - constant angular momentum
                return {
                    angularMom: this.vortexSign * 2.5,
                    targetX: baseX + cos(t * 0.3) * 80,
                    targetY: H * 0.38 + sin(t * 0.4) * 40,
                    cohesionMult: 1.3,
                    name: 'Vortex Spiral'
                };
                
            case 'wave':
                // Sinusoidal wave - oscillating vertical bias
                return {
                    angularMom: sin(t * 2) * 1.5,
                    targetX: baseX + sin(t * 0.5) * 140,
                    targetY: H * 0.38 + sin(t * 1.5) * 60,
                    cohesionMult: 1.2,
                    name: 'Wave Flow'
                };
                
            case 'split':
                // Split and merge - two attractors
                this.splitPhase = sin(t * 0.8);
                const splitDist = abs(this.splitPhase) * 110;
                return {
                    angularMom: 0,
                    targetX: baseX + (this.splitPhase > 0 ? splitDist : -splitDist) * 0.3,
                    targetY: H * 0.38,
                    splitMode: true,
                    splitDist: splitDist,
                    cohesionMult: 1.0 + abs(this.splitPhase) * 0.3,
                    name: 'Split & Merge'
                };
                
            case 'breathe':
                // Expand and contract - pulsing cohesion
                this.breathePhase = sin(t * 1.2);
                return {
                    angularMom: this.breathePhase * 0.8,
                    targetX: baseX,
                    targetY: H * 0.38,
                    cohesionMult: 0.7 + (1 + this.breathePhase) * 0.5,
                    separationMult: 1.5 - this.breathePhase * 0.4,
                    name: 'Breathe'
                };
                
            case 'ribbon':
                // Figure-8 twist
                this.ribbonPhase = t * 0.6;
                return {
                    angularMom: cos(this.ribbonPhase * 2) * 2,
                    targetX: baseX + sin(this.ribbonPhase) * 160,
                    targetY: H * 0.38 + sin(this.ribbonPhase * 2) * 70,
                    cohesionMult: 1.4,
                    name: 'Ribbon Twist'
                };
                
            case 'column':
                // Vertical rise and fall
                const columnY = sin(t * 0.7) * 100;
                return {
                    angularMom: sin(t * 3) * 0.5,
                    targetX: baseX + sin(t * 0.4) * 60,
                    targetY: H * 0.35 + columnY,
                    cohesionMult: 1.5,
                    verticalBias: cos(t * 0.7) * 0.8,
                    name: 'Column Rise'
                };
                
            case 'sweep':
                // Horizontal sweep across screen - visits tree area
                const sweepX = sin(t * 0.4) * (W * 0.32);
                return {
                    angularMom: -this.sweepDir * cos(t * 0.4) * 1.5,
                    targetX: W * 0.5 + sweepX,
                    targetY: H * 0.38 + cos(t * 0.8) * 40,
                    cohesionMult: 1.3,
                    name: 'Horizontal Sweep'
                };
                
            case 'tornado':
                // Tight spinning column
                return {
                    angularMom: this.vortexSign * 4,
                    targetX: baseX + cos(t * 0.2) * 40,
                    targetY: H * 0.38 + sin(t * 0.5) * 80,
                    cohesionMult: 1.8,
                    name: 'Tornado'
                };
                
            default:
                return {
                    angularMom: 0,
                    targetX: baseX,
                    targetY: H * 0.38,
                    cohesionMult: 1.0,
                    name: 'Default'
                };
        }
    }
};
// ═══════════════════════════════════════════════════════════════════════════════
let attrs = [];

function updateAttractors(dt) {
    // Attractors orbit around CENTER of flying area - keeps flock visible
    const centerX = W * 0.5;
    const centerY = H * 0.38;
    
    for (let i = 0; i < attrs.length; i++) {
        const a = attrs[i];
        const phase = time * a.orbitSpeed + a.orbitPhase;
        a.x = centerX + cos(phase) * a.orbitRadius;
        a.y = centerY + sin(phase) * a.orbitRadius * 0.4 + 
              sin(phase * 2 + a.orbitPhase) * 25;
        
        // Keep attractors within bounds
        a.x = clamp(a.x, W * 0.15, W * 0.85);
        a.y = clamp(a.y, H * 0.12, H * 0.65);
    }
}

function initAttractors() {
    attrs = [
        { x: 0, y: 0, s: 1.0, orbitRadius: 140, orbitSpeed: 0.15, orbitPhase: 0 },
        { x: 0, y: 0, s: 0.7, orbitRadius: 100, orbitSpeed: -0.22, orbitPhase: PI * 0.7 },
        { x: 0, y: 0, s: 0.8, orbitRadius: 160, orbitSpeed: 0.10, orbitPhase: PI * 1.3 }
    ];
}

// ═══════════════════════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════════
let tree, grass, birds = [], flock, pred, scare = null;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

function init() {
    resize();
    sunrise.init();
    weather.init();
    atmosphere.cur = { top: atmosphere.colors.nightTop, mid: atmosphere.colors.nightMid, hor: atmosphere.colors.nightHor };
    initClouds();
    initAttractors();
    
    const grassY = H * 0.88;
    tree = new Tree(W * 0.82, grassY, H * 0.52);
    grass = new Grass(grassY, W, H);
    
    flock = new Flock();
    birds = [];
    Choreographer.init();
    
    // 500 BIRDS centered on screen in tight cluster
    const cx = W * 0.5, cy = H * 0.35;
    const BIRD_COUNT = 500;
    for (let i = 0; i < BIRD_COUNT; i++) {
        const a = random() * PI2;
        // Very tight initial radius - creates ribbon-like starting formation
        const r = random() * random() * random() * 60; // Cubed random = very concentrated center
        birds.push(new Bird(cx + cos(a) * r, cy + sin(a) * r * 0.35, flock));
    }
    
    pred = new Predator(W * 0.15, H * 0.25);
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════════
let lastTime = 0, frameCount = 0, fpsTime = 0, showDebug = false, showMath = false;
let lastPredState = 0;

function frame(timestamp) {
    const dt = min(0.05, (timestamp - lastTime) / 1000);
    lastTime = timestamp;
    time += dt;
    
    frameCount++;
    fpsTime += dt;
    if (fpsTime >= 0.5) {
        const fps = frameCount / fpsTime;
        document.getElementById('fps').textContent = fps.toFixed(0) + ' FPS';
        document.getElementById('fps').className = 'fps' + (fps < 30 ? ' bad' : fps < 50 ? ' warn' : '');
        frameCount = 0; fpsTime = 0;
    }
    
    const t0 = performance.now();
    
    // Update
    sunrise.update(dt);
    weather.update(dt, sunrise.phase);
    atmosphere.update(dt, sunrise.phase);
    updateClouds(dt);
    updateAttractors(dt);
    
    const wind = 0.5 + sunrise.phase * 0.5;
    tree.update(dt, wind);
    grass.update(dt);
    
    flock.update(dt, birds);
    buildHash(birds);
    
    const flockTurnDir = flock.getTurnDir();
    const flockAngMom = flock.getAngularMomentum();
    
    // Calculate global flock center for reuniting separated birds
    let flockCenterX = 0, flockCenterY = 0;
    let flyingCount = 0;
    for (const b of birds) {
        if (b.st === 0) {
            flockCenterX += b.x;
            flockCenterY += b.y;
            flyingCount++;
        }
    }
    if (flyingCount > 0) {
        flockCenterX /= flyingCount;
        flockCenterY /= flyingCount;
    } else {
        flockCenterX = W * 0.5;
        flockCenterY = H * 0.38;
    }
    
    for (const b of birds) {
        b.update(dt, birds, attrs, scare, tree.perches, pred, flockTurnDir, flockAngMom, flockCenterX, flockCenterY);
    }
    
    pred.update(dt, birds, flock, grass.gy, tree);
    
    // Sound
    const predStateChanged = pred.huntPhase !== lastPredState;
    const falconCryTrigger = predStateChanged && (pred.huntPhase === 2 || pred.huntPhase === 6);
    if (falconCryTrigger && soundSystem.enabled) {
        soundSystem.falconCry();
    }
    lastPredState = pred.huntPhase;
    
    soundSystem.update(dt, weather.rainIntensity, 0.5 + sunrise.phase * 0.5, sunrise.phase, pred.huntPhase, flock.st === 1);
    
    if (scare) {
        scare.r += dt * 80;
        scare.alpha -= dt * 0.8;
        if (scare.alpha <= 0) scare = null;
    }
    
    // Draw
    atmosphere.draw();
    weather.drawRainbow(W * sunrise.x, H * sunrise.y);
    drawClouds();
    sunrise.draw();
    sunrise.drawLensFlare();
    weather.drawRain();
    tree.draw();
    drawBirds(birds);
    pred.draw();
    grass.draw();
    
    if (scare) {
        ctx.strokeStyle = `rgba(255,200,100,${scare.alpha * 0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(scare.x, scare.y, scare.r, 0, PI2);
        ctx.stroke();
    }
    
    const updMs = performance.now() - t0;
    
    // Debug
    if (showDebug) {
        const flying = birds.filter(b => b.st === 0).length;
        const perched = birds.filter(b => b.st === 2).length;
        
        // Calculate average density
        let totalDensity = 0;
        for (const b of birds) if (b.st === 0) totalDensity += b.localDensity;
        const avgDensity = flying > 0 ? (totalDensity / flying).toFixed(2) : '0';
        
        document.getElementById('sunPhase').textContent = sunrise.phase.toFixed(2);
        document.getElementById('weatherState').textContent = weather.stateName();
        document.getElementById('rainInt').textContent = (weather.rainIntensity * 100).toFixed(0) + '%';
        document.getElementById('rainbowVis').textContent = (weather.rainbowVisible * 100).toFixed(0) + '%';
        document.getElementById('soundState').textContent = soundSystem.enabled ? 'ON' : 'OFF (press s)';
        document.getElementById('flockCoh').textContent = (flock.crr.C / flock.crr.omega).toFixed(2);
        document.getElementById('flockState').textContent = flock.stateName();
        document.getElementById('currentMove').textContent = Choreographer.currentMove;
        document.getElementById('flockDensity').textContent = avgDensity;
        document.getElementById('birds').textContent = `${flying}/${perched}`;
        document.getElementById('predState').textContent = pred.stateName();
        document.getElementById('predCoh').textContent = (pred.huntCRR.C / pred.huntCRR.omega).toFixed(2);
        document.getElementById('upd').textContent = updMs.toFixed(1);
    }
    
    requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════════
// EVENTS
// ═══════════════════════════════════════════════════════════════════════════════
window.addEventListener('resize', () => {
    resize();
    grass = new Grass(H * 0.88, W, H);
});

canvas.addEventListener('click', (e) => {
    scare = { x: e.clientX, y: e.clientY, r: 30, alpha: 1 };
    flock.rupture();
    soundSystem.flockStartle();
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'c') {
        showDebug = !showDebug;
        document.getElementById('debug').classList.toggle('show', showDebug);
    }
    if (e.key === 'm') {
        showMath = !showMath;
        document.getElementById('mathPanel').classList.toggle('show', showMath);
    }
    if (e.key === 'r') {
        weather.manualRain = !weather.manualRain;
        if (weather.manualRain && weather.state === 0) {
            weather.state = 1;
        } else if (!weather.manualRain && weather.state === 2) {
            weather.state = 3;
        }
    }
    if (e.key === 's') {
        const enabled = soundSystem.toggle();
        console.log('Sound:', enabled ? 'ON' : 'OFF');
    }
});

// Start
init();
requestAnimationFrame(frame);

</script>
</body>
</html>
