<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Black Hole Physics - Coherence Rupture Regeneration</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #ffffff;
            color: #1a1a1a;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
        }

        .main-container {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.06);
            max-width: 1400px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .header .subtitle {
            color: #666666;
            font-size: 1rem;
            font-weight: 400;
            margin-bottom: 20px;
        }

        .equation-banner {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            font-family: 'Georgia', monospace;
            font-size: 0.95rem;
            color: #495057;
            margin-bottom: 30px;
        }

        /* Mathematical Explainer Styles */
        .math-explainer-container {
            margin-bottom: 30px;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            overflow: hidden;
        }

        .math-explainer-header {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .math-explainer-header:hover {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e3a8a 100%);
        }

        .math-explainer-header h3 {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .math-explainer-toggle {
            font-size: 1.5rem;
            transition: transform 0.3s ease;
        }

        .math-explainer-toggle.open {
            transform: rotate(180deg);
        }

        .math-explainer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
            background: #f8f9fa;
        }

        .math-explainer-content.open {
            max-height: 3000px;
        }

        .math-section {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .math-section:last-child {
            border-bottom: none;
        }

        .math-section h4 {
            color: #2563eb;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .equation-block {
            background: white;
            border-left: 4px solid #2563eb;
            padding: 16px;
            margin: 12px 0;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
        }

        .equation-title {
            color: #1e40af;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .equation-formula {
            font-size: 1.1rem;
            color: #1a1a1a;
            margin: 8px 0;
            line-height: 1.6;
        }

        .equation-description {
            color: #666666;
            font-size: 0.85rem;
            margin-top: 8px;
            font-family: 'Inter', sans-serif;
            line-height: 1.5;
        }

        .mapping-arrow {
            text-align: center;
            color: #2563eb;
            font-size: 1.5rem;
            margin: 12px 0;
        }

        .code-snippet {
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            margin: 12px 0;
        }

        .code-comment {
            color: #888888;
        }

        .code-keyword {
            color: #ff79c6;
        }

        .code-function {
            color: #50fa7b;
        }

        .code-number {
            color: #bd93f9;
        }

        .code-string {
            color: #f1fa8c;
        }

        .approximation-notice {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            font-size: 0.85rem;
        }

        .approximation-notice strong {
            color: #856404;
        }

        .equation-overlay {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
        }

        .current-equation {
            font-family: 'Courier New', monospace;
            font-size: 1.4rem;
            color: #2563eb;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .equation-description-text {
            font-size: 0.85rem;
            color: #666666;
            line-height: 1.4;
        }

        .simulation-area {
            position: relative;
            width: 100%;
            height: 750px;
            background: radial-gradient(circle at center, #000000, #0a0015);
            border: 1px solid #e0e0e0;
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        #blackhole-canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 16px;
        }

        .system-legend {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #495057;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 10px;
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
        }

        .metric-card h3 {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .metric-label {
            color: #6c757d;
        }

        .metric-value {
            font-weight: 500;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            color: #374151;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #f9fafb;
            border-color: #2563eb;
            color: #2563eb;
            transform: translateY(-1px);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .blackhole-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #333333;
            backdrop-filter: blur(25px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            font-size: 12px;
        }

        .blackhole-controls .title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffffff;
            font-size: 14px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .bh-control-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }

        .bh-control-group label {
            min-width: 120px;
            color: #cccccc;
            font-size: 11px;
        }

        .bh-control-group input[type="range"] {
            flex: 1;
            height: 6px;
            background: linear-gradient(to right, #333333, #666666);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .bh-control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        }

        .bh-value {
            min-width: 60px;
            text-align: right;
            color: #ffffff;
            font-family: monospace;
            font-size: 11px;
        }

        .bh-section {
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #2563eb;
        }

        .bh-section h4 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .blackhole-controls::-webkit-scrollbar {
            width: 6px;
        }

        .blackhole-controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .blackhole-controls::-webkit-scrollbar-thumb {
            background: #2563eb;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>CRR Black Hole Physics</h1>
            <div class="subtitle">Coherence ‚Ä¢ Rupture ‚Ä¢ Regeneration Framework Applied to Gravitational Systems (Educational Demo)</div>
        </div>

        <div class="equation-banner">
            CRR Operators Applied to Black Holes: C(M,r) ‚Ä¢ Œ¥(Rs) ‚Ä¢ R[T_H] modeling gravitational phase transitions
        </div>

        <!-- MATHEMATICAL EXPLAINER SECTION -->
        <div class="math-explainer-container">
            <div class="math-explainer-header" onclick="toggleMathExplainer()">
                <h3>üìê Mathematical Framework: CRR ‚Üí Physics ‚Üí Code</h3>
                <span class="math-explainer-toggle" id="mathToggle">‚ñº</span>
            </div>
            <div class="math-explainer-content" id="mathExplainerContent">
                
                <!-- Section 1: CRR Theory -->
                <div class="math-section">
                    <h4>1. Core CRR Framework (Theoretical)</h4>
                    
                    <div class="equation-block">
                        <div class="equation-title">Coherence Accumulation</div>
                        <div class="equation-formula">
                            dC/dt = L(x,t)<br>
                            C(t) = ‚à´‚ÇÄ·µó L(x,œÑ) dœÑ
                        </div>
                        <div class="equation-description">
                            The coherence functional C accumulates over time through the Lagrangian L, which measures system organization and information integration. For black holes, this represents the integrated matter-energy density in stable orbital configurations.
                        </div>
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Rupture Operator</div>
                        <div class="equation-formula">
                            Œ¥(t - t_i) : C(t_i) ‚â• C_crit<br>
                            C_crit = Œ© log(Œõ/Œª‚ÇÄ)
                        </div>
                        <div class="equation-description">
                            When accumulated coherence exceeds critical threshold, the system undergoes discontinuous transition (rupture). For black holes, this maps to the event horizon where spacetime geometry forces discrete state change.
                        </div>
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Rebirth/Regeneration</div>
                        <div class="equation-formula">
                            Œ¶(t) = ‚à´‚ÇÄ·µó œÜ(x,œÑ) exp(C(œÑ)/Œ©) dœÑ
                        </div>
                        <div class="equation-description">
                            Post-rupture dynamics weighted exponentially by accumulated coherence. For black holes, this represents Hawking radiation emerging from quantum fluctuations at the horizon, weighted by the black hole's history.
                        </div>
                    </div>
                </div>

                <!-- Section 2: Mapping to Black Hole Physics -->
                <div class="math-section">
                    <h4>2. Translation to Black Hole Physics</h4>
                    
                    <div class="equation-block">
                        <div class="equation-title">Coherence ‚Üí Matter Distribution</div>
                        <div class="equation-formula">
                            C(M,r) ‚âà ‚à´ œÅ(r) dV<br>
                            where œÅ = matter density in accretion disk
                        </div>
                        <div class="equation-description">
                            Coherence maps to integrated mass distribution. Stable orbital matter in the accretion disk represents coherent state. The Lagrangian L(x,t) becomes the local matter-energy density.
                        </div>
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Rupture ‚Üí Event Horizon</div>
                        <div class="equation-formula">
                            Œ¥(r - R_s) where R_s = 2GM/c¬≤<br>
                            Schwarzschild radius = rupture boundary
                        </div>
                        <div class="equation-description">
                            The event horizon is the rupture surface. Once matter crosses R_s, it undergoes irreversible transition (no return trajectory exists). This is a geometric rupture in spacetime itself.
                        </div>
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Regeneration ‚Üí Hawking Radiation</div>
                        <div class="equation-formula">
                            R[T_H] = dS/dt<br>
                            T_H = ‚Ñèc¬≥/(8œÄGMk_B)<br>
                            L_H = ‚Ñèc‚Å∂/(15360œÄG¬≤M¬≤)
                        </div>
                        <div class="equation-description">
                            Hawking temperature and luminosity represent regeneration flux. Quantum fluctuations at the horizon create particle-antiparticle pairs, with outgoing radiation weighted by the black hole's mass history (accumulated C).
                        </div>
                    </div>
                </div>

                <!-- Section 3: Code Implementation -->
                <div class="math-section">
                    <h4>3. Browser-Compatible Implementation</h4>
                    
                    <div class="approximation-notice">
                        <strong>Important:</strong> Full CRR dynamics require O(n¬≤) integration over all past states and cannot run in real-time in browsers. The code below uses visually accurate approximations that preserve CRR structure while remaining computationally feasible.
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Coherence Accumulation (Simplified)</div>
                        <div class="equation-formula">
                            Full equation: C(t) = ‚à´‚ÇÄ·µó œÅ(r,œÑ) dV dœÑ<br>
                            Approximation: C(t) ‚âà C(t-dt) + ŒîC¬∑dt
                        </div>
                    </div>

                    <div class="mapping-arrow">‚Üì</div>

                    <div class="code-snippet">
<span class="code-comment">// Coherence evolution using exponential relaxation</span>
<span class="code-keyword">updateCRRStates</span>(<span class="code-keyword">deltaTime</span>) {
    <span class="code-comment">// Simplified coherence: exponential approach to equilibrium</span>
    <span class="code-keyword">this</span>.crr.coherenceLevel += 
        (<span class="code-keyword">this</span>.crr.coherenceStrength - <span class="code-keyword">this</span>.crr.coherenceLevel) 
        * deltaTime * <span class="code-number">0.5</span>;
    
    <span class="code-comment">// This approximates: dC/dt = k(C_target - C_current)</span>
    <span class="code-comment">// instead of full integral over matter distribution</span>
}
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Rupture Events (Stochastic)</div>
                        <div class="equation-formula">
                            Full: Œ¥(t - t_i) when C ‚â• C_crit<br>
                            Approximation: P(rupture) ‚àù ruptureRate¬∑dt
                        </div>
                    </div>

                    <div class="mapping-arrow">‚Üì</div>

                    <div class="code-snippet">
<span class="code-comment">// Rupture as stochastic process (Poisson-like)</span>
<span class="code-keyword">if</span> (Math.<span class="code-function">random</span>() < <span class="code-keyword">this</span>.crr.ruptureRate * deltaTime) {
    <span class="code-keyword">this</span>.crr.ruptureEvents++;
    <span class="code-comment">// Trigger visual disruption of particle states</span>
    <span class="code-keyword">this</span>.<span class="code-function">triggerRuptureEvent</span>();
}

<span class="code-comment">// Real physics: deterministic at C = C_crit</span>
<span class="code-comment">// Visualization: probabilistic for smoother animation</span>
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Hawking Radiation (Particle Emission)</div>
                        <div class="equation-formula">
                            Full: Œ¶(t) = ‚à´ œÜ(œÑ) exp(C(œÑ)/Œ©) dœÑ<br>
                            Approximation: emission rate ‚àù T_H ¬∑ intensity
                        </div>
                    </div>

                    <div class="mapping-arrow">‚Üì</div>

                    <div class="code-snippet">
<span class="code-comment">// Hawking radiation as particle escape velocity</span>
<span class="code-keyword">vec3</span> escape = <span class="code-function">normalize</span>(pos) 
              * time * <span class="code-number">0.01</span> * hawking;

<span class="code-comment">// Particles generated near horizon (r ‚âà 1.05 R_s)</span>
<span class="code-comment">// Velocity weighted by Hawking temperature</span>
<span class="code-comment">// Visual intensity represents exp(C/Œ©) weighting</span>

pos += escape + <span class="code-function">sin</span>(time + pos * <span class="code-number">5.0</span>) * energy * <span class="code-number">0.02</span>;
                    </div>
                </div>

                <!-- Section 4: Physical Constants -->
                <div class="math-section">
                    <h4>4. Physical Constants (Used in Calculations)</h4>
                    
                    <div class="code-snippet">
<span class="code-keyword">const</span> G = <span class="code-number">6.67430e-11</span>;       <span class="code-comment">// Gravitational constant (m¬≥/kg¬∑s¬≤)</span>
<span class="code-keyword">const</span> c = <span class="code-number">299792458</span>;         <span class="code-comment">// Speed of light (m/s)</span>
<span class="code-keyword">const</span> M_sun = <span class="code-number">1.989e30</span>;      <span class="code-comment">// Solar mass (kg)</span>
<span class="code-keyword">const</span> k_B = <span class="code-number">1.380649e-23</span>;    <span class="code-comment">// Boltzmann constant (J/K)</span>
<span class="code-keyword">const</span> hbar = <span class="code-number">1.054571817e-34</span>; <span class="code-comment">// Reduced Planck constant (J¬∑s)</span>

<span class="code-comment">// Schwarzschild radius (exact)</span>
R_s = (<span class="code-number">2</span> * G * mass) / (c * c);

<span class="code-comment">// Hawking temperature (exact)</span>
T_H = (hbar * c¬≥) / (<span class="code-number">8</span> * œÄ * G * mass * k_B);

<span class="code-comment">// Hawking luminosity (Stefan-Boltzmann law)</span>
L_H = (hbar * c‚Å∂) / (<span class="code-number">15360</span> * œÄ * G¬≤ * mass¬≤);
                    </div>
                </div>

                <!-- Section 5: What's Accurate vs Approximate -->
                <div class="math-section">
                    <h4>5. Accuracy Assessment</h4>
                    
                    <div class="equation-block">
                        <div class="equation-title">Physically Accurate (Exact Calculations)</div>
                        <div class="equation-description">
                            ‚úì Schwarzschild radius R_s = 2GM/c¬≤<br>
                            ‚úì Hawking temperature T_H = ‚Ñèc¬≥/(8œÄGMk_B)<br>
                            ‚úì ISCO radius for Kerr metric (spin-dependent)<br>
                            ‚úì Surface gravity Œ∫ = GM/R_s¬≤<br>
                            ‚úì Hawking luminosity (Stefan-Boltzmann)<br>
                            ‚úì Information rate (entropy flow)
                        </div>
                    </div>

                    <div class="equation-block">
                        <div class="equation-title">Pedagogical Approximations (For Visualization)</div>
                        <div class="equation-description">
                            ‚ö† Coherence accumulation: uses exponential relaxation instead of full spatial integration<br>
                            ‚ö† Rupture events: stochastic trigger instead of deterministic threshold<br>
                            ‚ö† Particle dynamics: simplified N-body without full GR geodesics<br>
                            ‚ö† Accretion disk: temperature profile approximated, no magnetohydrodynamics<br>
                            ‚ö† Gravitational lensing: artistic representation, not ray-traced<br>
                            ‚ö† Frame dragging: simplified rotation, not full Kerr metric
                        </div>
                    </div>

                    <div class="approximation-notice">
                        <strong>Bottom Line:</strong> This visualization accurately computes black hole thermodynamics but uses simplified dynamics for real-time rendering. The CRR principles (coherence accumulation ‚Üí rupture ‚Üí regeneration) are preserved in structure, though not with full mathematical rigor. For research-grade simulations, see numerical relativity codes (Einstein Toolkit, SpEC).
                    </div>
                </div>

            </div>
        </div>

        <div class="equation-overlay">
            <div class="current-equation" id="currentEquation">R_s = 2GM/c¬≤</div>
            <div class="equation-description-text" id="equationDescription">Schwarzschild radius: gravitational rupture boundary where spacetime curvature creates event horizon</div>
        </div>

        <div class="system-legend">
            <h3 style="margin-bottom: 12px; font-size: 0.9rem; color: #495057;">Black Hole System Components</h3>
            <div class="legend-grid">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #000000, #0a0a2a);"></div>
                    <span>Event Horizon (Rupture Boundary)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #ffaa00, #ffdd44);"></div>
                    <span>Photon Ring (Light Orbits)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #ff4444, #ff8888);"></div>
                    <span>Accretion Disk (Coherent Matter)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #4488ff, #88bbff);"></div>
                    <span>Infalling Particles (Coherent State)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #ff4488, #ff88bb);"></div>
                    <span>Disrupted Matter (Rupture Events)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #44ff88, #88ffbb);"></div>
                    <span>Hawking Radiation (Regeneration)</span>
                </div>
            </div>
        </div>

        <div class="simulation-area">
            <canvas id="blackhole-canvas"></canvas>
            
            <div class="blackhole-controls">
                <div class="title">Black Hole Parameters</div>
                
                <div class="bh-section">
                    <h4>Physical Properties</h4>
                    <div class="bh-control-group">
                        <label>Mass (Solar Masses):</label>
                        <input type="range" id="blackHoleMass" min="3" max="100" value="10" step="0.5">
                        <span class="bh-value" id="blackHoleMassValue">10 M‚òâ</span>
                    </div>
                    <div class="bh-control-group">
                        <label>Spin Parameter:</label>
                        <input type="range" id="spinParameter" min="0" max="0.998" value="0.7" step="0.001">
                        <span class="bh-value" id="spinParameterValue">0.700</span>
                    </div>
                    <div class="bh-control-group">
                        <label>Accretion Rate:</label>
                        <input type="range" id="accretionRate" min="0.1" max="5.0" value="2.0" step="0.1">
                        <span class="bh-value" id="accretionRateValue">2.0</span>
                    </div>
                </div>

                <div class="bh-section">
                    <h4>CRR Framework</h4>
                    <div class="bh-control-group">
                        <label>Coherence Strength:</label>
                        <input type="range" id="coherenceStrength" min="0.1" max="3.0" value="1.5" step="0.1">
                        <span class="bh-value" id="coherenceStrengthValue">1.5</span>
                    </div>
                    <div class="bh-control-group">
                        <label>Rupture Event Rate:</label>
                        <input type="range" id="ruptureRate" min="0.0" max="0.1" value="0.02" step="0.005">
                        <span class="bh-value" id="ruptureRateValue">0.02</span>
                    </div>
                    <div class="bh-control-group">
                        <label>Regeneration Factor:</label>
                        <input type="range" id="regenFactor" min="0.1" max="2.0" value="0.8" step="0.1">
                        <span class="bh-value" id="regenFactorValue">0.8</span>
                    </div>
                </div>

                <div class="bh-section">
                    <h4>Visualisation</h4>
                    <div class="bh-control-group">
                        <label>Particle Count:</label>
                        <input type="range" id="particleCount" min="200" max="2000" value="800" step="50">
                        <span class="bh-value" id="particleCountValue">800</span>
                    </div>
                    <div class="bh-control-group">
                        <label>Hawking Radiation:</label>
                        <input type="range" id="hawkingIntensity" min="0.0" max="3.0" value="1.0" step="0.1">
                        <span class="bh-value" id="hawkingIntensityValue">1.0</span>
                    </div>
                    <div class="bh-control-group">
                        <label>Lensing Strength:</label>
                        <input type="range" id="lensingStrength" min="0.0" max="3.0" value="1.5" step="0.1">
                        <span class="bh-value" id="lensingStrengthValue">1.5</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="metrics-panel">
            <div class="metric-card">
                <h3>CRR Framework States</h3>
                <div class="metric-row">
                    <span class="metric-label">Coherence Level C(M,r):</span>
                    <span class="metric-value" id="coherenceLevel">0.750</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Rupture Events Œ¥(Rs):</span>
                    <span class="metric-value" id="ruptureEvents">0</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Regeneration Rate R[T_H]:</span>
                    <span class="metric-value" id="regenerationRate">0.8</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">System Entropy S:</span>
                    <span class="metric-value" id="systemEntropy">1.25</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Matter State Dynamics</h3>
                <div class="metric-row">
                    <span class="metric-label">Coherent Orbits:</span>
                    <span class="metric-value" id="stableOrbits">42</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Infalling Matter:</span>
                    <span class="metric-value" id="infallingMatter">156</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Disrupted Objects:</span>
                    <span class="metric-value" id="disruptedObjects">8</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Hawking Particles:</span>
                    <span class="metric-value" id="hawkingParticles">23</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Physical Properties</h3>
                <div class="metric-row">
                    <span class="metric-label">Schwarzschild Radius:</span>
                    <span class="metric-value" id="schwarzschildRadius">29.5 km</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Event Horizon:</span>
                    <span class="metric-value" id="eventHorizonRadius">1.0 Rs</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Photon Sphere:</span>
                    <span class="metric-value" id="photonSphereRadius">1.5 Rs</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">ISCO Radius:</span>
                    <span class="metric-value" id="iscoRadius">6.0 Rs</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Thermodynamic Properties</h3>
                <div class="metric-row">
                    <span class="metric-label">Hawking Temperature:</span>
                    <span class="metric-value" id="hawkingTemp">6.2e-8 K</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Surface Gravity:</span>
                    <span class="metric-value" id="surfaceGravity">1.7e6 m/s¬≤</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Luminosity:</span>
                    <span class="metric-value" id="luminosity">2.3e25 W</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Information Rate:</span>
                    <span class="metric-value" id="informationRate">4.7 bits/s</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" onclick="applyPreset('stellar')">Stellar Mass</button>
            <button class="control-btn" onclick="applyPreset('supermassive')">Supermassive</button>
            <button class="control-btn" onclick="applyPreset('extremal')">Extremal Spin</button>
            <button class="control-btn" onclick="applyPreset('quiet')">Quiet System</button>
        </div>
    </div>

    <script>
        // Toggle mathematical explainer
        function toggleMathExplainer() {
            const content = document.getElementById('mathExplainerContent');
            const toggle = document.getElementById('mathToggle');
            
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }

        // Main CRR Black Hole class (unchanged from original - same user experience)
        class CRRBlackHole {
            constructor() {
                this.canvas = document.getElementById('blackhole-canvas');
                this.setupCanvas();
                
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, this.canvas.offsetWidth / this.canvas.offsetHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true 
                });
                
                this.physics = {
                    mass: 10.0,
                    spin: 0.7,
                    accretionRate: 2.0,
                    schwarzschildRadius: 0,
                    photonSphere: 0,
                    isco: 0,
                    hawkingTemp: 0,
                    surfaceGravity: 0,
                    luminosity: 0,
                    informationRate: 0
                };
                
                this.crr = {
                    coherenceStrength: 1.5,
                    ruptureRate: 0.02,
                    regenFactor: 0.8,
                    coherenceLevel: 0.75,
                    ruptureEvents: 0,
                    systemEntropy: 1.25
                };
                
                this.visual = {
                    particleCount: 800,
                    hawkingIntensity: 1.0,
                    lensingStrength: 1.5
                };
                
                this.time = 0;
                this.particles = [];
                this.hawkingParticles = [];
                this.ruptureEvents = [];
                
                this.eventHorizon = null;
                this.photonRing = null;
                this.accretionDisk = null;
                this.particleSystem = null;
                this.hawkingSystem = null;
                
                this.init();
            }
            
            setupCanvas() {
                const container = this.canvas.parentElement;
                const resize = () => {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    if (this.camera) {
                        this.camera.aspect = rect.width / rect.height;
                        this.camera.updateProjectionMatrix();
                    }
                    if (this.renderer) {
                        this.renderer.setSize(rect.width, rect.height);
                    }
                };
                resize();
                window.addEventListener('resize', resize);
            }
            
            async init() {
                this.setupRenderer();
                this.setupCamera();
                this.setupLighting();
                this.calculatePhysics();
                
                await this.createEventHorizon();
                await this.createPhotonRing();
                await this.createAccretionDisk();
                await this.createParticleSystem();
                await this.createHawkingRadiation();
                
                this.setupControls();
                this.animate();
            }
            
            calculatePhysics() {
                const G = 6.67430e-11;
                const c = 299792458;
                const M_sun = 1.989e30;
                const k_B = 1.380649e-23;
                const hbar = 1.054571817e-34;
                
                const mass_kg = this.physics.mass * M_sun;
                
                this.physics.schwarzschildRadius = (2 * G * mass_kg) / (c * c);
                this.physics.photonSphere = 1.5 * this.physics.schwarzschildRadius;
                
                const a = this.physics.spin;
                const Z1 = 1 + Math.pow(1 - a*a, 1/3) * (Math.pow(1 + a, 1/3) + Math.pow(1 - a, 1/3));
                const Z2 = Math.sqrt(3*a*a + Z1*Z1);
                const r_isco = 3 + Z2 - Math.sqrt((3 - Z1) * (3 + Z1 + 2*Z2));
                this.physics.isco = r_isco;
                
                this.physics.hawkingTemp = (hbar * c * c * c) / (8 * Math.PI * G * mass_kg * k_B);
                this.physics.surfaceGravity = (G * mass_kg) / (this.physics.schwarzschildRadius * this.physics.schwarzschildRadius);
                this.physics.luminosity = (hbar * c * c * c * c * c * c) / (15360 * Math.PI * G * G * mass_kg * mass_kg);
                this.physics.informationRate = this.physics.luminosity / (this.physics.hawkingTemp * k_B * Math.log(2));
                
                this.updatePhysicsUI();
            }
            
            updatePhysicsUI() {
                const rs_km = this.physics.schwarzschildRadius / 1000;
                document.getElementById('schwarzschildRadius').textContent = `${rs_km.toFixed(1)} km`;
                document.getElementById('eventHorizonRadius').textContent = `1.0 Rs`;
                document.getElementById('photonSphereRadius').textContent = `1.5 Rs`;
                document.getElementById('iscoRadius').textContent = `${this.physics.isco.toFixed(1)} Rs`;
                document.getElementById('hawkingTemp').textContent = `${this.physics.hawkingTemp.toExponential(1)} K`;
                document.getElementById('surfaceGravity').textContent = `${(this.physics.surfaceGravity/1e6).toFixed(1)}e6 m/s¬≤`;
                document.getElementById('luminosity').textContent = `${this.physics.luminosity.toExponential(1)} W`;
                document.getElementById('informationRate').textContent = `${this.physics.informationRate.toFixed(1)} bits/s`;
            }
            
            setupRenderer() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.renderer.setSize(rect.width, rect.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x000000, 1);
                this.scene.fog = new THREE.Fog(0x000008, 30, 200);
            }
            
            setupCamera() {
                this.camera.position.set(0, 20, 40);
                this.camera.lookAt(0, 0, 0);
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x222222, 0.3);
                this.scene.add(ambientLight);
                
                this.accretionLight = new THREE.PointLight(0xff4444, 2, 100);
                this.accretionLight.position.set(0, 0, 0);
                this.scene.add(this.accretionLight);
                
                this.coherenceLight = new THREE.PointLight(0x4444ff, 1, 80);
                this.coherenceLight.position.set(0, 15, 0);
                this.scene.add(this.coherenceLight);
            }
            
            async createEventHorizon() {
                const geometry = new THREE.SphereGeometry(3, 64, 32);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        mass: { value: this.physics.mass },
                        spin: { value: this.physics.spin },
                        coherence: { value: this.crr.coherenceStrength }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float spin;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normal;
                            
                            vec3 pos = position;
                            float frameDrag = spin * 0.1;
                            float angle = time * frameDrag;
                            mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                            pos.xz = rotation * pos.xz;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float mass;
                        uniform float coherence;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            vec3 color = vec3(0.0, 0.0, 0.05);
                            float glow = pow(1.0 - abs(dot(vNormal, normalize(vPosition))), 2.0);
                            color += vec3(0.1, 0.3, 0.8) * glow * coherence * 0.3;
                            float redshift = 1.0 - 1.0 / (1.0 + mass * 0.1);
                            color *= redshift;
                            
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                
                this.eventHorizon = new THREE.Mesh(geometry, material);
                this.scene.add(this.eventHorizon);
            }
            
            async createPhotonRing() {
                const geometry = new THREE.TorusGeometry(4.5, 0.1, 16, 100);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        spin: { value: this.physics.spin },
                        lensing: { value: this.visual.lensingStrength }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float spin;
                        varying vec2 vUv;
                        
                        void main() {
                            vUv = uv;
                            vec3 pos = position;
                            float orbitalVel = sqrt(1.0 / length(pos.xy)) * spin;
                            float angle = time * orbitalVel;
                            mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                            pos.xy = rotation * pos.xy;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float lensing;
                        varying vec2 vUv;
                        
                        void main() {
                            vec3 photonColor = vec3(1.0, 0.9, 0.4);
                            float intensity = sin(time * 8.0 + vUv.x * 20.0) * 0.5 + 0.5;
                            intensity *= lensing;
                            photonColor *= intensity;
                            
                            gl_FragColor = vec4(photonColor, intensity * 0.8);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.photonRing = new THREE.Mesh(geometry, material);
                this.photonRing.rotation.x = Math.PI / 2;
                this.scene.add(this.photonRing);
            }
            
            async createAccretionDisk() {
                const geometry = new THREE.RingGeometry(6, 25, 32, 64);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        mass: { value: this.physics.mass },
                        accretion: { value: this.physics.accretionRate },
                        coherence: { value: this.crr.coherenceStrength }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float mass;
                        varying vec2 vUv;
                        varying vec3 vPosition;
                        varying float vTemperature;
                        
                        void main() {
                            vUv = uv;
                            vPosition = position;
                            
                            vec3 pos = position;
                            float radius = length(pos.xy);
                            vTemperature = pow(6.0 / radius, 0.75);
                            
                            float orbitalVel = sqrt(mass / radius) * 0.1;
                            float angle = time * orbitalVel;
                            mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                            pos.xy = rotation * pos.xy;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float accretion;
                        uniform float coherence;
                        varying vec2 vUv;
                        varying vec3 vPosition;
                        varying float vTemperature;
                        
                        vec3 blackBodyColor(float temp) {
                            temp = clamp(temp, 0.1, 3.0);
                            if (temp < 1.0) {
                                return vec3(1.0, 0.3, 0.1) * temp;
                            } else if (temp < 2.0) {
                                return vec3(1.0, 0.7, 0.2);
                            } else {
                                return vec3(0.9, 0.9, 1.0);
                            }
                        }
                        
                        void main() {
                            float radius = length(vPosition.xy);
                            vec3 diskColor = blackBodyColor(vTemperature);
                            float spiral = sin(atan(vPosition.y, vPosition.x) * 6.0 + 
                                              radius * 0.8 - time * 2.0) * 0.5 + 0.5;
                            spiral *= coherence;
                            diskColor *= (0.5 + spiral * 0.8) * accretion;
                            float alpha = (1.0 - radius * 0.03) * vTemperature * 0.4;
                            
                            gl_FragColor = vec4(diskColor, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                
                this.accretionDisk = new THREE.Mesh(geometry, material);
                this.accretionDisk.rotation.x = Math.PI / 2;
                this.scene.add(this.accretionDisk);
            }
            
            async createParticleSystem() {
                const count = this.visual.particleCount;
                const positions = new Float32Array(count * 3);
                const velocities = new Float32Array(count * 3);
                const states = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const radius = 10 + Math.random() * 40;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(1 - 2 * Math.random());
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    const speed = Math.sqrt(this.physics.mass * 0.1 / radius) * (0.7 + Math.random() * 0.6);
                    const tangent = new THREE.Vector3(-positions[i * 3 + 2], 0, positions[i * 3]).normalize();
                    
                    velocities[i * 3] = tangent.x * speed;
                    velocities[i * 3 + 1] = tangent.y * speed;
                    velocities[i * 3 + 2] = tangent.z * speed;
                    
                    states[i] = Math.random() > 0.8 ? Math.floor(Math.random() * 3) : 0;
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('state', new THREE.BufferAttribute(states, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        mass: { value: this.physics.mass },
                        coherence: { value: this.crr.coherenceStrength },
                        pointSize: { value: 3.0 }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float mass;
                        uniform float pointSize;
                        attribute vec3 velocity;
                        attribute float state;
                        varying float vState;
                        varying float vDistance;
                        
                        void main() {
                            vState = state;
                            vDistance = length(position);
                            vec3 pos = position;
                            vec3 gravity = -normalize(pos) * mass * 0.001 / (vDistance * vDistance);
                            pos += velocity * 0.05 + gravity;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = pointSize * (1.0 + state);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying float vState;
                        varying float vDistance;
                        
                        void main() {
                            vec2 coord = 2.0 * gl_PointCoord - 1.0;
                            if (dot(coord, coord) > 1.0) discard;
                            
                            vec3 color;
                            if (vState < 0.5) {
                                color = vec3(0.2, 0.5, 1.0);
                            } else if (vState < 1.5) {
                                color = vec3(1.0, 0.2, 0.2);
                            } else {
                                color = vec3(0.2, 1.0, 0.5);
                            }
                            
                            float alpha = 1.0 - vDistance * 0.01;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
            }
            
            async createHawkingRadiation() {
                const count = 100;
                const positions = new Float32Array(count * 3);
                const energies = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const radius = 3.2 + Math.random() * 0.3;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(1 - 2 * Math.random());
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    energies[i] = Math.random();
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('energy', new THREE.BufferAttribute(energies, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        hawking: { value: this.visual.hawkingIntensity },
                        regen: { value: this.crr.regenFactor }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float hawking;
                        attribute float energy;
                        varying float vEnergy;
                        
                        void main() {
                            vEnergy = energy;
                            vec3 pos = position;
                            vec3 escape = normalize(pos) * time * 0.01 * hawking;
                            pos += escape + sin(time + pos * 5.0) * energy * 0.02;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = 2.0 + energy * 3.0;
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float regen;
                        varying float vEnergy;
                        
                        void main() {
                            vec2 coord = 2.0 * gl_PointCoord - 1.0;
                            if (dot(coord, coord) > 1.0) discard;
                            
                            vec3 color = vec3(0.5, 1.0, 1.0);
                            color += vec3(1.0, 1.0, 0.5) * vEnergy;
                            color *= regen;
                            
                            float alpha = vEnergy * 0.8;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.hawkingSystem = new THREE.Points(geometry, material);
                this.scene.add(this.hawkingSystem);
            }
            
            setupControls() {
                const controls = [
                    { id: 'blackHoleMass', target: 'physics', prop: 'mass', format: v => `${v} M‚òâ` },
                    { id: 'spinParameter', target: 'physics', prop: 'spin', format: v => `${v}` },
                    { id: 'accretionRate', target: 'physics', prop: 'accretionRate', format: v => `${v}` },
                    { id: 'coherenceStrength', target: 'crr', prop: 'coherenceStrength', format: v => `${v}` },
                    { id: 'ruptureRate', target: 'crr', prop: 'ruptureRate', format: v => `${v}` },
                    { id: 'regenFactor', target: 'crr', prop: 'regenFactor', format: v => `${v}` },
                    { id: 'particleCount', target: 'visual', prop: 'particleCount', format: v => `${v}` },
                    { id: 'hawkingIntensity', target: 'visual', prop: 'hawkingIntensity', format: v => `${v}` },
                    { id: 'lensingStrength', target: 'visual', prop: 'lensingStrength', format: v => `${v}` }
                ];
                
                controls.forEach(({ id, target, prop, format }) => {
                    const element = document.getElementById(id);
                    const valueDisplay = document.getElementById(id + 'Value');
                    
                    if (element && valueDisplay) {
                        element.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            this[target][prop] = value;
                            valueDisplay.textContent = format(value);
                            
                            if (target === 'physics') {
                                this.calculatePhysics();
                            }
                            
                            this.updateShaderUniforms();
                        });
                        
                        valueDisplay.textContent = format(this[target][prop]);
                    }
                });
            }
            
            updateCRRStates(deltaTime) {
                // CRR Framework update (as explained in Mathematical Explainer)
                this.crr.coherenceLevel += (this.crr.coherenceStrength - this.crr.coherenceLevel) * deltaTime * 0.5;
                
                if (Math.random() < this.crr.ruptureRate * deltaTime) {
                    this.crr.ruptureEvents++;
                }
                
                this.crr.systemEntropy += deltaTime * 0.1 * (1.0 + this.physics.accretionRate * 0.1);
                
                const equations = [
                    { formula: "R_s = 2GM/c¬≤", description: "Schwarzschild radius: gravitational rupture boundary where spacetime curvature creates event horizon" },
                    { formula: "C(M,r) = ‚à´ œÅ(r) dV", description: "Coherence: integrated matter density in stable orbital structures around the black hole" },
                    { formula: "T_H = ‚Ñèc¬≥/8œÄGMk_B", description: "Hawking temperature: regeneration through thermal radiation emerging from quantum fluctuations" },
                    { formula: "Œ¥(R_s) = Œò(r-R_s)", description: "Rupture operator: step function marking the information boundary at the event horizon" },
                    { formula: "R[T_H] = dS/dt", description: "Regeneration rate: entropy flow and information recovery through Hawking radiation processes" }
                ];
                
                const eqIndex = Math.floor(this.time * 0.2) % equations.length;
                document.getElementById('currentEquation').textContent = equations[eqIndex].formula;
                document.getElementById('equationDescription').textContent = equations[eqIndex].description;
                
                this.updateMetricsUI();
            }
            
            updateMetricsUI() {
                document.getElementById('coherenceLevel').textContent = this.crr.coherenceLevel.toFixed(3);
                document.getElementById('ruptureEvents').textContent = this.crr.ruptureEvents.toString();
                document.getElementById('regenerationRate').textContent = this.crr.regenFactor.toFixed(1);
                document.getElementById('systemEntropy').textContent = this.crr.systemEntropy.toFixed(2);
                
                let infalling = 0, stable = 0, disrupted = 0, hawking = 0;
                
                if (this.particleSystem) {
                    const states = this.particleSystem.geometry.attributes.state.array;
                    for (let i = 0; i < states.length; i++) {
                        if (states[i] < 0.5) stable++;
                        else if (states[i] < 1.5) disrupted++;
                        else infalling++;
                    }
                }
                
                hawking = Math.floor(this.visual.hawkingIntensity * 50);
                
                document.getElementById('infallingMatter').textContent = infalling.toString();
                document.getElementById('stableOrbits').textContent = stable.toString();
                document.getElementById('disruptedObjects').textContent = disrupted.toString();
                document.getElementById('hawkingParticles').textContent = hawking.toString();
            }
            
            updateShaderUniforms() {
                const meshes = [this.eventHorizon, this.photonRing, this.accretionDisk, this.particleSystem, this.hawkingSystem];
                
                meshes.forEach(mesh => {
                    if (mesh && mesh.material && mesh.material.uniforms) {
                        const uniforms = mesh.material.uniforms;
                        if (uniforms.time) uniforms.time.value = this.time;
                        if (uniforms.mass) uniforms.mass.value = this.physics.mass;
                        if (uniforms.spin) uniforms.spin.value = this.physics.spin;
                        if (uniforms.accretion) uniforms.accretion.value = this.physics.accretionRate;
                        if (uniforms.coherence) uniforms.coherence.value = this.crr.coherenceStrength;
                        if (uniforms.hawking) uniforms.hawking.value = this.visual.hawkingIntensity;
                        if (uniforms.lensing) uniforms.lensing.value = this.visual.lensingStrength;
                        if (uniforms.regen) uniforms.regen.value = this.crr.regenFactor;
                    }
                });
                
                if (this.accretionLight) {
                    this.accretionLight.intensity = this.physics.accretionRate;
                }
                if (this.coherenceLight) {
                    this.coherenceLight.intensity = this.crr.coherenceLevel * 2;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = 0.016;
                this.time += deltaTime;
                
                this.updateCRRStates(deltaTime);
                this.updateShaderUniforms();
                
                if (this.eventHorizon) {
                    this.eventHorizon.rotation.y += deltaTime * 0.1 * this.physics.spin;
                }
                
                if (this.accretionDisk) {
                    this.accretionDisk.rotation.z += deltaTime * 0.2 * (1 + this.physics.spin);
                }
                
                const radius = 40 + Math.sin(this.time * 0.1) * 5;
                this.camera.position.setFromSphericalCoords(radius, Math.PI / 2 - 0.2, this.time * 0.05);
                this.camera.lookAt(0, 0, 0);
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        window.applyPreset = function(presetName) {
            const presets = {
                stellar: {
                    blackHoleMass: 10,
                    spinParameter: 0.3,
                    accretionRate: 1.0,
                    coherenceStrength: 2.0,
                    hawkingIntensity: 0.5
                },
                supermassive: {
                    blackHoleMass: 100,
                    spinParameter: 0.9,
                    accretionRate: 4.0,
                    coherenceStrength: 1.0,
                    hawkingIntensity: 0.1
                },
                extremal: {
                    blackHoleMass: 50,
                    spinParameter: 0.998,
                    accretionRate: 3.0,
                    coherenceStrength: 0.5,
                    ruptureRate: 0.05
                },
                quiet: {
                    blackHoleMass: 5,
                    spinParameter: 0.1,
                    accretionRate: 0.5,
                    coherenceStrength: 3.0,
                    hawkingIntensity: 2.0
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            Object.keys(preset).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = preset[key];
                    element.dispatchEvent(new Event('input'));
                }
            });
        };
        
        window.addEventListener('load', () => {
            window.crrBlackHole = new CRRBlackHole();
        });
        
        window.addEventListener('resize', () => {
            if (window.crrBlackHole) {
                window.crrBlackHole.setupCanvas();
            }
        });
    </script>
</body>
</html>